<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<TITLE>tk: Functional Programming for GUIs</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.1 (Solaris Sparc)">
	<META NAME="CREATED" CONTENT="20010321;13350800">
	<META NAME="CHANGEDBY" CONTENT="Burkhart Wolff">
	<META NAME="CHANGED" CONTENT="20010323;16101900">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">

<!-- -----------------------------------------------------------------------
 
   tk introduction, documentation and reference manual. 
 
   (C) 1996, Bremen Institute for Safe Systems, Universitaet Bremen
 
    ------------------------------------------------------------------- -->
	<STYLE>
	<!--
		H1 { color: #000000 }
		TD P { color: #000000 }
		H2 { color: #000000 }
		H3 { color: #000000 }
		H4 { color: #000000 }
		P { color: #000000 }
		PRE { color: #000000 }
		DT { color: #000000 }
		DD { color: #000000 }
		A:link { color: #0000ff }
	-->
	</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#ffffff">
<P STYLE="margin-bottom: 0in">&nbsp; 
</P>
<TABLE CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P><A HREF="http://www.uni-bremen.de/"><IMG SRC="images/uni-hb-logo.gif" NAME="Graphic1" ALT="Uni Bremen" ALIGN=BOTTOM WIDTH=268 HEIGHT=49 BORDER=0></A></P>
		</TD>
		<TD>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P><A HREF="http://www.uni-freiburg.de/"><IMG SRC="images/alu-logo.gif" NAME="Graphic2" ALT="ALU Freiburg" ALIGN=BOTTOM WIDTH=223 HEIGHT=80 BORDER=0></A></P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P><A HREF="http://www.informatik.uni-bremen.de/">FB3- Mathematics
			and Computer Science</A></P>
		</TD>
		<TD></TD>
		<TD>
			<P><A HREF="http://www.informatik.uni-freiburg.de/">Institut f&uuml;r
			Informatik</A></P>
		</TD>
	</TR>
</TABLE>
<HR>
<H1><B>tk</B>: Functional Programming for Graphical User
Interfaces</H1>
<H3>Release 3.0</H3>
<P STYLE="margin-bottom: 0in">Originally by <A HREF="http://www.informatik.uni-bremen.de/~cxl/">Christoph
L&uuml;th</A> and <A HREF="http://www.informatik.uni-freiburg.de/~wolff/">Burkhart
Wolff</A> (with many later edits by Cynbe ru Taren)
</P>
<HR>
<H2>Contents:</H2>
<H3><A HREF="#intro"><B>1. A Gentle Introduction to tk</B></A></H3>
<H3><A HREF="#design_issues">2. Design Issues</A></H3>
<H3><A HREF="#ref_man">3. The <B><U><FONT COLOR="#0000ff">tk</FONT></U></B>
Reference Manual</A></H3>
<H3><A HREF="#toolkit">4. The tk Toolkit</A></H3>
<H3><A HREF="#installation">5. Installation</A></H3>
<H3><A HREF="#bib">6. Bibliography</A></H3>
<H3><A HREF="#appx">7. Appendix: A Commented Logfile</A></H3>
<HR>
<H2><A NAME="intro"></A>1. A Gentle Introduction to tk</H2>
<H3>What is <B>tk</B>?</H3> <P><B>tk</B> is a Standard ML
(SML) package that provides a portable, typed and abstract interface
to the user interface description and command language
Tcl/Tk. <B>tk</B> was originally developed in the <A
HREF="http://www.informatik.uni-bremen.de/uniform">UniForM-Project</A>
and has been continually developed since by the universities of Bremen and
Freiburg.</P> 
<P>Tcl/Tk consists of two components, which in principle are
independent: the interface toolkit Tk offering a highly portable
interface to various operating systems and their graphical display engine
(such as Windows, MacOS and UNIX with its X Window System)  and
the command language Tcl, an untyped string-based scripting
language. (For more information, see [Oust94], [REF 96], [HM 97], [Fos 97],
[Wel 97] or
the <A HREF="http://dev.scriptics.com/software/tcltk/">home page</A>). While we appreciate both Tk's portability and level of
abstraction to access a window system, we do not subscribe to the Tcl
design philosophy that one should have a weakly typed and structured
scripting language to tie together smallish applications written in
another language. We believe that this leads to all the kind of
drawbacks one wants to avoid by using a structured language in the
first place (code that is ugly to read, prone to errors and hard to
maintain), and that one should use a structured language which offers
structuring concepts in-the-large for this purpose, such as Standard
ML [Pau94] with its module language. Hence, we prefer to use Tk to
build graphical user interfaces for applications written in the
functional language SML via an interface from SML directly.
</P>
<P>The package <B>tk</B> has been designed to combine the
advantages of the Tk toolkit with those of SML. As a consequence, a
novice in interface programming can skip the first fifteen chapters
of the reference book [Oust94] dealing with Tcl and concentrate on
those parts of the book addressing the visual appearance of graphical
objects and their layout control using Tk. <B>tk</B> covers most of the Tk functionality, and
is easy to extend. 
</P>
<P>Part of the <B>tk</B> package is a toolkit library of reusable
interface building components, including 
</P>
<UL>
	<LITERAL><P STYLE="margin-bottom: 0in">a collection of frequently used
	windows to display error messages, warnings or prompt for user
	input, 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a file browser (&quot;tk
	Explorer&quot;), 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a generic drag&amp;drop-canvas, 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a generic tree-navigation-canvas,
	and 
	</P>
	<LI><P>a generic user interface generate_gui_g. 
	</P>
</UL>
<P>This library benefits greatly from the SML module system. For
example, <tt>generate_gui_g</tt> is a class macro which when instantiated with an
application yields a graphical user interface controlling that
application. We have used this toolkit library to implement user
interfaces for applications based on theorem provers (see [LW99] and
[LW00]). 
</P>
<P>The core of <B>tk</B> implements the following entities: 
</P>
<UL>
	<li><P><I>Windows</I> (the basic building block of a graphical user
	interface) 
	</P>
	<li><P STYLE="margin-bottom: 0in"><I>Widgets </I>(graphical objects with
	a particular appearance and behaviour like buttons, Menus or
	Textfields); 
	</P>
	<li><P STYLE="margin-bottom: 0in"><I>Annotations</I> (of a text, like
	hyperlinks, inserted pictures or buttons); and 
	</P>
	<li><P><I>Canvas Items</I> (items on a drawing area, a so-called canvas,
	such as lines, points, small icons, text). 
	</P>
</UL>
<P>Each of these corresponds to an SML enum, called <TT>Window</TT>,
<TT>Widget, Text_Item </TT>and <TT>Canvas_Item </TT>respectively. Any of
these objects must have a unique <I>identification</I> (&quot;id&quot;)
that is used to reference them. The management of these
identifications and their mapping to appropriate names in Tcl is
handled by <B>tk</B>. The central enum <TT>Widget</TT> provides
one variant for each graphical entity like buttons, labels, menus,
text fields, etc. They are usually composed of the following: 
</P>
<UL>
	<LI>an identifier (<I>widget id</I>) 
	<LI>a list of subwidgets, if
	applicable (e.g. a menu
	consists of buttons); 
	<LI><I>event_callbacks,&nbsp;</I>which
	specify which SML functions are activated by <I>events</I> (such as
	mouse clicks, see below) in the GUI. These functions, called
	&quot;actions&quot; control the application in an event-triggered way 
	<LI><I>configurations</I>,
	(&quot;resources&quot; in the sense of [Oust94]) determining the
	visual appearance of the widget; 
	<LI><I>Packing options</I> specifying the 
	placement of widgets, either in a fairly declarative style relative
	to each other (e.g. X should be left from Y, and both should be
	placed on top of Z), or in a grid-oriented style (e.g. this widget
	goes in the third column of the second row). 
</UL>
<P><I>Windows</I> are essentially given by 
</P>
<UL>
	<LI>an <I>identifier</I> (window id), 
	<LI><I>window configurations</I>, such
	as the title and geometry, 
	<LI>the list of widgets occuring in
	that window 
	<LI>and a list of event_callbacks. 
</UL>
<P>Such a window, described by a Mythryl expression, can either be passed
to the function <TT>start_tcl</TT> that creates a GUI (consisting of
this window or possibly a list of windows) as a reactive system, or
to suitable operations that create windows dynamically during the
lifetime of the reactive system. While the reactive system is
running, the input from the Mythryl interpreter is blocked, so the
function <TT>start_tcl</TT> only returns once the reactive system has
terminated (i.e. the main window has been closed again). 
</P>
<H3>A Small Example</H3>
<P>To give a flavour of programming in <B>tk</B>, we sketch a
small example: suppose we want to construct a small window consisting
of a text entry field labelled &quot;name:&quot; left from this
field, and a quit button. After clicking on the text field, new text
can be entered and line-edited. After finishing by hitting the Return
key, the entered text should rename the window. When the quit button
is pressed (i.e. clicked on with the mouse) the window should be
closed, and the example terminates. 
</P>
<P>After opening the packages <TT>tk_types</TT> and <TT>tk</TT>,
which contain the export api of <B>tk</B> as described in
detail below, we are ready to start. We will have three graphical
entities (widgets): 
</P>
<UL>
	<LI>the text entry field,
	<LI>the text label &quot;name:&quot;,
	<LI>and the quit button.
</UL>
<P>All of these are of the type <TT>widget</TT>, using the three
constructors <TT>TEXT_ENTRY</TT>, <TT>LABEL</TT> and <TT>BUTTON</TT>. We
first need two identifiers, one for the main window and one for the
text entry widget, which we generate by the two functions <TT>make_window_id</TT>
and <TT>make_widget_id</TT>, respectively: 
</P>
<PRE>                                                                  my 
main_window_ID = make_window_id ()                                 my
text_entry_widget_ID = make_widget_id ()
</PRE><P>
The other two widgets can remain anonymous, since we need not refer
to them explicitly. 
</P>
<PRE>#  Define the widgets: 

                                                                  my
label_widget
    =
    LABEL {
	widget_id = make_widget_id (),
	packing_hints = [PACK_AT LEFT],
	traits  = [TEXT &quot;name:&quot;],
	event_callbacks = []
    }
                                                                  my
text_entry_widget
    =
    let fun return_keypress_callback _
            =
            change_title
                main_window_ID
                (make_title   (get_tcl_text   text_entry_widget_ID))
        in
            TEXT_ENTRY {
                widget_id    = text_entry_widget_ID,
                packing_hints = [],
                traits  = [WIDTH 20],
                event_callbacks = [EVENT_CALLBACK(KEY_PRESS &quot;Return&quot;,return_keypress_callback)]
            }
        end
                                                                  my 
quit_button
    =
    let fun quit_button_callback _
            =
            close_window main_window_ID
    in
	BUTTON {
	    widget_id    = make_widget_id(),
	    packing_hints = [PACK_AT BOTTOM],
	    traits  = [TEXT &quot;Quit&quot;, CALLBACK quit_button_callback],
	    event_callbacks = []
	}
    end
</PRE><P>
The function <TT>return_keypress_callback</TT> is bound to the the <I>Return</I> key,
and the 
function <TT>quit_button_callback</TT>, which closes the main window and hence
terminates the application, is bound to the button labelled <TT>Quit</TT>.
</P>
<P>The layout is achieved as follows: <TT>label_widget</TT>
and <TT>text_entry_widget</TT> should be placed side by side on top, with
<TT>quit_button</TT> at the bottom. To put two widgets side by side,
we put them in one widget called a frame: 
</P>
<PRE>
                                                                  my 
top_two_widgets
    =
    FRAME {
	widget_id = make_widget_id (),
	subwidgets  = PACKED [label_widget, text_entry_widget],
	packing_hints = [PACK_AT TOP],
	traits  = [],
	event_callbacks = []
    }
</PRE><P>
We are now ready to create the main window: 
</P>
<PRE>
                                                                  my 
main_window_widget
    =
    {   window_id   = main_window_ID,
	traits      = [WINDOW_TITLE &quot;Please enter name&quot;],
	subwidgets  = PACKED [top_two_widgets, quit_button],
	event_callbacks = [],
	init     = noAction
    }
</PRE><P>
Note that the order of the widgets is not important in this
particular example. However, in general order here is relevant.
Moreover, the result of the Tk layout and packing algorithm can be
somewhat surprising, and may require some experimentation. 
</P>
<P>We now have to initialize <B>tk</B>; this has to be done
before any <B>tk</B> application is started. After that, we can
start our small GUI: 
</P>
<PRE>tk.init ();
start_tcl [make_window main_window_widget];</PRE><P>
The following window appears on the screen: 
</P>
<P><IMG SRC="images/small_ex.1.gif" NAME="Grafik3" ALT="[Imagine a small window here.]" ALIGN=BOTTOM WIDTH=150 HEIGHT=80 BORDER=0>
</P>
<P>We can now click on the entry field, and type in some text,
finishing with &lt;Return&gt;, and we get: 
</P>
<P><IMG SRC="images/small_ex.2.gif" NAME="Grafik4" ALT="[Imagine a small window here with its title changed to qwerty]" ALIGN=BOTTOM WIDTH=150 HEIGHT=80 BORDER=0>
</P>
<P>&quot;Pressing&quot; the quit button (i.e. moving the cursor over
it and pressing a mouse button) closes the window and terminates the
<TT>start_tcl</TT> command. 
</P>
<H3>About this document</H3>
<P>The purpose of this documentation is: 
</P>
<UL>
	<LI>to give an informal description of the design of <B>tk</B>
	for users familiar with SML
	<BR>but unacquainted with Tk or graphical interface programming
	in general, 
	</li>
	<li>to explain the design rationale behind <B>tk</B> (Section 2), </li>
	<li>to serve as a reference manual to
	<B>tk</B> and its components (Section 3), 
	</li>
	<li>to give a description of the toolkit library (Section 4), and</li>
	<li>to explain how to install <b>tk</b> (Section 5)</li>
</UL>
A detailed description of small examples and some tricks and
debugging techniques may help beginning programmers. We suggest using
some of the smaller examples and extending them stepwise - many
frustrating beginner's errors are avoided this way. The example above
can be found in the directory <TT>src/tests+examples</TT> in the file
<TT>small_ex.pkg</TT>; that directory also contains many more
examples that the beginning <B>tk</B> programmer is encouraged to
have a look at. 
</P>
<P>This document is not intended to replace a <A HREF="http://www.tclconsortium.org/resources/manpages/">Tk-Reference
Manual</A>, rather to be complementary. For serious working with
<B>tk&nbsp;</B><SPAN STYLE="font-weight: medium">the user will
constantly want to consult this document in order to get more
information on legal options or the visual appearance of widgets.</SPAN>
</P>
<H3>History and Acknowledgements</H3>
<P>Tk is derived from Sml_Tk.  A first version of <B>Smlt_Tk</B> [KSW96] was developed from
GoferTK [VTS95]. After translating it from a lazy pure functional
language (Gofer) into an eager impure functional language (SML), and
the extension of the functionality in the following versions, only a
passing similarity remains, but we acknowledge the ancestry. We also
snatched some code for the <I>TCL_INSIDE</I> configuration on the
C-level. 
</P>
<P>More recently, Elsa Gunter and Dave McQueen of Bell Labs have made
many suggestions and contributions which we gratefully acknowledge;
in particular, Elsa Gunter has provided the implementation for
polygons, arrowheads, and mixed colours.

<P> For the current release, Erik Behrends provided code for the
<i>TCL_INSIDE</i> configuration, and Andre L&uuml;dtke many invaluable
improvements on both the kernel and the toolkit (in particular, the filer).
</P>

<H2><A NAME="design_issues"></A>2. Design Issues</H2>
<P>Technically, <B>tk</B> starts a Tcl interpreter (called a <I>wish</I>
for <U>wi</U>ndowing <U>sh</U>ell) either as subprocess or a
subroutine. At runtime, <B>tk</B> compiles
the description of the user interface (given by Widgets, Windows, etc
described above) into Tcl expressions which are passed to the wish.
<BR><B>tk</B> comes in two configurations: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">the default configuration is based
	on a loose coupling with the <I>wish</I>, which is created
	as a child process. The connection between the
	wish and <B>tk</B> is established via pipes, which is
	sufficiently fast for most applications and machines. This
	configuration runs with all SML compilers implementing the <TT>Posix</TT>
	module, on operating systems such as Linux and
	Solaris, but not Windows. 
	</P>
	<LI><P>In the so-called <I>TCL_INSIDE</I> configuration Tk is linked
	into the SML runtime system. This configuration is only available
	for one particular implementation of SML, namely SML of New Jersey
	(SML/NJ). It offers higher speed, but is slightly more difficult to
	install. However, <I>TCL_INSIDE</I> is independent from the <TT>Posix</TT>
	module of SML (and thus potentially easier to port to Windows). 
	</P>
</UL>
<P><B>tk</B> keeps an internal GUI state consisting of a list of
windows and additional information. This state is a logical image of
the (external) state of the wish. This is pretty much in the style of
[VTS95], but in contrast to the Tk interface caml_tk [PR95], where
widgets and windows are built by successive calls of functions with
side effects; in <B>tk</B>, the data types for widgets and
windows are <I>freely generated</I> in order to support a more
functional style of programming, with less side effects. 
</P>
<P>The functionality of <B>tk</B> can be divided into the
following categories: 
</P>
<OL>
	<li>constructors and selectors (<TT>selXX</TT>)
	for all datatypes;</li>
	<li>functions for dynamically <I>adding</I>,
	<I>deleting</I> and <I>updating</I> (exchanging) widgets, widget
	components or windows to the GUI;</li>
	<li>functions to inspect components in the
	GUI state (<TT>getXX</TT>)</li>
	<li>functions to inspect the actual state of the wish (<TT>readXX</TT>);</li>
	<li>functions to set the actual state of the wish (<TT>setXX</TT>,
	<TT>insertXX</TT>)</li>
</OL>
<P>The user can change the state of the wish by inserting text into a
text widget, by clicking on a radio button, by selecting a text in a
listbox, by inserting a cursor into a text, by manipulating a
scrollbar or by resizing a window. Since it would require far too
much implementation overhead to enforce the equivalence between GUI
state and state of the wish <I>automatically </I>and at all times,
the distinction between the <TT>getXX</TT>-functions and the
<TT>readXX</TT>-functions is crucial. In many cases, configuration
and coordinates in the GUI state represent only the <I>initial</I>
value, while the actual values have to be explicitly read from the
wish. This is especially the case for Tcl variables, cursor positions
within a texts, and texts editable by the user. 
</P>
<P>The GUI state is particularly useful to realize a naming
mechanism. To most widgets, event_callbacks can be annotated with the
constructor <TT>EVENT_CALLBACK</TT>, which takes as arguments an <I>event</I>
and a <I>callback</I>. An event is given by the structured data type
<TT>Event</TT>, which models events as given in Tcl (see [Oust94],
Chapter 8, pp. 199) in a structured way (examples are the events
<TT>BUTTON_PRESS(THE 1)</TT> for the first mouse button being
pressed, or <TT>KEY_PRESS &quot;Return&quot;</TT> for the Return key
being pressed), and a <I>callback</I>, which is a Mythryl function of the
functionality <TT>Tk_Event-&gt; Void</TT>. <TT>Tk_Event</TT> is a data
type containing information on the cursor position (both relative to
the window and absolute and the buttons pressed) etc. <B>tk</B>
will map the Mythryl functions (callbacks) to the events as extracted from
the GUI state, and call the relevant function when the specified
event occurs. 
</P>
<P>Tk is not completely orthogonal. In some cases, configuration
options for a widget are expressed differently for each individual
widget; <B>tk</B> allows to abstract from these.  However, the
problem remains that not every component can be arbitrarily combined
with each other, e.g. only particular widgets are allowed to build a
menu. In Tk these constraints are checked dynamically.  Since SML does
not contain a subclass concept like <A
HREF="http://www.haskell.org/">Haskell</A> which would allow to
express such contextual side conditions on the type level, a
compromise had to be made between precision in modelling the data
types on the one hand and usability, flexibility and simplicity of the
<B>tk</B> user interface on the other. This compromise consists in
collecting all configuration options into one data type, leaving
violations to dynamic checks, while in all other places the
construction of widgets is as accurate as possible.
</P>
<P>Since Tcl does not provide any data type other than texts, and in
particular no constructors for aggregations like arrays or lists,
some ad-hoc constructs had been introduced to express collections and
groups of objects. Since SML offers better ways to represent
aggregations, <B>tk</B> does not support these concepts and hence
sometimes simplifies the view of Tk. This holds also for scrollbars
(on text widgets and canvas widgets) which are no longer widgets in
their own right in <B>tk</B>. 
</P>
<P>An important design decision was made in naming SML functions
(rather than threads) to events. This is the basis for <B>tk</B>'s
simplicity; available concurrency toolkits (such as John Reppy's
Concurrent ML, which unfortunately is based on cooperative
multitasking) would limit <B>tk </B>to particular SML
implementations without providing a full solution to important
requirements (such as a kill-button for diverging threads). For these
reasons we stuck to the naming of functions to events (giving the
control to the application during its evaluation) and provided an
ad-hoc solution for the kill-button (see <A HREF="#extensions">below</A>).
</P>
<H2><A NAME="ref_man"></A>3. The <B>tk</B> Reference Manual</H2>
<P>This chapter contains a technical description of <B>tk</B>'s
export interface in a reference manual style. The export interface
consists of two apis: 
</P>
<UL>
	<li><tt>Tk_Types</tT>
	(in the file <TT>tk/src/tk_types.pkg</TT>), contains the types,
	data types along with their constructors and selectors, and
	exceptions provided by <B>tk</B>. This will be described in
	section 3.1.</li>
	<li><TT>Tk</TT> (in the file <TT>tk/src/export.pkg</TT>)
	contains the functions provided by <B>tk</B>, as described in
	section 3.2.</li>
</UL>
<P>The two apis correspond to the two phases in which a <B>tk</B>
application's interface is built. In the first phase the initial
appearance of the interface is specified in a declarative way,
, using the data types from
<TT><I><FONT FACE="courier">Tk_Types</FONT></I></TT>.
Then in the second phase
control is passed to <B>tk</B>, and the runtime behaviour of the
application is a <I>reactive system</I>, i.e. the application's
behaviour is a reaction to the user's input, implemented using the
functions from <TT><I>Tk</I></TT> which allow dynamic changes to
the interface and much more. 
</P>
<P>The main external interface of <B>tk</B> is the class <TT>tk</TT>.
Its export interface consists of a join of the two apis
<TT>Tk_Types</TT> and <TT>Tk</TT>, which completely restrict the
implementing class (also in the file <TT>tk/src/export.pkg</TT>).
In SML terminology, the joint api is the <I>opaque&nbsp;</I> interface
to <B>tk</B>. 
</P>
<H3>3.1. The Api <TT>Tk_Types</TT></H3>
<P>This section describes the api <TT>Tk_Types</TT>. It mainly
contains the data types, constructors and selectors for the <I>freely
generated term package</I> by which the user interface is
declaratively specified.
</P>
<P>The data structures closely mirror the Tk concepts. In order to
understand these concepts, such as the different kinds of widgets,
their purpose and configuration options, the graphical layout and the
behaviour of the Tk layout algorithm (the &quot;packer&quot;), it
will be necessary to consult the Tcl/Tk-book [REF 96] or the <A HREF="http://www.tclconsortium.org/resources/manpages/">manual
pages</A> from the Tcl/Tk distribution package. This documentation
will not try to explain these Tk concepts, but rather point out where
<B>tk</B> behaves differently from Tk. 
</P>
<H4>3.1.1 Identifiers</H4>
<P>The following types are identifiers for windows, widgets, canvas
items, text text_items and images, respectively. See <A HREF="#ids">section
3.2.1</A> below how to create identifiers. 
</P>
<PRE> type Window_ID
 type Widget_ID
 type Canvas_Item_ID
 type Text_Item_ID
 type Image_ID</PRE><H4>
<A NAME="exceptions"></A>3.1.2. Exceptions</H4>
<P>Exceptions usually indicate a programming error. Favourite
examples include referring to non-existing widgets, windows or canvas
items, wrong configurations (some widgets require certain
configurations whereas others prohibit them), applying partial
selectors to the wrong variant of the data type, using non-existing
fonts or loading non-existing images. 
</P>
<PRE> exception CANVAS_ITEM of String
 exception WIDGET of String
 exception TCL_ERROR of String
 exception CONFIG of String
 exception WINDOWS of String</PRE><P>
There are two functions with which to start a <B>tk</B>
application; one catches these exceptions and prints the relevant
string (containing an error message), and one does not (see <A HREF="#eventloop">section
3.2.2</A> below). It should be pointed out these exceptions indicate
some kind of malfunction, usually a programming error, so just
catching them and continuing is not such a bright idea. 
</P>
<H4>3.1.3. <TT>Tk_Events</TT>, Callbacks and Event_Callbacks</H4>
<P>When running as reactive system, activation is driven by <I>events</I>
such as mouse buttons or keys being pressed, or the cursor entering
or leaving widgets (or more precisely, their graphical representations on the screen).
</P>
<P>The most common reaction in Tk applications is that of a <TT>CALLBACK</TT>.
Callbacks are specified as part of the <I>Trait</I> information in
widgets such as buttons. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> type Void_Callback = (Void -&gt; Void)</PRE><P>
For finer control of the interactive behaviour of the application,
the data type <TT>Event_Callback</TT> specifies a particular event and the
corresponding reaction. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> enum Event_Callback = EVENT_CALLBACK of Event * Callback</PRE><P>
Events are given by the enum <TT>Event</TT>. Events are either
basic events, or modifications of events.<p>Basic events are: 
</P>
<UL>
	<li>Keys being pressed or released (<TT>KEY_PRESS</TT>, <TT>KEY_RELEASE</TT>;
	the argument is a string describing the key being pressed, e.g. <TT>&quot;a&quot;</TT>
	or <TT>&quot;Return&quot;</TT>&quot;), 
	</li>
	<li>Mouse buttons being pressed or
	released (<TT>BUTTON_PRESS</TT>, <TT>BUTTON_RELEASE</TT>; the
	<BR>argument here is a specific mouse button, or <TT>NULL</TT> for
	any mouse button), or 
	</li>
	<li>The cursor entering (<TT>ENTER</TT>), leaving (<TT>LEAVE</TT>),
	or moving (<TT>MOTION</TT>) within a window or widget.</li>
</UL>
<P>These can be modified as follows: 
</P>
<UL>
	<li>A modifier key being pressed while the
	event occurs. Modifier keys are <TT>SHIFT</TT>, <TT>CONTROL</TT>, <TT>LOCK</TT>,
	<TT>ANY</TT>, <TT>ALT</TT>,<TT>META</TT>, <TT>MOD3</TT>, <TT>MOD4</TT>
	or <TT>MOD5</TT>. (Your keyboard may not provide all of these,
	though.)</li>
	<li>A <TT>BUTTON_PRESS</TT> event occurs
	twice or thrice within a certain period of time (<TT>DOUBLE</TT> or
	<TT>TRIPLE</TT>).</li>
	<li>A mouse button is being pressed while the event occurs
	(<TT>MODIFIER_BUTTON</TT>).</li>
</UL>
<P>A final different kind of event is given by <TT>DEPRECATED_EVENT</TT>, which
takes as argument a description of events in the style of Tcl (see
[Oust94] section 18.3). This kind of event description is strongly
discouraged, though, since syntactically wrong event descriptions
lead to a wish runtime error. 
</P>
<PRE> enum Event =
 #  window events 
 FOCUS_IN
 | FOCUS_OUT
 | CONFIGURE
 | MAP
 | UNMAP
 | VISIBILITY
 | DESTROY
 #  Key press/release events 
 | KEY_PRESS of String
 | KEY_RELEASE of String
 #  Button press/release events, NULL means any old Button 
 | BUTTON_PRESS of Int null_or.option
 | BUTTON_RELEASE of Int null_or.option
 #  Cursor events 
 | ENTER | LEAVE | MOTION
 #  user-defined events, or explicitly given events 
 | DEPRECATED_EVENT of String
 #  event modifiers 
 | SHIFT of Event | CONTROL of Event | LOCK of Event | ANY of Event
 | DOUBLE of Event | TRIPLE of Event
 | MODIFIER_BUTTON of Int * Event
 | ALT of Event | META of Event
 | MOD3 of Event | MOD4 of Event | MOD5 of Event</PRE><P STYLE="line-height: 100%">
Not all possible combinations make sense though; for example, a
button event modified with a different button, or a doubled enter
event are clearly paradoxical (and hence will never occur, so naming
anything to them is a lost cause). A <TT>Callback</TT> is an ML
function to be called when the specified event occurs:</P>
<PRE STYLE="margin-bottom: 0.2in"> type Callback = (Tk_Event -&gt; Void)</PRE><P>
Events have the following package: 
</P>
<PRE> 
enum Tk_Event =
 TK_EVENT of Int #  %b button number 
          * String #  %s state field 
          * Int #  %x x field 
          * Int #  %y y field 
          * Int #  %X x_root field 
          * Int /* %Y y_root field */</PRE><P>
The corresponding selector functions are: 
</P>
<PRE> 
 my get_button   : Tk_Event -&gt; Int
 my get_state    : Tk_Event -&gt; String
 my get_x_coordinate     : Tk_Event -&gt; Int
 my get_root_x_coordinate : Tk_Event -&gt; Int
 my get_y_coordinate     : Tk_Event -&gt; Int
 my get_root_y_coordinate : Tk_Event -&gt; Int</PRE><P>
When no naming for an event has been specified, nothing happens,
e.g. a button press in a canvas widget is simply ignored if no
naming has been specified and does <I>not</I> lead to an error. 
</P>
<P>With some widgets or items, not all events are allowed in their
naming; further, the information in <TT>Tk_Event</TT> is only valid
for some, but not all of the events. See chapter 18 in the Tcl/Tk
handbook [Oust94] or the <TT>bind</TT> manual page about the details
of events and event_callbacks. 
</P>
<P>Be also warned that the interaction between mouse button presses
and mouse movements is fairly intricate: when a mouse button is being
pressed, all subsequent mouse events go to the widget or item over
which this event has occurred until the mouse button is released. In
particular, no enter event is generated if the mouse is moved into
another widget, item or window with the mouse button pressed, the
enter event will only be generated once the mouse button has been
released. 
</P>
<P>Finally, be aware that the <I>keyboard focus</I> (see <A HREF="#focus">section
3.2.14</A>) determines where keyboard events go. It will rarely make
sense to bind actions to keys in widgets other than text widgets or
entry widgets, since these other widgets will usually not be in a
position to receive keyboard events. 
</P>
<H4>3.1.4. Fonts</H4>
<P>Fonts in <B>tk</B> are described by the data type <TT>Font</TT>,
which offers a slight abstraction over the standard X11 description.
The idea is to provide a set of standard fonts, which can be modified
for style and size. These standard fonts are mapped (on calling
<TT>tk.init</TT>) to specific X11 fonts. If a specific font is not
found (e.g. in a particular size or weight), another one is selected.
This approach has been chosen because fonts are provided by the X
server, and hence can change; this way, applications can still use
different fonts, but are not dependent on any particular X11 font
being present in the server. 
</P>
<P>The standard fonts are <TT>NORMAL_FONT</TT>, <TT>TYPEWRITER</TT>,
<TT>SANS_SERIF</TT> and <TT>SYMBOL</TT>. They can be modified as <TT>BOLD</TT>,
<TT>ITALIC</TT>, <TT>TINY</TT> (very small), <TT>SMALL</TT>,
<TT>NORMAL_SIZE</TT>, <TT>LARGE</TT> and <TT>HUGE</TT>. The modifier
<TT>SCALE</TT> allows to scale fonts arbitrarily, where <TT>SCALE 1.0</TT>
has the same effect as <TT>NORMAL_SIZE</TT>. Users insisting on a
particular X11 font can obtain these by <TT>XFONT</TT>. 
</P>
<PRE> enum Font_Trait = BOLD | ITALIC |
                       TINY | SMALL | NORMAL_SIZE | LARGE | HUGE |
                       SCALE of real

 enum Font = XFONT of String
               | NORMAL_FONT of Font_Trait List
               | TYPEWRITER of Font_Trait List
               | SANS_SERIF of Font_Trait List
               | SYMBOL of Font_Trait List</PRE><P>
The mapping of the standard fonts to the X11 font implementing them
is described by the type <TT>fonts.Config</TT>. The provided defaults
are as follows: 
</P>
<PRE> 
                                                                                my 
font_config
    =
    {   normal_font = ref &quot;-*-courier&quot;,
        typewriter = ref &quot;-misc-fixed&quot;,
        sans_serif = ref &quot;-*-helvetica&quot;,
        symbol = ref &quot;-*-symbol&quot;,
        base_size = ref 12,
        exact_match = ref true,
        resolution = ref 75
    }
</PRE>
<H4>3.1.5. Widget Configuration Options</H4>
<P><TT>Trait</TT> information correspond to Tk's <I>options</I>.
It is the information used to customise the predefined widgets.
Trait options which have not been specified are left open, and
the default for the widget type in question is chosen. 
</P>
<P>The effects and intended use of the various configuration options,
and which option is valid for which kind of widget, can be found in
the Tk manual. The following configure options are supported by
<B>tk</B>. For every constructor we give the corresponding Tk
option for easier reference to the Tk manual pages. 
</P>
<PRE> enum Trait =
 WIDTH of Int #  -width ... 
 | HEIGHT of Int #  -height ... 
 | BORDER_WIDTH of Int #  -borderwidth ... 
 | RELIEF of Relief_Kind #  -relief ... 
 | FOREGROUND of Color #  -foreground ... 
 | BACKGROUND of Color #  -background ... 
 | MENU_UNDERLINE of Int #  -underline ... for menus 
 | ACCELERATOR of String #  -accelerator &quot;bla&quot; 
 | TEXT of String #  -Label &quot;bla&quot; 
 | FONT of fonts.Font #  -font &quot;bla&quot; 
 | VARIABLE of String #  -variable &quot;bla&quot; 
 | VALUE of String #  -value &quot;bla&quot; 
 | ICON of Icon_Variety #  -bitmap or -image ... 
 | CURSOR of Cursor_Kind #  -cursor ... 
 | CALLBACK of Void_Callback #  -command ... 
 | ANCHOR of Anchor_Kind #  -anchor ... 
 | FILL_COLOR of Color #  -fill ... 
 | OUTLINE of Color #  -outline ... 
 | OUTLINE_WIDTH of Int #  -width ... 
 | SMOOTH of Bool #  -smooth .. 
 | ARROW of Arrowhead_Pos #  -arrow ... 
 | SCROLL_REGION of Int * Int * Int * Int #  -scrollregion ... 
 | CAP_STYLE of Capstyle_Kind #  -capstyle ... 
 | JOIN_STYLE of Joinstyle_Kind #  -joinstyle ... 
 | COLOR_MAP of Colormap_Entry List #  -colormap ... 
 | COLOR_MODE of Color_Mode #  -colormode ... 
 | FILE of String #  -file ... 
 | FONT_MAP of Fontmap_Entry List #  -fontmap ... 
 | PRINT_HEIGHT of String #  -height ... 
 | PAGE_ANCHOR of Anchor_Kind #  -pageanchor ... 
 | PAGE_HEIGHT of String #  -pageheight ... 
 | PAGE_WIDTH of String #  -pagewidth ... 
 | PAGE_X of String #  -pagex ... 
 | PAGE_Y of String #  -pagey ... 
 | ROTATE of Bool #  -rotate ... 
 | PRINT_WIDTH of String #  -width ... 
 | PRINT_X of String #  -x ... 
 | PRINT_Y of String #  -y ... 
 | OFFSET of Int #  -offset ... Offset over baseline for texts 
 | UNDERLINE #  -underline ... underline for texts (see MUnderline above) 
 | JUSTIFY of Justify #  -justify ... Justification: left/right/center 
 | WRAP of Wrap_Mode #  -wrap ... 
 | ORIENT of Orientation #  -orient ... 
 | ACTIVE of Bool #  -state ... 

 #  Scale configurations 
 | SLIDER_LABEL of String #  -label ... 
 | LENGTH of Int #  -length ... 
 | SLIDER_LENGTH of Int #  -sliderlength ... 
 | FROM of real #  -from ... 
 | TO of real #  -to ... 
 | RESOLUTION of real #  -resolution ... 
 | DIGITS of Int #  -digits ... 
 | BIG_INCREMENT of real #  -bigincrement ... 
 | TICK_INTERVAL of real #  -tickinterval ... 
 | SHOW_VALUE of Bool #  -showvalue ... 
 | SLIDER_RELIEF of Relief_Kind #  -sliderrelief ... 
 | REAL_CALLBACK of Real_Callback #  -command ... special command for use with scales (called with the scale value) 
 | REPEAT_DELAY of Int #  -repeatdelay ... 
 | REPEAT_INTERVAL of Int #  -repeatinterval ... 
 | THROUGH_COLOR of Color #  -throughcolor ... 

 | INNER_PAD_X of Int #  -padx ... 
 | INNER_PAD_Y of Int #  -pady ... 
 | SHOW of char #  -show ... (password entry fields etc.) 
 | TEAR_OFF of Bool /* -tearoff ... tearoff for menus */</PRE><H4>
Relief</H4>
<PRE> enum Relief_Kind = FLAT | GROOVE | RAISED | RIDGE | SUNKEN</PRE><P>
The relief customises the visual three-dimensional appearance (see
[Oust94] section 16.1.1) of widgets. 
</P>
<H4>Colours</H4>
<PRE> 
enum Color = NO_COLOR | BLACK | WHITE | GREY | BLUE | GREEN | RED | BROWN | YELLOW
               | PURPLE | ORANGE | MIX of {red : Int, blue : Int, green : Int}</PRE><P>
We apologise to British users for the spelling (and blame Tk for it).
</P>
<H4>Anchor Kind</H4>
<PRE> enum Anchor_Kind = NORTH | NORTHEAST |
                       EAST | SOUTHEAST |
                       SOUTH | SOUTHWEST |
                       WEST | NORTHWEST |
                       CENTER</PRE><P>
<A NAME="icons1"></A>The option <TT>Anchor_Kind</TT> is used for the
orientation of an object with respect to their position (anchor) (see
[Oust94] section 16.11.2). 
</P>
<H4>Capstyle and Joinstyle</H4>
<P>These datatypes describe how lines, when drawing on a canvas, are
joint. 
</P>
<PRE> enum Capstyle_Kind = BUTT | PROJECTING | ROUND
 enum Joinstyle_Kind = BEVEL | MITER | ROUND_JOIN</PRE><H4>
Icons and Images</H4>
<PRE> type Bitmap_Name
 type Bitmap_File
 type Image_File

 enum Icon_Variety =
 NO_ICON
 | TK_BITMAP of Bitmap_Name #  -bitmap &lt;tk bitmap&gt; 
 | FILE_BITMAP of Bitmap_File #  -bitmap @&lt;filename&gt; 
 | FILE_IMAGE of Image_File * Image_ID /* -image ... */</PRE><P>
<TT>TK_BITMAP</TT> and <TT>FILE_BITMAP</TT> allow the use of X11
bitmaps. <TT>Bitmap_Name</TT> must be the name of one of Tk's internal
bitmaps. <TT>Bitmap_File</TT> specifies a pathname of a file with the
appropriate format. Bitmaps can be used with some widgets such as
<TT>LABEL</TT> or <TT>BUTTON</TT> (see also the <TT>bitmap</TT>
manual page or [Oust94] section 16.3.3), and in <I>canvas items</I>
(see <A HREF="#citems">section 3.1.7</A>). 
</P>
<P>Tk also supports images (with depth more than 1). Images are
specified with <TT>FILE_IMAGE</TT>, where <TT>Image_File</TT> is the
pathname of a file in a recognised format such as GIF (for other
formats supported see the <TT>image</TT> manual page). Examples can
be found in <TT>src/tests+examples/big_ex.pkg</TT>. 
</P>
<P>The three types <TT>Bitmap_Name</TT>, <TT>Bitmap_File</TT> and
<TT>Image_File</TT> are synonymous with <TT>String</TT>. 
</P>
<H4>Cursors</H4>
<PRE> type Cursor_Name
 type Cursor_File

 enum Cursor_Kind
     =
 NO_CURSOR
 | XCURSOR of Cursor_Name * ((Color * (Color Null_Or )) Null_Or )
 | FILE_CURSOR of Cursor_File * Color * ((Cursor_File * Color) Null_Or )</PRE><P>
With <TT>XCURSOR</TT> the predefined Tk cursors can be used, where
the argument <TT>Cursor_Name</TT> is the name of a Tk cursor. The next
two optional arguments are for the foreground and background colour
of the bitmap cursor. 
</P>
<P>One can also use self-designed cursors via the constructor
<TT>FILE_CURSOR</TT>. The first argument is the name of the bitmap
file (<TT>Cursor_File</TT>) for the cursor, the second the foreground
colour and the last two optional arguments are a mask file
(<TT>Cursor_File</TT>) and the respective background colour. 
</P>
<P>The types <TT>Cursor_Name</TT> and <TT>Cursor_File</TT> are
synonymous with <TT>String</TT>. 
</P>
<P>Examples can be found in <TT>src/tests+examples/big_ex.pkg</TT>
and details in [Oust94] section 16.11.1. 
</P>
<P>If users find they need to use Tk options which are not supported
by <strong>tk</strong>, they are invited to add support for them;
look at <TT>src/config.pkg</TT> to see how the other configurations
are translated in Tcl code (and that is essentially all there is to
do).
</P>
<H4>3.1.6. Controlling the Layout</H4>
<P>The layout in <B>tk</B> is done with the Tk packer. Since
release 3.0 <B>tk</B> also supports grid packing, which means
that you also place widgets in a specified row and column of a grid
within a container. You can choose the packing algorithm using the
<TT>PACKED</TT> or <TT>GRIDDED</TT> constructor of the type <TT>Widgets</TT>,
which is used to specify the initial content of a container
(containers in <B>tk</B> are <TT>FRAME</TT> as a normal container
widget, <TT>TEXT_ITEM_WIDGET</TT> for widgets within annotated texts, <TT>CANVAS_WIDGET</TT>
for widgets within canvases, and of course windows). Once chosen you
can not change the applied packing algorithm. The programmer is
strongly encouraged to read chapter 17 of [Oust94] and try out some
of the examples, as the Tk packer exhibits a somewhat intractable
behaviour with occasionally rather surprising results; hence a
certain amount of experimentation and experience will not go amiss. 
</P>
<P>Bear in mind that 
</P>
<UL>
	<LI>pack information, once specified for a
	given widget, cannot be changed; and
	<LI>pack information not specified is left to Tk to use its default
	values.
</UL>
<P><B>tk</B> implements a basic subset of Tk's pack options and
possibilities. These are: 
</P>
<PRE> enum Edge = TOP | BOTTOM | LEFT | RIGHT
 enum Fill_Style = ONLY_X | ONLY_Y | XY

 enum Sticky_Kind = TO_N   | TO_S   | TO_E   | TO_W   | 
                        TO_NS  | TO_NE  | TO_NW  | TO_SE  |
                        TO_SW  | TO_EW  | TO_NSE | TO_NSW |
                        TO_NEW | TO_SEW | TO_NSEW

 enum Packing_Hint
     =
     EXPAND of Bool
   | FILL of Fill_Style
   | PAD_X of Int
   | PAD_Y of Int
   | PACK_AT of Edge
   | COLUMN of Int
   | ROW of Int
   | STICK of Sticky_Kind
</PRE>
<H4>3.1.7. The core of <B>tk</B>: Widgets and their Components</H4>

<P>Widgets (and their components) are the most important and powerful
enum of <B>tk</B> (and Tk). They are the basic building
blocks of any gui. 
</P>
<P>The different types of widgets are explained in the chapter <I>A
guided Tour through Tk Widgets</I> in [Oust94]. <B>tk</B> offers
one constructor for every widget type. Selector and update functions
on widgets are given where useful. 
</P>
<P>Some widgets like frames (a grouping of widgets), canvas widgets
(a &quot;drawing pad&quot;) and text widgets can contain either
widgets themselves, or items (canvas items or text text_items) which
contain widgets; this results in a mutually recursive, fairly lengthy
data type definition. 
</P>
<P>As remarked above, the <TT>Widget</TT>, <TT>Canvas_Item</TT> and
<TT>Text_Item</TT> data types have some parameters which are only
intended as <I>initial</I> values. They appear in italics below. If
one wants to get the actual value of such an initial value, one has
to use a <TT>readXXX</TT> function rather than a <TT>getXXX</TT> or
<TT>selXXX</TT> function. 
</P>
<PRE>enum Widget =
 FRAME of {widget_id : Widget_ID, subwidgets : Widgets,
           packing_hints : Packing_Hint List, traits : Trait List,
           event_callbacks : Event_Callback List}
 | MESSAGE of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
               traits : Trait List, event_callbacks : Event_Callback List}
 | LABEL of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
             traits : Trait List, event_callbacks : Event_Callback List}
 | LIST_BOX of {widget_id : Widget_ID, scrollbars : Scrollbars_At,
               packing_hints : Packing_Hint List, traits : Trait List,
               event_callbacks : Event_Callback List}
 | BUTTON of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
              traits : Trait List, event_callbacks : Event_Callback List}
 | RADIO_BUTTON of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
                   traits : Trait List, event_callbacks : Event_Callback List}
 | CHECK_BUTTON of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
                   traits : Trait List, event_callbacks : Event_Callback List}
 | MENU_BUTTON of {widget_id : Widget_ID, mitems : Menu_Item List,
                  packing_hints : Packing_Hint List, traits : Trait List,
                  event_callbacks : Event_Callback List}
 | TEXT_ENTRY of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
             traits : Trait List, event_callbacks : Event_Callback List}
 | TEXT_WIDGET of {widget_id : Widget_ID, scrollbars : Scrollbars_At,
               live_text : Live_Text, packing_hints : Packing_Hint List,
               traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS of {widget_id : Widget_ID, scrollbars : Scrollbars_At,
              citems : Canvas_Item List, packing_hints : Packing_Hint List,
              traits : Trait List, event_callbacks : Event_Callback List}
 | POPUP of {widget_id : Widget_ID, tearoff : Bool, mitems : Menu_Item List}
 | SCALE_WIDGET of {widget_id : Widget_ID, packing_hints : Packing_Hint List,
                traits : Trait List, event_callbacks : Event_Callback List}
 and Widgets = PACKED of (Widget List)
             | GRIDDED of (Widget List)</PRE>
<P>
The type <TT>Widgets</TT> represents a collection of widgets, packed
either with Tk's Packer geometry manager, or with the Grid geometry
manager. Every widget has an identifier of the type <TT>Widget_ID</TT>,
and pack information, configuration options and event_callbacks. Other
parameters are widget specific, such as The following are useful
selector and update functions for <TT>Widget</TT>. (Note that you
can't update the widget identifier.) Some of these are necessarily
partial, and when applied to the wrong variant of widget will raise
the exception <TT>WIDGET</TT>. First, the ones applicable to all
widgets: 
</P>
<PRE> 
 my get_widget_id   : Widget -&gt; Widget_ID
 my get_widget_event_callbacks : Widget -&gt; Event_Callback List
 my get_widget_traits : Widget -&gt; Trait List
 my get_widget_packing_hints : Widget -&gt; Packing_Hint List

 my update_widget_event_callbacks : Widget -&gt; Event_Callback List -&gt; Widget
 my update_widget_traits : Widget -&gt; Trait List -&gt; Widget</PRE><P>
Functions specific to <TT>Canvas</TT>: my update_widget_packing_hints : Widget -&gt;
Packing_Hint List-&gt; Widget 
</P>
<PRE> 
 my get_canvas_items      : Widget -&gt; Canvas_Item List
 my get_canvas_scrollbars : Widget -&gt; Scrollbars_At

 my update_canvas_items      : Widget -&gt; Canvas_Item List -&gt; Widget
 my update_canvas_scrollbars : Widget -&gt; Scrollbars_At -&gt; Widget</PRE><P>
Functions specific to <TT>TEXT_WIDGET</TT>: 
</P>
<PRE> 
 my get_text_widget_scrollbars  : Widget -&gt; Scrollbars_At
 my get_text_widget_text        : Widget -&gt; String
 my get_text_widget_text_items : Widget -&gt; Text_Item List

 my update_text_widget_scrollbars  : Widget -&gt; Scrollbars_At -&gt; Widget
 my update_text_widget_annotations : Widget -&gt; Text_Item List -&gt; Widget</PRE><H4>
Scrollbars</H4>
<P>As opposed to Tk, <B>tk</B> does not offer a dedicated widget
type for scrollbars. Rather, for the widget types for which scroll
bars are useful- text widgets, canvas widgets, and list boxes-
scrollbars are provided automatically. Their location is determined
by the argument <TT>scrollbars</TT> in their constructor (where
<TT>NOWHERE</TT> means no scroll bars at all). 
</P>
<PRE STYLE="margin-bottom: 0.2in"> enum Scrollbars_At = NOWHERE | AT_LEFT | AT_RIGHT | AT_TOP | AT_BOTTOM |
 AT_LEFT_AND_TOP | AT_RIGHT_AND_TOP | AT_LEFT_AND_BOTTOM | AT_RIGHT_AND_BOTTOM</PRE><P>
<A NAME="citems"></A>This also has the advantage that the programmer
need not to concern himself with the programming of the scroll bar. 
</P>
<H4>Canvas Items</H4>
<P>A <I>canvas</I> widget is a &quot;drawing pad&quot;. Drawing on a
canvas is done by placing the following <I>canvas items</I> onto it,
and as opposed to normal widgets, the location of the items is
exactly specified by means of coordinates, rather than left to a
packing algorithm. In the toolkit library, canvas widgets have been
used to implement a drag&amp;drop package and a generic user
interface (see <A HREF="#toolkit">section 4</A>). 
</P>
<P><B>tk</B> provides all types of canvas items found in Tk.
These are: 
</P>
<PRE>enum Canvas_Item
    =
    CANVAS_RECTANGLE of {citemId : Canvas_Item_ID, <I>coord1 : Coordinate</I>, <I>coord2 : Coordinate</I>,
                traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_OVAL of {citemId : Canvas_Item_ID, <I>coord1 : Coordinate</I>, <I>coord2 : Coordinate</I>,
             traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_LINE of {citemId : Canvas_Item_ID, <I>coords : Coordinate List</I>,
             traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_POLYGON of {citemId : Canvas_Item_ID, <I>coords : Coordinate List</I>,
             traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_TEXT of {citemId : Canvas_Item_ID, <I>coord : Coordinate</I>,
             traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_ICON of {citemId : Canvas_Item_ID, <I>coord : Coordinate</I>, icon_variety : Icon_Variety,
             traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_WIDGET of {citemId : Canvas_Item_ID, <I>coord : Coordinate</I>, subwidgets : Widgets,
               traits : Trait List, event_callbacks : Event_Callback List}
 | CANVAS_TAG of {citemId : Canvas_Item_ID, citemIds : Canvas_Item_ID List}</PRE><P>
As already noted above, italic parameters are the initial value.
Coordinates as arguments of the constructors allow convenient
specification of the initial position. 
</P>
<P>The following are the selector and update functions for <TT>Canvas_Item</TT>.
Again, some of them will be necessarily partial and when applied to
the wrong type of widget will raise an exception <TT>CANVAS_ITEM</TT>.
First, the functions applicable to most or all canvas items: 
</P>
<PRE> my get_canvas_item_ID : Canvas_Item -&gt; Canvas_Item_ID
 my get_canvas_item_coordinates : Canvas_Item -&gt; Coordinate List
 my get_canvas_item_traits   : Canvas_Item -&gt; Trait List
 my get_canvas_item_event_callbacks   : Canvas_Item -&gt; Event_Callback List

 my update_canvas_item_coordinates : Canvas_Item -&gt; Coordinate List -&gt; Canvas_Item
 my update_canvas_item_traits   : Canvas_Item -&gt; Trait List -&gt; Canvas_Item
 my update_canvas_item_event_callbacks   : Canvas_Item -&gt; Event_Callback List -&gt; Canvas_Item</PRE><P>
The following are specific to <TT>CANVAS_ICON</TT>: 
</P>
<PRE> my get_canvas_item_icon : Canvas_Item -&gt; Icon_Variety

 my update_canvas_item_icon : Canvas_Item -&gt; Icon_Variety -&gt; Canvas_Item</PRE><P>
Within a <TT>CANVAS_ICON</TT> item one can have the same bitmaps and images
as presented in <A HREF="#icons">section 3.1.5</A>. 
</P>
<P>The following are specific to <TT>CANVAS_WIDGET</TT>: 
</P>
<PRE>
 my get_canvas_item_subwidgets : Canvas_Item -&gt; Widget List

 my updItemWidgetConf : Canvas_Item -&gt; Trait List -&gt; Canvas_Item
 my update_canvas_item_subwidgets : Canvas_Item -&gt; Widget List -&gt; Canvas_Item</PRE><P>
<TT>CANVAS_WIDGET</TT> allows widgets within canvas items. Tk offers to
have one widget within a <I>window item</I>. We found it useful to
have more than one, so an <B>tk</B> widget canvas item contains a
list of widgets, which are placed within a frame widget. The <TT>Widget_ID</TT>
and <TT>Configuration</TT> arguments of the <TT>CANVAS_WIDGET</TT>
constructor refer to this frame widget. The identifier for the frame
widget must be obtained by using the function <TT>make_canvas_item_frame_id</TT>
(see <A HREF="#ids">section 3.2.1</A>). 
</P>
<P>The following functions are specific for <TT>CANVAS_TAG</TT>: 
</P>
<PRE> my get_canvas_item_canvas_items : Canvas_Item -&gt; Canvas_Item_ID List

 my update_canvas_item_canvas_items : Canvas_Item -&gt; Canvas_Item_ID List -&gt; Canvas_Item</PRE><P>
<TT>CANVAS_TAG</TT> is only a very weak way of structuring canvas items.
Many of the operations on <TT>CItems</TT> are not applicable to <TT>CANVAS_TAG</TT>,
but e.g. <TT>move_canvas_item</TT> and <TT>set_canvas_item_coordinates</TT> are, giving a
convenient way of moving about groups of canvas items. 
</P>
<H4><A NAME="text_items"></A>Text Annotations and Annotated Texts</H4>
<P>Text annotations are event_callbacks and traits for specific
parts of text within a text widget. They can be used for two
purposes, corresponding to the two variants of the data type
<TT>Text_Item</TT> below: 
</P>
<UL>
	<LI>First, to have different fonts or
	styles, or even event_callbacks, for parts of the text. By associating
	event_callbacks with regions of text, one can implement hyperlink-like
	structures as in HTML (but the action bound to a hyperlink can be
	arbitrary).
	<LI>Second, to have subwidgets embedded within text widgets (to
	continue the HTML analogy, embedded widgets allow the design of
	form-like texts, but again far more versatile)
</UL>
<P><A NAME="mark"></A>Positions or regions within a text are
specified with the data type <TT>MARK</TT>. For historical reasons,
<B>tk</B>'s marks are Tk's indices. For details, see [Oust94]
section 19.6. 
</P>
<PRE> enum Mark = MARK of Int #  line number [1..] 
                        * Int #  Char number [0..] 
    | MARK_TO_END of Int #  end of line i 
    | MARK_END #  end of text 


 and Text_Item =
 TEXT_ITEM_TAG of {text_item_ID : Text_Item_ID, marks : (Mark * Mark) List,
           traits : Trait List, event_callbacks : Event_Callback List}
 | TEXT_ITEM_WIDGET of {text_item_ID : Text_Item_ID, mark : Mark, widget_id : Widget_ID,
           subwidgets : Widgets, traits1 : Trait List,
           traits2 : Trait List, event_callbacks : Event_Callback List}</PRE><P>
As already noted italic arguments are only initial values. The
position arguments of the constructors allow convenient specification
of their initial position. 
</P>
<P>The following are the selector and update functions for
<TT>Text_Item</TT>. First, those that are applicable to both
variants of text_items: 
</P>
<PRE> my get_text_item_ID : Text_Item -&gt; Text_Item_ID
 my get_text_item_traits : Text_Item -&gt; Trait List
 my get_text_item_event_callbacks : Text_Item -&gt; Event_Callback List
 my get_text_item_marks : Text_Item -&gt; (Mark * Mark) List

 my update_text_item_traits : Text_Item -&gt; Trait List -&gt; Text_Item
 my update_text_item_event_callbacks : Text_Item -&gt; Event_Callback List -&gt; Text_Item</PRE><P>
<TT>get_text_item_marks</TT> applied to a <TT>TEXT_ITEM_WIDGET</TT> returns a
singleton list containing a pair of two marks both equal to the
position of the widget annotation, i.e. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> get_text_item_marks(TEXT_ITEM_WIDGET(_,p,_,_,_,_,_)) = [(p, p)]</PRE><P>
The following functions are specific to <TT>TEXT_ITEM_WIDGET</TT> and will
raise an exception <TT>TEXT_ITEM</TT> when applied to <TT>TEXT_ITEM_TAG</TT>.
</P>
<PRE> my get_text_item_widget_ID : Text_Item -&gt; Widget_ID
 my get_text_widget_subwidgets : Text_Item -&gt; Widget List
 my get_text_item_widget_traits : Text_Item -&gt; Trait List

 my update_text_item_subwidgets : Text_Item -&gt; Widget List -&gt; Text_Item</PRE><P>
<TT>TEXT_ITEM_WIDGET</TT> allows to embed widgets within a text. Tk offers to
have one widget within a <I>window annotation</I>. We found it useful
to have more than one, so an <B>tk</B> widget annotation contains
a list of widgets, which are placed within a frame widget. The <TT>Widget_ID</TT>
and <TT>Configuration</TT> arguments of the <TT>TEXT_ITEM_WIDGET</TT>
constructor refer to this frame widget. The identifier for the frame
widget must be obtained by using the function <TT>make_text_item_frame_ID</TT>
(see <A HREF="#ids">section 3.2.1</A>). 
</P>
<H4><A NAME="anno_text"></A>Annotated Texts</H4>
<P>Annotated texts consist of a text, given by a string, and a list
of text_items within that text. They are provided as a separate
enum because this way they can be treated abstractly; e.g. there
is a function which concatenates two annotated texts, adjusting the
text_items in the second text (see <A HREF="#anno_texts">section
3.2.9</A>). The first, optional argument of the constructor <TT>LIVE_TEXT</TT>
in the following is the length of the text (in lines and columns); if
it is not given, it will be calculated on a by-need basis. 
</P>
<PRE> and Live_Text =
 LIVE_TEXT of {len : (Int* Int) null_or.option, str : String,
 text_items : Text_Item List}</PRE><P>
The selectors and update functions for annotated texts are 
</P>
<PRE> my get_livetext_text : Live_Text -&gt; String
 my get_livetext_text_items : Live_Text -&gt; Text_Item List
 my update_livetext_text_items : Live_Text -&gt; Text_Item List -&gt; Live_Text</PRE><P>
Annotated texts can be conveniently produced with <B>tk</B>'s
markup language and the generic parser provided for it (see <A HREF="#markup_parser">section
4.2</A>), which alleviates the need to meticulously count lines and
columns within a text. 
</P>
<H4><A NAME="mitems"></A>Menu Items</H4>
<P>A menu is a list of the following items: 
</P>
<PRE> and Menu_Item = MENU_CHECKBUTTON of (Trait) List
            | MENU_RADIOBUTTON of (Trait) List
            | MENU_CASCADE of Menu_Item List * Trait List
            | MENU_SEPARATOR
            | MENU_COMMAND of (Trait) List</PRE><P>
These correspond to the Tk type. Note that for <TT>MENU_CHECKBUTTONs</TT>
and <TT>MENU_RADIOBUTTON</TT>, a Tcl variable has to be specified (using
the <TT>Variable</TT> configuration option) holding the status of the
check or radio button. Their current status can be read using
<TT>get_tcl_var_value</TT> (see <A HREF="#tclvalues">section 3.2.10</A>
below). Following are the selectors for <TT>Menu_Item</TT>: 
</P>
<PRE> my get_menu_item_callback : Menu_Item -&gt; Void_Callback
 my get_menu_item_relief_kind : Menu_Item -&gt; Relief_Kind
 my get_menu_item_text : Menu_Item -&gt; String
 my get_menu_item_width : Menu_Item -&gt; Int
 my get_menu_item_traits : Menu_Item -&gt; Trait List</PRE><H4>
3.1.8. Windows</H4>
<P>A window is a quadruple of a window identifier, a list of window
manager options, its constituting widgets, and a <TT>Void_Callback</TT>
that is evaluated just after the creation of the window. The latter
can be used for initialisation of the widgets in the window, e.g.
listboxes or text widgets can be filled with an initial content.
Windows are created with the following function: 
</P>
<PRE STYLE="margin-bottom: 0.2in"> type Window
 my make_window : {window_id : Window_ID,
 traits : Window_Trait List,
 subwidgets : Widgets,
 event_callbacks: Event_Callback List,
 init : Void_Callback} -&gt; Window</PRE><P>
Identifiers for windows can be obtained by the functions <TT>make_window_id</TT>
or <TT>make_tagged_window_id</TT> (see <A HREF="#ids">section 3.2.1</A>). 
</P>
<P>The selector functions for <TT>Window</TT> are: 
</P>
<PRE> my get_window_callback : Window -&gt; Void_Callback
 my get_window_traits : Window -&gt; Window_Trait List
 my get_window_subwidgets : Window -&gt; Widget List
 my get_window_ID : Window -&gt; Window_ID</PRE><P>
The type <TT>Window_Trait</TT> provides a subset of the window
manager options for windows, corresponding to the arguments of Tk's
<TT>wm</TT> command (see chapter 22 of [Oust94]): 
</P>
<PRE> enum User_Kind =
 User
 | Program

 enum Window_Trait
     =
 WINDOW_ASPECT_RATIO_LIMITS of Int * Int * Int *Int #  xthin/ythin xfat/yfat 
 | WIDE_HIGH_X_Y of ((Int * Int) null_or.option) #  width x height 
 * ((Int * Int) null_or.option) #  xpos x ypos 
 | WIDE_HIGH_MAX of Int * Int #  width * height 
 | WIDE_HIGH_MIN of Int * Int
 | WINDOW_POSITIONED_BY of User_Kind
 | WINDOW_SIZED_BY of User_Kind
 | WINDOW_TITLE of String
 | WINDOW_GROUP of Window_ID #  window / leader 
 | TRANSIENTS_LEADER of Window_ID null_or.option
 | OMIT_WINDOW_MANAGER_DECORATIONS of Bool</PRE><P>
A window title must only contain printable characters (space up to
~). See also the function <TT>check_window_title</TT> in <A HREF="#checks">section
3.2.13</A>. 
</P>
<P>The selector functions for <TT>Window_Trait</TT> are: 
</P>
<PRE> my selWinAspect : Window -&gt; (Int * Int * Int * Int) Null_Or
 my selWinGeometry : Window -&gt;
 (((Int * Int) Null_Or) *
 ((Int * Int) Null_Or) ) Null_Or
 my selWinMaxSize : Window -&gt; (Int * Int) Null_Or
 my selWinMinSize : Window -&gt; (Int * Int) Null_Or
 my selWinPositionFrom : Window -&gt; User_Kind Null_Or
 my selWinSizeFrom : Window -&gt; User_Kind Null_Or
 my selWinTitle : Window -&gt; Title Null_Or
 my selWinGroup : Window -&gt; Window_ID Null_Or
 my selWinTransient : Window -&gt; Window_ID Null_Or option
 my selWinOverride : Window -&gt; Bool Null_Or</PRE><H3>
3.2. The Api <TT>Tk</TT></H3>
<P>This section describes the functions from the api <TT>Tk</TT>.
Whereas the data types and functions from the api <TT>Tk_Types</TT>
generate the term package specifying the <I>initial appearance</I>
of windows, widgets and other elements of the user interface, the
functions from this section are primarily used to control the <I>runtime
behaviour</I> of the application. 
</P>
<P><b>tk</b>'s runtime behaviour is centred around the concept
of an <I>event loop</I>. This means that after building the GUI as
specified by a list of initial windows (see <TT><A HREF="#eventloop">start_tcl</A></TT>
below), <B>tk</B> enters a loop waiting for <I>events</I> from
the user sent to the graphical display. They are interpreted
internally in Tk, passed to&nbsp;<B><SPAN STYLE="font-style: normal">tk</SPAN></B>
and then processed by calling ML functions provided by the
programmer. In other words, <B>tk</B> is running as a <I>reactive
system</I>, since the application merely <I>reacts</I> to user
interaction. These reactions can be specified as 
</P>
<UL>
	<LI>initialisation functions (for
	windows),
	<LI><TT>CALLBACK</TT> traits, or
	<LI>event callbacks.
</UL>
<P><A NAME="other_apps"></A>Technically, this means that <B>tk</B>
keeps track which ML function is bound to which event. The wish is
configured to send a string identifying the particular event when it
occurs, and <B>tk</B> maps this string to the corresponding ML
function, which is then executed. 
</P>
<H4>3.2.1. Names and Identifiers</H4>
<P>In Tk, windows and widgets are referred to by their pathnames. In
<B>tk</B>, windows and widgets are referred to by unique
<I>identifiers</I>. The following operations produce fresh
identifiers for windows, widgets, canvas items, frames for widgets
within canvas items, text text_items and frames for widgets within
>text text_items. The <TT>makeXX</TT> variants can be used to generate
more meaningful names, for the advanced programmer analyzing the
logfile (see the <A HREF="#appx">appendix</A>). 
</P>
<PRE> my make_window_id : Void -&gt; tk_types.Window_ID
 my make_widget_id : Void -&gt; tk_types.Widget_ID
 my make_canvas_item_id : Void -&gt; tk_types.Canvas_Item_ID
 my make_canvas_item_frame_id : Void -&gt; tk_types.Widget_ID
 my make_text_item_id : Void -&gt; tk_types.Text_Item_ID
 my make_text_item_frame_ID : Void -&gt; tk_types.Widget_ID

 my make_tagged_window_id : String -&gt; tk_types.Window_ID
 my make_tagged_canvas_item_id : String -&gt; tk_types.Canvas_Item_ID
 my make_tagged_widget_id : String -&gt; tk_types.Widget_ID
 my make_tagged_frame_id : String -&gt; tk_types.Widget_ID</PRE><P>
Sometimes it is useful to generate names for widget identifiers from
given ones in a reconstructible way. This can be done using the
following function: 
</P>
<PRE STYLE="margin-bottom: 0.2in"> fun make_sub_widget_ID(w, str)= w ^ str</PRE><P>
The programmer should take great care not to use one identifier for
more than one window (widget, canvas item, etc), and in particular
should not use identifiers other than those obtained by the above
functions. 
</P>
<H4><A NAME="eventloop"></A>3.2.2. Starting and Terminating <B>tk</B></H4>
<P>The following four functions control <B>tk</B>'s event loop,
in particular start and termination of <B>tk</B>: 
</P>
<PRE> my start_tcl : tk_types.Window List -&gt; Void
 my start_tcl_and_trap_tcl_exceptions : tk_types.Window List -&gt; String

 my exit_tcl : Void -&gt; Void

 my reset_tcl : Void -&gt; Void</PRE><P>
<TT>start_tcl</TT> takes the main window description and starts the
event loop- i.e. it builds and displays the specified list of windows
(with all their widgets and subcomponents), and then waits and reacts
to user interaction until either <TT>exit_tcl</TT> is called, or the
main window is closed. 
</P>
<P><TT>start_tcl_and_trap_tcl_exceptions</TT> does the same as <TT>start_tcl</TT>, but
additionally catches any exceptions which are raised within <B>tk</B>
and prints their associated string value, detailing the nature of the
failure leading to the exception (see <A HREF="#exceptions">section
3.1.2</A> above). 
</P>
<P><TT>reset_tcl</TT> has to be called before the application can be
started again after it was interrupted irregularly, either by a user
interruptor by raising an exception. There are two forms of interupts
that can be sent by the user to the main window: either &lt;CTRL-C&gt;
is pressed which will result in an interuption of the current
evaluation of a function bound to an event and continue with the
eventloop,or &lt;CTRL-\&gt; pressed which will result in a break of
the eventloop and kill the user interface. 
</P>
<H4>3.2.3. Windows</H4> <P>Opening a window with <TT>open_window</TT>
displays the window on the screen and adds it to the GUI state; for
the main window, this is done by <TT>start_tcl</TT>. An attempt to open
a window with a window id equal to that of an already open window
results in an error. The function <TT>is_open</TT> can be used to
find out if a window with a specific id has already been opened.
</P>
<P>A window is closed with the function <TT>close_window</TT>. Closing
the main window results in a call to <TT>exit_tcl</TT>; this is the
preferred way to terminate an <B>tk</B> application. 
</P>
<PRE> my open_window : tk_types.Window -&gt; Void
 my is_open : tk_types.Window_ID -&gt; Bool
 my close_window : tk_types.Window_ID -&gt; Void</PRE><P>
The functions <TT>get_window</TT> and <TT>get_all_windows</TT> can be
used the extract information about some or all windows from the GUI
state. <TT>change_title</TT> changes the title of the window (as
appearing in its title bar). 
</P>
<PRE> my get_window : tk_types.Window_ID -&gt; tk_types.Window
 my get_all_windows : Void -&gt; tk_types.Window List

 my change_title : tk_types.Window_ID -&gt; tk_types.Title -&gt; Void</PRE><H4>
<A NAME="widget_ops"></A>3.2.4. General Operations on Widgets</H4>
<P>The function <TT>get_widget</TT> retrieves the widget specified by
the identifier <TT>Widget_ID</TT> from the GUI state. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> my get_widget : tk_types.Widget_ID -&gt; tk_types.Widget</PRE><P>
Widgets can also be added or deleted dynamically. <TT>addWidget</TT>
adds the widget to the window specified by <TT>Window_ID</TT> into the
widget specified by <TT>Widget_ID</TT>. The latter widget has to be a
frame widget, and the widget to be added will be inserted at the end
of its list of subwidgets. <TT>delete_widget</TT> deletes the specified
widget. 
</P>
<P>An example for the use of <TT>addWidget</TT> and <TT>delete_widget</TT>
can be found in <TT>src/tests+examples/big_ex.pkg</TT>. 
</P>
<PRE> my addWidget : tk_types.Window_ID -&gt; tk_types.Widget_ID -&gt; tk_types.Widget -&gt; Void
 my delete_widget : tk_types.Widget_ID -&gt; Void</PRE><P>
Note that it is not possible to add a widget to a window without any
frames in it. In particular, it is not possible to add widgets to an
initially empty window- clearly a pathological situation. If you
really want a window which initially does not contain any widget,
consider using only an invisible frame. 
</P>
<P>The visual appearance and the behaviour of a widget is modified by
the configuration options and naming of the widget. This is is
achieved with the following functions: <TT>set_event_callbacks</TT> and
<TT>set_traits</TT> completely overwrite the event_callbacks or configuration
options for the specified widget, whereas <TT>add_event_callbacks</TT> and
<TT>add_trait</TT> replace event_callbacks or configuration options of the same
kind, add new ones and leave the rest untouched.
</P>
<PRE> my add_event_callbacks : tk_types.Widget_ID -&gt; tk_types.Event_Callback List -&gt; Void
 my add_trait : tk_types.Widget_ID -&gt; tk_types.Trait List -&gt; Void

 my set_event_callbacks : tk_types.Widget_ID -&gt; tk_types.Event_Callback List -&gt; Void
 my set_traits : tk_types.Widget_ID -&gt; tk_types.Trait List -&gt; Void</PRE><P>
The functions <TT>getTextWidWidgets</TT> and <TT>getCanvasWidgets</TT>
allow the convenient extraction of all top level widgets within text
or canvas widgets; they are undefined for all other variants of
widgets. 
</P>
<PRE> my getTextWidWidgets : tk_types.Widget -&gt; tk_types.Widget List
 my getCanvasWidgets : tk_types.Widget -&gt; tk_types.Widget List</PRE><P>
You can also disable certain widgets using the <TT>Active</TT>
configure option, which can also be set when the widget is already
constructed (by the <TT>add_trait</TT> or <TT>set_traits</TT> functions).
You can apply the <TT>Active</TT> configure option to buttons,
radiobuttons, checkbuttons, menubuttons, scale widgets, entry
widgets, and text widgets. 
</P>
<H4>3.2.5. Configuration Options and Event_Callbacks for Widgets</H4>
<P>The functions in this section are for convenience only. They allow
the easy extraction of parts of configuration options or event_callbacks for
a widget specified by its <TT>Widget_ID</TT>. 
</P>
<PRE> #  Are all derived from get_widget 
 my get_traits : tk_types.Widget_ID -&gt; tk_types.Trait List
 my get_relief_kind : tk_types.Widget_ID -&gt; tk_types.Relief_Kind
 my get_callback : tk_types.Widget_ID -&gt; tk_types.Void_Callback
 my get_event_callbacks : tk_types.Widget_ID -&gt; tk_types.Event_Callback List
 my get_width : tk_types.Widget_ID -&gt; Int
 my get_menu_callback : tk_types.Widget_ID -&gt; Int List -&gt; tk_types.Void_Callback</PRE><P>
For example, <TT>get_traits</TT> is the composition of <TT>get_widget</TT>
and <TT>get_widget_traits</TT>. 
</P>
<H4>3.2.6. Operations for Widgets with Text</H4>
<P>This section describes some uniform operations for widgets
containing text. These encompass mainly list boxes and entry widgets.
</P>
<P>A position within text in these widgets is specified with the
enum <TT>Mark</TT> (see <A HREF="#mark">section 3.1.7</A> above)
is used, with the following conventions: 
</P>
<UL>
	<li>for a list box, the position is always
	<TT>Mark(n,_)</TT> where <TT>n</TT> is the index of the selected
	item in the list box, and the second argument is irrelevant;
	<li>for an entry widget, positions are (at the moment) ignored; any
	operation will always affect the whole text.
</UL>
<H4>Manipulation of Text</H4>
<P>These functions are mainly geared towards list boxes and entry
widgets. For text widgets, we recommend the funtions detailed <A HREF="#insannotext">below</A>,
since they take annotated texts as arguments, and in particular
handle read-only text widgets correctly - note that using <TT>insertText</TT>
etc. on a read-only text widget will fail! 
</P>
<P>The functions <TT>insertText</TT> and <TT>insertTextEnd</TT>
insert text into the widget specified by <TT>Widget_ID</TT> at either the
specified position, or the end. The function <TT>clearText</TT>
deletes all text from the specified widget, and <TT>deleteText</TT>
deletes the specified region of text from the specified widget. 
</P>
<PRE> my insertText : tk_types.Widget_ID -&gt; String -&gt; tk_types.Mark -&gt; Void
 my insertTextEnd : tk_types.Widget_ID -&gt; String -&gt; Void

 my clearText : tk_types.Widget_ID -&gt; Void
 my deleteText : tk_types.Widget_ID -&gt; tk_types.Mark * tk_types.Mark -&gt; Void</PRE><P>
Text in widgets of these kinds can be changed interactively by the
user. Since this change is not reflected in the GUI state, the
following functions have to be used to obtain the actual text (or
region of text) from a widget. 
</P>
<PRE> my get_tcl_selected_text : tk_types.Widget_ID -&gt; tk_types.Mark * tk_types.Mark -&gt; String
 my get_tcl_text : tk_types.Widget_ID -&gt; String</PRE><H4>
<A NAME="selposrange"></A>Selection of Positions and Ranges</H4>
<P>The user may <I>select</I> a position or a range of text within
widgets containing text (see <A HREF="#selection">section 3.2.15</A>
below). <TT>get_tcl_cursor</TT> returns the position of the cursor, and
<TT>get_tcl_selection_range</TT> returns the regions of the selection as a list
of pairs of positions (denoting start and end of the selected
regions). 
</P>
<PRE> my get_tcl_cursor : tk_types.Widget_ID -&gt; tk_types.Mark
 my get_tcl_selection_range : tk_types.Widget_ID -&gt; (tk_types.Mark * tk_types.Mark) List</PRE><P>
For example, if <TT>wl</TT> is a list box, <TT>get_tcl_cursor wl</TT>
returns <TT>Mark(n,_)</TT> where <TT>n</TT> is the index of the list
box currently containing the cursor. 
</P>
<P><A NAME="insannotext"></A>Before using the function <TT>get_tcl_selection_range</TT>
it should be checked with the function <TT>get_tcl_selection_window</TT> (see
<A HREF="#selection">section 3.2.15</A> below) that the user has
indeed selected some text within the widget. 
</P>
<H4>Operations for Text Widgets</H4>
<P>To get and change the current state (read-only or user editable)
of a text widget, use the following functions: 
</P>
<PRE> my get_tcl_text_widget_read_only_flag : Widget_ID -&gt; Bool
 my set_tcl_text_widget_read_only_flag : Widget_ID -&gt; Bool -&gt; Void</PRE><P>
To manipulate the contents of text widgets, the following functions
are provided. They work on read-only text widgets, and they take
annotated texts as arguments, adjusting the text_items in the text
as necessary when inserting it. 
</P>
<PRE> my clear_livetext : Widget_ID -&gt; Void
 my replace_livetext : Widget_ID -&gt; Live_Text-&gt; Void
 my delete_marked_livetext : Widget_ID -&gt; Mark* Mark-&gt; Void
 my insert_livetext_at_mark : Widget_ID -&gt; Live_Text-&gt; Mark-&gt; Void
 my append_livetext : Widget_ID -&gt; Live_Text-&gt; Void /* use discouraged-- very inefficient! */</PRE><P>
The function <TT>append_livetext</TT> has been implemented in the
obvious way, which involves reading the content of the text widget
and counting its length, and is far more inefficient that in has to
be. If you find you really need this function, consider contributing
a more efficient implementation to <B>tk</B>. Until then,
restrict its usage to cases where it cannot be avoided. 
</P>
<H4>3.2.7. Canvases and Canvas Items</H4>
<P>The following functions are the counterpart to the functions on
widgets in <A HREF="#widget_ops">section 3.2.4</A> above for canvas
items. They allow the dynamic addition of canvas items to a canvas,
their removal from it and the reconfiguration of canvas item event_callbacks
and configurations. Canvas Items are identified by the <TT>Widget_ID</TT>
of the canvas within which they appear together with their <TT>Canvas_Item_ID</TT>
identifier. 
</P>
<PRE> my get_canvas_item : tk_types.Widget_ID -&gt;
                     tk_types.Canvas_Item_ID -&gt;
                     tk_types.Canvas_Item

 my add_canvas_item :     tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item -&gt; Void
 my delete_canvas_item :     tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item_ID -&gt; Void

 my get_canvas_item_event_callbacks : tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item_ID -&gt;
                    tk_types.Event_Callback List
 my get_canvas_item_traits : tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item_ID -&gt;
                    tk_types.Trait List

 my add_canvas_item_event_callbacks : tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item_ID -&gt;
                    tk_types.Event_Callback List -&gt; Void
 my add_canvas_item_traits : tk_types.Widget_ID -&gt;
                    tk_types.Canvas_Item_ID -&gt;
                    tk_types.Trait List -&gt; Void</PRE><P>
As already noted above the coordinates given to the constructor of a
canvas item are only its initial values; the actual values can be
read with <TT>get_tcl_canvas_item_coordinates</TT>. <TT>set_canvas_item_coordinates</TT> sets new
coordinates, and <TT>move_canvas_item</TT> moves an item by the specified
distance. 
</P>
<PRE> my get_tcl_canvas_item_coordinates : tk_types.Widget_ID -&gt;
                            tk_types.Canvas_Item_ID -&gt;
                            tk_types.Coordinate List
 my set_canvas_item_coordinates :       tk_types.Widget_ID -&gt;
                            tk_types.Canvas_Item_ID -&gt;
                            tk_types.Coordinate List -&gt;
                            Void
 my move_canvas_item :            tk_types.Widget_ID -&gt;
                            tk_types.Canvas_Item_ID -&gt;
                            tk_types.Coordinate -&gt;
                            Void</PRE><P>
Note <TT>set_canvas_item_coordinates</TT> does not work for <TT>CANVAS_TAG</TT> canvas
items, but <TT>move_canvas_item</TT> does. Also, deleting a <TT>CANVAS_TAG</TT>
item does not delete the subitems, only the tag item itself, and
adding event_callbacks to a <TT>CANVAS_TAG</TT> item is somewhat useless, since
they are not displayed as such --- you most probably want to add the
event_callbacks to the subitems. 
</P>
<P>The following functions return the height and width of a canvas
item in a uniform way. For items of type <TT>CANVAS_ICON</TT> with an image
content, this is the only way to get their actual width and height.
Note that the canvas item has to be displayed on a canvas to use
these functions. 
</P>
<PRE> my get_tcl_canvas_item_height : tk_types.Widget_ID -&gt; tk_types.Canvas_Item_ID -&gt; Int
 my get_tcl_canvas_item_width : tk_types.Widget_ID -&gt; tk_types.Canvas_Item_ID -&gt; Int</PRE><H4>
3.2.8. Annotations for Text Widgets</H4>
<P>The same set of basic functions as for canvas items is available
for text text_items in text widgets. Text text_items are identified
by the <TT>Widget_ID</TT> of the parent text widget and an <TT>Text_Item_ID</TT>
identifier. 
</P>
<PRE> my get_text_item :    tk_types.Widget_ID -&gt;
                         tk_types.Text_Item_ID -&gt;
                         tk_types.Text_Item

 my add_text_item :     tk_types.Widget_ID -&gt;
                         tk_types.Text_Item -&gt; Void
 my delete_text_item :     tk_types.Widget_ID -&gt; 
                         tk_types.Text_Item_ID -&gt;Void

 my get_text_item_event_callbacks : tk_types.Widget_ID -&gt;
                         tk_types.Text_Item_ID -&gt;
                         tk_types.Event_Callback List
 my get_text_item_traits : tk_types.Widget_ID -&gt;
                         tk_types.Text_Item_ID -&gt;
                         tk_types.Trait List

 my add_text_item_event_callbacks : tk_types.Widget_ID -&gt;
                         tk_types.Text_Item_ID -&gt;
                         tk_types.Event_Callback List -&gt; Void
 my add_text_item_traits : tk_types.Widget_ID -&gt;
                         tk_types.Text_Item_ID -&gt;
                         tk_types.Trait List -&gt; Void</PRE><P>
The actual position and regions of text_items can be changed
dynamically by the user (by editing the text in the widget); the
function <TT>get_tcl_text_item_marks</TT> reads their actual values.
<TT>readSelection</TT> returns the location of selected text within
the particular text widget. Before using this function, it should be
checked with the function <TT>get_tcl_selection_window</TT> <A HREF="#selection">(section
3.2.15)</A> that the user has really selected some regions in this
widget, otherwise the exception <TT>TCL_ERROR</TT> will be raised. 
</P>
<PRE> my get_tcl_text_item_marks : tk_types.Widget_ID -&gt;
                                tk_types.Text_Item_ID -&gt;
                                (tk_types.Mark * tk_types.Mark) List

 my readSelection : tk_types.Widget_ID -&gt;
                    (tk_types.Mark * tk_types.Mark) List</PRE><P>
<B>Caution:</B> Since the user can interactively edit the text, it is
possible that text_items are deleted without <B>tk</B> noticing.
Hence, you cannot be sure that an annotation, although defined and
displayed, still exists, and referring to it may lead to an error.
There are three ways to handle this situation: 
</P>
<UL>
	<LI>setting the text widget option
	<TT>TextWidState</TT> to <TT>TextWidStateDisabled</TT>, so the user
	can no longer change the contents of a text widget;
	<LI>defining your own event_callbacks for every
	destructive key stroke and deleting any text_items yourself;
	<LI>catching the exception resulting from referring to a deleted
	annotation.
</UL>
<H4><A NAME="anno_texts"></A>3.2.9 Annotated Texts</H4>
<P>For annotated texts the following utility functions are provided.
<TT>string_to_livetext</TT> makes a string into an annotated text without any
text_items, <TT>empty_livetext</TT> is the empty annotated text, <TT>++</TT>
concatenates annotated texts, keeping track of the text_items. <TT>append_newline_to_livetext</TT>
appends a newline to the annotated text, and <TT>concatenate_livetext_with</TT>
concatenates a list of annotated texts, interspersing them with the
given string. 
</P>
<PRE> my string_to_livetext : String -&gt; tk_types.Live_Text
 my empty_livetext : tk_types.Live_Text

 infix 70 ++
 my ++ : tk_types.Live_Text * tk_types.Live_Text -&gt; tk_types.Live_Text

 my append_newline_to_livetext : tk_types.Live_Text -&gt; tk_types.Live_Text
 my concatenate_livetext_with : String -&gt; tk_types.Live_Text List -&gt; tk_types.Live_Text</PRE><H4>
3.2.10. Menu Widgets</H4>
<P>Menus items are widgets, and as such can be added or deleted from
a frame (containing other menu items, most likely) by the functions
<TT>addWidget</TT> and <TT>delete_widget</TT> above. Currently, <B>tk</B>
does not support the disabling of menus. 
</P>
<P>POPUP_TYPE-up menus are supported by the following two functions:
<TT>make_and_pop_up_window</TT> takes a pop-up menu widget and pops it up
at the specified coordinate, and <TT>pop_up_menu</TT> pops up a menu at
the specified coordinate which has already been specified somewhere
else in the widget tree. The optional integer parameter is the index
of the menu item which should be below the mouse when the menu pops
up. 
</P>
<PRE> my make_and_pop_up_window : tk_types.Widget -&gt;
                            Int tk_types.Null_Or -&gt;
                            tk_types.Coordinate -&gt;
                            Void

 my pop_up_menu : tk_types.Widget_ID -&gt;
                 Int tk_types.Null_Or -&gt;
                 tk_types.Coordinate -&gt; Void</PRE><P>
<TT>src/tests+examples/popup_ex.pkg</TT> is an example for the use of
popup menus. 
</P>
<H4><A NAME="tclvalues"></A>3.2.11. Buttons and Tcl Values</H4>
<P>As already noted in <A HREF="#mitems">section 3.1.7</A> above,
these two functions are needed in the context of check buttons or
radio buttons. The first argument is the variable name, the second
argument for <TT>set_var_value</TT> is the intended value. 
</P>
<PRE> my set_var_value : String -&gt; String -&gt; Void
 my get_tcl_var_value : String -&gt; String</PRE><H4>
3.2.12. Coordinates</H4>
<P><I>Coordinates</I> are pairs of integers. They can be added or
subtracted with <TT>add_coordinates</TT> and <TT>subtract_coordinates</TT>; <TT>scale_coordinate</TT>
is multiplication with a scalar. 
</P>
<PRE> type Coordinate= Int* Int
 my add_coordinates : tk_types.Coordinate -&gt; tk_types.Coordinate -&gt; tk_types.Coordinate
 my subtract_coordinates : tk_types.Coordinate -&gt; tk_types.Coordinate -&gt; tk_types.Coordinate
 my scale_coordinate : Coordinate-&gt; Int-&gt; Coordinate</PRE><P>
A <I>rectangle</I> is given by two coordinates, specifying two of its
corners. <TT>inside p r</TT> returns true if the point at coordinate
<TT>p</TT> is inside the rectangle <TT>r</TT>, and <TT>intersect</TT>
checks wether the two rectangles intersect. <TT>move_rectangle</TT> moves a
rectangle by the specified coordinate (considered as a vector). 
</P>
<PRE> type Rectangle = Coordinate* Coordinate
 my inside : tk_types.Coordinate -&gt; Rectangle -&gt; Bool
 my intersect : Rectangle-&gt; Rectangle-&gt; Bool
 my move_rectangle : Rectangle -&gt; tk_types.Coordinate -&gt; Rectangle</PRE><H4>
Finally, show functions are provided as a convenience.</H4>
<PRE> my show_coordinate : Coordinate List -&gt; String
 my coordinates_from_string : String -&gt; Coordinate List
 my show_rectangle : Rectangle -&gt; String</PRE><H4>
<A NAME="checks"></A>3.2.13. Checks</H4>
<PRE>
my check_widget_ID    : Widget_ID -> Bool
my check_window_ID    : Window_ID -> Bool
my check_window_title : tk_types.Title -&gt; Bool
</PRE><P>
These functions checks whether the argument is a
correct window id, widget id or window title. 
</P>
<P>Implicit checks of the widget configurations have been added. The
applied configurations are checked, when the widgets are packed. An
exception <TT>WIDGET</TT> will be raised, when bad configure options
are found. However, <b>tk</b>'s checks are not as comprehensive as
one might hope for.  The exception <TT>TCL_ERROR</TT> is raised when
the wish returns a Tcl error- this happens in particular if an illegal
window (widget, canvas item, etc.) is passed to the wish.
</P>
<H4><A NAME="focus"></A>3.2.14. Focus and Grabs</H4>
<P>The functions <TT>focus</TT> and <TT>de_focus</TT> set and reset
the keyboard focus to the specified window. Please refer to chapter
21 in [Oust94] for an explanation of the Tk focus model. 
</P>
<PRE> my focus : tk_types.Window_ID -&gt; Void
 my de_focus : tk_types.Window_ID -&gt; Void</PRE><P>
With <TT>grab</TT> and <TT>de_grab</TT>, <I>modal interactions</I> can
be implemented in <B>tk</B> (see chapter 24 of [Oust94]). A grab
&quot;claims ownership&quot; of the mouse and keyboard, such that all
subsequent events will go to the claiming window. A particular
example of this is a a window containing a dialog box the user is
required to answer before proceeding. 
</P>
<PRE> my grab : tk_types.Window_ID -&gt; Void
 my de_grab : tk_types.Window_ID -&gt; Void</PRE><P>
<A NAME="selection"></A>Be careful to alway release a grab with
<TT>de_grab</TT>; failing to do so can lead into unpleasant
situations. To prevent the worst case (completely freezing up the
display) global grabs are not provided by <B>tk</B>, i.e. all
grabs are local. 
</P>
<H4>3.2.15. The Selection</H4>
<P>In window systems such as X windows, the user can <I>select</I>
regions of text by holding a mouse button and moving the mouse over
the region of text to be selected. This selection is display-wide,
and is called the <I>X selection</I> below. An application is said to
<I>own the selection</I> if a region in one of its windows is
selected. The function <TT>get_tcl_selection_window</TT> returns <TT>NULL</TT>
if the application does not own the X selection, and the identifiers
of the window and widget which own the X selection otherwise. Within
text widgets, list boxes and entry widgets, the X selection can be
accessed with the <TT>get_tcl_selection_range</TT> 
</P>
<PRE STYLE="margin-bottom: 0.2in"> my get_tcl_selection_window : Void -&gt; (tk_types.Window_ID * tk_types.Widget_ID) tk_types.Null_Or</PRE><P>
Chapter 20 in [Oust94] explains the <I>X selection</I> in depth. 
</P>
<H4>3.2.16. Interrupt Handling</H4>
<P>To handle interrupts (<TT>CTRL-C</TT>), <B>tk</B> uses a very
simple-minded broadcast model. Applications can register so-called
listeners, which are functions which are called when an interrupt
occurs (i.e. the user aborts an ongoing computation by hitting
<TT>CTRL-C</TT>). Such a listener is given by the abstract data type
<TT>intr_listener</TT>, and about the only thing we can do with that
is de-register it again (which means, of course, that it isn't called
anymore when an interrupt occurs). Typically, a listener will ensure
an application's state consistency - note that interrupts can occur
anywhere inside a function, so stateful computations may need to
reset the state to a consistent value. 
</P>
<PRE>type intr_listener

 my register_signal_callback : (Void-&gt; Void)-&gt; intr_listener
 my deregister_signal_callback : intr_listener-&gt; Void</PRE><P>
<A NAME="init-config"></A>Note that the user can also always type
<TT>CTRL-/</TT> to abort <B>tk</B> altogether and return to the
SML toplevel. If you want to change this behaviour (or the keys they
are bound to), have a look at <TT>src/njml.pkg</TT>.&nbsp; Note: this
 behaviour may not work correctly with all SML compilers (though it
 does with SML/NJ).
</P>

<H4>3.2.17. <B>tk</B> Initialization and Configuration</H4>
<P>The <TT>init</TT> function initializes <B>tk</B>: it sets the
basic configurations of <B>tk</B> from the environment as
explained in <A HREF="#smltk_config">section</A>, and initializes the
fonts and the terminal. <B>It needs to be called before any tk
application is started.</B> You can also initialize the fonts
separately and unconditionally (<TT>init</TT> only initializes the
fonts if the environment variable <TT>DISPLAY</TT> has changed.) 
</P>
<PRE> my init : Void -&gt; Void
 my set_up_fonts : Void -&gt; Void</PRE><P>
The following functions can be used to read or update the current
values of the runtime configuration variables (see <A HREF="#config-runtime">).
Note that updates will be overwritten by the next call to <TT>init</TT></A>.
The only two interesting functions here will probably be <TT>get_lib_path</TT>
to get the location of image files etc, and <TT>update_logfile_path</TT>
to switch on logging for one debug run of the system (see the
<A HREF="#appx">appendix</A>). 
</P>
<PRE> my get_lib_path : Void -&gt; String
 my update_lib_path : String -&gt; Void
 my get_tcl_path : Void -&gt; String
 my update_tcl_path : String-&gt; Void
 my get_logfile_path : Void-&gt; String
 my update_logfile_path : String-&gt; Void</PRE><H2>
<A NAME="toolkit"></A>4. The Toolkit Library</H2>
<P>The toolkit library offers two collection of modules which are not
part of the core of tk, but offer additional functionality. The
first collection is called <i>Common Infrastructure</i> (CI) and
comprises utilities, abstract events, exchange mechanisms between
gui-components and common intercaces for visualizable elements that
are used and exchanged between various more astract gui-components.
The second collection called <i>Gui Components</i> (GC) and
contains a number of preconceived (and sometimes generic) widgets and
windows for a number of routine tasks in the implementation of gui's.
</P>
<P>In more detail, the <i>Common Infrastructure</i> contains: 
</P>
<UL>
	<LI> module clipboard, which allows
	the exchange of objects between different <B>tk</B>
	applications, for example the Filer and generate_gui_g;</LI> 
	<LI>a module icons, which allows an
	abstract icon management;</LI> 
	<LI>a markup language parser
	facilitating the use of annotated texts;</LI> 
	<LI>a family of apis and
	generics for representation and manipulation &quot;visualizable
	elements&quot; - called <I>objects </I>- that represent a common
	data model for some gui components </LI>
	<LI>a family of apis for representing &quot;applications&quot;
	yielding abstract interfaces for the functional kernel to be plugged
	into a gui </LI>
</UL>
<P>Based on CI, the <I>Gui Components</I> comprise the following:
</P>
<UL>
	<LI>a module <TT>util_window</TT>, which</LI>
	implements some utility windows to display warnings, error messages,
	wait for user confirmation or enter some text; 
	<LI>a module <TT>lazy_trees</TT>
	yielding a widget for the incremental generation of hierarchical
	trees for navigation </LI>
	<LI>a module <TT>filer</TT>, which
	implements a browser for the file system, allowing the user to
	select specific files or directories (based on <TT>lazy_trees)</TT>;</LI>
	<LI> a module <TT>drag_and_drop</TT>,
	which extends a canvas (cf. above) to allow drag&amp;drop-style
	operations between the items on the canvas; </LI>
	<LI> a module <TT>tree_list</TT>
	yielding a widget for the incremental generation of hierarchical
	trees for navigation; <BR>(similar to <TT>lazy_trees</TT>, but in
        contrast to it, based
	on CI and providing more selection functionality); </LI>
	<LI>a module <TT>notepad</TT> built on
	<TT>tree_list</TT> as navigation throuh a hierarchy of
	drag&amp;drop-canvasses; </LI>
	<LI>a module <TT>tgen_gui </TT>(and
	its simpler version <TT>gen_gui</TT>) which is a generic user
	interface built on the notepad (or the drag&amp;drop-package resp.);</LI>
	<LI>a module <TT>table</TT> yields a
	widget displaying a table (organized in rows an colums) composed of
	editable entries;</LI> 
	<LI>a module <TT>tabs</TT> yields a
	widget displaying several sub-widgets in the style of register tabs,
	allowing to switch between the sub-widgets just by </LI>
	<LI>a module <tt>widget_box</tt> yields widget boxes,
	which are like list boxes, except they contain widgets,
	rather than text</LI>
</UL>
<P>The next five sections are concerned with the discription of CI,
while the rest of the chapter is devoted to the description of Gui
Components.</P>
<H3>4.1. Exchanging Objects: the Clipboard</H3>
<P>The clipboard module allows to interchange objects between
different applications, like the filer and generate_gui_g. 
</P>
<P>Its basic idea is that applications can put objects into the
clipboard, and other applications can get the objects previously put
into the clipboard. The actions of putting and getting are certified
by a <TT>Tk_Event</TT>, and a subsequent get only retrieves the object
if the cursor root positions of the certifying events match. For
example, a put can be triggered by releasing the drag button outside
the window, and the get can be triggered by the cursor entering the
window. Then we would only want the get to retrieve the put object if
the cursor has not moved in between, i.e. the root position of the
<TT>Tk_Events</TT> are equal. 
</P>
<P>The api of the clipboard reads as follows: 
</P>
<PRE>api Clipboard =
 api
 type Part

 exception EMPTY

 my get: tk_types.Tk_Event-&gt; Part
 my copy : tk_types.Tk_Event-&gt; Part
 my put: Part-&gt; tk_types.Tk_Event -&gt; (Void-&gt; Void)-&gt; Void

 my is_empty: tk_types.Tk_Event -&gt; Bool
 end</PRE><P>
<TT>get</TT> is as described above. The third argument to <TT>put</TT>
is a call-back function, which is called if a subsequent <TT>get</TT>
for the object succeeds. This can be used to ``pass'' objects from
one application to another - the call-back function would delete the
object from one application once another application has successfully
taken it out of the clipboard. <TT>copy</TT> takes the object out of
the clipboard <I>without</I> calling the call-back; hence if the
callback is used to delete an object once it appears elswhere, by
calling <TT>copy</TT> we would copy the object, rather than move it.
<TT>is_empty</TT> is true if a subsequent <TT>get</TT> (or <TT>copy</TT>)
with the same event would be successful. An unsuccessful <TT>get</TT>
or <TT>copy</TT> (either because there is no object, or because the
two events do not match) will raise the exception <TT>EMPTY</TT>.
Further, any unsuccessful <TT>get</TT> or <TT>copy</TT> will empty
the clipboard. 
</P>
<P>As an example, consider the way the filer and generate_gui_g interchange
objects. The filer is a class macro which has as its argument the
clipboard, and two functions converting files and directories into
clipboard objects (because it depends on the application generate_gui_g is
instantiated with how to convert a file name or directory name into
an object): 
</P>
<PRE>generic package clip_filer_g
 (package m : api my filter_files : String -&gt; String -&gt; Bool;
 exception bad_regexp
 package clipboard: Clipboard
 my file_to_part : String* String-&gt; clipboard.Part
 my dir_to_part : String-&gt; clipboard.Part
 end): Filer</PRE><P>
(At least, thuThe filer will call <TT>clipboard.put</TT> whenever the user releases the
mouse button after a file selection. (By the peculiarities of Tk's
event handling, even if the cursor has been moved over another window
in the meantime, the <TT>Release</TT> event will still go the filer.)
</P>
<P>Any application instantiating the generate_gui_g has to have a clipboard
subpackage: 
</P>
<PRE>api Application =
 api
 [...]
 package clipboard : Clipboard
 sharing clipboard.Part = Void -&gt; Part_Ilk List
 end</PRE><P>
Whenever a cursor enters the construction area, a <TT>clipboard.put</TT> is
tried. If the cursor position matches the previous <TT>clipboard.get</TT>,
then the cursor has not moved in between: this means that the <TT>ENTER</TT>
event has occurred immediately after a button release. (Note that if
the mouse is moved into the construction area with the mouse button
pressed, no <TT>ENTER</TT> event is generated, only once the mouse
button is released.) If the <TT>clipboard.get</TT> is successful, the user
has dragged a file from the filer into the construction area, and
generate_gui_g will have the object appear at that position. Note how we pass
a closure rather than the actual object in order to avoid the
unnecessary creation of objects. 
</P>
<P>Note the the type sharing equation above is not legal according to
the SML97 standard, hence the real api looks a bit more
complicated. </P>
<P>Finally, the clipboard has two sub-apis, <TT>Read_Only_Clipboard</TT>
and <TT>Write_Only_Clipboard</TT>, which are for read-only and write-only
access to the clipboard. For example, in the above the argument of
the clip_filer_g has actually write-only access to the clipboard, so the
line reads 
<pre>
package clipboard: Write_Only_Clipboard 
</pre>
<H3>4.2. Managing Icons</H3>
<P>Some gui-components such as <tt>generate_gui_g</tt> associate an <I>icon</I> with
every object, depending on its type and mode. The application has to
implement these icons, assigning an icon to every object type and
mode with the function <TT>icon: Part_Type* mode -&gt; icons.Icon</TT>.
The icon has to be implemented by the application, using the
package <TT>icons</TT> in the toolkit library, which has the
following export api: 
</P>
<PRE>api Icons =
 api type Icon

 my get_icon : String * String -&gt; Icon

 my get_width : Icon -&gt; Int
 my get_height : Icon -&gt; Int

 my get_normal_variety : Icon -&gt; tk.Icon_Variety
 my get_highlighted_variety : Icon -&gt; tk.Icon_Variety
 my get_outlined_variety : Icon -&gt; tk.Icon_Variety
 my get_microlined_variety : Icon -&gt; tk.Icon_Variety

 exception ICON end</PRE> <P> Every icon comes in four varieties:
normal, highlighted, outlined and microlined (i.e. wee). The
highlighted image is displayed to signal that an object is ready to
receive a drag&amp;drop operation (see above), the outlined image is
displayed when an object is not ready to receive any kind of
operation, the microlined object is used in the tree navigation
component, and the normal image is presented at all other times.
</P>
<P>The present implementation of icons assumes that all icons are Tk
file images (i.e. graphical formats such as GIF readily understood by
the wish). To create an icon, the function <TT>get_icon</TT> is called
with the directory the file image is in, and its file name. The
highlighted and outlined images are supposed to be in the same
directory, with the base file name of the normal image suffixed with
<TT>-hi</TT>, <TT>-out</TT> and <tt>-mic</tt> respectively (followed by the file
name extension). They are also supposed to be of the same size as the
normal image. Further, a data file with the same file name but the
extension <TT>data</TT> has to exist which contains, in two lines,
the width and height of the icon. (This is due to a catch 22 in the
image handling of Tcl/Tk and generate_gui_g - essentially, we cannot know how
large an image without displaying it, but we since we want to place
it on the notepad, we need to know how large it is before we do
that.) 
</P>
<P>For example, an application could have types of objects called
<TT>wotsits</TT> and assign icons to them by the following function
declaration 
</P>
<PRE>fun icon wotsits = get_icon(&quot;/home/me/example/icons&quot;, &quot;wotsit.gif&quot;)
 | icon ... = ...</PRE><P>
Then the directory <TT>/home/me/example/icons</TT> has to include the
files <TT>wotsit.gif</TT>, <TT>wotsit-hi.gif</TT>,
 <TT>wotsit-out.gif</TT>>, <TT>wotsit-mic.gif</TT> 
and <TT>wotsit.data</TT>. If all of <TT>wotsit*.gif</TT> are GIF
images sixty pixels wide and forty pixels high will consist of only
the two lines 
</P>
<PRE STYLE="margin-bottom: 0.2in">60
40</PRE><P>
<A NAME="gengui_conf"></A>(Note that GIF images are a licensed
trademark of Unisys, Inc.) Finally, the icon used to represent the
trashcan is determined by the configuration as in the next section.
</P>
<H3><A NAME="markup_parser"></A>4.3. The Markup Language Parser</H3>
<P>Once you've written down two or three annotated texts, you very
easily get bored at having to count lines and rows in order to get
your text_items in the text. In order to remedy this situation,
<B>tk</B> provides a markup language, and a generic parser for
it. 
</P>
<P>The fully generic markup language parser is a class macro takes as an
argument a class describing tags. A tag is an SGML element of the
form 
</P>
<PRE STYLE="margin-bottom: 0.2in"> &lt;tagname arg1 ... argn&gt; ... &lt;/tagname&gt;</PRE><P>
This generates an annotation from the start of the tag to the end of
the tag. Tags are given by <TT>matching_tag</TT>, where the first
argument is the <TT>tagname</TT> above. The annotation is generated
by the function <TT>text_item_for_tag</TT>, which is passed the tag as
the first argument, and the list of arguments as the second argument.
The type <TT>Widget_Info</TT> is just a workaround to allow
<TT>text_item_for_tag</TT> to be passed arguments like the identity of
the widget. 
</P>
<P>The markup parser further recognizes escape sequences of the form
<TT>&amp;name;</TT>. These are given by the function <TT>escape</TT>,
which is passed the name of the escape sequence, and either returns a
string replacing the escape, or <TT>NULL</TT> in which case the
escape sequence is left as is in the text. Three escape sequences are
predefined, namely <TT>&amp;amp;</TT> for &amp;, <TT>&amp;gt;</TT>
for &gt; and <TT>&amp;lt;</TT> for &lt; (since these are needed by
any sensible markup language). 
</P>
<P>Finally, the exception <TT>TEXT_ITEM_ERROR</TT> can be raised by
the function generating to annotation to indicate an error (e.g. a
tag with not enough parameters). The exception <TT>error</TT> is
raised if there is a critical error during parsing. The parser is
actually quite good-natured, and will e.g. only print warnings (via
<TT>warning</TT>) if there are open elements which do not close (for
these, text_items up to the end of the text are generated). The only
critical errors are <TT>&lt;</TT> and <TT>&amp;</TT> not followed by
any <TT>&gt;</TT> or <TT>;</TT> respectively. 
</P>
<PRE>api Tags =
 api
 type Tag
 type Widget_Info

 my matching_tag : String-&gt; Tag Null_Or
 my text_item_for_tag : Tag -&gt;String List-&gt; Widget_Info-&gt;
                        (tk_types.Mark* tk_types.Mark)-&gt;
                        tk_types.Text_Item
 my escape : String-&gt; String Null_Or

 exception TEXT_ITEM_ERROR of String
 my warning : String-&gt; Void
 my error : String-&gt; exn
 end</PRE><P>
The markup language parser exports just one function, which takes a
text in a markup language as described by the argument, and returns
an annotated text: 
</P>
<PRE>api Tk_Markup =
 api
 type Widget_Info
 my get_livetext : Widget_Info-&gt; String-&gt; tk_types.Live_Text
 end

generic package tk_markup_g (tags: Tags) : Tk_Markup
 where type Widget_Info= tags.Widget_Info</PRE><P>
The file <TT>src/toolkit/tests+examples/markup_ex.pkg</TT> contains
an example of a small self-defined markup language. Moreover, the
toolkit library contains an extendible markup language, the <B>tk</B>
Standard Markup Language, which provides tags to set fonts, scale
fonts, or raise and lower boxes, and in particular a rich set of
escape sequences for mathematical characters and mathematical
notations (<TT>&amp;alpha;, &amp;forall;, &amp;tensor;</TT> etc.) The
file <TT>src/toolkit/tests+examples/stdmark_ex.pkg</TT> shows how to
use the standard markup language. It comes in two variations, one
which is extendible (<TT>generic standard_tags_g</TT>) with more tags, and
one which is closed and ready to use (<TT>package StdMarkup</TT>). 
</P>
<H3>4.4. A Common Interface for Visualizable Elements: <I>Objects</I></H3>
<P>Several higher toolkit components
require a common notion (or: format) of <I>objects </I> for their
visualization functionality - this notion is represented by the
api <TT>Part_Class</TT> that is part of the
input api of the generics representing these higher Toolkit
Components. Thus, <TT>Part_Class</TT> is fundamental for 
toolkit components like tree_list_g or GenGui. Morover, there is a
class macro <tt>obj2tree_obj</tt>, that extends <TT>Part_Class</TT>
to <tt>Tree_Part_Class</TT>, where <tt>Tree_Part_Class</TT>
is a strict api extension of <tt>Part_Class</tt>. The instances
of  <tt>Tree_Part_Class</tt> all have a tree-like package and are
suited for the representation of file-systems, proof-terms, etc. 
Once we have one notion of objects, <tt>obj2tree_obj </tt> builds
a tree-like organization with folders as nodes and input objects as
leaves. This facilitates the construction and data exchange
via uniform interfaces and common lifting facilities for
toolkit-components with respect to objects.
</P>
<P><TT>Part_Class</TT> and its variants 
are part of the Common Infrastructure <FONT FACE="courier,
monospace">CI.</FONT> In more detail, <TT>Part_Class</TT>
instances contain the following elements:</P>
<UL>
	<LI>a type of objects object</li>
	<LI>an ordering on object</li>
	<LI>a unique abstract name for
	each object</li>
	<LI>a (formatable) string
	representation thereof</li>
	<LI> a &quot;user-name&quot;, i.e. a string hiding the string
	representation of the name, set or reset explicitly  via
	side effects</li>
	<LI>an object type <tt>part_type</tt> for each object</li>
	<LI>an icon for each obj-type </li>
</UL>
<P>The api in itself reads as follows:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; api Part_Class =</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;
api</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
Part_Ilk</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eqtype
Part_Type</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* think of it as : id */</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
ord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Ilk * Part_Ilk -&gt; order/* based on name */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; name_of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Part_Ilk
-&gt; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
think of it as : id_of */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; string_of_name : Name -&gt;&nbsp;&nbsp; print.format -&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
rename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : String
-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Part_Ilk -&gt; Void/* side effect */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; reset_name&nbsp;&nbsp;&nbsp;&nbsp; : Part_Ilk -&gt;
Void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* side effect */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; part_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Part_Ilk -&gt;
Part_Type</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
icon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
Part_Type -&gt; icons.Icon</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</P>
<P>More formally, these elements are specified to have the following
properties: 
</P>
<OL>
	<LI> <TT>ord</TT> is a linear ordering on names of objects</LI> 
	<LI> <TT>name_of(o)</TT> must be unique in all system states</LI>
	<LI>/* this fact is only used in tree_object_classes, <BR> more
	precisely: select_from_path,remove_at_path,update_at_path */</LI> 
	<LI><TT>name_of(rename(s,o)) = name_of(o)&nbsp;</TT> /* rename is actually
	a relabelling */</LI>
	<LI><TT>name_of(reset_name(s,o)) = name_of(o)</TT></LI>
	<LI><TT>part_type(rename(s,o)) = part_type(o)</TT> </LI>
	<LI><TT>part_type(reset_name(s,o)) = part_type(o)</TT></LI>
	<LI><TT>icon(rename(s,o)) = part_type(o)</TT></LI>
	<LI><TT>icon(reset_name(s,o)) = part_type(o)</TT></LI>
	<LI><TT>string_of_name n f</TT> should be &quot;as nice as possible&quot;.</LI>
	<LI><TT>(rename s o; string_of_name(name_of o) f) = &quot;nice s&quot;</TT></LI>
	<LI> <TT>(rename s o; reset_name o;  string_of_name o f) = <BR>
	(reset_name_node o; string_of_name_node o f)</TT> </LI>
</OL>
<P><BR><BR>
</P>
<P>In the following. we turn to the extension of
<TT>Part_Class</tt>, namely <tt>Tree_Part_Class</TT>.  The entity
<TT>Tree_Part_Class</TT> is a subclass of
<TT>Part_Class</TT>. It is enriched by <TT>Folder_Info</tt>,
<tt>SUBNODE_INFO</tt> and functions that exploit (or enforce) the
tree-like package of 
<TT>Tree_Part_Class</TT>-elements, i.e. terms of type Part.
Additionally, they provide the concept path on folders and
path-related operations.  The auxilliary apis
<tt>Folder_Info</tt> contains the information that makes abstractly the
<i>skeleton</i> or just the <i>node</i> of a folder, but not its
content. This <tt>Node_Info</tt> must contain the following:
</P>
<UL>
	<LI>an ordering
	<LI>an (implicit) name 
	<LI>rename and reset-name facilities 
	<LI> additional info's that may be attached directly to
	subcomponents  of a folder (i.e. positions, layout, ...)
</UL>
<P>Now, <tt>Folder_Info</tt> reads as follows:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; api Folder_Info =</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;
api</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;
Node_Info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type&nbsp;&nbsp; Subnode_Info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp;&nbsp;&nbsp; string_of_name_node : Node_Info -&gt;
print.format -&gt; String</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp;&nbsp;&nbsp; ord_node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Node_Info * Node_Info -&gt; order</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp;&nbsp;&nbsp; rename_node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String -&gt; Node_Info -&gt; Void</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp;&nbsp;&nbsp; reset_name_node&nbsp;&nbsp;&nbsp;&nbsp; :
Node_Info -&gt; Void</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>Some properties are specified as follows:</P>
<UL>
	<LI>ord_node is a linear ordering 
	<LI> (rename_node s ni;  string_of_name_node ni f) = &quot;nice
	s&quot; 
	<LI>(rename_node s ni;  reset_name_node ni;  string_of_name_node
	ni f) = <BR> (reset_name_node ni; string_of_name_node ni f) 
</UL>
<P> The api  <TT>Tree_Part_Class</TT> is constructed on top:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; api Tree_Part_Class =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; api</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include Part_Class;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include Folder_Info;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
package basic : Part_Class;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; getContent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Part_Ilk -&gt;
basic.Part_Ilk * Subnode_Info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; getFolder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
Part_Ilk -&gt; Node_Info * Part_Ilk List</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; isFolder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
Part_Ilk -&gt; Bool</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; Content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: basic.Part_Ilk * Subnode_Info -&gt; Part_Ilk</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; Folder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Node_Info * Part_Ilk List -&gt; Part_Ilk</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; isFolderType&nbsp;&nbsp;&nbsp;&nbsp; : Part_Type -&gt; Bool</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
getContentType&nbsp;&nbsp; : Part_Type -&gt; basic.Part_Type</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
ContentType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : basic.Part_Type -&gt;
Part_Type</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>Its specification contains the following conditions:</P>
<UL>
	<LI><TT>getContent(Content m) = m</TT>
	<LI><TT>getFolder(Folder m) = m</TT>
	<LI><TT>Content(getContent o) = o</TT>
	<LI><TT>Folder(getFolder o) = o</TT>
	<LI><TT>tree_objects are generated over Content and Folder</TT>
	<LI><TT>isFolder(Folder m) = true, isFolder(Content m) = false</TT>
	<LI><TT>getContentType(ContentType ot) = ot</TT>
	<LI><TT>ContentType(getContentType ot) = ot</TT> 
</UL>
<P>A variant of <TT>Tree_Part_Class</tt> is the api 
<TT>Ptree_Part_Class</tt>, which extends the former by path-related
operations.</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; api Ptree_Part_Class =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; api</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include Tree_Part_Class;</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= Node_Info List * basic.Part_Ilk Null_Or</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* path and name are identical in Ptree_Part_Class. Unfortunately,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * this can't
be said explicitly in SML. Therefore, we establish an</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* isomorphism. */</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
ord_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path *
path -&gt; order</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; is_prefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path
* path -&gt; Bool</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; join_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path * path -&gt;
path</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
name2path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Name -&gt; path</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
path2name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path -&gt; Name</TT>
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp; The
foll. opns may fail if paths do not exist or are not unique&nbsp;&nbsp;
*/</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;
NOTE : this implies that Node_Info and obj must be unique if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;
these operations are expected to work properly */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my&nbsp; get_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
Part_Ilk -&gt; Part_Ilk -&gt; path List</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* get_path a b produces path</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of sub-object b in object a */</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exception INCONSIST_PATH;</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
select_from_path : Part_Ilk List -&gt; path -&gt; Part_Ilk</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
remove_at_path&nbsp;&nbsp; : Part_Ilk List -&gt; path -&gt; Part_Ilk List</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* removes_at_path a&nbsp;&nbsp; produces object</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
from a with subobject at p removed */</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my&nbsp;
update_at_path&nbsp;&nbsp; : Part_Ilk List -&gt; path -&gt; Part_Ilk -&gt;
Part_Ilk List</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>A standard method to lift instances of <TT>Part_Class</TT>
to <TT>Ptree_Part_Class</TT> (and thus <TT>Tree_Part_Class</TT>) is
given by the class macro <TT>obj2tree_obj</TT>, that embeds standard objects into
a tree-like data package:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; generic package obj2tree_obj (package
N:Folder_Info and</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
M:Part_Class) : Ptree_Part_Class</TT> 
</P>
<H3>4.5. A Common Interface for the Data Model:
<I>Applications</I></H3> <P>The <B>tk</B>-Toolkit provides two
larger parametric components, that produce for a given
<I>application</I> a graphical user interface, slightly similar to the
model-view-controller paradigm known from object-oriented GUI
programming, where our application corresponds to the
model. Technically, these two parametric components, <tt>GenGui</tt> and
<tt>TGenGui</tt>, are implemented as generics that map applications
to widgets that contain the GUI for this application. Applications are
part of the Common Infrastructure CI.</P> 
<P>In the following, we represent a family of <I>application
apis </I> <TT>Notepad0_Application, 
Notepad_Application</TT> and <TT>Application</TT> that represent the interface into
which a given application must be wrapped in order to be accomodated
for this class macro. 
</P>
<P>An application essentially contains:</P>
<UL>
	<LI>the class of objects an application is working with (given by <tt>Part_Class</tt>)
	<LI>additional information for objects used for a refined handling in a
        GUI - <BR>an object can have a <I>mode </I>(for advanced drag&amp;drop
        interaction) or belong to<BR>the special group of <I>construction </I>objects
	<LI>a table of actions manipulating objects (called mon_ops for historical
	reasons)
	<LI>a table of drag-drop actions associated with objects (calles bin_ops
	for historical reasons
	<LI>a clibboard for exchanging objects between parts of a gui via
	drag-drop
	<LI>a complete subwidet called <I>construction area </I>where
	application defined &quot;small grain&quot; <BR>modifications with
	construction objects can be handled
	<LI>a gui-state for persistent tool implementations.
</UL>
<P>In more detail, the discussed apis look as follows:</P>
<P><TT>ignature Notepad0_Application =</TT><BR>
       <TT><TT>&nbsp; api</TT></TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include Part_Class</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* New objects are objects
together with an annotation where</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * they should appear.&nbsp;
This is a coordinate followed by an Anchor</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * which gives the direction
in which generate_gui_g tries to place the</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * object if another object
is in the way.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * New_Part will correspond
directly to Contents in TreeObjects.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; type New_Part = Part_Ilk *
(tk.Coordinate* tk.Anchor_Kind)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* Now comes the
generate_gui_g-specific Part_Class extensions:</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Typing, modes,
is_constructed, outline. */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; /* Typing */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my objlist_type : Part_Ilk
List -&gt; Part_Type null_or.option</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my is_constructed :
Part_Type-&gt; Bool</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* objects of this type are construction objects */</TT> <TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT><BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* &quot;Modes&quot; are
states for objects. They are changed with the object's pop-up</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * menu, which displays the
mode by the mode_name given below.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Every object's mode can be
set within the range given by its type</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * (function modes below) by
set_mode.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Every object's mode can be
set within the range given by its type (function</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * modes below) by set_mode.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; eqtype mode</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; mode&nbsp;&nbsp;
/* New ! mode is attached to Part_Type</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for structuring reasons . . . */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my modes&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; mode List</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my mode_name : mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&gt; String</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my set_mode&nbsp; : Part_Ilk * mode
-&gt; Void</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* These objects are
displayed with an &quot;outline&quot; icon, to indicate</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * some out-of-date
condition. Note that they can still receive</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * drag-and-drop operations.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my outline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Ilk-&gt; Bool</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /*</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Nullary objects are
constants, or in other words, objects</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * existiting a priori.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The init function returns
a list of all these objects; it will</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * only be called once, on
startup.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my init&nbsp;&nbsp; : Void -&gt;
New_Part list</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* Unary operations */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* standard actions, called
ops for historic reasons */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my std_ops&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Type-&gt; ((Part_Ilk -&gt; Void) * String) List</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* better api ? */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my create_actions: (({pos :
tk.Coordinate, tag : String} -&gt; Void)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* String) List</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my label_action&nbsp; : {obj :
Part_Ilk,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc : String -&gt; Void}-&gt; Void</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Part_Ilk -&gt; Void</TT> <BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* further object type
specific operations: for a type t, monOps t</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * is a list of pairs (f, s),
where f is a unary operation, and s</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * is a string, the name
under which it appears in the pop-up</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * menu. f has the
functionality</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;
Part_Ilk* tk.Coordinate-&gt; (newObject-&gt; Void)-&gt; Void;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * where the first argument
is the object itself, together with its present</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * location, and the second
argument is a fate you can use</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * to create new objects.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my mon_ops : Part_Type -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((Part_Ilk * tk.Coordinate -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(New_Part -&gt;&nbsp; Void) -&gt; Void) * String) List</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /*</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * binary operations</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * aka.the
drag&amp;drop-action-table</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my bin_ops :&nbsp; Part_Type *
Part_Type -&gt; (Part_Ilk * tk.Coordinate *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Part_Ilk List *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(New_Part-&gt; Void) -&gt; Void)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
null_or.option</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* --- Subpackages
-------------------------------------------------- */</TT> &nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp;&nbsp; /* The clipboard will
allow the exchange of items between</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the drag&amp;drop
area and other application-specific</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * widgets-- eg. a
chooser.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * It gets passed
closures of objects, so we create</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * an object only if it
is really taken out of the clipboard</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp;&nbsp; type objectlist= Void-&gt;
Part_Ilk List</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; package clipboard : Clipboard</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; sharing clipboard.Part =
objectlist</TT> <BR>&nbsp; <TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp; /* --- Configuration -- see above --- */</TT>
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; package Conf : GENGUI_CONF</TT>
<BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>end;</TT> <BR><BR>This api is enriched by
a concept of object locking in api  <TT>Notepad_Application:</TT></P>
<P><TT><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>api Notepad_Application =</TT></TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN><TT>&nbsp; api</TT></TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include Notepad0_Application</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my object_action&nbsp;&nbsp;
: {window : tk.Window_ID,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
obj : Part_Ilk,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
replace_object_action : Part_Ilk -&gt; Void,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
outline_object_action : Void -&gt; Void}</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&gt; Void</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; my is_locked_object: Part_Ilk
-&gt; Bool /* locking manipulations -</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* e.g. opened construction objects */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>end;</TT> 
</P>
<P>Finally, the concepts for the
construction area and a GUI state (plus initialization operations)
are added:</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>api Application =</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp; api</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include Notepad0_Application</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* --- The Construction Area
----------------------------------------- */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; type ca</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* This data type represents
the Construction Area's</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * state. It might eg.
probably contain the area's</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * widget's widget id.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* This should be the
respective row of the drag&amp;drop table in</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * binaryOps above. Has to be
here explicitly, since it will change</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the whole area rather than
just the object. Further, objects may</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * behave differently while
being open.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my&nbsp; area_ops&nbsp; :
Part_Type-&gt; ca-&gt; Part_Ilk List-&gt; Void</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; /* open an object to be
worked on the construction area</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The old object is deleted
from the manipulation area.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * One (or even more?) new
objects may appear on the notepad</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * when the construction
finishes, they are introduced with</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the second argument.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The result is a tuple,
consisting of a data package</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * ws as above, a list of
widgets representing the</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * area on the screen and an
init function to be called after</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the widget has been placed
and that would not be necessary</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * if we could instantiate
text widgets properly.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; */</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my area_open&nbsp; : tk.Window_ID*
Part_Ilk* (Part_Ilk -&gt; Void) -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ca* tk.Widget List* (Void-&gt; Void))</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; my area_init&nbsp; : Void-&gt;
Void</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* initializations that need to be done only once.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* !!! Caution, this is called when the area isn't open.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp; end</TT> 
</P>
<H3>4.6. Utility Windows</H3>
<P>The module <TT>UW</TT> offers a variety of often used windows
for user confirmation, error or warning messages, or user input.
Conceptually, there are two different types of input dialogues: <I>modal</I>
and <I>non-modal</I>. With modal windows, the whole system should
only proceed once the input is completed; with non-modal windows, the
input can be mixed arbitrarily with other inputs. Non-modal windows
may remain open and communicate via a global state. Nearly all of the
windows exported from <TT>util_window</TT> are non-modal in the above
sense, except for <TT>enterText</TT> and <TT>enterLine</TT>. 
</P>
<P>In detail, the module <TT>util_window</TT> exports the following
functions: 
</P>
<h4>Errors and warnings:</h4>
The simple, non-modal form of these is: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> my error : String -&gt; Void</FONT>
<FONT SIZE=3> my warning : String -&gt; Void</FONT></PRE><P>
Brings up a window with an error or warning messages as given by the
first argument, and once the OK button is clicked. There is no
semantic difference between an error and a warning except for the
icon used. 
<P>For modal error or warning windows, use the following: 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my error_cc : String* (Void-&gt; Void)-&gt; Void</FONT>
<FONT SIZE=3> my warning_cc : String* (Void-&gt; Void)-&gt; Void</FONT></PRE><P>
The argument should be the fate, i.e. the function to be
called after the <TT>Continue</TT> button has been clicked. Both of
these functions return once they opened the window, so for modal
behaviour you'll have to pass the fate: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> let go_on = fn x=&gt; (print(&quot;The close button has been clicked.\n&quot;);</FONT>
<FONT SIZE=3>                         testw x)</FONT>
<FONT SIZE=3> in UW.error_cc(&quot;An error has occured.&quot;, go_on);</FONT>
<FONT SIZE=3> print &quot;The window has just been opened.\n&quot;</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
<IMG SRC="images/error.gif" NAME="Grafik5" ALT="[An Error Window]" ALIGN=MIDDLE WIDTH=320 HEIGHT=170 BORDER=0><IMG SRC="images/warning.gif" NAME="Grafik6" ALT="[A Warning Window]" ALIGN=MIDDLE WIDTH=300 HEIGHT=138 BORDER=0>
<BR>&nbsp; <BR>&nbsp; 
</P>
<h4>Confirmation</h4>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> my confirm : String* (Void-&gt; Void)-&gt;Void</FONT></PRE><P>
Brings up a window with the given text. If the user clicks the OK
button, the fate is called, otherwise the call evaluates to
nothing. The window looks like this: 
</P>
<UL>
	<P><IMG SRC="images/confirm.gif" NAME="Grafik7" ALT="[AConfirmation Window]" ALIGN=BOTTOM WIDTH=360 HEIGHT=160 BORDER=0>
		</P>
</UL>
<P>The icon appearing with the confirmation window is the same as
appearing in warning windows (but this can be changed - see below). 
</P>
<h4>Information windows.</h4>
<P>Information windows display informative messages to the user. They
come in two variations, a simple non-modal one which stays open until
it is dismissed, and a modal one, which returns a function which when
called closes the window (ensuring it stays open at least ten
seconds). 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> my info : String-&gt; Void</FONT>
<FONT SIZE=3> my info_cc : String-&gt; (Void-&gt; Void)</FONT></PRE><P>
Both open a window like the following, except the modal version lacks
a close button: 
</P><UL>
<P><IMG SRC="images/info.gif" NAME="Grafik7" ALT="[An information window]" ALIGN=BOTTOM WIDTH=300 HEIGHT=188 BORDER=0>
</P></UL>
<h4>Displaying texts.</h4>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> my display: {title: String, width: Int, height: Int,</FONT>
<FONT SIZE=3> text: tk.Live_Text, cc: tk.Widget_ID-&gt; Void}-&gt; Void</FONT>

<FONT SIZE=3> my display_id: {window_id: tk.Window_ID, widget_id: tk.Widget_ID, title: String,</FONT>
<FONT SIZE=3> width: Int, height: Int, text: tk.Live_Text}-&gt; Void</FONT></PRE><P>
These functions open up a window and display an annotated text in a
dedicated window with a close button at the bottom left corner. Their
difference is the way in which the identity of the text widget is
handled: the first variant creates a text widget from scratch, and
passes the widget id to the fate <TT>cc</TT>, the other takes
a window and widget id as argument and builds a text widget in a
window of that parish. 
</P>
<h4>Entering Text.</h4>
<PRE >
 my enterText : {title : String, prompt : String, default : String,
 width : Int, height : Int, cc : String-&gt; Void} -&gt; Void 
 my enterLine : {title : String, prompt : String, default : String,
 width : Int, cc : String-&gt; Void } -&gt; Void
</PRE>
<BR><BR>These functions invite the user to enter some text, either a single
line of it (<TT>enterLine</TT>) in a single entry widget, or a larger oeuvre
in a text widget of many lines (<TT>enterText</TT>). Both are given a
<TT>default</TT> string to fill the text or entry widget with, a window
<TT>title</TT>, a <TT>prompt</TT> string diplayed in front of or above the
entry or text widget, and a fate <TT>cc</TT> which is passed the text
once the entry has finished. Both functions bring up a window with an ok and a
cancel button. but entry in an <TT>enterLine</TT> widget is finished by
pressing return.

<H4>Configuring <TT>util_window</TT></H4>
<P>If you want different fonts, icons or layout, all can be easily
rearranged by changing the configurations of the utility windows,
which are the first couple of lines in <TT>src/toolkit/util_window.pkg</TT>.
<BR>&nbsp; 
</P>

<H3 STYLE="margin-top: 0in">4.7. Numeric Choosers</H3>
<P>Simple numeric choosers, an entry for integer values as in the
following dialog (taken from the tabs example in
<TT>src/toolkit/tests+examples/tabs_ex.pkg</TT>):
</P> 

<UL>
<P><IMG SRC="images/numeric_choosers.gif" NAME="Grafik12" ALIGN=BOTTOM WIDTH=280 HEIGHT=70 BORDER=0> </P></UL>
<br>
<P>The class <TT>NumericChooser</TT>
has the following export api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api NUMERIC_CHOOSER_SIG =</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> my numeric_chooser : {initial_value : Int,</FONT>
<FONT SIZE=3> min : Int Null_Or,</FONT>
<FONT SIZE=3> max : Int Null_Or,</FONT>
<FONT SIZE=3> increment : Int,</FONT>
<FONT SIZE=3> width : Int,</FONT>
<FONT SIZE=3> orientation : tk.Orientation,</FONT>
<FONT SIZE=3> selection_notifier : Int -&gt; Void} -&gt;</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<FONT SIZE=3>chooser : tk.Widget,</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE=3> set_value : Int -&gt; Void,</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE=3> read_value : Void -&gt; Int}</FONT>
<FONT SIZE=3> end</FONT></PRE></P>
The function <TT>numeric_chooser</TT> needs the following data to
create a numeric chooser: the initial value of the chooser, an 
optional minimum and maximum value, a value to add/subtract when a
button is pressed, the number of columns of the label, in which the
value is displayed, the orientation of the chooser (<FONT FACE="courier, monospace">tk.VERTICAL</FONT>
or <FONT FACE="courier, monospace">tk.HORIZONTAL</FONT>) and a
function to be called when the value changes.  It returns a frame widget
containing the numeric chooser, a function for external setting of
the value and a function that returns the current value of the
chooser. 
</P>
<H3>4.8. The Filer</H3>
<P>The class macro <TT>filer_g</TT> offers a generic file browser, allowing
the user to browse the file system in the usual manner, and even
search for regular expressions: 
</P>
<P><IMG SRC="images/filer.gif" NAME="Grafik9" ALIGN=BOTTOM WIDTH=655 HEIGHT=541 BORDER=0>
</P>
<P>The <FONT FACE="courier, monospace">filer_g</FONT> class macro has the
following argument api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api</FONT>
<FONT SIZE=3> my icons_path : Void -&gt; String</FONT></PRE><P>
The directory containing the icons to display for the filetypes
specified in the list below. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>my icons_size : Int * Int</FONT></PRE><P>
The maximum width and height of these icons, needed to calculate the
width and height of the file entries. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>my root : Void -&gt; String Null_Or</FONT></PRE><P>
An optional root directory in the browsed filesystem (if there is no
root directory specified, the whole filesystem is browsed). 
</P>
<PRE STYLE="margin-bottom: 0.2in"> <FONT SIZE=3>my default_pattern : String Null_Or</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The displayed files are
filtered using the regular expression matcher contributed by Ryan
Stansifer &lt;<A HREF="mailto:ryan@cs.unt.edu">ryan@cs.unt.edu</A>&gt;
(which can be found in </FONT><FONT FACE="courier, monospace">src/toolkit/regExp</FONT><FONT FACE="times, serif">).
Here you can specify a default pattern, which still can be changed by
the user, but which is reapplied for every new entered directory.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>package clipboard : Write_Only_Clipboard</FONT></PRE><P>
The clipboard instantiation (see <A HREF="#clipboard">Sect. 4.5 below</A>
for further informations on the clipboard). 
</P>
<PRE>
my filetypes : {ext : String List
                 display :{comment : String,
                           icon : String,
                 preview : ({dir : String,
                             file : String} -&gt; Void) Null_Or,
                 file_to_obj : ({dir : String,
                                 file : String} -&gt; clipboard.Part)
                               Null_Or} Null_Or} List</PRE><P>
The list of known filetypes. A file is associated with a filetype by
the extension. The extensions matching a filetype are given in a
<FONT SIZE=2><FONT FACE="courier, monospace">String List</FONT></FONT>.
You can also specify a default filetype (using the empty string <FONT FACE="courier, monospace">&quot;&quot;</FONT>
in the extensions list), which is applied when no other filetype is
matched. If no default filetype is specified, unmatched files are
displayed as &raquo;Unknown filetype&laquo; with a system icon. The
file type determines the icon used to display the file, how to
preview a file with the middle mouse button, and how to import it
into other <B>smlt_tk</B> components. 
</P>
<P>The <FONT FACE="courier, monospace">display</FONT> parameter is an
option, because you might not want to display all filetypes. If it is
set to <FONT FACE="courier, monospace">NULL</FONT>, files of this
type will not be displayed. If a filetype should be displayed, you
need to specify at least a comment to display with the files, such as
&raquo;GIF image&laquo; of &raquo;ML source&laquo;, and an icon (of
the maximum size above). Optionally there is also a preview function
to be called with the file (see also the filer example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/filer_ex.pkg</FONT>).
The optional <FONT FACE="courier, monospace">file_to_obj</FONT>
function is part of the clipboard instantiation and returns a
representation of the dragged file in the clipboard object type. It
only needs to be specified if you want to provide drag and drop
functionality for this filetype. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> package Conf : FILER_CONFIG</FONT></PRE><P>
In the <FONT FACE="courier, monospace">Conf</FONT> class further
configuration options concerning the look and feel of the filer are
offered. There is also a class <FONT FACE="courier, monospace">FilerDefaultConfig</FONT>
(in <FONT FACE="courier, monospace">src/toolkit/filer_default_config.pkg</FONT>),
which you can use if you do not want to configure the filer from
scratch. 
</P>
<PRE STYLE="margin-bottom: 0.2in">end</PRE><P>
The class <FONT FACE="courier, monospace">Conf</FONT> has to
match the following api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api FILER_CONFIG =</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> my title : String Null_Or</FONT></PRE><P>
The title of the file selection window. If no title is specified, it
will be &raquo;File selection&laquo;. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my font : tk.Font</FONT>
<FONT SIZE=3> my font_height : Int</FONT></PRE><P>
The font to use in the file selection dialog, its height in pixels is
needed to calculate the height of a single lines in the files- and
folders-boxes. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my foldersbox_width : Int</FONT>
<FONT SIZE=3> my filesbox_width : Int</FONT>
<FONT SIZE=3> my filesbox_numcols : Int</FONT>
<FONT SIZE=3> my boxes_height : Int</FONT></PRE><P>
The size of the boxes (in pixels), in which the files and folders are
displayed, the number of columns of icons in the files box, and the
height. Both boxes have the same height. The width of the filesbox
must be at least <TT>filesbox_numcols</TT> times the width of a label
containing <FONT FACE="courier, monospace">filenames_cut</FONT>
characters (see below) in the specified font, otherwise the file
entries might cross the right border of the visible part of the
filesbox canvas (because <B>tk</B> cannot really calculate the
size of any components drawn onto a canvas-Widget). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my foldernames_cut : Int</FONT>
<FONT SIZE=3> my filenames_cut : Int</FONT></PRE><P>
Here you can specify the maximum length of the displayed names of the
files and folders. 
</P>
<PRE STYLE="margin-left: 0.79in"> my icon_font : tk.Font
 my icon_font_height : Int</PRE><P>
The user can choose between detailed mode, which means that files are
displayed with comments and the date of last modification, and
non-detailed mode, where only the icon and filename is displayed in
&raquo;icon style&laquo;. In this case, you might want to use a
smaller font, which you can specify here, and of course you need to
give the maximum height of this font here as well. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my preferences : {sort_names : Bool,</FONT>
<FONT SIZE=3> sort_types : Bool,</FONT>
<FONT SIZE=3> show_hidden_files : Bool,</FONT>
<FONT SIZE=3> hide_icons : Bool,</FONT>
<FONT SIZE=3> hide_details : Bool}</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
These are the user configurable settings, when the filer is first
opened. As mentioned above, the files can be displayed in detailed or
non-detailed mode, but the user can also choose if and how the files
should be sorted, if he wants to see hidden files and if icons should
be displayed. <BR>The filer can be run in two modes: stand-alone,
where it runs as the main <B>tk</B> window, and returns the
directory and file name of a selected file, and as a subwindow, where
the filer communicates with other components via drag&amp;drop. Thus,
we have the following export api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api Filer =</FONT>
<FONT SIZE=3> api</FONT>

<FONT SIZE=3> /* critical errors -- e.g. can't open root directory */</FONT>
<FONT SIZE=3> exception ERROR of String</FONT>

<FONT SIZE=3> /* stand alone version */</FONT>
<FONT SIZE=3> my stand_alone : Void -&gt; (String Null_Or * String Null_Or) Null_Or</FONT>

<FONT SIZE=3> /* system versions */</FONT>
<FONT SIZE=3> my file_select : ((String Null_Or * String Null_Or) Null_Or -&gt; Void) -&gt; Void</FONT>
<FONT SIZE=3> my enter_file : Void -&gt; Void</FONT></PRE><P>
<TT>stand_alone</TT>starts its own wish using <FONT FACE="courier, monospace">start_tcl</FONT>
and therefore should not be used in the context of a running
<B>tk</B>-based application. Its main use is probably to debug
filer configurations. The <TT>file_select</TT> function needs a
fate function to be called with the the directory and file
name of a selected file, both as an option because there might be
none. The normal way to start the filer is the <TT>enter_file</TT>
function. It does not return a value, since selected files will be
exchanged via the clipboard (see below). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>/* set preferences */</FONT>
<FONT SIZE=3> my set :{sort_names : Bool Null_Or,</FONT>
<FONT SIZE=3> sort_types : Bool Null_Or,</FONT>
<FONT SIZE=3> show_hidden_files : Bool Null_Or,</FONT>
<FONT SIZE=3> hide_icons : Bool Null_Or,</FONT>
<FONT SIZE=3> hide_details : Bool Null_Or} -&gt; Void</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
The <FONT FACE="courier, monospace">set</FONT> function can be used
to set the user configurable options. It should only be used when the
file selection window is not open. <BR>There is also a partial
instantiation of the filer without clipboard support, the class macro
<FONT FACE="courier, monospace">simple_filer_g</FONT>, which has the
following argument api: 
</P>
<PRE STYLE="margin-left: 0.79in">f<FONT SIZE=3>unctor simple_filer_g(package options :</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> my icons_path : Void -&gt; String</FONT>
<FONT SIZE=3> my icons_size : Int * Int</FONT>
<FONT SIZE=3> my root : Void -&gt; String Null_Or</FONT>
<FONT SIZE=3> my default_pattern : String Null_Or</FONT>

<FONT SIZE=3> my filetypes : {ext : String List,</FONT>
<FONT SIZE=3> display : {comment : String,</FONT>
<FONT SIZE=3> icon : String,</FONT>
<FONT SIZE=3> preview : ({dir : String,</FONT>
<FONT SIZE=3> file : String} -&gt; Void) Null_Or,</FONT>
<FONT SIZE=3> /* instantiate with NULL ! */ file_to_obj : ({dir : String,</FONT>
<FONT SIZE=3> file : String} -&gt; DummyCB.Part) Null_Or} Null_Or} List</FONT>

<FONT SIZE=3> package Conf : FILER_CONFIG</FONT>
<FONT SIZE=3> end) : Filer</FONT></PRE><P>
As there is no clipboard support, you don't need to specify
<FONT FACE="courier, monospace">file_to_obj</FONT> functions in the
filetypes list. 
</P>
<H3>4.9. Displaying and Browsing Tree-like Structures: Tree Lists</H3>
<P>Tree Lists are used to edit, browse and select in tree-like
objects. These tree-like objects are represented by <FONT FACE="courier, monospace">PTREE_OBJECT</FONT>,
a data package that is part of the Common Infrastructure <FONT
FACE="courier, monospace">CI</FONT> which is also used by other GUI
components. Consequently, 
<FONT FACE="courier, monospace">PTREE_OBJECTS</FONT> can be
exchanged with these components via the clipboard. A
tree list can look like in the following screenshot (taken
from the example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/tree_list_ex.pkg</FONT>):
</P>
<P><IMG SRC="images/treelist.gif" NAME="Graphic3" ALIGN=BOTTOM WIDTH=400 HEIGHT=360 BORDER=0>
</P>
<P>tree_list_g is a class macro that maps objects of  <FONT FACE="courier, monospace">Ptree_Part_Class</FONT>
(enriched by additional information) to a widget together with
operations maniputating its state. The input apis are in
detail:</P>
<P STYLE="margin-left: 0.79in"><BR> <FONT FACE="courier, monospace">api
Treelist_Callbacks = <BR>&nbsp; api <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;
Part_Ilk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SML-necessity since no
HO-generics */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eqtype Node_Info&nbsp;&nbsp;&nbsp;
/* SML-necessity since no HO-generics */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type&nbsp;&nbsp; Subnode_Info /* SML-necessity since no HO-generics
*/ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp; path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* SML-necessity since no HO-generics */ </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my content_label_action : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{path:path, was: String, cc: String -&gt; Void} -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* fired whenever a content label is activated. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* Should be a modal action. */ </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my focus_change_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{changed_at:path List} -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* fired whenever a folder label or a folder icon is modified;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
should be used if tree_list_g is nonmodally coupled over <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* gui_state with a notepad. */ </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my objtree_change_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{changed_at: path} -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* fired whenever the tree-package (gui_state) has been modified -
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
e.g. as a consequence of an internal drag-drop. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* Used for rehresh`s of other views. */ </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my open_close_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{is_open:Bool,changed_at:path List} -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* fired whenever a folder label or a folder icon is opened;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
can be used if internal tree is incrementally . */ </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my error_action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* fired whenever illegal drag-drop-operations are attempted.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
Should be a modal action. */ <BR>&nbsp; end </FONT>
</P>
<P><FONT FACE="times, serif">Note that open_close_notifier can be
used to generate this part of a subtree that is not already
displayed; by this means, large trees can be displayed by
incrementally inserting additional parts of the tree-state whenever
this part is actually needed in the display.  For technical reasons,
the following wrapper api brings all elements together that are
needed for the tree_list_g class macro:</FONT></P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">api
join_g = /* only there fore stupid SML-reasons */ <BR>  api <BR>&nbsp;&nbsp;&nbsp;&nbsp;
package&nbsp; M&nbsp; : Ptree_Part_Class; <BR> &nbsp;&nbsp;&nbsp;
package&nbsp; A&nbsp; : Treelist_Callbacks; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
package&nbsp; clipboard : Clipboard; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.Part_Ilk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= M.Part_Ilk; <BR>&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
objlist = Void -&gt; M.Part_Ilk List;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* there it is, the stupid reason */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type clipboard.Part&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= objlist; <BR>&nbsp;&nbsp;&nbsp;&nbsp; sharing&nbsp;&nbsp;&nbsp;
type A.Node_Info&nbsp;&nbsp;&nbsp; = M.Node_Info; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.Subnode_Info = M.Subnode_Info; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= M.path <BR>&nbsp; end </FONT>
</P>
<P><FONT FACE="times, serif">On top of this definition, we have the
class macro tree_list_g that generates our gui-component:</FONT></P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">generic package
tree_list_g (package&nbsp; S : Join) : <BR> api <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
enum Scale&nbsp;&nbsp; = MICRO | MINI | DEMO <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type Config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = {height&nbsp;&nbsp;&nbsp;&nbsp;
: Int Ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* default 300 */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
width&nbsp;&nbsp;&nbsp;&nbsp; : Int Ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* default 400 */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scrollbars: tk.Scrollbars_At Ref,#  Default NoneScb
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no_icons&nbsp; : Bool Ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* no icons used;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default false */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std_icons : Bool Ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* use icons speci-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* fied in M or use
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* std-icons;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default true */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scale_factor: Scale Ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
/* scales display,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default MICRO */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Config </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my create_canvas: S.M.Part_Ilk List -&gt; tk.Widget </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my upd_guistate : S.M.path -&gt; S.M.Part_Ilk List -&gt; Void <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my get_guistate : Void -&gt; S.M.Part_Ilk List <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my refresh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : S.M.path -&gt; Void
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my refresh_label: Void -&gt;
Void </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my get_selected : Void -&gt; S.M.Part_Ilk List <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my set_selected : S.M.path List -&gt; Void <BR>&nbsp;&nbsp; end</FONT></P>
<H3 STYLE="margin-top: 0in">4.10. Lazy Tree Lists</H3>
<P>There is a slighly older version of the TreeList-Component
described in the previous section, called Lazy Tree Lists. It has
even in some parts a slightly better implementation, but is not
integrated into the common infrastructure (CI). It also provides a
simple history to navigate within the browsed data. You have to
instantiate <FONT FACE="courier, monospace">lazy_tree_g</FONT> with an
object type and some functionality on it. Most prominently, the lazy
tree lists are used in the filer, whence the following screenshot has
been taken: 
</P>
<P><IMG SRC="images/lazy_tree_lists.gif" NAME="Grafik14" BORDER=0><BR>&nbsp;
<BR>&nbsp; 
</P>
<P>The class macro <FONT FACE="courier,
monospace">lazy_tree_g</FONT> has the following argument api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>generic package lazy_tree_g(package Obj : Lazy_Tree_Objects)</FONT>

<FONT SIZE=3>api Lazy_Tree_Objects =</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> type Part</FONT>

<FONT SIZE=3> my children : Part -&gt; Part List</FONT>
<FONT SIZE=3> my is_leaf : Part -&gt; Bool</FONT>
<FONT SIZE=3> my sel_name : Part -&gt; String</FONT>
<FONT SIZE=3> my icon : Part -&gt; tk.Icon_Variety</FONT>
<FONT SIZE=3> my selected_icon : Part -&gt; tk.Icon_Variety</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
The type <TT>Part</TT> is a representation of the objects to display
in the tree list. The other functions are selectors for the needed
information to build the tree: A function to get the children of a
single object, a function that must be <TT>true</TT> for leaf objects
of the displayed tree, a function to get the name of a single object
and functions that return the icons to display for a single selected
and non-selected object. <BR>The export api is: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>generic package lazy_tree_g(package Obj : Lazy_Tree_Objects) :</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> api</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type Part = Obj.Part</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> exception ERROR of String</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> enum history_state = hist_start | hist_middle | hist_end | hist_empty</FONT></FONT></PRE><P>
The object type, an exception to be raised when errors occur and the
return type of the function <TT>position</TT> below, that returns the
position within the history. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my tree_list :</FONT>
<FONT SIZE=3> {width : Int,</FONT>
<FONT SIZE=3> height : Int,</FONT>
<FONT SIZE=3> font : tk.Font,</FONT>
<FONT SIZE=3> selection_notifier : Part Null_Or -&gt; Void} -&gt;</FONT></PRE><P>
The tree list configuration options: The size in pixels of canvas
widget containing the tree list, the font to use, a function to be
called with the selected object (when the selection changes; the
selected object is given as an option, because the selection can also
change to none, e.g. when the parent node of the selected object is
closed). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>{canvas : Part -&gt; tk.Widget,</FONT>
<FONT SIZE=3> selection : Void -&gt; Part Null_Or,</FONT>
<FONT SIZE=3> up : Void -&gt; Void,</FONT>
<FONT SIZE=3> position : Void -&gt; history_state,</FONT>
<FONT SIZE=3> back : Void -&gt; Void,</FONT>
<FONT SIZE=3> forward : Void -&gt; Void}</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
<FONT FACE="courier, monospace"><FONT FACE="times, serif">The
function </FONT><TT><FONT FACE="times, serif">tree_list</FONT></TT><FONT FACE="times, serif">
returns the canvas widget containing the tree list, a function that
return the selected object as an option (there might be none), a
function to change the selection to the parent node, a function that
returns whether the history is empty, at the beginning, the end or
somewhere in the middle (which might be needed if you want to
activate/deactive buttons associated with the history functionality
in the user interface; see also enum history_state above), a and
functions that make the tree list go backwards and forward in the
history. </FONT></FONT>
</P>
<H3>4.11. The drag&amp;drop package</H3>
<P>The drag&amp;drop package is the lower layer of the generic
interface package. It provides a canvas on which items are displayed,
which can be ``grabbed'' with the mouse (by moving the cursor on them
and pressing the right mouse button) and ``dropped'' (moving the
cursor to another place on the canvas and releasing the right mouse
button). By dropping objects onto each other, specific operations can
be triggered. 
</P>
<P>Like generate_gui_g, the package is generic over the items in question: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>generic package drag_and_drop_g(drag_and_drop_items: Drag_And_Drop_Items) :</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> include Drag_And_Drop</FONT>
<FONT SIZE=3> sharing item = drag_and_drop_items.item</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
with the following export api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api Drag_And_Drop =</FONT>
<FONT SIZE=3>api</FONT>
<FONT SIZE=3> type item;</FONT>
<FONT SIZE=3> type DDCanvas;</FONT>

<FONT SIZE=3> exception DRAG_AND_DROP of String;</FONT>

<FONT SIZE=3> my init : tk_types.Widget_ID-&gt; DDCanvas;</FONT>
<FONT SIZE=3> my place : DDCanvas-&gt; item -&gt; Void;</FONT>
<FONT SIZE=3> my delete : DDCanvas-&gt; item -&gt; Void;</FONT>

<FONT SIZE=3> my canvas_event_callbacks : tk_types.Widget_ID -&gt; tk_types.Event_Callback List;</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
Technically, the drag&amp;drop package enriches the items on a canvas
to handle drag&amp;drop style manipulation. One creates a canvas
widget, and passes its widget ID to the function <TT>init</TT>. The
result is a <I>drag&amp;drop</I>-canvas, on which one can place items
with the function <TT>place</TT> and delete objects by the function
<TT>delete</TT>. These items are described by the apis <TT>Drag_And_Drop_Items</TT>:
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api Drag_And_Drop_Items =</FONT>
<FONT SIZE=3>api</FONT>
<FONT SIZE=3> type item</FONT>

<FONT SIZE=3> my get_canvas_item_ID : item-&gt; tk_types.Canvas_Item_ID</FONT>
<FONT SIZE=3> my selDropZone : item-&gt; coordinate.Rectangle</FONT>
<FONT SIZE=3> my isImmobile : item-&gt; Bool</FONT>

<FONT SIZE=3> my grab : item-&gt; Void</FONT>
<FONT SIZE=3> my release : item-&gt; Void</FONT>

<FONT SIZE=3> my enter : item -&gt; item List -&gt; Bool</FONT>
<FONT SIZE=3> my leave : item -&gt; Void</FONT>
<FONT SIZE=3> my drop : item -&gt; item List -&gt; Bool</FONT>

<FONT SIZE=3> package clipboard : api include Write_Only_Clipboard</FONT>
<FONT SIZE=3> sharing Part= item</FONT>
<FONT SIZE=3> end</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
The function <TT>selCItemId</TT> returns the Id of the underlying
canvas item. Every item has a <I>drop zone</I> associated with it.
This is the area, relative to the canvas item's upper left corner, in
which the item is susceptible to drag&amp;drop operations. (It is
left to the class providing the drag&amp;drop items to ensure
that the drop zone does not extend beyond the underlying item.) 
</P>
<P>Items can be selected by clicking them with the middle mouse
button (the ``select'' button). Selected items are highlighted;
selection allows cut, copy &amp; paste operations, and in particular
dragging multiple objects. 
</P>
<P>If the cursor is moved over an item <TT>i</TT>, and the left mouse
button (called the grab button hereafter) is pressed, the item (along
with other previously selected items) is ``grabbed'', if the function
<TT>isImmobile i</TT> returns <TT>false</TT> (otherwise, nothing
happens). The function <TT>grab i</TT> is called, so the item can
e.g. change its graphical representation to indicate this fact. The
object may either stay where it is, and the cursor may change shape
to indicate the user is currently moving an item, or the whole object
may be moved about along with the cursor, depending on the
implementation of drag&amp;drop, but the item class should not
make any presumptions about this. 
</P>
<P>If the cursor enters the drop zone of an item <TT>i</TT> while
dragging another objects <TT>[j_1, ...,j_n]</TT>, the function <TT>enter
i [j_1, ...,j_n]</TT> is called. If it returns <TT>true</TT>, the
entered object <TT>i</TT> is supposed to be accepting a drop of the
objects <TT>j_1, ...,j_n</TT>. It may (and should) change its visual
representation to signal this fact. If the cursor is then released
without having left the drop zone, a drop operation is performed by
calling the function <TT>drop i [j_1, ..., j_n]</TT>. If the result
is <TT>false</TT>, the drop is said to be &quot;destructive&quot;,
and the dropped item is deleted from the canvas, otherwise it
reappears at the position where it was grabbed. If on the other hand
the cursor leaves the drop zone of <TT>i</TT> again without the grab
button being released, the function <TT>leave i</TT> is called, so <TT>i</TT>
can eg. revert its visual appearance to the normal state. <TT>leave i</TT>
is also called after a drop operation (no matter if destructive or
not), but it is <B>not</B> called if the preceding call of <TT>enter</TT>
returned <TT>false</TT>. 
</P>
<P>If the grab button is released with the grabbed item being over no
other item's drop zone, the item is moved to that place on the canvas
and the function <TT>release</TT> is called. <TT>release</TT> is also
called after a non-destructive drop operation for all the dropped
items. 
</P>
<P>The drag&amp;drop-package further interfaces to the clipboard to
allow interchange of objects across different drag&amp;drop canvases,
or to other applications. See the section on the clipboard below. 
</P>
<P>The file
<TT>toolkit/tests+examples/boxes.pkg</TT> contains a simple example
of how to use the drag&amp;drop package.
</P>
<H3>4.12. The Generic Graphical User Interfaces <tt>generate_gui_g</tt> and <TT>generate_tree_gui_g</tt></H3>
<P>The module generate_gui_g implements a simple generic user interface based
on the drag&amp;drop paradigm. It comes in two variants: one based on
&quot;flat&quot; objects (generate_gui_g); and another in which the
objects are hierarchically organized as trees (generate_tree_gui_g). Both
versions of the component are based on the common infrastructure
(CI).</P>
<P>It has been implemented with a view to implementing user
interfaces for applications based on the theorem prover Isabelle, but
can also be used without Isabelle. On top of it, we have bilt a more
elaborate user interface, the generic user interface toolkit <TT>GenIT</TT>.
In <TT>GenIT</TT>, the construction history of objects is recorded,
and becomes a first-class object of the interface. This allows
features such as replay, redo, change and dependency management, and
history navigation all to be implemented on the generic level of the
generate_gui_g. Because of its size and complexity, we have decided to make
<TT>GenIT</TT> available separately from <B>tk</B>. See also
[LW99,LW00]. 
</P>
<P>The application one wishes to build an interface for is described
by a api <TT>SIMPLE_APPL_SIG</TT>. The generic user interface
is a class macro 
</P>
<PRE STYLE="margin-bottom: 0.2in"> generic package SimGenGui(appl: SIMPLE_APPL_SIG) : SIMGENGUI</PRE><P>
which when instantiated with an application returns a graphical user
interface for that application. 
</P>
<H3>4.12.1. Basic Visual Appearance</H3>
<P>Every application provides a collection of <I>objects</I>, which
the generate_gui_g displays in a window (the ``notepad''). Every object has a
<I>type</I>, which determines the icon used to represent the object
on the manipulation area, and the operations applicable to that
object. In generate_tree_gui_g, aside to the notepad, there is a navigation board
displaying the object hierarchy, where the folders correspond to
contents of the notepad and the leafs the objects of the system.
</P>
<P>Operations come in three variations: nullary operations,
corresponding to constants, or in other words, the objects which are
there from the start; unary operations, which take exactly one object
as their argument; and binary operations, which take two objects
arguments. 
</P>
<P>Unary operations are applied by clicking on the object with the
right mouse button, and selecting the corresponding operation from
the menu appearing. Binary operations are applied by grabbing an
object with the left mouse button, dragging it across the screen, and
dropping onto another object. 
</P>
<P>New objects can be created as results of unary or binary
operations. 
</P>
<H3>4.12.2. Modelling in <TT>SIMPLE_APPL_SIG</TT></H3>
<P>In the api <TT>SIMPLE_APPL_SIG</TT>, there are two types
<TT>Part_Ilk</TT> and <TT>Part_Type</TT>, modelling the objects and the
possible object types respectively. The typing is modelling by a
function <TT>part_type: Part_Ilk -&gt; Part_Type</TT>, assigning to each
object a type, and its extension <TT>objlist_type : Part_Ilk List -&gt;
Part_Type</TT> to lists of objects. 
</P>
<P>Further, objects may have a limited form of state, as modelled by
the type <TT>mode</TT>. The mode of an object is given by the
<TT>sel_mode : Part_Ilk-&gt; mode</TT> function, and set by the
<TT>set_mode : Part_Ilk* mode-&gt; function</TT>. The mode can be set
by the user with a pop-up menu provided by generate_gui_g; to implement this,
modes have to have a name (given by <TT>mode_name: mode-&gt; String</TT>),
and the range an object's modes can take is limited by its type
(<TT>modes: Part_Type-&gt; mode List</TT>). 
</P>
<P>The type <TT>New_Part</TT> models objects which are about to
appear on the notepad. They are given by an object, a position where
it should appear, and a direction (indicated by <TT>tk_types.Anchor_Kind</TT>)
where it should appear if there already is an object at the indicated
direction. (The <A HREF="#gengui_conf">configuration option</A> delta
determines the minimum distance of objects when placing new objects.)
Unary operations come in two flavours, <I>standard</I> operations and
ones depending on the type of the object. Standard operations are
available for all objects, and comprise of a list given by <TT>std_ops</TT>
(typically, the first of this list will be a function to display an
object), and two special operations <TT>rename</TT> and <TT>delete</TT>.
Rename is called with the object, and a fate with which the
name of the object can be set. The actual querying the user for a
name, and more importantly accepting or rejecting the user's choice,
has to be implemented by the application. In contrast, <TT>delete</TT>
is called when the object is about to be deleted to allow the
application to clean up; the actual deletion (i.e. removal from the
notepad) is implemented by <TT>generate_gui_g</TT>. This is described by the
api <TT>SIMPLE_APPL_SIG</TT>, of which we have this excerpt: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api SIMPLE_APPL_SIG =</FONT>
<FONT SIZE=3> api</FONT>

<FONT SIZE=3> eqtype Part_Type</FONT>
<FONT SIZE=3> eqtype mode</FONT>

<FONT SIZE=3> type Part_Ilk</FONT>
<FONT SIZE=3> type New_Part = Part_Ilk * tk_types.Coordinate* tk_types.Anchor_Kind</FONT>


<FONT SIZE=3> /* Typing objects */</FONT>

<FONT SIZE=3> my part_type : Part_Ilk -&gt; Part_Type</FONT>
<FONT SIZE=3> my objlist_type : Part_Ilk List -&gt; Part_Type null_or.option</FONT>

<FONT SIZE=3> my is_constructed : Part_Type-&gt; Bool</FONT>
<FONT SIZE=3> /* objects of this type are construction objects */</FONT>

<FONT SIZE=3> /* Each object has a name, which can be selected and changed</FONT>
<FONT SIZE=3> * with the standard rename operation (below).</FONT>
<FONT SIZE=3> */</FONT>
<FONT SIZE=3> my sel_name : Part_Ilk -&gt; String null_or.option</FONT>

<FONT SIZE=3> /* Modes, and how to select, set and name them.</FONT>
<FONT SIZE=3> */</FONT>
<FONT SIZE=3> my modes : Part_Type -&gt; mode List</FONT>
<FONT SIZE=3> my mode_name : mode -&gt; String</FONT>
<FONT SIZE=3> my sel_mode : Part_Ilk -&gt; mode</FONT>
<FONT SIZE=3> my set_mode : Part_Ilk* mode-&gt; Void</FONT>

<FONT SIZE=3> /* Icons. Crucially, changing the mode may change the icon. */</FONT>
<FONT SIZE=3> my icon : Part_Type* mode -&gt; icons.Icon</FONT>

<FONT SIZE=3> /* constants */</FONT>
<FONT SIZE=3> my init : Void -&gt; New_Part List</FONT>

<FONT SIZE=3> /* standard unary operations */</FONT>
<FONT SIZE=3> my std_ops : ((Part_Ilk -&gt; Void)* String) List</FONT>
<FONT SIZE=3> my rename : Part_Ilk -&gt; (String-&gt; Void)-&gt; Void</FONT>
<FONT SIZE=3> my delete : Part_Ilk -&gt; Void</FONT>

<FONT SIZE=3> /* object-type-specific unary operatons */</FONT>
<FONT SIZE=3> my mon_ops : Part_Type -&gt;</FONT>
<FONT SIZE=3> ((Part_Ilk* tk_types.Coordinate -&gt;</FONT>
<FONT SIZE=3> (New_Part -&gt; Void) -&gt; Void) * String) List</FONT>

<FONT SIZE=3> /* binary operations */</FONT>
<FONT SIZE=3> my bin_ops : Part_Type* Part_Type -&gt; (Part_Ilk* tk.Coordinate*</FONT>
<FONT SIZE=3> Part_Ilk List*</FONT>
<FONT SIZE=3> (New_Part-&gt; Void)-&gt; Void) null_or.option</FONT></PRE><P>
The type of <TT>mon_ops</TT> and <TT>bin_ops</TT> certainly requires
an explanation. Both are indexed by the type of the object(s)
involved, which is the first argument. 
</P>
<P>For an object of type <TT>t</TT>, <TT>mon_ops t</TT> is a list of
pairs <TT>[(f_1,s_1), ..., (f_n, s_n)]</TT>, where <TT>s_i</TT> is
the name of the operations under which it appears in the menu, and
<TT>f_i:Part_Ilk -&gt; (Part_Ilk -&gt; Void) -&gt; Void</TT> is a
function implementing the operation, taking the object as its
argument, and a fate (of functionality <TT>New_Part-&gt;
Void</TT>) as its second argument, by which new objects can be
introduced to the notepad area (so each call of the fate
results in the appearance of exactly one object and its subsequent
appearance on the notepad). 
</P>
<P>For two objects of type <TT>t_1</TT> and <TT>t_2</TT>
(corresponding to an object of type <TT>t_2</TT> being dropped onto
an object of type <TT>t_1</TT>), <TT>binOps t_1 t_2</TT> is an
option: either it is <TT>NULL</TT> which means that the drop
operation is not possible; or it is <TT>THE f</TT> where <TT>f</TT>
is a function taking as its first argument the object being dropped
onto, as its second argument the singleton list of the object being
dropped, and as a third argument a fate producing new objects
on the notepad. Both the dropping and the dropped object remain
unchanged (to implement operations changing objects, see below). If
<TT>binOps t_1 t_2</TT> is <TT>THE f</TT>, its icon is highlighted
(see <A HREF="#icons">Section 4.4.4. below</A>) to indicate that the
operation is possible. 
</P>
<H3>4.12.3. Constructing Objects</H3>
<P>The only way to change an object's internal package is the
<I>construction area</I>. The general idea here is that each
instantiation of the generate_gui_g should be thought of as an application to
build objects of one specific type. For example, in the
Transformation Application System TAS the main construction objects
are programs, and the other objects are program transformations,
parameter instantiations etc. (see [LW99]), and in the interface
IsaWin to the theorem prover Isabelle, the main construction objects
are proofs (for theorems), and the other objects are theorems,
theories, rewriting sets etc. 
</P>
<P>A construction object can be opened by double-clicking it with the
left mouse button. A (sub)-window will appear (see <A HREF="#gengui-conf">configuring
generate_gui_g below</A>) showing the ``internals'' of the object, possibly
along with menus, buttons and other widgets. One can now either use
these to change the objects' internal package, or one can drag down
objects from the manipulation area to interact with the object under
construction. If one is done, there should be a closing button or
menu entry by which one can close the construction area again. The
specifics and visual appearance of the construction area are entirely
dependent on the application in question (hence there <I>should</I>
be a closing button, technically this is not enforced), and have to
be implemented by the application as follows. 
</P>
<P>Note also that there is no restriction to one type of object-
object types which can be constructed are those for which the
predicate <TT>is_constructed</TT> is true. The construction area is
described by the following excerpt from the api <TT>Application</TT>:
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> type ca</FONT>

<FONT SIZE=3> my area_ops : Part_Type-&gt; ca-&gt; Part_Ilk List-&gt; Void</FONT>

<FONT SIZE=3> my area_open : tk_types.Window_ID* Part_Ilk* (Part_Ilk -&gt; Void) -&gt;</FONT>
<FONT SIZE=3> (ca* tk_types.Widget List* (Void-&gt; Void))</FONT>
<FONT SIZE=3> my area_init : Void-&gt; Void</FONT></PRE><P>
The type <TT>ca</TT> models the state of the construction area. When
an object is opened in the construction area, <TT>area_open</TT> is
called with the object and the identifier of the window in which the
construction area sits. This may be generate_gui_g's window, or a separate
window, as determined by the configuration of generate_gui_g. The third
argument to <TT>area_open</TT> is a function which is called when the
construction is finished; it creates one (or more) objects on the
notepad, most notably the one which has been constructed. Be sure to
call this function with the constructed object prior to closing the
construction area, otherwise the object will disappear in a puff of
SML. <TT>area_open</TT> returns a triple, consisting of the state of
the construction area just created, a list of widgets making up the
construction area, and a function to be called after the widgets have
been installed which initializes them. 
</P>
<P>In contrast, <TT>area_init</TT> is just called once, after generate_gui_g
has been started, e.g. to initialize variables for radiobuttons. When
calling <TT>area_init</TT> the construction area is not open, so do
not try to initialize widgets here. 
</P>
<P>Finally, dragging an object down from the notepad into the
constructoin area results an operation being triggered. The operation
is given by <TT>area_ops: Part_Type-&gt; ca-&gt; Part_Ilk List-&gt; Void</TT>
which takes as argument the type of the object(s) dragged down, the
state of the constrution area, and the actual objects; it does not
have a meaningful return value. 
</P>
<P><A NAME="icons2"></A><A NAME="icons"></A>As we can see, the
construction area even more relies on side effects than the rest of
the generate_gui_g. The functional purist shudders, since this also means we
have to provide functionality like history navigation (or the close
button) individually, for each application, rather than on a generic
level. These failings area remedied in GenIt. <BR><BR><BR>
</P>
<H3>4.12.4. Configuring generate_gui_g</H3>
<P>Like the utility windows, the visual appearance of the generate_gui_g can
be configured. This configuration is handled by the subpackage
<TT>package Conf: GENGUI_CONF</TT> of the application with the
following api. Apart from visual details like colours, window
sizes and icons, we can also configure wether icons should remain
visible while being dragged across the notepad (<TT>moveOpaque</TT>),
and wether the construction area should be a subwindow of the
notepad, or a separate window (<TT>oneWindow</TT>). 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>api GENGUI_CONF =</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> api</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> /* This is the width and height of the construction area */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my width : Int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my height : Int</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The background colour of the construction area */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my background : tk_types.Color</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The font and the width of the box, in pixels,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * used to display the icons */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my iconNameFont : tk_types.Font</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my iconNameWidth : Int</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The icon used to display the trashcan, and its initial position */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my trashcanIcon : Void-&gt; icons.Icon</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my trashcanCoord : tk_types.Coordinate</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* If opaqueMove is true, then the whole item will move if it</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * is grabbed; ows. only change cursor to indicate an object is</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * being moved. */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my moveOpaque : Bool</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* If oneWindow is true, the construction area will appear as</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * a widget within the lower part of the window (which will be</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * large enough to hold it. Actually, this should be called _one</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * widget_, since it means that both construction and assembly</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * come within one frame); otherwise, the construction area</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * will appear as a separate window.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my oneWindow : Bool</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The height and width of the construction area, and the</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * position of the window. The X/Y position and the caTitle options</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * determine the placing and title of the construction area window,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * and only take effect if oneWindow is false.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my caHeight : Int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my caWidth : Int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my caXY : (Int* Int) null_or.option</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my caTitle : String-&gt; String</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The minimum distance between two objects' dropzones when placing</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * new objects</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my delta : Int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> end</FONT></FONT></PRE><H3>
<FONT FACE="times, serif"><FONT SIZE=4>4.12.5. Export api</FONT></FONT></H3>
<P><FONT SIZE=3><FONT FACE="times, serif">The export api of
</FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">generate_gui_g</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
divides roughly into two parts. The first block describes single
objects and how to introduce them onto the notepad. The second part
models the state of </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">generate_gui_g</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
as a whole (type </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">gui_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">).
There is an initial state </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">initial_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
corresponding to no objects being created yet, a function
</FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">state:Void-&gt;
gui_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
which returns the current state of notepad and construction area, and
a function </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">init:gui_state-&gt;
Void</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif"> which
has to be used as the initialization function of the main window,
because it initializes generate_gui_g. If generate_gui_g suddenly behaves very
strange indeed (e.g. doesn't react to drag&amp;drop) this is most
likely caused by failing to initialize it properly. Finally, the
whole generic interface is just a widget (isn't everything?): </FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>api Generated_GUI =</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> api</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type Part_Ilk</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type New_Part</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> my intro : New_Part -&gt; Void</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> /* Introduce (not &quot;create&quot; really) a new object</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * onto the manipulation area. */</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* the state of the gui */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type gui_state = New_Part List</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* The generate_gui_g main widget. You MUST use the init function below</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * to initialize this widget. (Note generate_gui_g doesn't check this</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * itself.) */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my main_wid : tk_types.Window_ID -&gt; tk_types.Widget</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* In the following, init takes a gui_state and returns a function</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * which has to be used as the init function of the main window,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * as it sets up the generate_gui_g.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * state returns a gui_state suitable as an argument to init.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> */</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> my init : gui_state-&gt; Void</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> /* call that as init action of main window */</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> my state : Void-&gt; gui_state</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* This is the initial state which only has those objects as given</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * by the application's init() function (see above). */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my initial_state : Void-&gt; gui_state</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> exception GENERATE_GUI_FN of String</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> /* Something went wrong. If this exception is raised, something</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * has badly, unrecoverably (for this session) gone wrong. */</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> /* Resynchronize all icons, e.g. if objects have changed their mode. */</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> my redisplay_icons : (Part_Ilk-&gt; Bool)-&gt; Void</FONT></FONT>


<FONT FACE="courier, monospace"><FONT SIZE=3> type objectlist= Part_Ilk List</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> package clipboard : Clipboard</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> sharing clipboard.Part = objectlist</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> end</FONT></FONT></PRE><H3>
4.12.6. An Example</H3>
<P>The file <TT>toolkit/tests+examples/simpleinst.pkg</TT> contains a
small example of how to use the generic graphical user interface. 
</P>
<P><TT>simpleinst</TT> knows two object types, texts and numbers.
Texts can be concatenated by drag&amp;drop (the dropped text being
appended to the one it is dropped onto), or they can be opened and
edited in the construction area. Numbers, on the other hand, have
four modes, corresponding to the four basic arithmetical operations.
When dropping a number onto another, it is added to, subtracted from,
multiplied with, or it divides the number it is dropped onto,
corresponding to the mode of the dropped object. 
</P>
<P>There is a button <TT>importFile</TT> which calls the filer to
select a file the contents of which (as a text) then appear on the
manipulation area. The following picture shows the visual appearance
of <TT>simpleinst</TT> with the object obtained by dropping the
predefined object <TT>Jerusalem 2</TT> onto <TT>Jerusalem 1</TT>
currently open in the construction area: 
</P>
<P><IMG SRC="images/simpleinst.gif" NAME="Grafik10" ALT="[Simple Instantation]" ALIGN=BOTTOM WIDTH=700 HEIGHT=400 BORDER=0>
</P>
<P>The visual appearance of a system obtained by instantiating <TT>generate_gui_g</TT>
can be customised considerably. The basic layout will remain the
same, with the the construction area appearing in the bottom half of
the screen, but the construction area's appearance and functionality
are freely programmable. The main window of the simple instantiation
can have menus and/or buttons attached to it, and of course the
icons, including the trashcan icon, can be changed. 
</P>
<H3><BR><BR>
</H3>
<H3 STYLE="margin-top: 0in">4.13. Tabs</H3>
<P>An implementation of tabs as in the following screenshot (taken
from the tabs example in <FONT FACE="courier, monospace">src/toolkit/tests+examples/tabs_ex.pkg</FONT>),
</P>
<P><IMG SRC="images/tabs.gif" NAME="Grafik13" ALIGN=BOTTOM WIDTH=600 HEIGHT=350 BORDER=0> 
</P>
<P><BR><BR>which has the following export api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api TABSSIG =</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> exception ERROR of String</FONT>

<FONT SIZE=3> my tabs : {pages : {title : String,</FONT>
<FONT SIZE=3> subwidgets : tk.Widgets,</FONT>
<FONT SIZE=3> show : tk.Void_Callback,</FONT>
<FONT SIZE=3> hide : tk.Void_Callback,</FONT>
<FONT SIZE=3> shortcut : Int Null_Or} List,</FONT></PRE><P>
The definition of the displayed pages including the page title, the
widgets displayed within the frame building the page, and a shortcut
key as an integer value (the nth char in the page title). The show
and hide actions are needed to initialize the widgets when a page is
shown, and save its content when a page is hidden. Therefore the show
action is called when the widgets are allready displayed, and the
hide action is called just before the widgets are (temporarily)
destroyed. There is also an example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/tabs_ex.pkg</FONT>).
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>configure : {width : Int,</FONT>
<FONT SIZE=3> spare : Int,</FONT>
<FONT SIZE=3> height : Int,</FONT>
<FONT SIZE=3> font : tk.Font,</FONT>
<FONT SIZE=3> labelheight : Int}}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">These are the available
configuration options: The width and height of the frame containing
the widgets of a single page, the amount of pixels to spare right
from the page titles, the font of the page titles and the maximum
height of the labels containing the page titles (height of the
specified font + x).</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>-&gt; tk.Widget *</FONT>
<FONT SIZE=3> tk.Event_Callback List</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The returned canvas widget in
which the tabs are displayed and the naming list containing the key
shortcuts, which should be bound to the window containing the tabs.
Unfortunately there is no other way of key adding event_callbacks to the
tabs, because Tcl/Tk does not support key event_callbacks to canvases.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>my std_conf : {width : Int,</FONT>
<FONT SIZE=3> spare : Int,</FONT>
<FONT SIZE=3> height : Int,</FONT>
<FONT SIZE=3> font : tk.Font,</FONT>
<FONT SIZE=3> labelheight : Int}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">This is a standard
configuration to use with the tabs (comments on parameters, see
above).</FONT></FONT> 
</P>
<H3 STYLE="margin-top: 0in">4.14. Tables</H3>
<P>A simple implementation of tables, that returns a grid of labels
within a frame (screenshot taken from the tables example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/table_ex.pkg</FONT>):
</P>
<P><IMG SRC="images/tables.gif" NAME="Grafik11" ALIGN=BOTTOM WIDTH=600 HEIGHT=250 BORDER=0> 
</P>
<P>The class <FONT FACE="courier, monospace">Table</FONT> has the
following export api: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>api TABLE_SIG =</FONT>
<FONT SIZE=3> api</FONT>
<FONT SIZE=3> my table : {constant_column_width : Bool,</FONT></PRE><P>
If set to <FONT FACE="courier, monospace">true</FONT>, the largest
column width found is applied to all columns. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>headline_relief : tk.Relief_Kind,</FONT>
<FONT SIZE=3> headline_borderwidth : Int,</FONT>
<FONT SIZE=3> headline_foreground : tk.Color,</FONT>
<FONT SIZE=3> headline_background : tk.Color,</FONT>
<FONT SIZE=3> field_relief : tk.Relief_Kind,</FONT>
<FONT SIZE=3> field_borderwidth : Int,</FONT>
<FONT SIZE=3> field_foreground : tk.Color,</FONT>
<FONT SIZE=3> field_background : tk.Color,</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The relief, borderwidth,
foreground and background colour of the headline and table fields.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>container_background : tk.Color} -&gt;</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The background colour of the
frame containing the table fields (visible if a different borderwidth
is set for headline and table fields).</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>tk.Live_Text List List -&gt; tk.Widget</FONT></PRE><P>
The textual content of the table. Adding widgets to the annotated
text might confuse the calculation of a constant comlumn width. 
</P>
<PRE STYLE="margin-bottom: 0.2in"></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The returned frame widget
containing the table.</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> my std_conf : {constant_column_width : Bool,</FONT>
<FONT SIZE=3> headline_relief : tk.Relief_Kind,</FONT>
<FONT SIZE=3> headline_borderwidth : Int,</FONT>
<FONT SIZE=3> headline_foreground : tk.Color,</FONT>
<FONT SIZE=3> headline_background : tk.Color,</FONT>
<FONT SIZE=3> field_relief : tk.Relief_Kind,</FONT>
<FONT SIZE=3> field_borderwidth : Int,</FONT>
<FONT SIZE=3> field_foreground : tk.Color,</FONT>
<FONT SIZE=3> field_background : tk.Color,</FONT>
<FONT SIZE=3> container_background : tk.Color}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">A standard configuration
offering standard values for the parameters described above.</FONT></FONT>
</P>
<H2><A NAME="installation"></A>5. Installation</H2>
<P>This section details the software and hardware requirements
necessary to run <B>tk</B>, the installation procedure, the
runtime configuration of <B>tk</B> and other helpful hints. 
</P>
<H3>5.1. Software and Hardware Requirements</H3>
<P><B>tk</B> requires the following software: 
</P>

For the default configuration (pipe-based communcation with Tcl/Tk), a
Standard ML compiler implementing the <TT><A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/pages/posix-chapter.html"><U><FONT
COLOR="#0000ff">Posix</FONT></U></A></TT> and <TT><A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/pages/unix.html"><U><FONT
COLOR="#0000ff">Unix</FONT></U></A></TT> packages from the <A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/"> base
library</A>. In particular, <b>tk</b> is known to work with the following
compilers:
<ul><li><A
HREF="http://cm.bell-labs.com/cm/cs/what/smlnj/index.html">Standard ML
of New Jersey (SML/NJ)</a>, version 110.0.6 and 110.0.7;
    <li><A HREF="http://www.lfcs.informatics.ed.ac.uk/software/polyml/">PolyML</A>, version 4.0beta1;
    <li><A HREF="http://www.dina.dk/~sestoft/mosml.html">MoscowML</A>, version 2.00.
</ul></P>

<p>A <tt>wish</tt> (Tcl/Tk interpreter) of version 4.0 to 8.0 or
later. If you do not know if the wish is installed on your system,
type <TT>wish</TT> in a shell window; you should get a Tcl prompt
(<TT>%</TT>) and a blank window called <TT>wish</TT>.  Otherwise,
download Tcl/Tk from <A
HREF="http://dev.scriptics.com/software/tcltk">here</A>.</p>

<P>Optionally, a standard make for installation (GNU make and Solaris
make are known to work).</P>
		
<p>The <I>TCL_INSIDE</I> configuration only runs with <A
HREF="http://cm.bell-labs.com/cm/cs/what/smlnj/index.html">Standard 
ML of New Jersey</A> (SML/NJ), but should be easier to port to 
non-Posix systems such as Windows. </p>

<P>Optionally, a standard make for installation (GNU make and Solaris
make are known to work).</P>

<P><B>tk</B> has no particular hardware requirements, and is
known to run on the Solaris and Linux operating systems.
</P>
<H3>5.2. Obtaining and Installing <B>tk</B></H3>
<P><B>tk</B> can be obtained as a single <TT>tar</TT> file from
the <A HREF="http://www.informatik.uni-bremen.de/~cxl/sml_tk/home.html"><B><U><FONT COLOR="#0000ff">tk</FONT></U></B>
home page</A>
</P>
<H4>Configuring <B>tk</B></H4>
<P>Before you start the installation itself, you have to configure
<B>tk</B> to your system's need by setting the variables in the
first section of the Makefile to appropriate values. The most
critical of these are obviously <TT>SMLTK_LIB</TT> and <TT>SMLTK_TCL</TT>:
</P>
<DL>
        <DT><TT>SMLTK_TCL</TT> 
	</DT><DD>
	the full pathname of the Tcl/Tk shell <tt>wish</tt>. 
	</DD><DT>
	<TT>SMLTK_LIB</TT> 
	</DT><DD>
	the full pathname of the runtime library of <B>tk</B>, which
	contains files such as images and icons needed at runtime. The
	default is the directory lib in the <B>tk</B> toplevel
	directory. 
	</DD><DT>
	<TT>SMLTK_LOGFILE</TT> 
	</DT><DD>
	the full pathname of the <I>logfile</I>. The logfile is a protocol
	file useful in debugging <B>tk</B> applications (see <A HREF="manual.html#appx">the
	appendix of the <B>tk</B> manual</A>). If it is not set, no
	protocol is written; this is the default. 
	</DD><DT>
	<TT>SMLTK_BINARY</TT> 
	</DT><DD>
	the full pathname of the binary to be produced. The directory has to
	exists and be writeable. (The default Makefile does not
        produce binaries with MoscowML.)
	</DD><DT>
	<TT>COMP</TT> 
	</DT><DD>
	the name of the compiler: can be <tt>njml</tt>, <tt>poly</tt>
        or <tt>mosml</tt>. 
        </DD><DT>
	<TT>COMP_BIN</TT> 
        </DT><DD>
	the name of the compiler, as a shell command or full pathname of its
	binary. For using the PolyML-compiler, you will have to add the path 
        to the ML-base file (Please save this file yourself after a build; 
        this is not handled by the Makefile!).
        </DD><DT>
	<TT>COMP_NAME</TT> 
	</DT><DD>
	the name of the compiler as a string, which will apear in the banner
	of the produced binary (<TT>tk for ...</TT>). 
	</DD></DL>
<P>
The variables <TT>SMLTK_LIB</TT>, <TT>SMLTK_LOGFILE</TT> and
<TT>SMLTK_TCL</TT> also control the runtime of <B>tk</B> (see <A
HREF="#config-runtime">section 5 of the <B>tk</B> manual</A>).
<B>tk</B> can be installed by producing a dumped image, or by
using SML/NJ's compilation manager. The installation itself is
painless.  Just type <TT>make</TT> in the toplevel directory, and it
will produce an image; alternatively, use SML/NJ's compilation
manager (see below).
</P>
<P>To remove the Compilation Manager's temporary files, do <TT>make
clean</TT>. To also remove the dumped image, use <TT>make realclean</TT>.
</P>
<H4>The Configuration <I>TCL_INSIDE</I></H4>
<P><A NAME="config-runtime"></A>As already mentioned previously,
<B>tk</B> comes in two different configurations: the default one,
based on a loose coupling with the Tcl/Tk shell, and another one
called&nbsp;<SPAN STYLE="font-weight: medium"><I>TCL_INSIDE</I><SPAN STYLE="font-style: normal">,
based on linking the Tk-sources on the C-level to the NJML-runtime
system. To install the configuration&nbsp;</SPAN><I>TCL_INSIDE&nbsp;</I><SPAN STYLE="font-style: normal">is
the package <B>njml_patch</B>which can be downloaded from the <B>tk</B>
web site is needed. It has to be applied to an existing SML/NJ
installation which it transforms by adding additional sources and
patching others at the level of C source files. After succesfully
running the&nbsp;</SPAN><I>Makefile</I><SPAN STYLE="font-style: normal">in
<B>njml_patch</B></SPAN> (for which various system dependent paths
have to be set appropriately; see documentation for details), the
compilation of&nbsp;<B><SPAN STYLE="font-style: normal">tk</SPAN></B>
on top of this extended runtime system is performed with the flag
TCL_INSIDE set on. The effect is limited only to a very small portion
of <B>tk</B>.</SPAN> 
</P>
<H3>5.3 <B>tk</B> Runtime Configuration</H3>
<P>The following variables govern the runtime behaviour of <B>tk</B>:
</P>
<UL>
	<LI><TT>SMLTK_LIB</TT> is the full
	pathname of the runtime library of <B>tk</B>. In a compiled
	<B>tk</B> application, you only need this directory, which
	contains image files and the odd shellscript. Of course, you may
	want to add image files for your own applications here as well.</LI>
	<LI><TT>SMLTK_LOGFILE</TT> is where the
	<I>logfile</I> can be found. The logfile is a protocol of the
	communication between <B>tk</B> and the wish. It can be useful
	for the experienced user in debugging <B>tk</B> applications
	(see the <A HREF="#appx">appendix</A>);</LI>
	<LI><TT>SMLTK_TCL</TT> is the complete path to the Tcl/Tk wish.</LI>
</UL>
<P>These are given default values in the <TT>Makefile</TT>. The
default values can be overridden by setting an environment variable
of the same name, and calling the function <TT>tk.init();</TT>
only the options to which the corresponding environment variable
actually exists are changed, allowing a selective update. The
environment variable can in turn be overriden by a commandline
argument of the form <TT>--&lt;VARNAME&gt;=value</TT> (as in
<TT>--SMLTK_TCL=/bin/wish</TT>) when calling an <B>tk</B>
application from the shell. Finally, their value can be changed from
within SML by calling e.g. <TT>tk.update_tcl_path</TT>, see <A HREF="#init-config">Sect.
3.2.17</A> above. 
</P>
<H3><A NAME="extensions"></A>5.4. Porting, Helpful Household Tips and
Known Problems</H3> <H4>Porting <B>tk</B></H4> <P><B>tk</B>
has been developed with SML/NJ, version 110.  Meanwhile, other SML97
compilers have become available, and <b>tk</b> runs under PolyML
and MoscowML as well (apart from small details such as the
kill-mechanism and the generation of a binary image for MoscowML).
Given these experiences, we believe it should be relatively easy to
port <B>tk</B> to other platforms and compilers; an experienced ML
programmer should be able to do this himself. The main work in porting
<B>tk</B> to another compiler is to write a class
<TT>sys_dep</TT>, which implements the api <TT>SYS_DEP</TT> (in
<TT>src/sys_dep.api</TT>). The files <TT>njml.pkg</TT>,
<TT>poly.pkg</TT> and <TT>mosml.pkg</TT> may serve as a starting
point.
</P>
<P>If you do port <B>tk</B> to another operating system or SML
compilers, please let us know so we can support your port in future
releases of <B>tk</B>. 
</P>
<P>We also invite further contributions to the toolkit library. If
you have written a piece of <B>tk</B> software which is
sufficiently versatile to be of general use, then please do get in
touch with us. We would very much like to extend the toolkit library
in future releases. 
</P>
<H4>Tips&amp;Tricks </H4>
<P>This section contains some tips which you may find useful. 
</P>
<UL>
        <LI><p>If you don't want to produce a binary image, or are using
        Moscow ML, you can load <b>tk</b> by <tt>use</tt>ing the
        file <tt>root_poly.pkg</tt> and <tt>root_mosml.pkg</tt> (for
        PolyML and Moscow ML respectively.)</p>

	<LI><P STYLE="margin-bottom: 0in">SML/NJ users can make
	efficient use of the Compilation Manager by including a
	reference to <TT>tk/src/sources.make6</TT> in the entity
	description files of their application(s), and the CM will
	automatically compile <B>tk</B> when needed. You may want
	to stabilize <B>tk</B> in that case (see the manual for
	CM).
	</P>

	<LI><P STYLE="margin-bottom: 0in">The dumped images contain some of
	the examples found in the source distribution. If you do not want
	them, change this in <TT>src/sources.make6</TT>. 
	</P>
	<LI><P>The export interface of <B>tk</B> consists of two
	packages <TT>tk_types</TT> and <TT>tk</TT>. If you want them to
	be opened in the dumped images, this can be changed in <TT>src/Makefile</TT>.
	Also, the dumped images call <TT>tk.initSmlTk</TT> first thing
	they are loaded (in order to correctly set <TT>SMLTK_ROOT</TT> etc.
	from the environment variables). This can be changed in
	<TT>src/njml1.sml</TT> in the function <TT>dump_executable_heap_image</TT>. 
	</P>
</UL>
<H4>Known Problems</H4>
<UL>
	<P STYLE="margin-bottom: 0in">TCL_INSIDE is quite tricky to install.
	It requires the installation of the package &quot;njml_patch&quot;,
	that attempts to modify and extend the C-sources of the njml-runtime
	system and to link the Tk-library to it. This process highly depends
	on very machine-dependent features and may fail for various reasons.</P>
	<P><B>tk</B> cannot send an interrupt to a running application
	(see the discussion in section 2), so one cannot implement an
	interrupt button. Interupts have to be sent to the window of the
	SML-shell.</P>
        <p>The interrupt mechanism doesn't work with SML compilers
        other than SML/NJ.</P>
</UL>
<H2>6. Bibliography</H2>
<P>[Fos 97] E. Foster-Johnson: Graphical Applications with Tcl and Tk
. M&amp;T Books . 2nd Edition December 1997 . ISBN:1558515690.
</P>
<P>[FW94] M. Fr&ouml;hlich, M. Werner: The Interactive
Graph-Visualization System daVinci - a User Interface for
Applications. Informatik-Bericht Nr. 5/94, Universit&auml;t Bremen,
1994. 
</P>
<P>[HM 97] M. Harrison, M. McLennan: Effective Tcl/Tk Programming.
Addison-Wesley, December 1997. ISBN: 0201634740. 
</P>
<P>[KSW96] Kolyang, T. Santen, B. Wolff: Correct and User-friendly
Implementations of Transformation Systems. In: M.C. Gaudel, J.
Woodcock (ed): FME'96: Industrial benefits and Advances of Formal
Methods, pp. 629-648. LNCS 1051,1996. 
</P>
<P>[Lib 94] D. Libes: Exploring Expect. O'Reilly 1994. ISBN:
1565920902.
</P>
<P>[LW99] C. L&uuml;th, B. Wolff: Functional Design and
Implementation of Graphical User Interfaces for Theorem Provers.
Journal of Functional 9(2), 167-- 189, 1999. 
</P>
<P>[LW00] C. L&uuml;th, B. Wolff: TAS - A Generic Window Inference
System. 13th International Conference on Theorem Proving in
Higher-Order Logics TPHOLs 2000, LNCS 1869, Springer Verlag. pages
405--422 
</P>
<P>[Oust 94],J. K. Ousterhout: Tcl and the Tk .Addison-Wesley . May
1994. ISBN: 020163337X. 
</P>
<P>[Pau 96] L. C. Paulsen: ML for the Working Programmer(2<SUP>nd</SUP>.
Ed.). Cambridge University Press 1996. See also
<A HREF="http://www.cl.cam.ac.uk/users/lcp/MLbook/">http://www.cl.cam.ac.uk/users/lcp/MLbook/</A>.
</P>
<P>[PR95] F. Pessaux, F. Rouaix: The Caml/Tk interface, Projet
Cristal, INRIA Roquencourt, July 1995.
<A HREF="ftp://ftp.inria.fr/lang/../INRIA/Projects/cristal/caml-light/camltk.dvi.tar.gz">ftp://ftp.inria.fr/lang/../INRIA/Projects/cristal/caml-light/camltk.dvi.tar.gz</A>.
</P>
<P>[REF 96] Tcl and Tk Reference Manual. Linux Systems Labs . May
1996. . See also <A HREF="http://www.tclconsortium.org/books/index.vet">http://www.tclconsortium.org/books/index.vet</A>.
</P>
<P>[VTS95] T. Vullinghs, D. Tuijnman, W. Schulte: &quot;Lightweight
GUIs for Functional Programming&quot;. PLILP 95, Utrecht, The
Netherlands, Sept. 20-22, 1995. 
</P>
<P>[Wel 97] B. Welch: Practical Programming in Tcl and Tk.
Prentice-Hall/PTR. 2nd Edition July 1997. ISBN: 0136168302. See also
http://www.tclconsortium.org/books/index.vet. <BR>&nbsp; <BR>&nbsp; 
</P>
<H2><A NAME="appx"></A>7. Appendix: A Commented Logfile</H2>
<P><B>tk</B> can produce a <I>logfile</I> (see above) in which
the communication between SML and the wish is recorded. Logfiles can
be helpful in debugging applications, since they show what &quot;really&quot;
happened; in particular, this can show whether source of unexpected
behaviour lies in the SML code, or quirks of Tk (or, God forbid, a
bug in <B>tk</B>). 
</P>
<P>Nevertheless, it should be stressed that logfiles are not for the
beginner, but rather the advanced user exploring the more intricate
features of both <B>tk</B> and Tk. 
</P>
<P>In this appendix, we present a commented logfile produced by the
small example from section 1. The user interaction proceeds as
follows: after starting the program, enter a name in the text entry,
press return and close the window by clicking the quit box. Here is
the resulting logfile. 
</P>
<P>The general format of the logfile is that lines beginning with <TT>==</TT>
are sent from <B>tk</B> to the wish, and lines beginning with <TT>&lt;==</TT>
are sent from the wish to <B>tk</B>. It always starts with a
standard prelude, which sets up the wish for use with <B>tk</B>: 
</P>
<PRE>== set tcl_prompt1 &quot;puts -nonewline {} &quot;
 set tcl_prompt2 &quot;puts -nonewline {} &quot;
proc Write {msg} {
 puts stdout $msg
 flush stdout
}
proc WriteSec {tag msg} {
 set status [catch {eval $msg} res]
 if {$status == 0} {
 puts stdout &quot;$tag $res&quot;
 } else {
 puts stdout &quot;ERROR $res&quot;
 }
 flush stdout
}
proc WriteCmd {tag msg} {
 set status [catch {eval $msg} res]
 if {$status == 0} {
 puts stdout &quot;$tag&quot;
 } else {
 puts stdout &quot;ERROR $res&quot;
 }
 flush stdout
}
proc WriteM {msg} {
 puts stdout $msg
 flush stdout
 puts &quot;EOM&quot;
 flush stdout
}</PRE><P>
Now follow the packing commands for the main window. Note the names:
the main window's Tk name will always be <TT>.</TT> (dot).
Sub-windows or widgets within a window, or subwidgets will always
have the name of the father window/widget, followed by a dot and
their own name. The names <TT>anowidXX</TT> are the anonymous widget
identifiers created by <TT>make_widget_id</TT>. 
</P>
<P>Here, the packing proceeds in the following order: first the frame
with its two components is packed, the text label &quot;name&quot; on
the left, and the text entry on the right followed by the event_callbacks
for the text entry: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {pack [frame .anowid24 ] -side top}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {pack [label .anowid24.anowid22 -text &quot;name:&quot;] -side left}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {pack [entry .anowid24.anowid21 -width 20] }
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {bind .anowid24.anowid21 &lt;Return&gt; {Write &quot;WNaming main .anowid24.anowid21 &lt;Return&gt; (%b,%s,%x,%y,%X,%Y) &quot;}}
&lt;== CMDOK</PRE><P>
Note how the wish acknowledges execution of each command sent with
<TT>CMDOK</TT>. Further, one cannot see from the logfile what
<TT>&lt;Return&gt;</TT> has been bound to, since <B>tk</B> only
binds it to a function indicating the event has occurred, and does
the mapping to the relevant ML function internally. The packing
continues with the quit button, and finishes with setting the window
title: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {pack [button .anowid23 -text &quot;Quit&quot; -command {Write &quot;Command main .anowid23&quot;}] -side bottom}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {wm title . &quot;Please enter name&quot;}
&lt;== CMDOK</PRE><P>
Now <B>tk</B> is waiting for user input. Hence, the next
communication is initiated by the wish, indicating that the <TT>&lt;Return&gt;</TT>
key has been pressed: 
</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;== WNaming main .anowid24.anowid21 &lt;Return&gt; (96,0,80,16,277,193)</PRE><P>
On the ML side, the function <TT>end_input</TT> is executed. This
calls the <B>tk</B> function <TT>get_tcl_text</TT> to read the
contents of the text widget. A value is requested from the wish with
<TT>WriteSec</TT>, and sent in a line preceded with <TT>VValue</TT>: 
</P>
<PRE>== WriteSec &quot;VValue&quot; {.anowid24.anowid21 get}
&lt;== VValue William Lee</PRE><P>
Then, the title of the window is set accordingly: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {wm title . &quot;William Lee&quot;}
&lt;== CMDOK</PRE><P>
Again, the system is waiting for something to happen. In this case,
the quit button (widget id <TT>anowid23</TT> is pressed. <B>tk</B>
calls the function <TT>quit</TT>, which in turn closes the window: 
</P>
<PRE>&lt;== Command main .anowid23
== destroy .</PRE><P>
It should be pointed out that in an application of decent size, the
interaction between wish and <B>tk</B> is not always as orderly
as above. In particular, event_callbacks may be activated at any point, even
when <B>tk</B> is waiting for a value from the wish. 
</P>
</BODY>
</HTML>
