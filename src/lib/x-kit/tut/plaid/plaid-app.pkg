## plaid-app.pkg
#
# This app draws screensaver-like rectangular patterns in a window.
#
# It has two modes, "idle" and "active".
#
# In "idle" mode it uses normal buffered xd::fill_boxes XOR-draw
# commands to fill the window with a rectangular pattern and stops.
#
# In "active" mode is uses unbuffered xd::fill_boxes XOR-draw
# commands to draw a continuously changing (another draw every
# 100ms) pattern.
#
# Clicking any mouse button anywhere in the window toggles
# the app between these two modes.
#
# This app uses the "unbuffered" window mode designed to support
# rubber-banding and also the XOR drawing mode used by rubber-banding;
# this makes it a useful unit test for rubber-banding functionality.
#
# One way to run this app from the base-directory commandline is:
#
#     linux% my
#     eval: make "src/lib/x-kit/tut/plaid/plaid-app.make6";
#     eval: plaid_app::do_it ();

# Compiled by:
#     src/lib/x-kit/tut/plaid/plaid-app.make6

stipulate
    include threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package rx  =  run_xkit;				# run_xkit			is from   src/lib/x-kit/widget/lib/run-xkit.pkg
    package xc  =  xcore;				# xcore				is from   src/lib/x-kit/xclient/xcore.pkg
    package xd  =  xdraw;				# xdraw				is from   src/lib/x-kit/xclient/xdraw.pkg
    package xg  =  xgeometry;				# xgeometry			is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;				# xinput			is from   src/lib/x-kit/xclient/xinput.pkg
    package xw  =  xwindow;				# xwindow			is from   src/lib/x-kit/xclient/xwindow.pkg
    package xtr =  xtracing;				# xtracing			is from   src/lib/x-kit/xclient/src/stuff/xtracing.pkg
    #
    package top =  topwindow;				# topwindow			is from   src/lib/x-kit/widget/basic/topwindow.pkg
    package wg  =  widget;				# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wa  =  widget_attribute;			# widget_attribute		is from   src/lib/x-kit/widget/lib/widget-attribute.pkg
    package wy  =  widget_style;			# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    #
    package sz  =  size_preference_wrapper;		# size_preference_wrapper	is from   src/lib/x-kit/widget/wrapper/size-preference-wrapper.pkg
    #
    tracefile   =  "plaid-app.trace.log";
    trace	=  xtr::print_if  xtr::io_tracing;	# Conditionally write strings to tracing.log or whatever.
herein

    package plaid_app: Plaid_App {			# Plaid_App			is from   src/lib/x-kit/tut/plaid/plaid-app.api

	run_selfcheck =  REF FALSE;

	stipulate
	    selfcheck_tests_passed =  REF 0;
	    selfcheck_tests_failed =  REF 0;
	herein
	    fun test_passed () =  selfcheck_tests_passed :=  *selfcheck_tests_passed + 1;
	    fun test_failed () =  selfcheck_tests_failed :=  *selfcheck_tests_failed + 1;
	    #
	    fun assert bool    =  if bool   test_passed ();
				  else      test_failed ();
				  fi;				
	    #
	    fun test_stats  ()
		=
                { passed => *selfcheck_tests_passed,
                  failed => *selfcheck_tests_failed
                };
	end;

	empty_box
	    =
	    xg::BOX
	      { col  => 0,
		row  => 0,
		wide => 0,
		high => 0
	      };


	# Center given box on given point:
	#
	fun center_box
            ( xg::BOX   { wide, high, ... },
              xg::POINT { col, row }
            )
	    = 
	    xg::BOX
	      { wide,
		high,
		col => col - (wide / 2),
		row => row - (high / 2)
	      };


	fun make_plaid_widgettree  root_window
	    =
	    {   bounds = wg::make_tight_size_preference (300, 200);

		sz::make_loose_size_preference_wrapper
		    (wg::make_widget
		      {
			root_window,
			size_preference_thunk_of =>  .{ bounds; },
			args                     =>  .{ { background => NULL }; },
			realize                  => realize_plaid
		      }
		    );
	    }
	    where
		screen = wg::screen_of root_window;
trace .{ "make_plaid_widgettree/AAA..."; };

		pen = xd::make_pen [
                                     xd::FOREGROUND (xc::rgb8_from_int 0xFF0000),	# Was xc::rgb8_color1
				     xd::FUNCTION   xd::OP_XOR
				   ];
trace .{ "make_plaid_widgettree/BBB..."; };
		idle_pen = pen;

trace .{ "make_plaid_widgettree/CCC..."; };
		timeout' =  timeout_in' (time::from_milliseconds 25);

		fun realize_plaid { window, size, kidplug }
		    =
		    {   make_thread "plaid" .{ do_active size;  };
			();
		    }
		    where
trace .{ "realize_plaid/AAA..."; };
			drawwin     = xd::drawable_of_window  window;

trace .{ "realize_plaid/BBB..."; };
			autodrawwin = xd::make_unbuffered_drawable  drawwin;

trace .{ "realize_plaid/CCC..."; };
			idle_fill = xd::fill_boxes drawwin     idle_pen;
trace .{ "realize_plaid/DDD..."; };
			fill      = xd::fill_boxes autodrawwin idle_pen;

trace .{ "realize_plaid/EEE..."; };
			(xi::ignore_keyboard  kidplug)
			    ->
			    xi::KIDPLUG { from_mouse', from_other', ... };

trace .{ "realize_plaid/FFF..."; };
			fun do_active (size as xg::SIZE { wide, high } )
			    =
			    start_over ()
			    where
trace .{ "do_active/AAA..."; };
				my middle as (xg::POINT { col=>midx, row=>midy } )
				    = 
				    xg::box::middle (xg::box::make (xg::point::zero, size));


trace .{ "do_active/BBB..."; };
				# Given a point (x,y) with a velocity (dx,dy),
				# make it bounce off walls to stay within
				#    0 < x < wide
				#    0 < y < high
				# by appropriately adjusting point and velocity
				# whenever it strays outside that area:	
				#
				fun bounce_if_outside_box
                                    (arg as ( xg::POINT { col=>x,  row=>y },		# Position.
					      xg::POINT { col=>dx, row=>dy }		# Velocity.
				    )       )
				    =
				    if   (x < 0)     bounce_if_outside_box (xg::POINT { col=> -x,             row=>  y             }, xg::POINT { col=> -dx, row=>  dy } );
				    elif (x >= wide) bounce_if_outside_box (xg::POINT { col=> 2*wide - x - 2, row=>  y             }, xg::POINT { col=> -dx, row=>  dy } );
				    elif (y < 0)     bounce_if_outside_box (xg::POINT { col=> x,              row=> -y             }, xg::POINT { col=>  dx, row=> -dy } );
				    elif (y >= high) bounce_if_outside_box (xg::POINT { col=> x,              row=> 2*high - y - 2 }, xg::POINT { col=>  dx, row=> -dy } );
				    else arg;
				    fi;


				# Step point by one velocity increment,
				# bouncing off any wall(s) encountered:
				#
				fun step_point (point, velocity)
				    =
				    {   point = xg::point::add (point, velocity);		# Move point one increment.
					#
					my (point, velocity)
					    =
					    bounce_if_outside_box (point, velocity);

					(point, velocity);
				    };
		
				# Step point, bouncing off walls,
				# and on odd cycles draw to display:
				#
				fun step_state { point, velocity, last_box, odd_cycle }
				    =
				    {   # Move the point per velocity,
					# bouncing off walls appropriately:
					#	
trace .{ "step_state/AAA..."; };
					(step_point (point, velocity))
					    ->
					    ( point  as  xg::POINT { col, row },
                                              velocity
                                            );
					    

trace .{ "step_state/BBB..."; };
					# Map 'point' into the fourth quadrant, then
					# define a box with that as one corner and
					# (0,0) as the other:
					#
					box = xg::BOX
						 { col  => 0,
						   row  => 0,
						   #
						   wide => 2 * abs(col - midx),
						   high => 2 * abs(row - midy)
						 };

trace .{ "step_state/CCC..."; };

					# Center above box on middle of drawing_window:
					#
					box = center_box (box, middle);

trace .{ "step_state/DDD..."; };
					if odd_cycle
					    #
					    fill (xg::box::xor (box, last_box));
					fi;

trace .{ "step_state/EEE..."; };
					{ point,
                                          velocity,
                                          last_box  =>  box,
                                          odd_cycle =>  not odd_cycle
                                        };
				    };


				fun do_mom (xi::ETC_REDRAW _)                              =>  start_over ();
				    do_mom (xi::ETC_RESIZE (xg::BOX { wide, high, ... } )) =>  do_active (xg::SIZE { wide, high } );
do_mom xi::ETC_OWN_DEATH => { print "do_active: do_mom: ETC_OWN_DEATH ignored\n"; (); };
				    do_mom _					           =>  ();
				end

				also
				fun active_loop state
				    = 
				    select [    timeout'     ==>  .{  active_loop (step_state state);  },
						from_other'  ==>  do_mom o xi::envelope_contents,
						from_mouse'  ==>  (fn mail =  case (xi::envelope_contents  mail)
										  #
										  xi::MOUSE_FIRST_DOWN _ =>  do_idle      size;
										  _                      =>  active_loop  state;
									      esac
								  )
				    ]

				also
				fun start_over ()
				    =
				    {
trace .{ "start_over/AAA..."; };
					xd::clear_drawable  drawwin;

trace .{ "start_over/BBB..."; };
					active_loop
					  {
					    point     =>  middle,
					    last_box  =>  empty_box,
					    odd_cycle =>  FALSE,
					    velocity  =>  xg::POINT { col=>1, row=>1 }
					  };
				    };
			    end			# fun do_active

			also
			fun do_idle (size as xg::SIZE { wide, high } )
			    =
			    idle_loop ()
			    where

				fun redraw ()
				    =
				    {
trace .{ "do_idle: redraw/AAA..."; };
					xd::clear_drawable  drawwin;
					redraw_loop 1;
				    }
				    where	
trace .{ "do_idle: redraw/BBB..."; };
					bound = int::min (wide, high) / 2;
trace .{ "do_idle: redraw/CCC..."; };

					fun redraw_loop i
					    = 
					    if (i <= bound)
						#
trace .{ "do_idle: redraw_loop/AAA..."; };
						idle_fill
						  [
						    xg::BOX { col=>i,            row=>i,            wide=>1,          high=>high-(2*i) },
						    xg::BOX { col=>wide - i - 1, row=>i,            wide=>1,          high=>high-(2*i) },
						    xg::BOX { col=>i,            row=>i,            wide=>wide-(2*i), high=>1 },
						    xg::BOX { col=>i,            row=>high - i - 1, wide=>wide-(2*i), high=>1 }
						  ];

trace .{ "do_idle: redraw_loop/BBB..."; };
						redraw_loop (i+2);
					    fi;

				    end;


				fun do_mom (xi::ETC_REDRAW _)                              =>  redraw ();
				    do_mom (xi::ETC_RESIZE (xg::BOX { wide, high, ... } )) =>  do_idle (xg::SIZE { wide, high } );
do_mom xi::ETC_OWN_DEATH => { print "do_idle: do_mom: ETC_OWN_DEATH ignored\n"; (); };
				    do_mom _						   =>  ();
				end;


				fun idle_loop ()
				    = 
				    select [ from_other' ==>  idle_loop  o  do_mom  o  xi::envelope_contents,
					     #
					     from_mouse' ==>  (fn envelope = case (xi::envelope_contents  envelope)
										  #
										  xi::MOUSE_FIRST_DOWN _ =>  do_active size;
										  _                      =>  idle_loop ();
									      esac

							      )

				    ];
			    end;					# fun do_idle
		    end;						# fun realize_plaid
	    end;							# fun make_plaid_widgettree


	# Thread to exercise the app by simulating user
	# mouseclicks and verifying their effects:
	#
	fun make_selfcheck_thread  { topwindow, widgettree }
	    =
	    xtr::make_thread "plaid-app selfcheck" selfcheck
	    where
	        fun selfcheck ()
		    =
		    {   # Wait until the widgettree is realized and running:
			# 
print "plaid-app: make_selfcheck_thread: Waiting for gui startup to complete...\n";
trace .{ "plaid-app: make_selfcheck_thread: Waiting for gui startup to complete...\n"; };
			get (wg::get_''gui_startup_complete''_oneshot_of  widgettree);
			test_passed ();
print "plaid-app: make_selfcheck_thread: Gui startup now complete.\n";
trace .{ "plaid-app: make_selfcheck_thread: Gui startup now complete.\n"; };


			# All done -- shut everything down:
			#
			(xw::xsession_of_window  (wg::window_of widgettree)) ->  xsession;
			xc::close_xsession  xsession;
			shut_down_thread_scheduler  winix::process::success;
		    };



#	        fun get_''seen_first_expose''_oneshot
#			window
#		    =
#		    case (xw::get_''seen_first_expose''_oneshot_of  window)
#			#
#			THE oneshot =>  oneshot;
#			NULL        =>  get_''seen_first_expose''_oneshot window;		# Cannot actually happen.
#		    esac;
#
#		fun selfcheck ()
#		    =
#		    {   wait_until_gui_is_stable       { drawing_window };
#		       (check_drawing_window_triangle_draw { })                              -> { antedraw_midwindow_image };
#			check_reset_button_operation       { antedraw_midwindow_image };
#			check_exit_button_operation { };
#		    }
#		    where
#			# Wait for drawing window to
#			# get its first EXPOSE x event:
#			#
#			fun wait_for_first_drawing_window_expose ()
#			    =
#			    {
#				# Normally we would use the
#				#
#				#     seen_first_redraw_oneshot_of
#				#
#				# from 
#				#
#				#     src/lib/x-kit/widget/basic/widget.api
#				#
#				# but the logic here doesn't use the widget
#				# support (I'm guessing this app predates
#				# the widget layer) so we have to use the
#				# following call instead:
#				#
#				# 
#				seen_first_drawing_window_expose_oneshot
#				    =
#				    get_''seen_first_expose''_oneshot
#					#
#					drawing_window;
#
#				get  seen_first_drawing_window_expose_oneshot;
#			    };
#
#			# Figure midpoint of window and also
#			# a small box centered on the midpoint:
#			#
#			fun midwindow window
#			    =
#			    {
#				# Get size of drawing window:
#				#
#				(xw::get_window_site  window)
#				    ->
#				    xg::BOX { row, col, high, wide };
#
#				# Define midpoint of drawing window,
#				# and a 9x9 box enclosing it:
#				#
#				stipulate
#				    row =  high / 2;
#				    col =  wide / 2;
#				herein
#				    midpoint =  xg::POINT { row, col };
#				    midbox   =  xg::BOX { row => row - 4, col => col - 4, high => 9, wide => 9 };
#				end;
#
#				(midpoint, midbox);
#			    };
#
#			# We do not want to start running the
#			# selfcheck code until the application
#			# is ready to respond:
#			#
#			fun wait_until_gui_is_stable { drawing_window }
#			    =
#			    {
# seen_first_redraw_oneshot_of
#				# First order of business is to wait
#				# until things are up and running.
#				#
#				# This may actually not be needed now
#				# that we wait on
#				#     done_first_drawing_window_redraw
#				# in below logic, but exercising the
#				# facility is useful anyhow:
#				#
#				wait_for_first_drawing_window_expose ();
#
#
#
#			    };	
#
#			fun check_drawing_window_triangle_draw { }
#			    =
#			    {
#				(midwindow      drawing_window) ->  (     drawing_window_midpoint, drawing_window_midbox);
#				(midwindow  exit_button_window) ->  ( exit_button_window_midpoint,  _                   );
#				(midwindow reset_button_window) ->  (reset_button_window_midpoint,  _                   );
#
#				# Fetch from X server the mid-window pixels
#				# over which we are about to draw a triangle.
#				# These should be all all background color (black)
#				# at the moment:
#				#
#				antedraw_midwindow_image  =  xc::make_clientside_pixmap_from_window (drawing_window_midbox, drawing_window);
#
#				# Do it again, verify that they compare equal:			
#				#
#				{   antedraw_midwindow_image2 =  xc::make_clientside_pixmap_from_window (drawing_window_midbox, drawing_window);
#				    #
#				    assert (xc::same_cs_pixmap (antedraw_midwindow_image, antedraw_midwindow_image2));
#				};
#
#				# Set up a hook to detect when
#				#
#				#     add_triangle ()
#				#
#				# runs.  To avoid race conditions, we must
#				# do this BEFORE sending the below simulated
#				# mouseclicks.  (I forgot this at first, and
#				# in fact got bitten.)
#				# 
#				triangle_list_slot =  make_mailslot ();
#				# 
#				add_triangle_watcher_slot :=  THE triangle_list_slot;
#
#				# Simulate a mouseclick in center of drawing window:
#				#
#				xw::send_mousebutton_press_xevent
#				  { window =>  drawing_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  drawing_window_midpoint
#				  };
#				#
#				xw::send_mousebutton_release_xevent
#				  { window =>  drawing_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  drawing_window_midpoint
#				  };
#
#				# 
#				select [
#				    take' triangle_list_slot ==>  check_triangle_list1,
#				    timeout'                 ==>  do_timeout1
#				]
#				where
#				    timeout' =   timeout_in' (time::from_milliseconds 5000);
#
#				    fun check_triangle_list1  [ point ]
#					    =>
#					    {
#						assert (xg::point::eq (point, drawing_window_midpoint));
#
#						add_triangle_watcher_slot :=  NULL;
#					    };
#
#					check_triangle_list1  []
#					    =>
#					    {   test_failed ();
#
#						add_triangle_watcher_slot :=  NULL;
#					    };
#
#					check_triangle_list1  triangles
#					    =>
#					    {   test_failed ();
#
#						add_triangle_watcher_slot :=  NULL;
#					    };
#				    end;
#
#				    fun do_timeout1 ()
#					=
#					{   test_failed ();
#
#					    add_triangle_watcher_slot :=  NULL;
#					};	
#				end;
#
#
#				# Fetch from X server the mid-window pixels
#				# over which we should have drawn a triangle.
#				#
#				# Verify that they differ from our original
#				# all-black image of the same area:
#				#
#				{   postdraw_midwindow_image =  xc::make_clientside_pixmap_from_window (drawing_window_midbox, drawing_window);
#				    #	
#				    assert (not (xc::same_cs_pixmap (antedraw_midwindow_image, postdraw_midwindow_image)));
#				};
#
#				{ antedraw_midwindow_image };
#			    };
#
#			fun check_reset_button_operation { antedraw_midwindow_image }
#			    =
#			    {
#				(midwindow      drawing_window) ->  (     drawing_window_midpoint, drawing_window_midbox);
#				(midwindow  exit_button_window) ->  ( exit_button_window_midpoint,  _                   );
#				(midwindow reset_button_window) ->  (reset_button_window_midpoint,  _                   );
#
#				# Set up a hook to detect when drawing_window_imp
#				#
#				#     do_reset ()
#				#
#				# runs.  To avoid race conditions, we must
#				# do this BEFORE sending the below simulated
#				# mouseclicks.  (I forgot this at first, and
#				# in fact got bitten.)
#				# 
#				drawing_window_''do_reset''_slot =  make_mailslot ();
#				# 
#				drawing_window_''do_reset''_watcher_slot :=  THE drawing_window_''do_reset''_slot;
#
#
#				# Simulate a mouseclick in center of reset button:
#				#
#				xw::send_mousebutton_press_xevent
#				  { window =>  reset_button_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  reset_button_window_midpoint
#				  };
#				#
#				xw::send_mousebutton_release_xevent
#				  { window =>  reset_button_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  reset_button_window_midpoint
#				  };
#
#				# 
#				select [
#				    take' drawing_window_''do_reset''_slot ==>  check_reset,
#				    timeout'                               ==>  do_timeout2
#				]
#				where
#				    timeout' =   timeout_in' (time::from_milliseconds 5000);
#
#				    fun check_reset ()
#					=
#					{   drawing_window_''do_reset''_watcher_slot :=  NULL;
#
#					    test_passed ();
#					};
#
#				    fun do_timeout2 ()
#					=
#					{   drawing_window_''do_reset''_watcher_slot :=  NULL;
#
#					    test_failed ();
#					};	
#				end;
#
#
#				# Fetch from X server the mid-window pixels
#				# over which we drew the triangle.
#				#
#				# Verify that they match our original
#				# all-black image of the same area:
#				#
#				{   postreset_midwindow_image =  xc::make_clientside_pixmap_from_window (drawing_window_midbox, drawing_window);
#				    #	
#				    assert (xc::same_cs_pixmap (antedraw_midwindow_image, postreset_midwindow_image));
#				};
#			    };
#
#			fun check_exit_button_operation { }
#			    =
#			    {
#				(midwindow  exit_button_window) ->  ( exit_button_window_midpoint,  _                   );
#
#				# Simulate a mouseclick in center of exit button:
#				#
#				xw::send_mousebutton_press_xevent
#				  { window =>  exit_button_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  exit_button_window_midpoint
#				  };
#				#
#				xw::send_mousebutton_release_xevent
#				  { window =>  exit_button_window,
#				    button =>  xi::MOUSEBUTTON 1,
#				    point  =>  exit_button_window_midpoint
#				  };
#
#				# Give the exit button time to fire.
#				# It should shut down all threads, so
#				# we should never make it past this sleep:
#				#
#				sleep_for (time::from_milliseconds 5000);
#
#				# The exit button didn't shut us down:
#				# register a bug:
#				#
#				test_failed ();
#
#				(test_stats ()) ->  { passed, failed };
#
#				# Go ahead and do the shutdown
#				# that the EXIT button should have done:
#				#
#				xc::close_xsession  xsession;
#				shut_down_thread_scheduler  winix::process::success;
#			    }; 	
#
#		    end;					# fun selfcheck
#

	    end;						# fun make_selfcheck_thread

	fun plaid_app root_window
	    =
	    {   name = wy::make_view
			 { name    =>   wy::style_name [],
			   aliases => [ wy::style_name [] ]
			 };

		style = wg::style_from_strings (root_window, []);

		view = (name, style);

		widgettree =  make_plaid_widgettree  root_window;

		args = [ (wa::title,     wa::STRING_VAL "Plaid"),
			 (wa::icon_name, wa::STRING_VAL "Plaid")
		       ];

		topwindow
		    =
		    top::topwindow  (root_window, view, args)  widgettree;

		top::start  topwindow;

		close_window' =  top::get_''close_window''_mailop  topwindow;

		make_thread "window closer" .{
		    #
		    select [
			close_window'
			    ==>
			   .{
				topwindow::destroy  topwindow;
				shut_down_thread_scheduler  winix::process::success;
			    }
		    ];	
		};

		if *run_selfcheck
		    #
		    make_selfcheck_thread  { topwindow, widgettree };
		    ();
		fi;

		();
	    };

	fun set_up_tracing ()
	    =
	    {   # Open tracelog file and
		# select tracing level:
		#
		include tracing;				# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg
		#
		log_trace_messages  (TO_FILE tracefile);
		enable all_tracing;				# Gross overkill.
	    };

	fun do_it' (debug_flags, server)
	    =
	    {   xtracing::init debug_flags;

		set_up_tracing ();

		rx::run_xkit'
		    #
		    plaid_app
		    #
		    { display => (server == "" ?? NULL :: THE server),
		      time_quantum_in_milliseconds => NULL
		    };
	    };


	fun do_it ()
	    =
	    {   set_up_tracing ();
		#
		rx::run_xkit  plaid_app;
	    };


	fun selfcheck ()
	    =
	    {   run_selfcheck :=  TRUE;
		do_it' ([], "");
		test_stats ();
	    };	


	fun main (program ! server ! _, _)
		=>
		do_it' ([], server);

	    main _
		=>
		do_it ();
	end;
    };				# package plaid
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1991, 1995 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
