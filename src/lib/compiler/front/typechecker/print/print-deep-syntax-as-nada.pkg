## print-deep-syntax-as-nada.pkg 

# Compiled by:
#     src/lib/compiler/front/typechecker/typecheck.make6



api Print_Deep_Syntax_As_Lib7 {

     print_pattern_as_nada:   symbol_table::Symbol_Table
                           -> prettyprint::Stream 
		           -> (deep_syntax::Case_Pattern,
                              Int)
                           -> Void;

     print_expression_as_nada:   (symbol_table::Symbol_Table,
                                 Null_Or( source_code_source::Input_Source ))
		              -> prettyprint::Stream
                              -> (deep_syntax::Deep_Expression,
                                 Int)
                              -> Void;

     print_rule_as_nada:  (symbol_table::Symbol_Table,
                          Null_Or( source_code_source::Input_Source ))
		       -> prettyprint::Stream
                       -> (deep_syntax::Case_Rule,
                          Int)
                       -> Void;

     print_named_value_as_nada:  (symbol_table::Symbol_Table,
                                  Null_Or( source_code_source::Input_Source ))
                               -> prettyprint::Stream
                               -> (deep_syntax::Named_Value,
                                  Int)
                               -> Void;

     print_recursively_named_value_as_nada:  (symbol_table::Symbol_Table,
                                           Null_Or( source_code_source::Input_Source ))
		                        -> prettyprint::Stream
                                        -> (deep_syntax::Named_Recursive_Values,
                                           Int)
                                        -> Void;

     print_declaration_as_nada:   (symbol_table::Symbol_Table,
                                  Null_Or( source_code_source::Input_Source ))
		               -> prettyprint::Stream
                               -> (deep_syntax::Declaration,
                                  Int)
                               -> Void;

     print_strexp_as_nada:  (symbol_table::Symbol_Table,
                            Null_Or( source_code_source::Input_Source ))
		         -> prettyprint::Stream
                         -> (deep_syntax::Package_Expression,
                            Int)
                         -> Void;

     lineprint:  Ref(  Bool );

     debugging:  Ref(  Bool );

}; #  Api Print_Deep_Syntax_As_Lib7 


package print_deep_syntax_as_nada: (weak) Print_Deep_Syntax_As_Lib7 {

    stipulate

        package em = error_message;		# error_message		is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
	package m  = module;			# module		is from   src/lib/compiler/front/typecheck-stuff/modules/module.pkg
	package b  = symbol_table_entry;	# symbol_table_entry	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package s  = symbol;			# symbol		is from   src/lib/compiler/front/basics/mlcomp/symbol.pkg
	package pp = prettyprint;		# prettyprint		is from   src/lib/prettyprint/src/prettyprint.pkg

	include deep_syntax;
        include tuples;
        include fixity;
        include variables_and_constructors;
        include types;
        include prettyprint;
        include print_as_nada_stuff;
        include print_type_as_nada;
        include print_value_as_nada;
    herein

	#  Debugging 
	say = control_print::say;
	debugging = REF FALSE;

	fun if_debugging_say (msg: String)
            =
	    if   *debugging      { say msg;   say "\n";};
                              else   ();fi;

	fun bug msg
            =
            error_message::impossible("print_deep_syntax_as_nada: " + msg);

	internals = typechecking_control::internals;

	lineprint = REF FALSE;

	fun by f x y
            =
            f y x;

	null_fix = INFIX (0, 0);
	inf_fix  = INFIX (1000000, 100000);

	fun stronger_l ( INFIX (_, m),
                         INFIX (n, _)
                       )
                =>
                m >= n;

	    stronger_l _
                =>
                FALSE;			#  should not matter 
        end;

	fun stronger_r ( INFIX (_, m),
                         INFIX (n, _)
                       )
                =>
                n > m;

	    stronger_r _
	        =>
                TRUE;			#  should not matter 
        end;

	fun prpos ( stream:  prettyprint::Stream,
		   source:  source_code_source::Input_Source,
                   charpos: Int
                 )
            =
	    if *lineprint

	         my (file: String, line: Int, pos: Int)
                     =
                     source_code_source::filepos  source  charpos;
	      
                 pp::string stream (int::to_string line);
		 pp::string stream ".";
		 pp::string stream (int::to_string pos);

	    else
                 pp::string stream (int::to_string charpos);
            fi;


	fun checkpat (n, NIL)
                =>
                TRUE;

	    checkpat (n, (symbol, _) ! fields)
		=> 
		s::eq (symbol, number_to_label n) and checkpat (n+1, fields);
        end;

	fun checkexp (n, NIL)
                =>
                TRUE;

 	    checkexp (n, (NUMBERED_LABEL { name=>symbol, ... }, _) ! fields)
		=> 
		s::eq (symbol, number_to_label n) and checkexp (n+1, fields);
        end;

	fun is_tuplepat (RECORD_PATTERN { fields => [_],                  ... } ) => FALSE;
	    is_tuplepat (RECORD_PATTERN { is_incomplete => FALSE, fields, ... } ) => checkpat (1, fields);
	    is_tuplepat _ => FALSE;
        end;

	fun is_tupleexp (RECORD_EXPRESSION [_]) => FALSE;
	    is_tupleexp (RECORD_EXPRESSION fields) => checkexp (1, fields);
	    is_tupleexp (SOURCE_CODE_REGION_FOR_EXPRESSION (a, _)) => is_tupleexp a;
	    is_tupleexp _ => FALSE;
        end;

	fun get_fix (dictionary, symbol)
            =
	    find_in_symbol_table::find_fixity_by_symbol
                (
                  dictionary,
                  s::make_fixity_symbol (s::name symbol)
                );

	fun strip_source_code_region_info (SOURCE_CODE_REGION_FOR_EXPRESSION (a, _))
                =>
                strip_source_code_region_info a;

	    strip_source_code_region_info x
                =>
                x;
        end;

	fun print_pattern_as_nada dictionary stream
            =
	    { ppsay = pp::string stream;

		fun print_pattern_as_nada' (_,                              0)   =>   ppsay "<pattern>";
		    print_pattern_as_nada' (VARIABLE_IN_PATTERN v,          _)   =>   print_var_as_nada stream v;
		    print_pattern_as_nada' (WILDCARD_PATTERN,               _)   =>   ppsay "_";
		    print_pattern_as_nada' (INT_CONSTANT_IN_PATTERN (i, t), _)   =>   ppsay (integer::to_string i);

	/*	     (begin_block stream INCONSISTENT 2;
		      ppsay "("; ppsay (integer::to_string i);
		      ppsay " :"; break stream { spaces=1, indent_on_wrap=1 };
		      prettyprint_type dictionary stream t; ppsay ")";
		      end_block stream) */

		    print_pattern_as_nada' (UNT_CONSTANT_IN_PATTERN (w, t), _) => ppsay (integer::to_string w);
	/*	     (open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 2);
		      ppsay "("; ppsay (integer::to_string w);
		      ppsay " :"; break stream { spaces=1, indent_on_wrap=1 };
		      print_type_as_nada dictionary stream t; ppsay ")";
		      end_box stream) */

		    print_pattern_as_nada' (FLOAT_CONSTANT_IN_PATTERN  r, _)   =>   ppsay r;
		    print_pattern_as_nada' (STRING_CONSTANT_IN_PATTERN s, _)   =>   print_lib7_string_as_nada stream s;
		    print_pattern_as_nada' (CHAR_CONSTANT_IN_PATTERN   s, _)   =>   { ppsay "#";   print_lib7_string_as_nada stream s;};

		    print_pattern_as_nada' (AS_PATTERN (v, p), d)
			=>
			{  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   print_pattern_as_nada'(v, d); ppsay " as "; print_pattern_as_nada'(p, d - 1);
			   end_box stream;
			};
				#  Handle 0 length case specially to avoid {, ... }: 

		    print_pattern_as_nada' (RECORD_PATTERN { fields => [], is_incomplete, ... }, _)
			=>
			if is_incomplete     ppsay "{... }";
		        else                 ppsay "()";
                        fi;

		    print_pattern_as_nada' (r as RECORD_PATTERN { fields, is_incomplete, ... }, d)
			=>
			if (is_tuplepat r)
			     print_closed_sequence_as_nada stream
			       { front=>(by pp::string "("),
				sep=>(fn stream => { pp::string stream ", ";
						   break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ),
				back=>(by pp::string ")"),
				pr=>(fn _ => fn (symbol, pattern) => print_pattern_as_nada'(pattern, d - 1); end; end ),
				style=>INCONSISTENT }
			       fields;
			else print_closed_sequence_as_nada stream
			       { front=>(by pp::string "{ "),
				sep=>(fn stream =  { pp::string stream ", ";
						     break stream { spaces=>0, indent_on_wrap=>0 };
                                                   }
                                      ),
				back=>(fn stream =  if is_incomplete  pp::string stream ", ... }";
						    else pp::string stream "}";
                                                    fi
                                      ),
				pr=>(fn stream = fn (symbol, pattern) =
				      { print_symbol_as_nada stream symbol; pp::string stream "=";
				        print_pattern_as_nada'(pattern, d - 1);
                                      }
                                    ),
				style=>INCONSISTENT }
			       fields;
                        fi;

		    print_pattern_as_nada' (VECTOR_PATTERN (NIL, _), d) => ppsay "#[]";

		    print_pattern_as_nada' (VECTOR_PATTERN (pats, _), d)
			=> 
			{   fun pr _ pattern = print_pattern_as_nada' (pattern, d - 1);

			    print_closed_sequence_as_nada stream
			      {   front => (by pp::string "#["),
				  sep   => (fn stream => { pp::string stream ", ";
						  break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ),
				  back  => (by pp::string "]"),
				  pr,
				  style => INCONSISTENT
			      }
			      pats;
			};

		    print_pattern_as_nada' (pattern as (OR_PATTERN _), d)
			=>
			{
			    fun make_list (OR_PATTERN (hd, tl)) => hd ! make_list tl;
			       make_list p => [p]; end;
			    fun pr _ pattern = print_pattern_as_nada'(pattern, d - 1);

			    print_closed_sequence_as_nada stream {
				front => (by pp::string "("),
				sep   => fn stream => { break stream { spaces=>1, indent_on_wrap=>0 };
						    pp::string stream "| ";}; end ,
				back  => (by pp::string ")"),
				pr,
				style => INCONSISTENT

			      } (make_list pattern);
			};

		    print_pattern_as_nada' (CONSTRUCTOR_PATTERN (e, _), _) => print_dcon_as_nada stream e;

		    print_pattern_as_nada' (p as APPLY_PATTERN _, d)
			=>
			print_dcon_pattern_as_nada (dictionary, stream) (p, null_fix, null_fix, d);

		    print_pattern_as_nada' (TYPE_CONSTRAINT_PATTERN (p, t), d)
			=>
			{ open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_pattern_as_nada'(p, d - 1); ppsay " :";
			  break stream { spaces=>1, indent_on_wrap=>2 };
			  print_type_as_nada dictionary stream t;
			  end_box stream;
			};

		    print_pattern_as_nada' _ => bug "print_pattern_as_nada'";
                end;
	    
                print_pattern_as_nada';
	    }

	also
	fun print_dcon_pattern_as_nada (dictionary, stream)
            = 
	    {   ppsay = pp::string stream;

		fun lpcond (atom) =   if atom    ppsay "(";   fi;
		fun rpcond (atom) =   if atom    ppsay ")";   fi;

		fun print_dcon_pattern_as_nada'(_, _, _, 0) => ppsay "<pattern>";

		   print_dcon_pattern_as_nada' (CONSTRUCTOR_PATTERN (ENUM_CONSTRUCTOR { symbol, ... }, _), l: Fixity, r: Fixity, _)
		       =>
		       print_symbol_as_nada  stream  symbol;

		   print_dcon_pattern_as_nada'(TYPE_CONSTRAINT_PATTERN (p, t), l, r, d)
		       =>
			{   open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppsay "("; print_pattern_as_nada dictionary stream (p, d - 1); ppsay " :";
			    break stream { spaces=>1, indent_on_wrap=>2 };
			    print_type_as_nada dictionary stream t; ppsay ")";
			    end_box stream;
                        };

		   print_dcon_pattern_as_nada'(AS_PATTERN (v, p), l, r, d)
		       =>
		       {   open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   ppsay "("; print_pattern_as_nada dictionary stream (v, d); break stream { spaces=>1, indent_on_wrap=>2 };
			   ppsay " as "; print_pattern_as_nada dictionary stream (p, d - 1); ppsay ")";
			   end_box stream;
                       };

		   print_dcon_pattern_as_nada' (APPLY_PATTERN (ENUM_CONSTRUCTOR { symbol, ... }, _, p), l, r, d)
		       =>
		       {   dname = s::name symbol; 

			   # Should really have original path, like for VARIABLE_IN_EXPRESSION 

			   this_fix = get_fix (dictionary, symbol);

			   eff_fix
                               =
                               case this_fix   
                                   NONFIX => inf_fix;
                                   x      => x;
                               esac;

			   atom = stronger_r (eff_fix, r) or stronger_l (l, eff_fix);

			   open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 2);
			   lpcond (atom);

			   case (this_fix, p)   

			       (INFIX _, RECORD_PATTERN { fields => [(_, pl), (_, pr)], ... } )
                                   =>
				   {   my (left, right)
                                           =
					   if atom  (null_fix, null_fix);
					   else (l, r);fi;
				       print_dcon_pattern_as_nada' (pl, left, this_fix, d - 1);
				       break stream { spaces=>1, indent_on_wrap=>0 };
				       ppsay dname;
				       break stream { spaces=>1, indent_on_wrap=>0 };
				       print_dcon_pattern_as_nada' (pr, this_fix, right, d - 1);
				   };

			       _ =>
				   {   ppsay dname;
                                       break stream { spaces=>1, indent_on_wrap=>0 };
				       print_dcon_pattern_as_nada'(p, inf_fix, inf_fix, d - 1);
                                   };
                           esac;

			   rpcond (atom);
			   end_box stream;
		       };

		   print_dcon_pattern_as_nada' (p, _, _, d) => print_pattern_as_nada dictionary stream (p, d); 
              end;

	    
                print_dcon_pattern_as_nada';
	    };

	fun trim [x] => [];
	    trim (a ! b) => a ! trim b;
	    trim [] => [];
        end;

	fun print_expression_as_nada (context as (dictionary, source_opt)) stream
            =
	    { ppsay = pp::string stream;

		fun lparen () = ppsay "(";
		fun rparen () = ppsay ")";

		fun lpcond (atom) = if atom  ppsay "("; fi;
		fun rpcond (atom) = if atom  ppsay ")"; fi;

		fun print_expression_as_nada' (_, _, 0) => ppsay "<expression>";

		    print_expression_as_nada' (VARIABLE_IN_EXPRESSION (REF var, _), _, _) => print_var_as_nada stream var;
		    print_expression_as_nada' (CONSTRUCTOR_EXPRESSION (con, _),    _, _) => print_dcon_as_nada stream con;
		    print_expression_as_nada' (   INT_CONSTANT_IN_EXPRESSION (i, t),     _, _) => ppsay (integer::to_string i);
		    print_expression_as_nada' (   UNT_CONSTANT_IN_EXPRESSION (w, t),     _, _) => ppsay (integer::to_string w);
		    print_expression_as_nada' ( FLOAT_CONSTANT_IN_EXPRESSION r,        _, _) => ppsay r;
		    print_expression_as_nada' (STRING_CONSTANT_IN_EXPRESSION s,      _, _) => print_lib7_string_as_nada stream s;
		    print_expression_as_nada' (CHAR_CONSTANT_IN_EXPRESSION s,        _, _) => { ppsay "#"; print_lib7_string_as_nada stream s;};

		    print_expression_as_nada' (r as RECORD_EXPRESSION fields, _, d)
			=>
			if   (is_tupleexp r)
			     print_closed_sequence_as_nada stream
			       { front=>(by pp::string "("),
				sep=>(fn stream => { pp::string stream ", ";
						   break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ),
				back=>(by pp::string ")"),
				pr=>(fn _ => fn (_, expression) => print_expression_as_nada'(expression, FALSE, d - 1); end; end ),
				style=>INCONSISTENT }
			       fields;
			else print_closed_sequence_as_nada stream
			       { front=>(by pp::string "{ "),
				sep=>(fn stream => { pp::string stream ", ";
						   break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ),
				back=>(by pp::string "}"),
				pr=>(fn stream => fn (NUMBERED_LABEL { name, ... }, expression) =>
				    { print_symbol_as_nada stream name; ppsay "=";
				     print_expression_as_nada'(expression, FALSE, d);}; end; end ),
				style=>INCONSISTENT }
			       fields;fi;

		    print_expression_as_nada' (RECORD_SELECTOR_EXPRESSION (NUMBERED_LABEL { name, ... }, expression), atom, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  lpcond (atom);
			  ppsay "#"; print_symbol_as_nada stream name;
			  print_expression_as_nada'(expression, TRUE, d - 1); ppsay ">";
			  rpcond (atom);
			 end_box stream;
                        };

		    print_expression_as_nada'(VECTOR_EXPRESSION (NIL, _), _, d) => ppsay "#[]";

		    print_expression_as_nada'(VECTOR_EXPRESSION (exps, _), _, d)
			=>
			{ fun pr _ expression = print_expression_as_nada'(expression, FALSE, d - 1);

			    print_closed_sequence_as_nada stream
			      {  front => (by pp::string "#["),
				 sep   => (fn stream => { pp::string stream ", ";
						  break stream { spaces=>1, indent_on_wrap=>0 } ;}; end ),
				 back  => (by pp::string "]"),
				 pr,
				 style => INCONSISTENT
			      }
			      exps;
			};

		    print_expression_as_nada'(PACK_EXPRESSION (e, t, tcs), atom, d)
			=> 
			if *internals

			    open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppsay "<PACK: "; print_expression_as_nada'(e, FALSE, d); ppsay "; ";
			    break stream { spaces=>1, indent_on_wrap=>2 };
			    print_type_as_nada dictionary stream t; ppsay ">";
			    end_box stream;
			else
			    print_expression_as_nada'(e, atom, d);
			fi;

		    print_expression_as_nada'(SEQUENTIAL_EXPRESSIONS exps, _, d)
			=>
			print_closed_sequence_as_nada stream
			  {   front => (by pp::string "("),
			      sep   => (fn stream => { pp::string stream ";";
					      break stream { spaces=>1, indent_on_wrap=>0 } ;}; end ),
			      back  => (by pp::string ")"),
			      pr    => (fn _ => fn expression => print_expression_as_nada'(expression, FALSE, d - 1); end; end ),
			      style => INCONSISTENT
			  }
			  exps;

		    print_expression_as_nada'(e as APPLY_EXPRESSION _, atom, d)
			=>
			{ infix0 = INFIX (0, 0);

			    lpcond (atom);
			    print_app_expression_as_nada (e, null_fix, null_fix, d);
			    rpcond (atom);
			};

		    print_expression_as_nada'(TYPE_CONSTRAINT_EXPRESSION (e, t), atom, d)
			=>
			 { open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   lpcond (atom);
			   print_expression_as_nada'(e, FALSE, d); ppsay ":";
			   break stream { spaces=>1, indent_on_wrap=>2 };
			   print_type_as_nada dictionary stream t;
			   rpcond (atom);
			   end_box stream;
                         };

		    print_expression_as_nada'(EXCEPT_EXPRESSION (expression, (rules, _)), atom, d)
			=>
			 { open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   lpcond (atom);
			   print_expression_as_nada'(expression, atom, d - 1); newline stream; ppsay "except ";
			   newline_indent stream 2;
			   ppvlist stream ("  ", "| ",
			      (fn stream => fn r => print_rule_as_nada context stream (r, d - 1); end; end ), rules);
			   rpcond (atom);
			  end_box stream;
                         };

		    print_expression_as_nada'(RAISE_EXPRESSION (expression, _), atom, d)
			=> 
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  lpcond (atom);
			  ppsay "raise exception "; print_expression_as_nada'(expression, TRUE, d - 1);
			  rpcond (atom);
			  end_box stream;
                        };

		    print_expression_as_nada'(LET_EXPRESSION (declaration, expression), _, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  ppsay "{ /*let*/ ";
			  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_declaration_as_nada context stream (declaration, d - 1); 
			  end_box stream;
			  break stream { spaces=>1, indent_on_wrap=>0 };
			  ppsay " /*in*/ ";
			  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada'(expression, FALSE, d - 1);
			  end_box stream;
			  break stream { spaces=>1, indent_on_wrap=>0 };
			  ppsay "} /*end of let*/";
			  end_box stream;
                        };

		    print_expression_as_nada'(CASE_EXPRESSION (expression, rules, _), _, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  ppsay "(given "; print_expression_as_nada'(expression, TRUE, d - 1); newline_indent stream 2;
			  ppvlist stream ("when ", "   when ",
			   (fn stream => fn r => print_rule_as_nada context stream (r, d - 1); end; end ), 
			    trim rules);
			  rparen();
			  end_box stream;
                        };

		    print_expression_as_nada' (IF_EXPRESSION { test_case, then_case, else_case }, atom, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			 lpcond (atom);
			 ppsay "if ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada' (test_case, FALSE, d - 1);
			 end_box stream;
			 break stream { spaces=>1, indent_on_wrap=> 0 };
			 ppsay "then ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada' (then_case, FALSE, d - 1);
			 end_box stream;
			 break stream { spaces=>1, indent_on_wrap=> 0 };
			 ppsay "else ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada' (else_case, FALSE, d - 1);
			 end_box stream;
			 rpcond (atom);
			 end_box stream;
			};

		    print_expression_as_nada' (AND_EXPRESSION (e1, e2), atom, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  lpcond (atom);
			  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada' (e1, TRUE, d - 1);
			  end_box stream;
			  break stream { spaces=>1, indent_on_wrap=> 0 };
			  ppsay "and ";
			  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada' (e2, TRUE, d - 1);
			  end_box stream;
			  rpcond (atom);
			  end_box stream;
                        };

		    print_expression_as_nada' (OR_EXPRESSION (e1, e2), atom, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			 lpcond (atom);
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			 print_expression_as_nada' (e1, TRUE, d - 1);
			 end_box stream;
			 break stream { spaces=>1, indent_on_wrap=> 0 };
			 ppsay "or ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			 print_expression_as_nada' (e2, TRUE, d - 1);
			 end_box stream;
			 rpcond (atom);
			 end_box stream;
                        };

		    print_expression_as_nada' (WHILE_EXPRESSION { test, expression }, atom, d)
			=>
			{ open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			 ppsay "while ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			  print_expression_as_nada'(test, FALSE, d - 1);
			 end_box stream;
			 break stream { spaces=>1, indent_on_wrap=> 0 };
			 ppsay "do ";
			 open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   print_expression_as_nada'(expression, FALSE, d - 1);
			 end_box stream;
			 end_box stream;
                        };

		    print_expression_as_nada'(FN_EXPRESSION (rules, _), _, d)
			=>
			{ begin_horizontal_else_vertical_box stream;
			 ppvlist stream ("(fn ", "  | ",
					 (fn stream => fn r =>
					    print_rule_as_nada context stream (r, d - 1); end;  end ),
					 trim rules);
			 rparen();
			 end_box stream;};

		    print_expression_as_nada' (SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (s, e)), atom, d)
			=>
			case source_opt

			     THE source
                               =>
			       if *internals
			             ppsay "<MARK(";
				     prpos (stream, source, s); ppsay ", ";
				     prpos (stream, source, e); ppsay "): ";
				     print_expression_as_nada'(expression, FALSE, d); ppsay ">";
			       else
                                     print_expression_as_nada'(expression, atom, d);
                               fi;

			    NULL => print_expression_as_nada'(expression, atom, d);
			esac;
                end 

		also
		fun print_app_expression_as_nada (_, _, _, 0)
                        =>
                        pp::string stream "<expression>";

		    print_app_expression_as_nada arg
			=>
			{   ppsay = pp::string stream;

			    fun fixitypp (name, operand, left_fix, right_fix, d)
				=
				{   dname = symbol_path::to_string (symbol_path::SYMBOL_PATH name);

				    this_fix = case name   
						 [id] =>   get_fix (dictionary, id);
						  _   =>   NONFIX;
					      esac;

				    fun pr_non expression
					=
					{ open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 2);
					 ppsay dname; break stream { spaces=>1, indent_on_wrap=>0 };
					 print_expression_as_nada'(expression, TRUE, d - 1);
					 end_box stream;};

				    case this_fix

					 INFIX _
					 =>
					 (case (strip_source_code_region_info operand)

					       RECORD_EXPRESSION [(_, pl), (_, pr)]
					       =>
						{   atom = stronger_l (left_fix, this_fix)  or
						           stronger_r (this_fix, right_fix);

						    my (left, right)
							=
							if atom  (null_fix,  null_fix);
							else     (left_fix, right_fix);
                                                        fi;

						    { open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 2);
						      lpcond (atom);
						      print_app_expression_as_nada (pl, left, this_fix, d - 1);
						      break stream { spaces=>1, indent_on_wrap=>0 };
						      ppsay dname;
						      break stream { spaces=>1, indent_on_wrap=>0 };
						      print_app_expression_as_nada (pr, this_fix, right, d - 1);
						      rpcond (atom);
						     end_box stream;};
						};

					      e' => pr_non e';
					  esac
					 );

					NONFIX => pr_non operand;
				    esac;
				};

			    fun apply_print (_, _, _, 0)
				    =>
				    ppsay "#";

				apply_print (APPLY_EXPRESSION (operator, operand), l, r, d)
				    =>
				    case (strip_source_code_region_info operator)

					 CONSTRUCTOR_EXPRESSION (ENUM_CONSTRUCTOR { symbol, ... }, _)
					     =>
					     fixitypp ([symbol], operand, l, r, d);

					 VARIABLE_IN_EXPRESSION (v, _)
					     =>
					     {   path = 
						     case *v
							  ORDINARY_VARIABLE { path=>symbol_path::SYMBOL_PATH p, ... } => p;
							  OVERLOADED_IDENTIFIER { name, ... } => [name];
							  errorvar => [s::make_value_symbol "<errorvar>"];
                                                     esac;

						 fixitypp (path, operand, l, r, d);
					     };

					 operator
					     =>
					     { open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 2);
					       print_expression_as_nada'(operator, TRUE, d - 1); break stream { spaces=>1, indent_on_wrap=>2 };
					       print_expression_as_nada'(operand,  TRUE, d - 1);
					       end_box stream;
					     };
				    esac;

			       apply_print (SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (s, e)), l, r, d)
				    =>
				    case source_opt

					 THE source
					     =>
					     if *internals

						   ppsay "<MARK(";
						   prpos (stream, source, s); ppsay ", ";
						   prpos (stream, source, e); ppsay "): ";
						   print_expression_as_nada'(expression, FALSE, d); ppsay ">";
					     else
						   apply_print (expression, l, r, d);
					     fi;

					 NULL => apply_print (expression, l, r, d);
				    esac;


			       apply_print (e, _, _, d) => print_expression_as_nada'(e, TRUE, d); end;

			    apply_print arg;
			};
                end;
	    
                (fn (expression, depth) =  print_expression_as_nada'(expression, FALSE, depth));
	    }

	also
	fun print_rule_as_nada (context as (dictionary, source_opt)) stream (CASE_RULE (pattern, expression), d)
            =
	    if   (d > 0)
	        
                  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
		  print_pattern_as_nada dictionary stream (pattern, d - 1);
		  pp::string stream " =>"; break stream { spaces=>1, indent_on_wrap=>2 };
		  print_expression_as_nada context stream (expression, d - 1);
		  end_box stream;
	    else
                  pp::string stream "<rule>";
            fi

	also
	fun print_named_value_as_nada (context as (dictionary, source_opt)) stream (NAMED_VALUE { pattern, expression, ... }, d)
            =
	    if   (d > 0)
	        
                  open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
		  print_pattern_as_nada dictionary stream (pattern, d - 1); pp::string stream " =";
		  break stream { spaces=>1, indent_on_wrap=>2 }; print_expression_as_nada context stream (expression, d - 1);
		  end_box stream;
	    else
                  pp::string stream "<naming>";
            fi

	also
	fun print_recursively_named_value_as_nada context stream (NAMED_RECURSIVE_VALUES { variable=>var, expression, ... }, d)
            = 
	    if   (d>0)
	        
                  open_style_box INCONSISTENT stream (pp::CURSOR_RELATIVE 0);
		  print_var_as_nada stream var; pp::string stream " =";
		  break stream { spaces=>1, indent_on_wrap=>2 }; print_expression_as_nada context stream (expression, d - 1);
		  end_box stream;
	    else
                  pp::string stream "<rec naming>";
            fi

	also
	fun print_declaration_as_nada (context as (dictionary, source_opt)) stream
            =
	    { ppsay = pp::string stream;

		fun print_declaration_as_nada'(_, 0) => ppsay "<declaration>";

		    print_declaration_as_nada'(VALUE_DECLARATIONS vbs, d)
                    =>
		    { open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);

		     ppvlist stream ("my ", "also ",
		       (fn stream => fn named_value => print_named_value_as_nada context stream (named_value, d - 1); end; end ), vbs);
		     end_box stream;};

		    print_declaration_as_nada'(RECURSIVE_VALUE_DECLARATIONS rvbs, d)
                    =>
		    { open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
		     ppvlist stream ("my rec ", "also ",
		       (fn stream => fn named_recursive_values => print_recursively_named_value_as_nada context stream (named_recursive_values, d - 1); end;  end ), rvbs);
		     end_box stream;};

		    print_declaration_as_nada'(TYPE_DECLARATIONS tycs, d)
                    =>
                    { fun f stream (DEFINED_TYPE_CONSTRUCTOR { path, type_scheme=>TYPE_SCHEME { arity, body }, ... } )
                            =>
			    {   case arity
				     0 => ();
				    1 => (ppsay "'a ");
				    n => { print_tuple_as_mythrl7 stream pp::string (type_formals n); 
					   ppsay " ";}; esac;

				print_symbol_as_nada stream (inverse_path::last path);

				ppsay " = ";
				print_type_as_nada dictionary stream body
                            ;};

			   f _ _ => bug "print_declaration_as_nada'(TYPE_DECLARATIONS)"; end;
		    
			open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			ppvlist stream ("type ", " also ", f, tycs);
			end_box stream;
		    };

		    print_declaration_as_nada' (ENUM_DECLARATIONS { datatype_constructors, with_type_constructors }, d)
                    =>
                    {   fun print_data_as_nada stream (PRIMITIVE_TYPE_CONSTRUCTOR { path, arity, kind, ... } )
				=>
				case kind
				      DATATYPE(_)
				      =>
				      {   case arity
					       0 => ();
					      1 => (ppsay "'a ");
					      n => { print_tuple_as_mythrl7 stream pp::string (type_formals n); 
						     ppsay " ";}; esac;

					   print_symbol_as_nada stream (inverse_path::last path); ppsay " = ..."
				      /* ;

					   print_sequence_as_nada
					       stream
					       {   sep = (fn stream => (pp::string stream " |";
							       break stream { spaces=1, indent_on_wrap=0 } )),

						   pr  = (fn stream =>
							  fn (ENUM_CONSTRUCTOR { symbol, ... } ) =>  
								print_symbol_as_nada  stream  symbol),

						   style = INCONSISTENT
					       }
					       dcons
				       */
				      ;};
				    _ => bug "print_declaration_as_nada'(ENUM_DECLARATIONS) 1.1";
				esac;

			    print_data_as_nada _ _
				=>
				bug "print_declaration_as_nada'(ENUM_DECLARATIONS) 1.2";
                        end;

			fun print_with_as_nada stream (DEFINED_TYPE_CONSTRUCTOR { path, type_scheme=>TYPE_SCHEME { arity, body }, ... } )
                            =>
			    {   case arity
				     0 => ();
				    1 => (ppsay "'a ");
				    n => { print_tuple_as_mythrl7 stream pp::string (type_formals n); 
					   ppsay " ";}; esac;

				print_symbol_as_nada stream (inverse_path::last path);

				ppsay " = ";

                                print_type_as_nada dictionary stream body
                            ;};

			   print_with_as_nada _ _
                            =>
                            bug "print_declaration_as_nada'(ENUM_DECLARATIONS) 2"; end;
		    
			#  Could call PPDec::print_declaration_as_nada here: 

			open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			ppvlist stream ("enum ", "also ", print_data_as_nada, datatype_constructors);
			newline stream;
			ppvlist stream ("withtype ", "also ", print_with_as_nada, with_type_constructors);
			end_box stream;
		    };

		   print_declaration_as_nada'(ABSTRACT_TYPE_DECLARATION _, d)
                    =>
                    ppsay "abstype";

		   print_declaration_as_nada'(EXCEPTION_DECLARATIONS ebs, d)
                    =>
                    { fun f stream (   NAMED_EXCEPTION {
                                             exception_constructor => ENUM_CONSTRUCTOR { symbol, ... },
                                             exception_type        => etype,
                                             ...
                                         }
                                     )
                            =>
			    {   print_symbol_as_nada  stream  symbol;

				case etype
				  
				    NULL => ();

				    THE type'
					 =>
					 {
#					     ppsay " of ";
					     ppsay " ";
					     print_type_as_nada dictionary stream type';
					 };
                                esac;
                            };

			   f stream (DUPLICATE_NAMED_EXCEPTION { exception_constructor  => ENUM_CONSTRUCTOR { symbol, ... },
					                          equal_to               => ENUM_CONSTRUCTOR { symbol=>symbol', ... }
                                                                }
                                     )
                            =>
			    {   print_symbol_as_nada stream symbol;
                                ppsay "=";
                                print_symbol_as_nada stream symbol';
                            };
                        end;
		    
			open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			ppvlist stream ("exception ", "also ", f, ebs);
			end_box stream;
		    };

		    print_declaration_as_nada'(PACKAGE_DECLARATIONS sbs, d)
                    =>
			{   fun f stream (NAMED_PACKAGE { name_symbol=>name, a_package=>m::A_PACKAGE { var_home, ... }, definition=>def } )
				    =>
				    {   print_symbol_as_nada stream name;
					print_var_home_as_nada stream var_home;
					ppsay " = ";
					break stream { spaces=>1, indent_on_wrap=>2 };
					print_strexp_as_nada context stream (def, d - 1);
				    };

			        f _ _
				    =>
				    bug "print_declaration_as_nada: PACKAGE_DECLARATION: NAMED_PACKAGE";
                            end;

			    open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppvlist stream ("package ", "also ", f, sbs);
			    end_box stream;
			};

		    print_declaration_as_nada'(GENERIC_DECLARATIONS fbs, d)
			=>
			{   fun f stream (NAMED_GENERIC { name_symbol => fname,
							  a_generic   => m::GENERIC { var_home, ... },
							  definition  => def
						        }
				       )
				=>
				{   print_symbol_as_nada stream fname;
				    print_var_home_as_nada stream var_home;
				    ppsay " = "; 
				    break stream { spaces=>1, indent_on_wrap=> 2 }; 
				    print_fctexp_as_nada context stream (def, d - 1)
				;};

			       f _ _
				=>
				bug "print_declaration_as_nada': GENERIC_DECLARATION"; end;

			    open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppvlist stream ("generic package ", "also ", f, fbs);
			    end_box stream;
			};

		   print_declaration_as_nada'(API_DECLARATIONS sigvars, d)
		       =>
		       {   fun f stream (m::API { name, ... } )
			       =>
			       {   ppsay "api "; 

				   case name
				        THE s => print_symbol_as_nada stream s;
				      NULL => ppsay "ANONYMOUS"; esac
			       ;};

			      f _ _
			       =>
			       bug "print_declaration_as_nada': API_DECLARATIONS"; end;

			   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);

			   print_sequence_as_nada
			       stream
			       {   sep   => newline,
				   pr    => f,
				   style => CONSISTENT
			       }
			       sigvars;

			   end_box stream;
		       };

		   print_declaration_as_nada'(GENERIC_API_DECLARATIONS sigvars, d)
		       =>
		       {   fun f stream (m::GENERIC_API { kind, ... } )
			       =>
			       {   ppsay "funsig "; 

				   case kind
				        THE s => print_symbol_as_nada stream s;
				       NULL => ppsay "ANONYMOUS"; esac
			       ;};

			      f _ _
			       =>
			       bug "print_declaration_as_nada': GENERIC_API_DECLARATIONS"; end;

			   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);

			   print_sequence_as_nada
			       stream
			       {   sep   => newline,
				   pr    => f,
				   style => CONSISTENT
			       }
			       sigvars;

			   end_box stream;
		       };

		   print_declaration_as_nada'(LOCAL_DECLARATIONS (inner, outer), d)
		       =>
		       {   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   ppsay "stipulate"; newline_indent stream 2;
			   print_declaration_as_nada'(inner, d - 1); newline stream;
			   ppsay "herein ";
			   print_declaration_as_nada'(outer, d - 1); newline stream;
			   ppsay "end";
			   end_box stream;
		       };

		   print_declaration_as_nada'(SEQUENTIAL_DECLARATIONS decs, d)
		       =>
		       {   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);

			   print_sequence_as_nada
			       stream
			       {   sep   => newline,
				   pr    => (fn stream => fn declaration => print_declaration_as_nada'(declaration, d); end;  end ),
				   style => CONSISTENT
			       }
			       decs;

			   end_box stream;
		       };

		   print_declaration_as_nada'(FIXITY_DECLARATION { fixity, ops }, d)
		       =>
		       {   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);

			   case fixity
                             
				NONFIX => ppsay "nonfix ";

				INFIX (i, _)
				    => 
				    {   if   (i % 2 == 0   )   ppsay "infix ";
							  else   ppsay "infixr ";   fi;

					if   (i / 2 > 0    )   ppsay (int::to_string (i / 2));
								 ppsay " ";
							  fi;
				    };
			   esac;

			   print_sequence_as_nada
			      stream
			      {   sep   => (fn stream =  break stream { spaces=>1, indent_on_wrap=>0 }),
				  pr    => print_symbol_as_nada,
				  style => INCONSISTENT
			      }
			      ops;

			   end_box stream;
		       };

		   print_declaration_as_nada'(OVERLOADED_VARIABLE_DECLARATION overloaded_variable, d)
		       =>
		       {   ppsay "overloaded val ";
			   print_var_as_nada  stream  overloaded_variable;
		       };

		   print_declaration_as_nada'(INCLUDE_DECLARATIONS named_packages, d)
		       =>
		       {   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			   ppsay "use ";
			   print_sequence_as_nada
			       stream
			       {   sep   => (fn stream =  break stream { spaces=>1, indent_on_wrap=>0 } ),
				   pr    => (fn stream =  fn (sp, _) =  ppsay (symbol_path::to_string sp)),
				   style => INCONSISTENT
			       }
			       named_packages;

			   end_box stream;
		       };

		   print_declaration_as_nada'(SOURCE_CODE_REGION_FOR_DECLARATION (declaration, (s, e)), d)
                    => 
		        case source_opt   

			    THE source
				=>
				{   ppsay "SOURCE_CODE_REGION_FOR_DECLARATION(";
				    print_declaration_as_nada'(declaration, d); ppsay ", ";
				    prpos (stream, source, s); ppsay ", ";
				    prpos (stream, source, e); ppsay ")";
				};

			    NULL => print_declaration_as_nada'(declaration, d);
                         esac;
                 end;

	      
                  print_declaration_as_nada';
	      }

	also
	fun print_strexp_as_nada (context as (_, source_opt)) stream
            =
	    {   ppsay   =   pp::string stream;

		fun print_strexp_as_nada'(_, 0)
			=>
			ppsay "<package_expression>";

		    print_strexp_as_nada'(PACKAGE_BY_NAME (m::A_PACKAGE { var_home, ... } ), d)
			=>
			print_var_home_as_nada stream var_home;

		    print_strexp_as_nada' (
                        COMPUTED_PACKAGE {
                            a_generic        => m::GENERIC   { var_home => fa, ... },
			    generic_argument => m::A_PACKAGE { var_home => sa, ... },
                            ...
                        },
                        d
                    )
			=>
			{   print_var_home_as_nada stream fa;
			    ppsay"(";
			    print_var_home_as_nada stream sa;
			    ppsay")";
			};

		    print_strexp_as_nada'(PACKAGE_DEFINITION namings, d)
			=>
			{   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppsay "pkg"; newline_indent stream 2;
			    ppsay "...";
			    #  printNamingAsNada not yet undefined 
			    /*
			       print_sequence_as_nada stream
				 { sep=newline,
				  pr=(fn stream => fn b => printNamingAsNada context stream (b, d - 1)),
				  style=CONSISTENT }
			       namings;
			     */
			    ppsay "end";
			    end_box stream;
			};

		    print_strexp_as_nada'(PACKAGE_LET { declaration, expression }, d)
			=>
			{   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppsay "stipulate "; print_declaration_as_nada context stream (declaration, d - 1); 
			    newline stream;
			    ppsay " herein "; print_strexp_as_nada'(expression, d - 1); newline stream;
			    ppsay "end";
			    end_box stream;
			};

		    print_strexp_as_nada'(SOURCE_CODE_REGION_FOR_PACKAGE (body, (s, e)), d)
			=>
			case source_opt

			         THE source
				 =>
				 {   ppsay "SOURCE_CODE_REGION_FOR_PACKAGE(";
				     print_strexp_as_nada'(body, d);   ppsay ", ";
				     prpos (stream, source, s);       ppsay ", ";
				     prpos (stream, source, e);       ppsay ")"
				 ;};

				NULL
				 =>
				 print_strexp_as_nada'(body, d);
                          esac;

		    print_strexp_as_nada' _
			=>
			bug "unexpected package expression in print_strexp_as_nada'";
                end;

	    
                print_strexp_as_nada';
	    }

	also
	fun print_fctexp_as_nada (context as (_, source_opt)) stream
            = 
	    {   ppsay   =   pp::string stream;

		fun print_fctexp_as_nada'(_, 0)
			=>
			ppsay "<generic_expression>";

		    print_fctexp_as_nada'(GENERIC_BY_NAME (m::GENERIC { var_home, ... } ), d)
			=>
			print_var_home_as_nada stream var_home;

		    print_fctexp_as_nada'(GENERIC_DEFINITION { parameter=>m::A_PACKAGE { var_home, ... }, definition=>def, ... }, d)
			=>
			{   ppsay " GENERIC("; 
			    print_var_home_as_nada  stream  var_home;
			    ppsay ") => "; newline stream;
			    print_strexp_as_nada context stream (def, d - 1);
			};

		    print_fctexp_as_nada'(GENERIC_LET (declaration, body), d)
			=>
			{   open_style_box CONSISTENT stream (pp::CURSOR_RELATIVE 0);
			    ppsay "stipulate "; print_declaration_as_nada context stream (declaration, d - 1); 
			    newline stream;
			    ppsay " herein "; print_fctexp_as_nada'(body, d - 1); newline stream;
			    ppsay "end";
			    end_box stream;
			};

		    print_fctexp_as_nada'(SOURCE_CODE_REGION_FOR_GENERIC (body, (s, e)), d)
			=>
			case source_opt
			  
			     THE source
				 =>
				 {   ppsay "SOURCE_CODE_REGION_FOR_GENERIC(";
				     print_fctexp_as_nada'(body, d); ppsay ", ";
				     prpos (stream, source, s); ppsay ", ";
				     prpos (stream, source, e); ppsay ")";
				 };

			     NULL
				 =>
				 print_fctexp_as_nada'(body, d);
			esac;

		    print_fctexp_as_nada' _
			=>
			bug "unexpected generic package expression in print_fctexp_as_nada'";
                end;

	    
                print_fctexp_as_nada';
	    };
    end;	#  top-level local 
};		#  package print_deep_syntax_as_nada


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1992 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
