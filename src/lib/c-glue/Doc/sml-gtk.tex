\documentclass{article}
    \usepackage{sml}
    \usepackage{alltt}
    \usepackage{html}
    \newcommand{\gtk}{\mbox{\sf Gtk+}}
    \newcommand{\smlgtk}{\mbox{\sf SML-Gtk}}
    \begin{latexonly}
    \smlTypeVar{a}{\(\alpha\)}
    \smlTypeVar{b}{\(\beta\)}
    \smlTypeVar{gadget}{\($gadget\)}
    \end{latexonly}

    \input{macros}

    \title{\large \smlgtk: \gtk\ namings for \smlnj}

    \bibliographystyle{alpha}

\begin{document}

    \maketitle

\section{Introduction}
    \smlgtk\ is a set of namings to \gtk, the GIMP Toolkit,
for the \smlnj\ compiler. 
\smlgtk\ is developed using \mlnlffigen\cite{c-glue-maker}, 
Matthias Blume's ``no longer''
foreign function interface generator.
This note describes the organization of this library.  It does not,
however, teach you how to use \gtk\ to build applications.
For that, you can refer to \gtk's documentation from its web site
at \htmladdnormallink{http://www.gtk.org}{http://www.gtk.org}.

    For the purpose of this document, I'll assume that you are already
familiar with how to use \gtk, \mlnlffigen\ and its interface library
provided in the package \verb|C|\footnote{The
\mlnlffigen\ distribution contains a tutorial.}.

\section{The \smlgtk\ Library}

   The \smlgtk\ library is composed of the following main packages:
\begin{center}
  \begin{tabular}{|l|l|} \hline
   \tt Gtk          & High level ``object oriented'' 
                      ML types for \gtk\ widgets \\
   \tt GLibEnums    & Enums definitions matching the prefix {\tt G\_}  \\
   \tt gdk_enums     & Enums definitions matching the prefix {\tt GDK\_} \\
   \tt gtk_enums     & Enums definitions matching the prefix {\tt GTK\_} \\
   \tt gtk_macros    & Useful ``macro'' functions \\
   \tt GtkGadgets   & A slightly high level widget layer \\
  \hline
  \end{tabular}
\end{center}

Generally speaking, there are three levels of abstraction available:
\begin{description}
   \item[The \mlnlffigen\ interface]  
These are simply the raw functions and types generated by \mlnlffigen.
While they are usable in theory, they are quite difficult to work with
since the types are ``all wrong'' from a \gtk\ programmer's perspective.
This interface is not available by default.  However, if you must use it,
you can access it via the CM file \verb|gtk/gtk-ffi/gtk-ffi.cm|.
   \item[The ``widgets'' interface] 
These are functions with all the suitable type conversions applied.
In particular, an object oriented view of the \gtk\ widgets is provided
so that you can write SML programs without using 
any type conversion macros, as you would need to do if you program in C.
All the object inheritance constraints are encoded using phantom types in ML.
   \item[The ``gadgets'' interface] This is a simple 
abstraction layer over the widget stuff. 
It takes advantage of higher order functions and a liberal dose 
of currying to make writing \gtk\ programs more succinct.
We can mix gadgets and widgets code together.  For example,
with gadgets, we can create a menu bar with three 
items ``New'',``Open'', and ``Close'', bind them with 
\gtk's underline accelerators and control key accelerators, 
and register the appropriate callbacks, by just saying:
\begin{smldisp}
   @.menu_bar item_factory
   [ @.branch "/File" "",
       @.item "/File/_New" "<Ctrl>N" new_callback,
       @.item "/File/_Open" "<Ctrl>O" open_callback,
       @.item "/File/_Close" "<Ctrl>C" close_callback
   ]
\end{smldisp}
See Section~\REF{sec:gadgets} for more details.
\end{description}

\subsection{CM}

In order to use this library, you should put the following imports
into your CM file:

\begin{verbatim}
   C/c.cm                       #  c-glue-maker's C interface 
   $smlnj-ffilib/gtk/Gtk.cm      #  The core sml-gtk library 
   $smlnj-ffilib/gtk/Gadgets.cm  /* The gadgets extension */ 
\end{verbatim}

\subsection{Functions}

   A function named {\em foo} in C is mapped into a package of the same name 
in SML.\footnote{Note that we have stripped away the {\tt F\_} prefix
generated by \mlnlffigen.}  
Its definition is placed in the file {\tt gtk/FFI/f-{\em foo}.sml}.
Within the package {\em foo}, the following items are defined:
   \begin{description} 
    \item[\tt f] The function {\tt f} is the same function as 
         the function {\tt f'} generated by \mlnlffigen, but
         with various type conversion functions inserted.  This is 
         the function you should use in your programs.
         The kind of type conversions include:
        \begin{enumerate}
          \item conversions between C type \Sml{(uchar,rw) ptr'} to 
                ML type \Sml{String}.
          \item conversions between C ``boolean'' type to ML type \Sml{Bool}.
          \item changing C enums types into ML datatypes, when applicable.
          \item changing call by reference in C into call by value in ML.
         \end{enumerate}
    \item[\tt g] The function {\tt g} is the same function as {\tt f}
         but with labeled arguments added.  You may want to use this
         to make your programs more readable and maintainable, at a cost
         of more verbosity.
         When the original C function prototype does not supply a suitable name,
         or it is identical to {\tt f}, generation of this function is omitted.
    \item[\tt m, m'] These are ``messsage'' functions to help
out Gadgets programming.  Function \verb|m| does not use labeled arguments,
while \verb|m'| does.  I'll describe more about these later.
  \end{description}

   Here's an example.  The \gtk\ function \verb|gtk_container_add| adds
a widget to a container.  In C, its prototype is:
\begin{verbatim}
    void gtk_container_add (GtkContainer * container, GtkWidget * widget);
\end{verbatim}

   In ML, this is represented by the package \Sml{gtk_container_add}:
   \begin{smldisp}
   package gtk_container_add :
   sig
      my f  : X GtkContainer * Y GtkWidget -> Void
      my g  : \{container:X GtkContainer, widget:Y GtkWidget\} -> Void
      my m  : Y GtkWidget -> X GtkContainer -> Void
      my m' : Y GtkWidget -> X GtkContainer -> Void
   end
   \end{smldisp}

   Here is another example.  The \gtk\ function \verb|gtk_calendar_get_date|
has the following C prototype:
\begin{verbatim}
   void gtk_calendar_get_date
         (GtkCalendar *calendar, 
          guint       *year, 
          guint       *month, 
          guint       *day); 
\end{verbatim}

In ML it is:
\begin{smldisp}
   package gtk_calendar_get_date : 
   sig
      my f  : X GtkCalendar -> mlrep.Unsigned.word * 
                                 mlrep.Unsigned.word *
                                 mlrep.Unsigned.word 
      my g  : X GtkCalendar ->
                 \{ year  : mlrep.Unsigned.word,
                   month : mlrep.Unsigned.word,
                   day   : mlrep.Unsigned.word 
                 \}
   end
\end{smldisp}
Note that while the arguments \verb|year, month, day| are call-by-reference
in C, we automatically convert them into call-by-value in ML, making the
function much easier to use:

\subsection{Enums}
      An enum type {\tt foo} is translated into a type of the same
name in ML.  An enum value {\tt bar} is also translated into an ML
value of the same name, i.e., no \Sml{e_} prefix as in \mlnlffigen.

Enums are not accessible from the toplevel by default.  You must,
instead, \Sml{use} the right package.
\begin{center}
  \begin{tabular}{|l|l|} \hline
   \tt GLibEnums    & Enums definitions matching the prefix {\tt G\_}  \\
   \tt gdk_enums     & Enums definitions matching the prefix {\tt GDK\_} \\
   \tt gtk_enums     & Enums definitions matching the prefix {\tt GTK\_} \\
\hline
  \end{tabular}
\end{center}

    Currently, we map enums into either sml datatypes or 
\Sml{mlrep.Signed.Int}.   Datatypes are used whenever possible, so that
pattern matching can be used on enums, but we fall back onto the 
\Sml{mlrep.Signed.Int} representation when the enum is meant to be used as a 
bit vector.
 
\subsection{Typecasts}
   In C, \gtk\ uses macros such as \verb|GTK_WIDGET()|, 
    \verb|GTK_CONTAINER()|, \verb|GTK_OBJECT()|,
   etc for type coercion within the widget hierarchy.  
   These macros also check for type consistency at runtime.   
   They are not provided in SML, however; instead, the object hierarchy 
   is directly encoded within the ML types, and the ML compiler will,
   in most cases, do the object coercion implicitly for you.

   For example, in C we write:
  \begin{verbatim}
       GtkWidget * window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
       GtkWidget * box    = gtk_hbox_new(FALSE, 0);
       gtk_container_add(GTK_CONTAINER(window), box);
  \end{verbatim}

   In SML, we write the following without the \verb|GTK_CONTAINER()| macro:

  \begin{smldisp}
       let 
           window = gtk_window_new.f(GTK_WINDOW_TOPLEVEL)
           box    = gtk_hbox_new.f(false, 0)
       in  
           gtk_container_add.f(window, box)
       end
  \end{smldisp}

   Why does this work?  This is because these functions have the following
   types:

   \begin{smldisp}
       my gtk_window_new.f    : GtkWindowType -> base GtkWindow
       my gtk_hbox_new.f      : Bool * mlrep.Signed.Int -> base GtkHBox
       my gtk_container_add.f : X GtkContainer * Y GtkWidget -> Void
   \end{smldisp}

   The sml types \Sml{GtkWindow}, \Sml{GtkContainer} etc.~are 
defined in the following manner, with phantom types tags that
encode the class hierarchy:

    \begin{smldisp}
       type base
       type X gtkptr' = (X su, rw) ptr'
       type X object_t
       type X widget_t
       type X container_t
       type X bin_t
       type X window_t
       type X box_t
       type X hbox_t
    \end{smldisp}

    \begin{smldisp}
       type X GtkObject_tag    = X object_t
       type X GtkWidget_tag    = X widget_t GtkObject_tag 
       type X GtkContainer_tag = X container_t GtkWindow_tag
       type X GtkBox_tag       = X box_t GtkContainer_tag
       type X GtkHBox_tag      = X hbox_t GtkBox_tag
       type X GtkBin_tag       = X bin_t GtkContainer_tag
       type X GtkWindow_tag    = X window_t GtkBin_tag

       type X GtkObject    = X GtkObject_tag gtkptr'
       type X GtkWidget    = X GtkWidget_tag gtkptr'
       type X GtkContainer = X GtkContainer_tag gtkptr'
       type X GtkBox       = X GtkBox_tag gtkptr'
       type X GtkHBox      = X GtkHBox_tag gtkptr'
       type X GtkBin       = X GtkBin_tag gtkptr'
       type X GtkWindow    = X GtkWindow_tag gtkptr'
    \end{smldisp}

\subsection{Upcasting}

 Encoding the object hierarchy within ML's type system is not 
 a perfect fit.  Sometimes the lack of a subsuming rule in ML gets in the way.
 Occasionally you need to explicitly upcast a widget up the class hierarchy
 to help SML out.  Upcasting functions are 
   are defined in the package \Sml{Gtk}.  They are of the form:

   \begin{smldisp}
     my asClass : X GtkClass -> base GtkClass
   \end{smldisp}

   Here's an example of how they may be useful.  Suppose we have a widget
factory function called \verb|f|, which when 
given the name of a widget's class, returns a widget instance.
We can define this function as follows:

 
    \begin{smldisp} 
   #  Create a widget; coerce it to a container. 
   use Gtk
   fun 
       f "button"   = asContainer(gtk_button_new_with_label.f "button")
     | f "hbox"     = asContainer(gtk_hbox_new.f(false, 0))
     | f "font_sel" = asContainer(gtk_font_selection_new.f())
     | f _          = asContainer(gtk_window_new.f GTK_WINDOW_TOPLEVEL)

   my f : String -> base GtkContainer
    \end{smldisp} 

   The function \verb|asContainer| has the following type:

   \begin{smldisp}
      my asContainer : X GtkContainer -> base GtkContainer
   \end{smldisp}

   Note that if we omit the calls to the upcasting functions 
   the function \Sml{f} will not
   typecheck, because the widget constructors return different widget types:

   \begin{smldisp}
     my gtk_button_new_with_label.f : String -> base GtkButton
     my gtk_hbox_new.f : Bool * int -> base GtkHBox
     my gtk_font_selection_new.f : Void -> base GtkFontSelection
     my gtk_window_new.f : GtkWindowType -> base GtkWindow
   \end{smldisp}

   In general, upcasting functions are useful for coercing a heterogenous
   collection of widgets into a common base class.  
 
\subsection{Downcasting}
 
   Downcasting functions do the opposite of upcasting functions.
   These functions raise the exception \Sml{GtkTypes.TYPE_ERROR} 
   if the operation fails.

   For example,

   \begin{smldisp}
     GtkBox.cast(asWidget(gtk_hbox_new.f(false,0))
   \end{smldisp}
   
   \noindent succeeds, because \Sml{HBox} is a subclass of \Sml{Box}, while
   doing 

   \begin{smldisp}
     GtkItem.cast(asWidget(gtk_hbox_new.f(false,0))
   \end{smldisp}

   \noindent 
     raises \Sml{Gtk.TYPE_ERROR}, because \Sml{GtkItem} is not a superclass
   of \Sml{HBox}.

   In general, each $GtkClass$ defines an upcasting function
   of the following form:

   \begin{smldisp}
      my cast : X GtkObject -> base \(GtkClass\)
   \end{smldisp}

   Of course, you can also use the 
   downcasting functions to perform upcasting --- 
   they don't care which direction you are performing the cast, but 
   of course you still have to pay the cost of a dynamic check.

   NOTE: applying a downcast function on a \Sml{NULL} pointer 
   will raise the exception \Sml{NULL_POINTER}.

\subsection{Structs and Unions}
      A struct or a union 
named {\em foo} in \gtk\ is translated into a package
of the same name in ML.   We place its definition in the
file {\tt gtk/FFI/s-{\em foo}.sml} or {\tt gtk/FFI/u-{\em foo}.sml}.

    Fields of a struct (or union) can be accessed using its
accessors functions.  Given a field \Sml{f : t}, its accessor functions
are of the general form:
\begin{smldisp}
   my get_f : (foo.tag, C) su_obj' -> t
   my get'f : (foo.tag, C) su_obj ptr' -> t
\end{smldisp}

   Mutator functions, when available, are of the form:
\begin{smldisp}
   my set_f : (foo.tag, C) su_obj' * t -> Void
   my set'f : (foo.tag, C) su_obj ptr' * t -> Void
\end{smldisp}


For example, we can accessed the 
\Sml{child} field of a \Sml{GtkBin} object 
with the functions: 
\begin{smldisp}
   my get_child : (X GtkBin_tag su,C) obj' -> base GtkWidget 
   my get'child : (X GtkBin_tag su,C) obj ptr' -> base GtkWidget 
\end{smldisp}

Note that accessor and mutator functions for \gtk\ widget of class \Sml{C}
are polymorphic over \Sml{C}, i.e., 
they can be applied to \Sml{C} and all subclasses of 
\Sml{C}. 

\subsection{Signals and Events Handling}

   The \gtk\ programming model specifies two different types of user
definable callbacks that a client can register to a widget.  
A {\em signal} is a logical event that is tied to some state 
changes of a widget, while
an {\em event} is tied to external events, usually X11 events.  

   A signal callback for widget class \Sml{GtkClass} is of the following type
\begin{smldisp}
   X GtkClass -> Void
\end{smldisp}
\noindent while an event callback is of the type
\begin{smldisp}
   X GtkClass * GdkEvent.t -> Bool
\end{smldisp}
\indent i.e., an event callback is given an addition \Sml{GdkEvent} object as
argument.   The return value of an event callback specifies whether
the event handling should terminate at this callback, or whether
the event should propagate to other callbacks.  For more
details about how this work, you can consult \gtk's
documentation.

To register a signal callback \Sml{f} function to signal \Sml{s}
at widget \Sml{w}, call the function:
\begin{smldisp}
   my gtk_signal_connect.f : 
         X GtkObject * String * (X GtkObject -> Void) -> int

   gtk_signal_connect.f(w, s, f);
\end{smldisp}

Similarly, to register an event callback \Sml{f}, call the function:
\begin{smldisp}
   my gtk_event_connect.f : 
         X GtkObject * String * (X GtkObject * GdkEvent.t -> Bool) -> int

   gtk_event_connect.f(w, s, f);
\end{smldisp}

These are basically the ML equivalent of \verb|gtk_signal_connect| in C.
However, note that these functions, unlike their C counterparts, 
do {\em not} carry around any callback data arguments.  
With currying, you don't need them.  For example: 
\begin{smldisp}
 let
     fun say text button = print text 
     button1 = gtk_button_new_with_label.f "Hello"
     button2 = gtk_button_new_with_label.f "GoodBye"
 in 
     gtk_signal_connect.f(button1, "clicked", say "Hello!");
     gtk_signal_connect.f(button2, "clicked", say "Goodbye!");
 end
\end{smldisp}

%\subsection{Things To Watch Out For}

\section{Programming with Gadgets}\label{sec:gadgets}

Gadgets is an experimental 
``object oriented'' layer on top of the basic \gtk\ functions.
There is nothing magical about it.
Think of it as just a set of currying conventions
to make writing \gtk\ applications more succinct.

\subsection{Gadgets, Messages and Message Constructors}

What is a gadget?
Currently a gadget is just a \gtk\ widget, but this may change in the future.
A gadget is an object, and it can perform some operations 
upon receiving a \Sml{message}. 
A message is simply a function applicable on a gadget:
\begin{smldisp}
   type $gadget message = $gadget -> Void
\end{smldisp}

We write message sending in infix style, with the \verb|<~| operator:

\begin{smldisp}
   infix <~
   my <~ : $gadget * $gadget message -> Void
\end{smldisp} 

Since it is quite common to send multiple messages to a gadget, we 
also provide another operator \verb|<-| to help us out:

\begin{smldisp}
   infix <-
   my <- : $gadget * $gadget message list -> $gadget
\end{smldisp}

Let's use these message sending operators to write some
code to create a new window, set it to size $200\times200$, give
it a title,  register a callback, and show it:
\begin{smldisp}
   let use Gtk GtkGadgets gtk_enums
       window = gtk_window_new.f GTK_WINDOW_TOPLEVEL 
   in  window <- 
         [ gtk_window_set_usize.m (0w200, 0w200),
           gtk_window_set_title.m "Hello",
           on "destroy" (fn _ => print "I'm dying"),
           gtk_widget_show.m
         ] 
   end
\end{smldisp}

Note that we are using the {\em message variants} of the \gtk\ functions
\begin{smldisp}
   my gtk_window_set_usize.m : word * word -> X GtkWindow -> Void
\end{smldisp}
and 
\begin{smldisp}
   my gtk_widget_show.m : X GtkWidget -> Void
\end{smldisp}

Okay, so \Sml{gtk_widget_show.m} is actually the same thing as
\Sml{gtk_widget_show.f} in the current implementation, but this may
change in the future.

The function \Sml{on} is a signal callback registration function
defined as follows:

\begin{smldisp}
   type $gadget signalHandler = ($gadget -> Void) -> $gadget message 
   my on : String -> X GtkObject signalHandler
\end{smldisp}

It is basically a curried version of \verb|gtk_signal_connect.f|.

\subsection{Gadget Makers}
It is a very common idiom to create a \gtk\ object and sends it 
some messages to initialize it.  So, we make it official
and call this a {\em gadget maker}.  There are two forms of gadget
makers, one taking some initial constructor arguments, and one that
doesn't.  The types of gadget makers are:

\begin{smldisp}
   type ($gadget,$initializer) maker = 
       $initializer -> $gadget message list -> $gadget 
   type $gadget maker' = $gadget message list -> $gadget
\end{smldisp}

\ \\
Let's rewrite the previous snippet of code with a Window maker:

\begin{smldisp}
   let use Gtk GtkGadgets gtk_enums
   in  Window.new GTK_WINDOW_TOPEVEL
        [ gtk_window_set_usize.m (0w200, 0w200),
          gtk_window_set_title.m "Hello",
          on "destroy" (fn _ => print "I'm dying"),
          gtk_widget_show.m
        ] 
   end
\end{smldisp}

In general, for each \gtk\ class {\em GtkClass} we provide a gadget
maker {\em Class}\verb|.new|.  Here are some common gadget makers and their
types:

\begin{smldisp}
   my Label.new    : (base GtkLabel,String) maker
   my Button.new   : base GtkButton maker'
   my Button.label : (base GtkButton,String) maker
   my HBox.new     : (base GtkHBox, Bool * int) maker
   my VBox.new     : (base GtkVBox, Bool * int) maker
   my FileSelection.new : (base GtkFileSelection, String) maker
\end{smldisp}

\subsection{Abbreviations}

To save typing, we provide many different types of abbreviations.
\begin{description}
 \item[\tt common abbreviations] Common operations
such as \verb|gtk_widget_show.m| are given a much shorter name.
For example, these are some common abbreviations defined in the
package \Sml{GtkGadgets}:
\begin{smldisp}
  my show     : X GtkWidget message
  my show_all : X GtkWidget message
  my hide     : X GtkWidget message
\end{smldisp}
 \item[\tt settting an attribute] Common attributes setting messages
are grouped together in the package \verb|set|.  Here is a sample
of the setter messages:
\begin{smldisp}
   my usize     : Signed.int * Signed.int -> X GtkWidget message
   my uposition : Signed.int * Signed.int -> X GtkWidget message
   my modal     : Bool -> X GtkWindow message
   my focus     : Y GtkWidget -> X GtkWindow message
   my title     : String -> X GtkWindow message
   my text      : String -> X GtkLabel message
   my justify   : GtkJustification -> X GtkLabel message
   my submenu   : Y GtkWidget -> X GtkMenuItem message
   my tip       : Y GtkWidget * String * String -> X GtkTooltips message
\end{smldisp}

 \item[\tt signal handler registration]
Common signal handler registration functions are defined in the 
packages \verb|on|.  Here is a brief snipbit:
\begin{smldisp}
    /* A signalHandler is a message constructor taking a signal callback as
     * argument.
     */
    type $gadget signalHandler = ($gadget -> Void) -> $gadget message

    my pressed: X GtkButton signalHandler
    my released: X GtkButton signalHandler
    my clicked: X GtkButton signalHandler
    my enter: X GtkButton signalHandler
    my leave: X GtkButton signalHandler
    my select: X GtkItem signalHandler
    my menu_item_activate: X GtkMenuItem signalHandler
    my destroy: X GtkObject signalHandler
    my hide: X GtkWidget signalHandler
    my map: X GtkWidget signalHandler
    my unmap: X GtkWidget signalHandler
    my realize: X GtkWidget signalHandler
    my set_focus: X GtkWindow signalHandler
\end{smldisp}

 \item[\tt event handler registration]
Common event handler registration functions are defined in the 
packages \verb|when|.  Here is a sample:
\begin{smldisp}
   #  An typed event handler explicitly handles one kind of events 
   type ($gadget,$event) typedEventHandler =
          ($gadget * $event -> Bool) -> $gadget message
   my delete : (X GtkWidget, GdkEventAny.t) typedEventHandler
   my destroy : (X GtkWidget, GdkEventAny.t) typedEventHandler
   my expose : (X GtkWidget, GdkEventExpose.t) typedEventHandler
   my two_button_press : (X GtkWidget, GdkEventButton.t) typedEventHandler
   my three_button_press : (X GtkWidget, GdkEventButton.t) typedEventHandler
   my button_release : (X GtkWidget, GdkEventButton.t) typedEventHandler
   my key_press : (X GtkWidget, GdkEventKey.t) typedEventHandler
   my key_release : (X GtkWidget, GdkEventKey.t) typedEventHandler
   my drag_enter : (X GtkWidget, GdkEventDND.t) typedEventHandler
   my drag_leave : (X GtkWidget, GdkEventDND.t) typedEventHandler
   my drop_start : (X GtkWidget, GdkEventDND.t) typedEventHandler
   my drop_finished : (X GtkWidget, GdkEventDND.t) typedEventHandler
   my client_event : (X GtkWidget, GdkEventClient.t) typedEventHandler
   my no_expose : (X GtkWidget, GdkEventNoExpose.t) typedEventHandler
\end{smldisp}

 \item[\tt makers]
Common object makers are accessable from the package \verb|$|.
\begin{smldisp}
   my window        : base GtkWindow maker'
   my hbox       : (base GtkHBox, Bool * mlrep.Signed.Int) maker
   my vbox       : (base GtkVBox, Bool * mlrep.Signed.Int) maker
   my hb         : base GtkHButtonBox maker'
   my vb         : base GtkVButtonBox maker'
   my l          : (base GtkLabel, String) maker
   my hscrollbar : (base GtkHScrollbar, X GtkAdjustment) maker
   my vscrollbar : (base GtkVScrollbar, X GtkAdjustment) maker
   my hsep       : base GtkHSeparator maker'
   my vsep       : base GtkVSeparator maker'
\end{smldisp}
\begin{smldisp}
   my b          : (base GtkButton, String) maker
   my m          : base GtkMenu maker'
   my mi         : (base GtkMenuItem, String) maker
   my menu_bar   : base GtkMenuBar maker'
   my menu_item  : String ->
          base GtkMenuItem message list -> X GtkMenu message
   my menu_bar_item : String -> 
           base GtkMenuItem message list -> X GtkMenuBar message
   my submenu    : base GtkMenu message list -> Y GtkMenuItem message
   my img        : (base GtkImage, GdkImage.t * GdkWindow.t) maker
   my tooltips   : base GtkTooltips maker'
\end{smldisp}

 \item[\tt adders]
  Adders are messages for inserting a widget into another container.
These abbreviations are defined in the package \Sml{+}.  Here's
a sample list of these functions:
\begin{smldisp}
   my add  : ...
   my add_list  : ...
   my pack_start : ...
   my pack : ...
   my pack_end  : ...
   my pack_list : ...
   my pack_start_list : ...
   my pack_end_list  : ...
\end{smldisp}
\end{description}

For example, using abbreviations, we can write:
\begin{smldisp}
   let use GtkGadgets
   in  \$.window
        [ set.usize (0w200, 0w200),
          set.title "Hello",
          on.destroy (fn _ => print "I'm dying"),
          show
        ] 
   end
\end{smldisp}

Pretty cool, eh?

To see the full set of message and function abbreviations, see the 
following files:
\begin{verbatim}
   gtk/Gadgets/Gadget-Set.sig
   gtk/Gadgets/Gadget-Signals.api
   gtk/Gadgets/Gadget-Events.sig
   gtk/Gadgets/Gadget-Makers.sig
   gtk/Gadgets/Gadget-Add.pkg
\end{verbatim}

\subsection{Labels and Buttons}
A bare window is not very useful, so let's add at a label to the mix.

\begin{smldisp}
   let use GtkGadgets
   in  \$.window
        [ set.usize (0w200, 0w200),
          set.title "Hello",
          on.destroy (fn _ => print "I'm dying"),
          +.add (\$.l "Hi" []),
          show
        ] 
   end
\end{smldisp}

The function \Sml{+.add} is an abbreviation for \verb|gtk_container_add.m|:
\begin{smldisp}
   my +.add : X GtkWidget -> Y GtkContainer message
\end{smldisp}
\noindent and can be used to insert an widget to a container.
The function \Sml{\$.l} is an abbreviation for the maker function
\Sml{Label.label}, which can be used to create a label.  We can also
use the function \Sml{\$.label}, which is a longer name for \Sml{\$.l}.

Since adding a label to a container is a very common action,
we provide an abbreviation \Sml{+.l}, which creates a label and
add it to a container 
at the same time.  The above code fragment can be rewritten as:
\begin{smldisp}
   let use GtkGadgets
   in  \$.window
        [ set.usize (0w200, 0w200),
          set.title "Hello",
          on.destroy (fn _ => print "I'm dying"),
          +.l "Hi" [],
          show
        ] 
   end
\end{smldisp}

Let's change the label to a button, using the function \Sml{\$.b} (or
\Sml{\$.button} if you prefer a longer name):
\begin{smldisp}
   let use GtkGadgets
   in  \$.window
        [ set.usize (0w200, 0w200),
          set.title "Hello",
          on.destroy (fn _ => print "I'm dying"),
          +.add (\$.b "Hi" [on.clicked (fn _ => print "Hi There!")]),
          show
        ] 
   end
\end{smldisp}

The button just prints the string \verb|"Hi There!"| when pressed.

Again, the above can be rewritten with the \Sml{+.b} function:
\begin{smldisp}
   let use GtkGadgets
   in  \$.window
        [ set.usize (0w200, 0w200),
          set.title "Hello",
          on.destroy (fn _ => print "I'm dying"),
          +.b "Hi" [on.clicked (fn _ => print "Hi There!")],
          show
        ] 
   end
\end{smldisp}

In summary, here are the functions you can use on buttons and labels.
\begin{smldisp}
   my \$.l      : String -> base GtkLabel message -> base GtkLabel
   my \$.b      : String -> base GtkButton message -> base GtkButton
   my \$.label  : String -> base GtkButton message -> base GtkButton
   my \$.button : String -> base GtkButton message -> base GtkButton
   my +.l      : String -> base GtkLabel message list 
                         -> X GtkContainer message
   my +.b      : String -> base GtkButton message list 
                         -> X GtkContainer message
   my +.label  : String -> base GtkLabel message list 
                         -> X GtkContainer message
   my +.button : String -> base GtkButton message list 
                         -> X GtkContainer message
\end{smldisp}

\subsection{Containers and Boxes}

\begin{smldisp}
   my +.add      : X GtkWidget -> Y GtkContainer message
   my +.add_list : X GtkWidget list -> Y GtkContainer message
\end{smldisp}

\begin{smldisp}
   my \$.hbox : (base GtkHBox, Bool * Signed.int) maker
   my \$.vbox : (base GtkVBox, Bool * Signed.int) maker
\end{smldisp}

\begin{smldisp}
   my +.pack_start : Bool * Bool * Unsigned.word -> 
                        X GtkWidget -> Y GtkBox message
   my +.pack       : Bool * Bool * Unsigned.word -> 
                        X GtkWidget -> Y GtkBox message
   my +.pack_end   : Bool * Bool * Unsigned.word -> 
                        X GtkWidget -> Y GtkBox message
\end{smldisp}

\begin{smldisp}
   my +.pack_start_list : 
         Bool * Bool * Unsigned.word -> X GtkWidget list -> Y GtkBox message
   my +.pack_list : 
         Bool * Bool * Unsigned.word -> X GtkWidget list -> Y GtkBox message
   my +.pack_end_list : 
         Bool * Bool * Unsigned.word -> X GtkWidget list -> Y GtkBox message
\end{smldisp}

\subsection{Menus}

\subsection{Item Factory}

\begin{smldisp}
   @.menu_bar item_factory
   [ @.branch "/File" "",
       @.item "/File/_New" "" (ok "New"),
       @.item "/File/_Open" "" (ok "Open"),
       @.item "/File/_Close" "" (ok "Close"),
       @.branch "/File/Properties" "",
         @.item "/File/Properties/Font" "" (ok "Font"),
         @.item "/File/Properties/Color" "" (ok "Color"),
         @.item "/File/_Exit" "<Ctrl>Q" print_and_quit,
     @.item "/Plot" "" (line_plot plot_area),
     @.item "/Help" "" (ok "Help")
   ]
\end{smldisp}

\subsection{Dialogs}

\subsection{Scrollbars}

\subsection{Text}

\subsection{More on Signal and Event Handling}

\subsection{Drag and Drop}

%\subsection{Creating Your Own Gadgets}

\section{Related Work}

    Ken Friis Larsen and Henning Niss have produced a version of 
\gtk\ namings for the Moscow ML compiler.  Their namings library
is called \verb|mGTK|\cite{mGTK} and is available from
\htmladdnormallink{http://mgtk.sourceforge.net}{http://mgtk.sourceforge.net}.

\bibliography{sml-gtk}

\end{document}
