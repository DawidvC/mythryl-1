## window.pkg
#
# See also:
#     src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/rw-pixmap.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6


###                 "The first rule of discovery is to have brains and good luck.
###                  The second rule of discovery is to sit tight and wait till you get a bright idea."
###
###                                                     -- Geore Polya



stipulate
    include threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package a   =  atom;				# atom				is from   src/lib/x-kit/xclient/src/iccc/atom.pkg
    package ci  =  color_imp;				# color_imp			is from   src/lib/x-kit/xclient/src/window/color-imp.pkg
    package cs  =  cursors;				# cursors			is from   src/lib/x-kit/xclient/src/window/cursors.pkg
    package di  =  draw_imp;				# draw_imp			is from   src/lib/x-kit/xclient/src/window/draw-imp.pkg
    package dt  =  draw_types;				# draw_types			is from   src/lib/x-kit/xclient/src/window/draw-types.pkg
    package dy  =  display;				# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package e2s =  xerror_to_string;			# xerror_to_string		is from   src/lib/x-kit/xclient/src/stuff/xerror-to-string.pkg
    package et  =  event_types;				# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package g   =  geometry;				# geometry			is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    package ip  =  iccc_property;			# iccc_property			is from   src/lib/x-kit/xclient/src/iccc/iccc-property.pkg
    package s2w =  sendevent_to_wire;			# sendevent_to_wire		is from   src/lib/x-kit/xclient/src/wire/sendevent-to-wire.pkg
    package sa  =  standard_x11_atoms;			# standard_x11_atoms		is from   src/lib/x-kit/xclient/src/iccc/standard-x11-atoms.pkg
    package sn  =  xsession;				# xsession			is from   src/lib/x-kit/xclient/src/window/xsession.pkg
    package v2w =  value_to_wire;			# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;			# wire_to_value			is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package wio =  window_io;				# window_io			is from   src/lib/x-kit/xclient/src/wire/window-io.pkg
    package wr  =  widgettree_root_xevent_router;       # widgettree_root_xevent_router	is from   src/lib/x-kit/xclient/src/window/widgettree-root-xevent-router.pkg
    package xok =  xsocket;				# xsocket			is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package xt  =  xtypes;				# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
herein

    package window: (weak)  Window {			# Window			is from   src/lib/x-kit/xclient/src/window/window.api

	Window = dt::Window;

	# Set the value of a property:
	#
	fun set_property (xsession, window_id, name, value)
	    =
	    sn::request  xsession
		#
		(v2w::encode_change_property
		  {
		    name,
		    window =>  window_id,
		    prop   =>  value,
		    mode   =>  xt::REPLACE_PROPERTY
		  }
		);

	# User-level window attributes:
	#
	Window_Attribute
	  = WA_BACKGROUND_NONE
	  | WA_BACKGROUND_PARENT_RELATIVE
	  | WA_BACKGROUND_RW_PIXMAP   	     dt::Rw_Pixmap
	  | WA_BACKGROUND_RO_PIXMAP          dt::Ro_Pixmap
	  | WA_BACKGROUND_COLOR              ci::Color
	  #
	  | WA_BORDER_COPY_FROM_PARENT
	  | WA_BORDER_RW_PIXMAP       	     dt::Rw_Pixmap
	  | WA_BORDER_RO_PIXMAP              dt::Ro_Pixmap
	  | WA_BORDER_COLOR                  ci::Color
	  #
	  | WA_BIT_GRAVITY                   xt::Gravity
	  | WA_WINDOW_GRAVITY                xt::Gravity
	  #
	  | WA_CURSOR_NONE
	  | WA_CURSOR                        cs::Xcursor
	  ;

	# Window configuration values:
	#
	Window_Config
	  = WC_ORIGIN      g::Point
	  | WC_SIZE        g::Size
	  | WC_BORDER_WID  Int
	  | WC_STACK_MODE                   xt::Stack_Mode
	  | WC_REL_STACK_MODE  (dt::Window, xt::Stack_Mode)
	  ;

	# Extract the pixel from a color:
	#
	fun pixel_of (ci::COLOR { pixel, ... } )
	    =
	    pixel;

	# Map user-level window attributes
	# to internal x-window attributes: 
	#
	fun user_window_attribute_to_internal_window_attribute (WA_BACKGROUND_NONE)
		=>
		wio::BACKGROUND_PIXMAP_NONE;

	    user_window_attribute_to_internal_window_attribute (WA_BACKGROUND_PARENT_RELATIVE)
		=>
		wio::BACKGROUND_PIXMAP_PARENT_RELATIVE;

	    user_window_attribute_to_internal_window_attribute (WA_BACKGROUND_RW_PIXMAP (dt::RW_PIXMAP { id, ... } ))
		=>
		wio::BACKGROUND_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (WA_BACKGROUND_RO_PIXMAP (dt::RO_PIXMAP (dt::RW_PIXMAP { id, ... } ))) 
	       => 
		wio::BACKGROUND_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (WA_BACKGROUND_COLOR color)
		=>
		wio::BACKGROUND_PIXEL (pixel_of color);

	    user_window_attribute_to_internal_window_attribute (WA_BORDER_COPY_FROM_PARENT)
		=>
		wio::BORDER_PIXMAP_COPY_FROM_PARENT;

	    user_window_attribute_to_internal_window_attribute (WA_BORDER_RW_PIXMAP (dt::RW_PIXMAP { id, ... } ))
		=>
		wio::BORDER_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (WA_BORDER_RO_PIXMAP (dt::RO_PIXMAP (dt::RW_PIXMAP { id, ... } )))
		=>
		wio::BORDER_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (WA_BORDER_COLOR color)
		=>
		wio::BORDER_PIXEL (pixel_of color);

	    user_window_attribute_to_internal_window_attribute (WA_BIT_GRAVITY g)
		=>
		wio::BIT_GRAVITY g;

	    user_window_attribute_to_internal_window_attribute (WA_WINDOW_GRAVITY g)
		=>
		wio::WINDOW_GRAVITY g;

	    user_window_attribute_to_internal_window_attribute (WA_CURSOR_NONE)
		=>
		wio::CURSOR_NONE;

	    user_window_attribute_to_internal_window_attribute (WA_CURSOR (cs::XCURSOR { id, ... } ))
		=>
		wio::CURSOR id;
	end;


	map_attributes = list::map user_window_attribute_to_internal_window_attribute;

	std_xevent_mask
	    =
	    et::mask_of_xevent_list
	      [
		et::XEVENT_KEY_PRESS,
		et::XEVENT_KEY_RELEASE,
		et::XEVENT_BUTTON_PRESS,
		et::XEVENT_BUTTON_RELEASE,
		et::XEVENT_POINTER_MOTION,
		et::XEVENT_ENTER_WINDOW,
		et::XEVENT_LEAVE_WINDOW,
		et::XEVENT_EXPOSURE,
		et::XEVENT_STRUCTURE_NOTIFY,
		et::XEVENT_SUBSTRUCTURE_NOTIFY,
                et::XEVENT_PROPERTY_CHANGE
	      ];

	popup_xevent_mask
	    =
	    et::mask_of_xevent_list
	      [
		et::XEVENT_EXPOSURE,
		et::XEVENT_STRUCTURE_NOTIFY,
		et::XEVENT_SUBSTRUCTURE_NOTIFY
	      ];

	exception BAD_WINDOW_FOOTPRINT;

	fun check_shape g
	    =
	    if (g::valid_shape g)   g;
	    else                    raise  exception  BAD_WINDOW_FOOTPRINT;
	    fi;

	fun make_simple_top_window (screen as sn::SCREEN { screen=>scrinfo, xsession } )
	    =
	    create_fn
	    where 
		scrinfo   ->  sn::SCREEN_INFO       { xscreen  => dy::XSCREEN { root, ... }, root_imps, ... };
		root_imps ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession  ->  sn::XSESSION          { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid();

		my (kidplug, window, delete_slot)
		    =
		    wr::make_widgettree_root_xevent_router
			(screen, root_imps, window_id);

		fun create_fn { geometry, border, background }
		    =
		    {
			wio::create_window  xsocket
			  {
			    depth,
			    #
			    id      => window_id,
			    parent  => root,
			    #
			    in_only => THE FALSE,
			    visual  => NULL,
			    #
			    geometry    => check_shape geometry,
			    #
			    attributes
				=>
				[ wio::BORDER_PIXEL     (pixel_of border),
				  wio::BACKGROUND_PIXEL (pixel_of background),
				  wio::EVENT_MASK       std_xevent_mask
				]
			  };


			(window, kidplug, delete_slot);
		    };
	    end;

	fun make_simple_subwindow (dt::WINDOW { id=>parent_id, screen, draw_fn, screen_depth, ... } )
	    =
	    create_fn
	    where 

		screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... }, ... };

		window_id = next_xid();

		window = dt::WINDOW {
		    id => window_id,
		    screen,
		    draw_fn,
		    screen_depth
		  };

		screen_depth ->   sn::SCREEN_DEPTH_IMPS { depth, ... };

		fun create_fn { geometry, border, background }
		    =
		    {   border_pixel
			    =
			    case border
				#
				NULL  =>   wio::BORDER_PIXMAP_COPY_FROM_PARENT;
				THE c =>   wio::BORDER_PIXEL (pixel_of c);
			    esac;


			background_pixel
			    =
			    case background
				#
				NULL  =>   wio::BACKGROUND_PIXMAP_PARENT_RELATIVE;
				THE c =>   wio::BACKGROUND_PIXEL (pixel_of c);
			    esac;


			  wio::create_window  xsocket  {
			      id => window_id,
			      parent => parent_id,
			      in_only => THE FALSE,
			      depth,
			      visual => NULL,
			      geometry => check_shape geometry,
			      attributes => [
				  border_pixel,
				  background_pixel,
				  wio::EVENT_MASK std_xevent_mask
				]
			    };

			  window;
		    };
	    end;


	# Create a simple popup window.
	#
	# These are simple windows used for menus
	# and tooltips and such;  they are neither
	# registered with nor decorated by the
	# window manager.  
	#
	# Compare with the plain and transient
	# windows provided by the topwindow package:
	#
	#     src/lib/x-kit/widget/basic/topwindow.pkg
	#
	fun make_simple_popup_window
		(scrn as sn::SCREEN { screen, xsession } )
		{ geometry, border, background }
	    =
	    (window, kidplug)
	    where 
		screen    ->  sn::SCREEN_INFO { xscreen => dy::XSCREEN { root, ... }, root_imps, ... };
		root_imps ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession  ->  sn::XSESSION    { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid();

		# modified ddeboer, Jul 2004; original: 
		# my (inDict, window) = TopLevelWin::mkTopLevelWinDict (scrn, root_imps, winId)

		my (kidplug, window, delete_slot)
		    =
		    wr::make_widgettree_root_xevent_router (scrn, root_imps, window_id);

		wio::create_window  xsocket  {
		    id => window_id,
		    parent => root,
		    in_only => THE FALSE,
		    depth,
		    visual => NULL,
		    geometry => check_shape geometry,
		    attributes => [
			wio::OVERRIDE_REDIRECT TRUE,
			wio::SAVE_UNDER TRUE,
			wio::BORDER_PIXEL (pixel_of border),
			wio::BACKGROUND_PIXEL (pixel_of background),
			wio::EVENT_MASK popup_xevent_mask
		      ]
		  };
	    end;

	# Create a simple transient window:
	#
	fun make_transient_window prop_window { geometry, border, background }
	    =
	    (window, kidplug)
	    where 

		prop_window ->  dt::WINDOW { id, screen=>scrn as sn::SCREEN { screen, xsession }, ... };
		screen      ->  sn::SCREEN_INFO { xscreen => dy::XSCREEN { root, ... }, root_imps, ... };

		root_imps   ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession    ->  sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid();

		# modified ddeboer, Jul 2004; original: 
		# my (inDict, window) = TopLevelWin::mkTopLevelWinDict (scrn, root_imps, winId)

		my (kidplug, window, delete_slot)
		    =
		    wr::make_widgettree_root_xevent_router (scrn, root_imps, window_id);

		wio::create_window  xsocket  {
		    id => window_id,
		    parent => root,
		    in_only => THE FALSE,
		    depth,
		    visual => NULL,
		    geometry => check_shape geometry,
		    attributes => [
			wio::BORDER_PIXEL (pixel_of border),
			wio::BACKGROUND_PIXEL (pixel_of background),
			wio::EVENT_MASK std_xevent_mask
		      ]
		};

		set_property (xsession, window_id, sa::atom_wm_transient_for, ip::make_transient_hint prop_window);

	    end;

	exception INPUT_ONLY;

	fun make_input_only_window  window  (g::BOX { col, row, wide, high } )
	    =
	    window
	    where  

		window ->   dt::WINDOW { id=>parent_id, screen, screen_depth, draw_fn, ... };
		screen ->   sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... }, ... };

		window_id = next_xid();

		fun draw_fn (arg as (di::DMSG_DESTROY _))
			=>
			draw_fn arg;

		    draw_fn _
			=>
			raise exception INPUT_ONLY;
		end;

		window
		    =
		    dt::WINDOW
		      {
			id => window_id,
			screen,
			draw_fn,
			screen_depth
		      };

		wio::create_window  xsocket  {
		    id => window_id,
		    parent => parent_id,
		    in_only => THE TRUE,
		    depth => 0,
		    visual => NULL,
		    attributes => [wio::EVENT_MASK std_xevent_mask],
		    #
		    geometry
			=>
			check_shape
			    (g::WINDOW_FOOTPRINT
			      { upperleft    => g::POINT { col, row },
				size         => g::SIZE { wide, high },
				border_width => 0
			      }
			    )
		};
	    end;


	# Set the standard window-manager
	# properties of a top-level window.
	#
	# This should be done before showing
	# (mapping) the window:
	#
	fun set_window_manager_properties

		window

		{ window_name,
		  icon_name,
		  argv,
		  size_hints,
		  nonsize_hints,
		  ilk_hints
		}
	    =
	    {   window ->  dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... };

		fun put_property (name, value)
		    =
		    set_property (xsession, id, name, value);

		fun put_string_prop (_, NULL)     =>   ();
		    put_string_prop (atom, THE s) =>   put_property (atom, ip::make_string_property s);
		end;

		put_string_prop (sa::atom_wm_name,    window_name);
		put_string_prop (sa::atom_wm_icon_name, icon_name);

		put_property (sa::atom_wm_normal_hints, ip::make_window_manager_size_hints        size_hints);
		put_property (sa::atom_wm_hints,        ip::make_window_manager_nonsize_hints  nonsize_hints);

		case ilk_hints
		    #	      
		    THE { res_name, res_ilk }
			=>
			put_property
			  ( sa::atom_wm_ilk,
			    ip::make_string_property (string::cat [res_name, "\000", res_ilk])
			  );

		    NULL => ();
		esac;

		case argv
		    #	      
		    [] => ();
		    _  => put_property (sa::atom_wm_command, ip::make_command_hints (argv));
		esac;
	    };


	# Set the window-manager protocols for a window:
	#
	fun set_window_manager_protocols window atoml
	    =
	    {   window ->  dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... };

		fun put_property n a
		    =
		    set_property (xsession, id, n, ip::make_atom_property a);

		case (a::find_atom  xsession  "WM_PROTOCOLS")
		    #
		    NULL => FALSE;
		    THE protocols_atom => { apply (put_property protocols_atom) atoml; TRUE;};
		esac;
	    };

	# Map window configuration values to a value list:
	#
	fun do_config_val arr
	    =
	    {   fun upd (i, v)
		    =
		    rw_vector::set (arr, i, THE v);


		fn (WC_ORIGIN (g::POINT { col, row } ))
			=>
			{   upd (0, unt::from_int col);
			    upd (1, unt::from_int row);
			};

		   (WC_SIZE (g::SIZE { wide, high } ))
			=>
			{   upd (2, unt::from_int wide);
			    upd (3, unt::from_int high);
			};

		   (WC_BORDER_WID wide)
		       =>
		       upd (4, unt::from_int wide);

		   (WC_STACK_MODE mode)
			=>
			{   rw_vector::set (arr, 5, NULL);
			    upd (6, v2w::stack_mode_to_wire mode);
			};

		   (WC_REL_STACK_MODE (dt::WINDOW { id=>(xt::XID x), ... }, mode))
			=>
			{   upd (5, x);
			    upd (6, v2w::stack_mode_to_wire mode);
			};
		end;
	    };

	do_config_vals
	    =
	    v2w::do_val_list 7 do_config_val;

	fun configure_window (dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... } ) vals
	    =
	    sn::request  xsession
	      ( v2w::encode_configure_window
		  {
		    window  => id,
		    vals => do_config_vals vals
		  }
	      );

	fun move_window   window pt   =   configure_window window [WC_ORIGIN pt];
	fun resize_window window size =   configure_window window [WC_SIZE size];

	fun move_and_resize_window window (g::BOX { col, row, wide, high } )
	    =
	    configure_window window
	      [ WC_ORIGIN (g::POINT { col,  row  } ),
		WC_SIZE   (g::SIZE  { wide, high } )
	      ];

	# Show ("map") a window:
	#
	fun show_window (dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   sn::request    xsession  (v2w::encode_map_window { window=>id } );
		sn::flush_out  xsession;
	    };

	# Hide ("unmap") a window:
	#
	fun hide_window (dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   sn::request    xsession  (v2w::encode_unmap_window { window=>id } );

		sn::flush_out  xsession;
	    };

	# Withdraw (unmap and notify window manager) a top-level window 
	#
	stipulate 

	    mask = et::mask_of_xevent_list
                     [ et::XEVENT_SUBSTRUCTURE_NOTIFY,
		       et::XEVENT_SUBSTRUCTURE_REDIRECT
		     ];
	herein

	    fun withdraw_window (dt::WINDOW { id, screen => sn::SCREEN { screen=> sn::SCREEN_INFO { xscreen, ... }, xsession }, ... } )
		=
		{   xscreen ->  dy::XSCREEN { root, ... };

		    sn::request  xsession
			#
			(s2w::encode_send_unmap_notify
			  { to => xt::SEND_EVENT_TO_WINDOW root,
			    propagate => FALSE,
			    event_mask => mask, 
			    event      => root,
			    window     => id,
			    from_configure => FALSE
			  }
			);

		    sn::flush_out  xsession;
	       };
	end;

	# Destroy a window.
	# We do this via draw_imp to avoid a race
	# with any pending draw requests on the window.
	#
	fun destroy_window (dt::WINDOW { id, draw_fn, ... } )
	    = 
	    draw_fn (di::DMSG_DESTROY (di::DESTROY_WINDOW id));


	# Map a point in the window's coordinate
	# system to the screen's coordinate system
	#
	fun window_pt_to_screen_pt (dt::WINDOW { id, screen, ... } ) pt
	    =
	    {   screen ->  sn::SCREEN { xsession, screen=> sn::SCREEN_INFO { xscreen => dy::XSCREEN { root, ... }, ... }, ... };

		my { to_point, ... }
		    =
		    w2v::decode_translate_coords_reply
		      (
			do_mailop
			  (sn::request_reply
			      xsession
			      (v2w::encode_translate_coords { from_window=>id, to_window=>root, from_point=>pt } )
			  )
		      );

		to_point;
	    };


	# Set the window cursor:
	#
	fun set_cursor (dt::WINDOW { id, screen, ... } ) c
	    =
	    {   screen -> sn::SCREEN { xsession => sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		cur =  case c
			   #		              
			   THE (cs::XCURSOR { id, ... } ) =>   wio::CURSOR id;
			   NULL                           =>   wio::CURSOR_NONE;
		       esac;

		wio::change_window_attributes  xsocket  (id, [cur]);
	    };


	# Set the background color attribute of the window.  Note that this does
	# not have an immediate affect on the window's contents, but if it is done
	# before the window is mapped, the window will come up with the right color.
	#
	fun set_background (dt::WINDOW { id, screen, ... } ) color
	    =
	    wio::change_window_attributes  xsocket  (id, [color])
	    where 
		screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		color
		    =
		    case color
			#	         
			NULL  =>   wio::BACKGROUND_PIXMAP_PARENT_RELATIVE;
			THE c =>   wio::BACKGROUND_PIXEL (pixel_of c);
		    esac;
	    end;

	# Set various window attributes 
	#
	fun change_window_attributes (dt::WINDOW { id, screen, ... } )
	    =
	    {   screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		change = wio::change_window_attributes  xsocket;

		fn attributes =  change (id,  map  user_window_attribute_to_internal_window_attribute  attributes);
	    };

	fun screen_of_window  (dt::WINDOW { screen, ... } )
	    =
	    screen;

	fun xsession_of_window (dt::WINDOW { screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    xsession;

	#  Added ddeboer Jan 2005 
	#  grabKeyboard: we would like a reply of xprottypes::GrabSuccess 
	#
	fun grab_keyboard (dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    0;

	    /* commented out, ddeboer, mar 2005 - this needs reworked.	 XXX BUGGO FIXME
	    let ans = 
		(w2v::decode_grab_keyboard_reply (do_mailop (sn::dpy_pequest_peply xsession
			    (v2w::encode_grab_keyboard { 
				window=id, * type XTy::XID *
				owner_events=FALSE, 
				ptr_mode=xt::AsynchronousGrab, 
				kbd_mode=xt::AsynchronousGrab, 
				time=xt::CURRENT_TIME } ))))
		    except Xok::LOST_REPLAY => raise exception (xgripe::XERROR "[reply lost]")
			 | (Xok::ERROR_REPLY err) =>
			    raise exception (xgripe::XERROR (e2s::xerror_to_string err))
	    in (case (ans) of
		xt::GrabSuccess => 0
	      | xt::AlreadyGrabbed => 1
	      | xt::GrabInvalidTime => 2
	      | xt::GrabNotViewable => 3
	      | xt::GrabFrozen => 4)
	    end */

	fun ungrab_keyboard (dt::WINDOW { id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   ans = ( /* w2v::decode_grab_keyboard_reply */

			(do_mailop
			  (sn::request_reply
			    xsession
			    (v2w::encode_ungrab_keyboard
			      { time=>xt::CURRENT_TIME }
		      ) ) ) )
		      except
			  xok::LOST_REPLAY     => raise exception (xgripe::XERROR "[reply lost]");
			  xok::ERROR_REPLY err => raise exception (xgripe::XERROR (e2s::xerror_to_string err));
		      end ;

	     #  TODO: figure out what type of reply comes from an ungrab request, and decode it 	XXX BUGGO FIXME
		0;
	    };
						# end added ddeboer 
    };						# Window 
end;						# stipulate


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
