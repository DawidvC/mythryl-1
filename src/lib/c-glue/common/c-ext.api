
#  C vectors on ML heap.
#
#  T vec is an ML object that whose address can be passed to a C function, 
#   as long as it is not retained (by the function)  
#  This mechanism is used to pass call-by-reference parameter cheaply.
#  In general, this is what we do:
#
#  1. we first allocate a vec on the heap.
#  2. initialize it (when necessary)
#  3. call the function and pass the address of the vec object 
#  4. extract contents from the vec (when necessary)
# 
#  NOTE: constness gets in the way of code generation so I don't bother
#        encoding it.  These functions should not be used directly.


api Cext =
api

   type vec( T )

   #  Extract the underlying representation 
   my c_string: String -> vec( c::uchar )

       # A note on c_string:
       #
       # Non-zero length string in ML is represented as
       # a pair: (length, pointer to '\0' terminated data)
       # We can use c_string to extract that pointer.
       #
       # However, an empty string in ML is represented as
       # a pair: 0, and ml Void (1 in internal representation).
       # This means that we have to treat this specially. 
       # This is probably a bug in the runtime/compiler.


   my c_char_vector:    char_vector::Vector -> vec( c::uchar )
   my c_char_array:     rw_char_vector::Rw_Vector -> vec( c::uchar )
   my c_double_array:   rw_float_vector::Rw_Vector -> vec( c::double )
   my c_double_vector:  real Vector -> vec( c::double )
   my c_word8_array:    rw_unt8_vector::Rw_Vector -> vec( c::uchar )
   my c_word8_vector:   unt8_vector::Vector -> vec( c::uchar )

   #  Allocate a vector of C objects on ML's heap 
   my c_alloc:     Int -> vec( T )                  #  n 32-bit words 
   my c_alloc64:   Int -> vec( T )                  #  n 64-bit dwords (64-bit alignment) 
   my cast:        vec( T ) -> vec( T' )

   package get:
   api
      my schar:   vec( c::schar ) * unt32::word -> mlrep::signed::Int
      my uchar:   vec( c::uchar ) * unt32::word -> mlrep::unsigned::word
      my sshort:  vec( c::sshort ) * unt32::word -> mlrep::signed::Int
      my ushort:  vec( c::ushort ) * unt32::word -> mlrep::unsigned::word
      my sint:    vec( c::sint ) * unt32::word -> mlrep::signed::Int
      my uint:    vec( c::uint ) * unt32::word -> mlrep::unsigned::word
      my slong:   vec( c::slong ) * unt32::word -> mlrep::signed::Int
      my ulong:   vec( c::ulong ) * unt32::word -> mlrep::unsigned::word
      my float:   vec( c::float ) * unt32::word -> mlrep::float::real
      my double:  vec( c::double ) * unt32::word -> mlrep::float::real
      my ptr:     vec( c::ptr( T ) ) * unt32::word -> c::ptr'( T )
   end 

   package set :
   api
      my schar:   vec( c::schar ) * unt32::word * mlrep::signed::Int -> Void
      my uchar:   vec( c::uchar ) * unt32::word * mlrep::unsigned::word -> Void
      my sshort:  vec( c::sshort ) * unt32::word * mlrep::signed::Int -> Void
      my ushort:  vec( c::ushort ) * unt32::word * mlrep::unsigned::word -> Void
      my sint:    vec( c::sint ) * unt32::word * mlrep::signed::Int -> Void
      my uint:    vec( c::uint ) * unt32::word * mlrep::unsigned::word -> Void
      my slong:   vec( c::slong ) * unt32::word * mlrep::signed::Int -> Void
      my ulong:   vec( c::ulong ) * unt32::word * mlrep::unsigned::word -> Void
      my float:   vec( c::float ) * unt32::word * mlrep::float::real -> Void
      my double:  vec( c::double ) * unt32::word * mlrep::float::real -> Void
      my ptr:     vec( c::ptr( T ) ) * unt32::word * c::ptr'( T ) -> Void
   end 

end
