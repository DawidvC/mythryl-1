/* WARNING: this is generated by running 'nowhere sparcPeephole.peep'.
 * Do not edit this file directly.
 * Version 1.2.2
 */

###line 10.1 "sparcPeephole::peep"
generic package SparcPeephole(
###line 11.5 "sparcPeephole::peep"
                      package instruction:  SPARCINSTR

###line 12.5 "sparcPeephole::peep"
                      package Eval:  Codetree_Eval

###line 13.7 "sparcPeephole::peep"
                      sharing Eval::T = instruction::T
                     ): PEEPHOLE =
pkg

###line 16.4 "sparcPeephole::peep"
   package i = instruction

###line 17.4 "sparcPeephole::peep"
   package cb = cells_basis

###line 20.4 "sparcPeephole::peep"
   fun peephole instrs = 
       let 
###line 21.8 "sparcPeephole::peep"
           fun isZero (i::LAB le) = (((Eval::valueOf le) = 0) except _ => FALSE
)
             | isZero (i::REG r) = (cb::registerNum r) = 0
             | isZero (i::IMMED i) = i = 0
             | isZero _ = FALSE

###line 26.8 "sparcPeephole::peep"
           fun removable p_0 = 
               let v_9 = p_0
                   fun state_5 () = FALSE
                   fun state_2 (v_0, v_1, v_2) = 
                       let d = v_0
                           and i = v_1
                           and r = v_2
                       in (cb::sameColor (r, d)) and (isZero i)
                       end
               in 
                  let v_8 = v_9
                  in 
                     (case v_8 of
                       i::NOTE v_5 => 
                       let my { a=v_7, i=v_6, ... } = v_5
                       in 
                          let a = v_7
                              and i = v_6
                          in removable i
                          end
                       end
                     | i::INSTRUCTION v_5 => 
                       (case v_5 of
                         i::ARITH v_4 => 
                         let my { a=v_3, d=v_0, i=v_1, r=v_2, ... } = v_4
                         in 
                            (case v_3 of
                              i::ADD => state_2 (v_0, v_1, v_2)
                            | i::SUB => state_2 (v_0, v_1, v_2)
                            | _ => state_5 ()
                            )
                         end
                       | _ => state_5 ()
                       )
                     | _ => state_5 ()
                     )
                  end
               end

###line 31.8 "sparcPeephole::peep"
           fun loop (current, instrs) = 
               let v_13 = current
               in 
                  (case v_13 of
                    op . v_12 => 
                    let my (v_11, v_10) = v_12
                    in 
                       let i = v_11
                           and rest = v_10
                       in (if (removable i)
                             then (loop (rest, instrs))
                             else 
                             let i = v_11
                                 and rest = v_10
                             in loop (rest, i . instrs)
                             end)
                       end
                    end
                  | NIL => instrs
                  )
               end
       in loop (instrs, [])
       end
end

