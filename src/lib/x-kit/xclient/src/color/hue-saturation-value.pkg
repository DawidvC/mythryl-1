## hue-saturation-value.pkg
#
# Various color space utilities.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6



###         "I have never known any distress that an
###          hour's reading did not relieve."
###
###                             -- Charles Louis de Secondat,
###                                Baron de la Brede et de Montesquieu 



stipulate
    package xt  = xtypes;							# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
herein
    package hue_saturation_value: (weak)  Hue_Saturation_Value {		# Hue_Saturation_Value		is from   src/lib/x-kit/xclient/src/stuff/color.api

	maxrgb = 65535.0;

	Hsv = HSV { hue:          Float,
		    saturation:   Float,
		    value:        Float
		  };

	fun to_floats (HSV v)
	    =
	    v;

	fun from_floats v							# XXX BUGGO FIXME:  Should do some sort of validation (restriction to [0,1) interval). What exception should we throw? Or should we silently truncate?
	    =
	    HSV v;

	fun max (a:  Float, b) = if (a >= b) a; else b; fi;
	fun min (a:  Float, b) = if (a <= b) a; else b; fi;

	fun sc r  =  unt::from_int (float::truncate (maxrgb*r));
	fun w2r w =  real (unt::to_int_x w);

	fun rgb_to_hsv (xt::RGB { red, green, blue } )
	    =
	    {   realr = (w2r red)//maxrgb;
		realg = (w2r green)//maxrgb;
		realb = (w2r blue)//maxrgb;

		max_v = max (realr, max (realg, realb));
		min_v = min (realr, min (realg, realb));

		delta = max_v - min_v;

		if (float::(====) (delta, 0.0))
		    #                
		     HSV { hue=>0.0, saturation=>0.0, value=>max_v };
		else 
		    saturation = delta // max_v;

		    rc = (max_v - realr)//delta;
		    gc = (max_v - realg)//delta;
		    bc = (max_v - realb)//delta;

		    h1 = if   (float::(====) (realr, max_v) ) bc - gc;
			 elif (float::(====) (realg, max_v) ) 2.0 + rc - bc;
			 else 4.0 + gc - rc;
			 fi;
		    h2 = 60.0 * h1;                    #   Convert to degrees 

		    hue = if (h2 < 0.0)  h2 + 360.0; #  make nonnegative 
			  else           h2;
			  fi;

		    HSV { hue, saturation, value=>max_v };
		 fi;
	      };

	fun hsb_to_rgb (HSV { saturation, value, hue } )
	    =
	    if (float::(====) (saturation, 0.0))
		#
		v = sc value;   xt::RGB { red=>v, green=>v, blue=>v }; 
	    else
		h = if (float::(====) (hue, 360.0) ) 0.0; else hue//60.0;fi;
		i = floor h;

		ri = real i;
		f = h - ri;

		p = value*(1.0 -  saturation);
		q = value*(1.0 - (saturation*f));
		t = value*(1.0 - (saturation*(1.0 - f)));

		fun mkrgb (r, g, b)
		    =
		    xt::RGB { red   =>  sc r,
			      green =>  sc g,
			      blue  =>  sc b
			    };

		case i
		    #
		    0 =>  mkrgb (value, t, p);
		    1 =>  mkrgb (q, value, p);
		    2 =>  mkrgb (p, value, t);
		    3 =>  mkrgb (p, q, value);
		    4 =>  mkrgb (t, p, value);
		    _ =>  mkrgb (value, p, q);
		esac;
	    fi;

    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
