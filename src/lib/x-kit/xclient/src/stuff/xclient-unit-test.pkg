## xclient-unit-test.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6

# NB: We must compile this locally via
#         xclient-internals.make6
#     instead of globally via
#         src/lib/test/unit-tests.make6
#     like most unit tests, in order to have
#     access to required library internals.

# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include unit_test;
    include make7::scripting_globals;
    #
    package ctl =  thread_scheduler_control;			# thread_scheduler_control	is from   src/lib/thread-kit/src/unix/thread-scheduler-control.pkg
    package tr  =  tracing;					# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg
    package xtr =  xtracing;					# xtracing			is from   src/lib/x-kit/xclient/src/stuff/xtracing.pkg
    package sox =  socket_stuff;				# socket_stuff			is from   src/lib/internet/socket-stuff.pkg
    package xok =  xsocket;					# xsocket			is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w   =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package g   =  geometry;					# geometry			is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    #
    tracefile   =  "xclient-unit-test-trace.log";
herein

    package xclient_unit_test {

	name = "src/lib/x-kit/xclient/src/stuff/xclient-unit-test.pkg";

	trace =  xtr::print_if  xtr::io_tracing;		# Conditionally write strings to tracing.log or whatever.

	default_time_quantum					# Copied from src/lib/x-kit/widget/lib/run-xkit.pkg
	    =
	    time::from_milliseconds 20;

	fun exercise_window_stuff  (xdisplay:  dy::Xdisplay)
	    =
	    {   xdisplay -> dy::XDISPLAY { default_screen, screens, next_xid, xsocket, ... };

		screen =  list::nth  (screens, default_screen);

		screen -> dy::XSCREEN { root_window_id => parent_id, root_visual, black_pixel, white_pixel, ... };

		background_pixel = white_pixel;
		border_pixel     = black_pixel;

		window_id =  next_xid ();

		xevent_in'
                    =
                    xok::wait_for_xevent  xsocket;


		case root_visual
		    #
		    xt::NO_VISUAL_FOR_THIS_DEPTH int
                        =>
                        {   # This case should never happen.
			    assert FALSE;
			    print "root_visual is NO_VISUAL_FOR_THIS_DEPTH?!\n";
			};

		    xt::VISUAL { depth, visual_id, ... }
                        =>
                        {   printf "root_visual is VISUAL as expected, depth d=%d.\n" depth;

			    create_window_request
				=
				v2w::encode_create_window
				      {
					window_id,
					parent_id,
					visual_id => xt::SAME_VISUAL_AS_PARENT,
					#
					depth,
					io        => xt::INPUT_OUTPUT,
					#
					site =>
                                            g::WINDOW_SITE
					      { upperleft    =>  g::POINT { col=>100, row=>100 },
						size         =>  g::SIZE { wide=>400, high=>400 },
						border_width =>  1
					      },

					attributes
					    =>
					    [ xt::wa::BORDER_PIXEL     border_pixel,
					      xt::wa::BACKGROUND_PIXEL background_pixel,
					      xt::wa::EVENT_MASK        w::standard_xevent_mask
					    ]
				      };

trace .{ sprintf "xclient_unit_test: Now  writing create_window_request to socket."; };
#			    sox::send_vector (socket, create_window_request);
trace .{ sprintf "xclient_unit_test: Done writing create_window_request to socket."; };


trace .{ sprintf "xclient_unit_test: Now  reading back header of reply for create_window request."; };
#			    header = rse::do_syscall_retry_on_eintr					# We need this retry mechanism because our 50Hz SIGALRM
#					 #								# timer may hit before the X server reply gets back to us.
#					 sox::receive_vector (socket, 8);
trace .{ sprintf "xclient_unit_test: Done reading back header of reply for create_window request."; };
			};
		esac;



#		window
#		    =
#	            create_window
#	    :
#	    xok::Xsocket
#	    ->
#	     { id:      xt::Window_Id,
#	       parent:  xt::Window_Id,
#	       #
#	       in_only: Null_Or( Bool ),
#	       depth:   Int,
#	       visual:  Null_Or( xt::Visual_Id ),
#	       #
#	       geometry:    g::Window_Site,
#	       attributes:  List( Xwin_Val )
#	     }
#	    ->
#	    Void;

		();
	    };

	fun run ()
	    =
	    {   printf "\nDoing %s:\n" name;   

		# Remove any old version of the tracefile:
		#
		if (isfile tracefile)
		    #
		    unlink tracefile;
		fi;

		# Open tracelog file and
                # select tracing level:
		#
		{   include tracing;				# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg
		    #
		    log_trace_messages  (TO_FILE tracefile);
		    #
		    enable all_tracing;				# Gross overkill.
#		    enable xtr::xkit_tracing;			# Lesser overkill.
#		    enable xtr::io_tracing;			# Saner yet.	
		};

	        ctl::start_up_thread_scheduler'
		    default_time_quantum
		   .{
			assert  (ctl::thread_scheduler_is_running ());

		        my  ( display_name:     String,						# Typically from $DISPLAY environment variable.
			      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
			    )
			    =
			    au::get_xdisplay_string_and_xauthentication  NULL;

			trace .{ sprintf "xclient_unit_test: DISPLAY variable is set to '%s'" display_name; };

			trace .{ sprintf "xclient_unit_test: Now  calling dy::open_xdisplay"; };

			{   xdisplay =  dy::open_xdisplay { display_name, xauthentication };	# Raises dy::XSERVER_CONNECT_ERROR on failure.
				

			    trace .{ sprintf "xclient_unit_test: Done calling dy::open_xdisplay"; };

			    exercise_window_stuff  xdisplay;

#                           do_it (make_root_window NULL);

			} except
			    dy::XSERVER_CONNECT_ERROR string
				=
				{   fprintf file::stderr "xclient_unit_test: Could not connect to X server: %s\n" string;
				    fprintf file::stderr "xclient_unit_test: *** OMITTING XCLIENT UNIT TESTS. ***\n";

			            trace .{ sprintf "xclient_unit_test: Could not connect to X server: %s" string; };
			            trace .{         "xclient_unit_test: *** OMITTING XCLIENT UNIT TESTS. ***";     };

		                    assert FALSE;
				};

			trace .{ sprintf "xclient-unit-test.pkg: Now  calling ctl::shut_down_thread_scheduler"; };

			ctl::shut_down_thread_scheduler  winix::process::success;
		    };

		# Close tracelog file:
		#
		{   include tracing;				# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg

		    tracing_to =  currently_tracing_to ();

		    log_trace_messages  TO_STDERR;

		    case tracing_to
			#
			TO_STREAM stream =>  file::close_output stream;
			#
			_                =>  ();
                    esac;
		};

		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;