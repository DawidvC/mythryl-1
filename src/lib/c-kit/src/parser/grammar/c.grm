#  DO NOT CHANGE THIS FILE -- this file was generated from cd.grm 


#  new comments from Satish Chandra, 6/21/99 

# Overriding design approach: 
#
# Accept all legal programs, but possibly some illegal ones at this stage. 
# Do not attempt to make a really tight grammar. Our tools are supposed to
# work on "correct" C programs (i.e. those that cc -ansi would compile without
# warnings). Of course, a type checker on the parse tree can report some errors
# as syntax errors.
#
# Note on MARK:
#
# External_Decl, statement, and expression are the non-terms that are marked.
# Compound statements are not separately marked.
# declarations eventually become either a statement or a External_Decl
#   if they are outside any function. They are marked accordingly.
#
# Note on function definitions:
#
# The order of the paramaters will always come from the FUNC_DECR.
# The types of the parameter may come from the second declaration list  
# (in K&R style)
#
# Note on the package of the grammar:
#
# It is difficult to write a LALR(1) grammar based on the grammar given at
# the back of the K&R book. The basic difficulty is that both TYPE_NAME and
# IDENTIFIER are tokens that are strings, but it depends on the context whether
# a given string is to be treated as an IDENTIFIER or a TYPE_NAME.
# We have borrowed the solution used in GCC's parser specification. In this
# scheme, the lexer always return the token TYPE_NAME if a name has been 
# defined as a type name (via a typedef) in an applicable scope. The grammar 
# productions are heavily rearranged (from K&R's grammar) to do the right 
# thing. In this rearrangement, the basic idea is that a TYPE_NAME is  
# allowed to appear in a declaration as a plain identifier only after a type 
# specifier has previously appeared in the declaration. Also, a TYPE_NAME may 
# appear only once in a declaration as a type specifier.


#  old comments below 
#  Shortcomings 
# 1. No floating-point whatsoever

# Notes on MARK:
# External_Decl and statement are the non-terms that are marked.
# Compound statements are not separately marked.
# expressions are not marked at all.
# declarations eventually become either a statement or a External_Decl
#   if they are outside any function. they are marked accordingly.

 
# Overriding theme: accept all legal programs, but also some illegal ones at this
# stage. Do not attempt to make a really tight grammar. Our tools are supposed to
# work on "correct" C programs (i.e. those that cc -ansi would compile without
# warnings). Of course, a type checker on the parse tree can report some errors
# as syntax errors.



###                      "You can either have software quality
###                       or you can have pointer arithmetic,
###                       but you cannot have both at the same time."
###
###                                            -- Bertrand Meyer



# About function definitions:
# The order of the parameters will always come from the FUNC_DECR thing 
# The types of the parameter may come from the second declaration list  (in K&R style)


include parse_tree; # PortingHelp



fun mark_external_decl src_map (d, left, right)
    = 
    MARKEXTERNAL_DECL(source_map::location src_map (left, right), d);



fun mark_declaration src_map (d, left, right)
    = 
    MARKDECLARATION(source_map::location src_map (left, right), d);



fun mark_declarator src_map (d, left, right)
    = 
    MARKDECLARATOR(source_map::location src_map (left, right), d);



fun mark_statement src_map (s, left, right)
    = 
    MARKSTATEMENT(source_map::location src_map (left, right), s);



fun mark_expression src_map (s, left, right)
    = 
    MARKEXPRESSION(source_map::location src_map (left, right), s);

unknown = { storage => [], qualifiers => [], specifiers => [] }: Decltype;

# This code duplicated in BuildRawSyntaxTree in function processDeclarator:

fun ctype_decr_to_type_name (type as { qualifiers, specifiers }, decr)
    =
    {   fun mk_typ spc =   { qualifiers => [], specifiers => [spc] };
        fun add_qual q =   { qualifiers => q ! qualifiers, specifiers };

        case decr

	    VAR_DECR x => (type, THE x);

	    POINTER_DECR x
                =>
	        ctype_decr_to_type_name (mk_typ (POINTER type), x);

	    ARRAY_DECR (x, size)
                =>
	        ctype_decr_to_type_name (mk_typ (ARRAY (size, type)), x);

	    FUNC_DECR (x, lst)
                =>
	        ctype_decr_to_type_name (mk_typ (FUNCTION { ret_type => type, parameters => lst } ), x);

	    QUAL_DECR (q, decr)
                =>
	        ctype_decr_to_type_name (add_qual q, decr);

	    EMPTY_DECR                =>  (type, NULL);
	    ELLIPSES_DECR             =>  (mk_typ ELLIPSES, THE("**ellipses**"));
	    DECR_EXT _                =>  (type, NULL);   # Should call decr extension?
	    MARKDECLARATOR(loc, decr) =>  ctype_decr_to_type_name(type, decr);

        esac;
     };

fun dclr2str dcl
  = 
  case (ctype_decr_to_type_name ({ qualifiers => [], specifiers => [] }, dcl))

      (_, THE s) =>  s;
      (_, NULL)  =>  "";
  esac;

fun combine_decltypes ( { qualifiers => q1, storage => st1, specifiers => sp1 },
	                { qualifiers => q2, storage => st2, specifiers => sp2 }
	              )
  =
  { qualifiers => q1@q2, storage => st1@st2, specifiers => sp1@sp2 };      #   @ ok

fun apply_pointer (POINTER_DECR x, rest) => POINTER_DECR (apply_pointer (x, rest));
    apply_pointer (QUAL_DECR (q, x), rest) => QUAL_DECR (q, apply_pointer (x, rest));
    apply_pointer (EMPTY_DECR, rest) => rest;
    apply_pointer (_, rest) => rest;
end;  
    /* NCH/David B MacQueen[6/14/99]: this case can never occur  */



fun add_storage (st, { qualifiers, storage, specifiers } )
    =
    { qualifiers, storage => st ! storage, specifiers };



fun add_qualifiers (qs, { qualifiers, storage, specifiers } )
    =
    { qualifiers => qs@qualifiers, storage, specifiers };    #   @ ok



fun add_qualifier (q, { qualifiers, storage, specifiers } )
    =
    { qualifiers => q ! qualifiers, storage, specifiers };



fun add_specifier (sp, { qualifiers, storage, specifiers } )
    =
    { qualifiers, storage, specifiers => sp ! specifiers };



add_all = combine_decltypes;

fun loop_qd (q ! rst, acc) => loop_qd(rst, QUAL_DECR (q, acc));
    loop_qd (NIL, acc) => acc;
end;

fun mk_ctype type = type;


# David B MacQueen: major kludge, using TYPEDEF as storage ilk 

fun insert_decl_names ({ storage, ... }: Decltype, idl)
    =
    case storage
         [TYPEDEF] =>  list::apply (fn x as (dcl, _) =  type_defs::add_tdef    (dclr2str dcl))  idl;
         _         =>  list::apply (fn x as (dcl, _) =  type_defs::add_no_tdef (dclr2str dcl))  idl;
    esac;

fun insert_func_name dcl
      =
      {   name = dclr2str dcl;
	  type_defs::add_no_tdef name;
      };

fun insert_func_params (FUNC_DECR (_, parameters)) : Void
    => 
    {   fun get_name (ct, dclr)
            =
            dclr2str dclr;

	names = map get_name parameters;

        list::apply type_defs::add_no_tdef names;
    };

    insert_func_params (ARRAY_DECR (dcl, _)) => insert_func_params dcl;
    insert_func_params (POINTER_DECR dcl) => insert_func_params dcl;
    insert_func_params _ => ();    # This is actually an error, but it will be caught in
end;		                 # BuildRawSyntaxTree when processing a xt::FUNCTION_DEF

abstype Seq X = SEQ List( X )
with empty_seq = SEQ NIL;
     fun singleton_seq x = SEQ [x];
     fun add_to_seq (x, SEQ yl) = SEQ(x ! yl);      # add to end of sequence!
#    fun addListToEnd(xl, yl) = SEQ((list::reverse xl) @ yl);

     fun add_opt_to_end (NULL,  yl    ) =>   yl;
         add_opt_to_end (THE x, SEQ yl) =>   SEQ(x ! yl);
     end;

     fun seq_to_list (SEQ yl)
         =
         list::reverse yl;
end;

%%

%header (generic package lr_vals_g(package token : Token; 
			    ))

%term 
 	  EOF 
	| COLON | SEMICOLON | LPAREN | RPAREN | LCURLY | RCURLY 
	| LBRACE | RBRACE | DOT 
	| COMMA | QUESTION | PERCENT | AMP | BAR | TILDE | DIVIDE | PLUS
	| MINUS | HAT | BANG | TIMES
	| INC | DEC | ARROW
	| IDENTIFIER of String  
	| EQUALS | PLUSEQUALS | MINUSEQUALS | XOREQUALS | MODEQUALS 
	| TIMESEQUALS | DIVEQUALS | OREQUALS  | ANDEQUALS | LSHIFTEQUALS 
	| RSHIFTEQUALS
	| LTE | GTE | LT | GT | EQ | NEQ | OR_T | AND_T | LSHIFT | RSHIFT
	| DECNUM of large_int::Int
        | REALNUM of Float 
	| STRING_CONSTANT of String 
	| CCONST of large_int::Int
	| EXTERN | AUTO | STATIC | REGISTER | CONST | VOLATILE
	| IF_T | THEN_T | ELSE_T
	| FOR_T | DO_T |  SWITCH | CASE_T | DEFAULT
	| WHILE_T | RETURN 
	| BREAK | CONTINUE | GOTO
	| CHAR | DOUBLE | ENUM_T | FLOAT | INT | LONG | SHORT
        | FRACTIONAL | SATURATE                                /* D */
	| STRUCT | UNION | UNSIGNED | SIGNED
	| VOID | SIZEOF | TYPEDEF | UNARY
	| ELIPSIS
	| TYPE_NAME of String

%nonterm 
	translationUnit of List External_Decl
	| tu of Seq External_Decl
	| statement of Statement
	| ostatementlist of List Statement

	| statementlist of Seq Statement
	| compoundstatement of Statement
	| expr of Expression
	| opexpr of Expression
	| exprwcomma of Expression
	| unaryoperator of Operator
	| argumentexprlist of Seq Expression
	| trailingcomma of Bool
	| enumeratorlist of Seq( (String, Expression) )
	| enumerator of (String, Expression)
	| abstractdeclarator of Declarator
	| directabstractdeclarator of Declarator
	| initdeclarator of (Declarator, Expression)
	| notypeinitdeclarator of (Declarator, Expression)
	| initdeclaratorlist of  Seq( (Declarator, Expression) )
	| notypeinitdeclaratorlist of Seq( (Declarator, Expression) )
	| pointer of Declarator
	| declarator of Declarator
        | aftertypedeclarator of Declarator
        | notypedeclarator of Declarator
        | parmdeclarator of Declarator
	| aftertypedirectdeclarator of Declarator
	| notypedirectdeclarator of Declarator
        | parmdirectdeclarator of Declarator
	| declarationspecifiers of Decltype 
	| declarationmodifiers of Decltype
        | reservedeclarationspecifier of Decltype
        | specifierqualifierreserved of Ctype
	| reservedspecifierqualifiers of Ctype
	| initializer of Expression
	| initializerlist of Seq Expression
	| storageilkspecifier of Storage
	| typename of Ctype
	| typespecifier of Specifier
        | typespecifierreserved of Specifier
	| typequalifier of Qualifier
        | typequalifierlist of List Qualifier
	| specifierqualifierlist of Ctype
	| enumspecifier of Specifier
	| structorunionspecifier of Specifier
	| fdefdeclaration of (Decltype, Declarator)
	| declarationlist of Seq Declaration
	| identlist of Seq( (String, Int, Int) )
	| functiondefinition of External_Decl
	| declaration of Declaration
	| declaration1 of Declaration
	| externaldeclaration of Null_Or External_Decl
	| parameterlist of Seq( (Decltype, Declarator) )
	| parametertypelist of List( (Decltype, Declarator) )
	| parameterdeclaration of (Decltype, Declarator)
	| structorunion of Bool
	| structdeclarator of (Declarator, Expression)
	| notypestructdeclarator of (Declarator, Expression)
	| structdeclaratorlist of Seq( (Declarator, Expression) )
	| notypestructdeclaratorlist of Seq( (Declarator, Expression) )
	| structdeclarationlist of Seq( (Ctype, List( (Declarator, Expression))) )
	| structdeclaration of (Ctype, List( (Declarator, Expression)) )
	| pushScope of Void
        | popScope of Void
        | strings of String





%pos Int
%verbose
%pure
%start translationUnit
%eop EOF 
%noshift EOF
%keyword QUESTION IF_T THEN_T ELSE_T FOR_T DO_T SWITCH CASE_T DEFAULT WHILE_T RETURN BREAK CONTINUE GOTO
%subst TYPE_NAME for IDENTIFIER
%value TYPE_NAME({ error::hint "Likely cause: missing typedef declaration.\n"; "bogus"; } )

%arg (src_map) : source_map::Sourcemap

%name Ckit

%left COMMA
%right EQUALS PLUSEQUALS MINUSEQUALS TIMESEQUALS DIVEQUALS MODEQUALS XOREQUALS OREQUALS ANDEQUALS LSHIFTEQUALS RSHIFTEQUALS
%right QUESTION
%left OR_T
%left AND_T
%left BAR
%left HAT
%left AMP
%left EQ NEQ
%left LT GT LTE GTE
%left LSHIFT RSHIFT
%left PLUS MINUS
%left TIMES DIVIDE PERCENT
%right UNARY
%right INC DEC SIZEOF
%left LBRACE LPAREN ARROW DOT

%%

translationUnit:  
	tu			(seq_to_list tu)

tu:
					(empty_seq)
	| tu externaldeclaration	(add_opt_to_end (externaldeclaration, tu))

externaldeclaration:
	  declaration			(THE(mark_external_decl src_map (EXTERNAL_DECL declaration,
						                       declarationleft,
								       declarationright)))
	| SEMICOLON			(NULL)
	| functiondefinition		(THE(mark_external_decl src_map (functiondefinition,
						   	               functiondefinitionleft,
							               functiondefinitionright)))

statement:
	FOR_T LPAREN opexpr SEMICOLON opexpr SEMICOLON opexpr RPAREN statement
					(mark_statement src_map (FOR(opexpr1, opexpr2, opexpr3, statement),
							for_tleft, statementright))
	| WHILE_T LPAREN exprwcomma RPAREN statement
					(mark_statement src_map (WHILE(exprwcomma, statement),
							while_tleft, statementright))
	| SWITCH LPAREN exprwcomma RPAREN statement
					(mark_statement src_map (SWITCH(exprwcomma, statement),
							switchleft, statementright))
	| DO_T statement WHILE_T LPAREN exprwcomma RPAREN SEMICOLON
					(mark_statement src_map (DO(exprwcomma, statement),
							do_tleft, semicolonright))
	| BREAK SEMICOLON		(mark_statement src_map (BREAK, 
							breakleft, semicolonright))
	| CONTINUE SEMICOLON		(mark_statement src_map (CONTINUE, 
							continueleft, semicolonright))
	| RETURN opexpr SEMICOLON	(mark_statement src_map (RETURN(opexpr), 
							returnleft, semicolonright))
	| GOTO IDENTIFIER SEMICOLON	(mark_statement src_map (GOTO(identifier), 
							gotoleft, semicolonright))
	| compoundstatement		(compoundstatement)
	| IDENTIFIER COLON statement	(mark_statement src_map (LABELED (identifier, statement),
							identifierleft, statementright))
	| DEFAULT COLON statement	(mark_statement src_map (DEFAULT_LABEL(statement),
							defaultleft, statementright))
	| CASE_T exprwcomma COLON statement		
					(mark_statement src_map (CASE_LABEL(exprwcomma, statement),
							case_tleft, statementright))
	| IF_T LPAREN exprwcomma RPAREN statement
					(mark_statement src_map (IF_THEN (exprwcomma, statement),
							if_tleft, statementright))
	| IF_T LPAREN exprwcomma RPAREN statement ELSE_T statement
					(mark_statement src_map (IF_THEN_ELSE (exprwcomma, statement1, statement2),
							if_tleft,
							statement2right))
        | exprwcomma SEMICOLON	(mark_statement src_map (EXPR (exprwcomma),
							exprwcommaleft, semicolonright))
	| SEMICOLON		        (mark_statement src_map (EXPR(EMPTY_EXPR),
							semicolonleft, semicolonright))






declaration:
          declaration1 SEMICOLON        (declaration1)


declaration1:
      declarationspecifiers
					(   {   insert_decl_names (declarationspecifiers, []);

						mark_declaration src_map
						  (DECLARATION (declarationspecifiers, []), 
						   declarationspecifiersleft, declarationspecifiersright);
					    } 
					)

    | declarationspecifiers
      initdeclaratorlist	        (   {   decl = (declarationspecifiers, seq_to_list initdeclaratorlist);
					        insert_decl_names decl;
						mark_declaration src_map
						  (DECLARATION decl, declarationspecifiersleft, initdeclaratorlistright);
					    }
                                        )

    | declarationmodifiers
      notypeinitdeclaratorlist
					(    {   decl = (declarationmodifiers, seq_to_list notypeinitdeclaratorlist);
					         insert_decl_names decl;
					         mark_declaration src_map
					             (DECLARATION decl, declarationmodifiersleft, notypeinitdeclaratorlistright);
					     }
                                        )

ostatementlist:	 
	statementlist 			(seq_to_list statementlist)
	| 				([])

statementlist:
	statement			(singleton_seq statement)
	| statementlist statement	(add_to_seq(statement, statementlist))


/* original code: changed for "let" statements in D */
compoundstatement: 
	  LCURLY pushScope declarationlist ostatementlist popScope RCURLY
					(mark_statement src_map (COMPOUND ((map DECL (seq_to_list declarationlist)) @ ostatementlist), lcurlyleft, rcurlyright))
	| LCURLY ostatementlist RCURLY
 					(mark_statement src_map (COMPOUND (ostatementlist), lcurlyleft, rcurlyright))
/* */





unaryoperator: 
	AMP	(ADDR_OF)
	| TIMES (STAR)
	| PLUS  (UPLUS)
	| MINUS (NEGATE)
	| TILDE (BIT_NOT)
	| BANG  (NOT)

expr:
	expr QUESTION exprwcomma COLON expr %prec QUESTION (mark_expression src_map (QUESTION_COLON(expr1, exprwcomma1, expr2), expr1left, expr2right))
        | expr PLUSEQUALS expr  	(mark_expression src_map (BINOP(PLUS_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr MINUSEQUALS expr		(mark_expression src_map (BINOP(MINUS_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr TIMESEQUALS expr		(mark_expression src_map (BINOP(TIMES_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr DIVEQUALS expr		(mark_expression src_map (BINOP(DIV_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr MODEQUALS expr		(mark_expression src_map (BINOP(MOD_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr XOREQUALS expr		(mark_expression src_map (BINOP(XOR_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr OREQUALS expr		(mark_expression src_map (BINOP(OR_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr ANDEQUALS expr		(mark_expression src_map (BINOP(AND_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr LSHIFTEQUALS expr	(mark_expression src_map (BINOP(LSHIFT_ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr RSHIFTEQUALS expr	(mark_expression src_map (BINOP(RSHIFT_ASSIGN, expr1, expr2), expr1left, expr2right))
	| expr EQUALS expr 		(mark_expression src_map (BINOP(ASSIGN, expr1, expr2), expr1left, expr2right))
        | expr OR_T expr  		(mark_expression src_map (BINOP(OR, expr1, expr2), expr1left, expr2right))
        | expr AND_T expr 		(mark_expression src_map (BINOP(AND, expr1, expr2), expr1left, expr2right))
        | expr BAR expr 		(mark_expression src_map (BINOP(BIT_OR, expr1, expr2), expr1left, expr2right))
        | expr HAT expr 		(mark_expression src_map (BINOP(BIT_XOR, expr1, expr2), expr1left, expr2right))
        | expr AMP expr 		(mark_expression src_map (BINOP(BIT_AND, expr1, expr2), expr1left, expr2right))
        | expr EQ expr 			(mark_expression src_map (BINOP(EQ, expr1, expr2), expr1left, expr2right))
        | expr NEQ expr 		(mark_expression src_map (BINOP(NEQ, expr1, expr2), expr1left, expr2right))
        | expr LT expr 			(mark_expression src_map (BINOP(LT, expr1, expr2), expr1left, expr2right))
        | expr GT expr 			(mark_expression src_map (BINOP(GT, expr1, expr2), expr1left, expr2right))
        | expr LTE expr			(mark_expression src_map (BINOP(LTE, expr1, expr2), expr1left, expr2right))
        | expr GTE expr			(mark_expression src_map (BINOP(GTE, expr1, expr2), expr1left, expr2right))
        | expr LSHIFT expr		(mark_expression src_map (BINOP(LSHIFT, expr1, expr2), expr1left, expr2right))
        | expr RSHIFT expr		(mark_expression src_map (BINOP(RSHIFT, expr1, expr2), expr1left, expr2right))
        | expr PLUS expr		(mark_expression src_map (BINOP(PLUS, expr1, expr2), expr1left, expr2right))
        | expr MINUS expr		(mark_expression src_map (BINOP(MINUS, expr1, expr2), expr1left, expr2right))
        | expr TIMES expr		(mark_expression src_map (BINOP(TIMES, expr1, expr2), expr1left, expr2right))
        | expr DIVIDE expr		(mark_expression src_map (BINOP(DIVIDE, expr1, expr2), expr1left, expr2right))
        | expr PERCENT expr		(mark_expression src_map (BINOP(MOD, expr1, expr2), expr1left, expr2right))
	| expr INC %prec INC		(mark_expression src_map (UNOP(POST_INC, expr), exprleft, incright))
	| expr DEC %prec INC		(mark_expression src_map (UNOP(POST_DEC, expr), exprleft, decright))
	| INC expr %prec INC		(mark_expression src_map (UNOP(PRE_INC, expr), incleft, exprright))
	| DEC expr %prec INC	 	(mark_expression src_map (UNOP(PRE_DEC, expr), decleft, exprright))
	| unaryoperator expr  %prec UNARY (mark_expression src_map (UNOP(unaryoperator, expr), unaryoperatorleft, exprright))
	| SIZEOF expr  			(mark_expression src_map (UNOP(SIZEOF, expr), sizeofleft, exprright))
	| LPAREN typename RPAREN expr %prec INC 
					(mark_expression src_map (CAST (typename, expr), lparenleft, exprright))
	| SIZEOF LPAREN typename RPAREN %prec SIZEOF 
					(mark_expression src_map (UNOP(SIZEOF_TYPE typename, EMPTY_EXPR), sizeofleft, rparenright))
	| expr LBRACE exprwcomma RBRACE
					(mark_expression src_map (BINOP(SUB, expr, exprwcomma), exprleft, rbraceright))



	| expr LPAREN RPAREN		(mark_expression src_map (CALL(expr,[]), exprleft, rparenright))
	| expr LPAREN argumentexprlist RPAREN
					(mark_expression src_map (CALL(expr, seq_to_list argumentexprlist), exprleft, rparenright))
	| expr DOT IDENTIFIER		(mark_expression src_map (BINOP(DOT, expr, ID(identifier)), exprleft, identifierright))
	| expr ARROW IDENTIFIER		(mark_expression src_map (BINOP(ARROW, expr, ID(identifier)), exprleft, identifierright))
	| expr DOT TYPE_NAME		(mark_expression src_map (BINOP(DOT, expr, ID(type_name)), exprleft, type_nameright))
	| expr ARROW TYPE_NAME		(mark_expression src_map (BINOP(ARROW, expr, ID(type_name)), exprleft, type_nameright))
	| LPAREN exprwcomma RPAREN	(mark_expression src_map (exprwcomma, lparenleft, rparenright))
	| DECNUM			(mark_expression src_map (INT_CONST decnum, decnumleft, decnumright))
        | REALNUM                       (mark_expression src_map (REAL_CONST realnum, realnumleft, realnumright))
	| CCONST			(mark_expression src_map (INT_CONST cconst, cconstleft, cconstright))
	| IDENTIFIER			(mark_expression src_map (ID(identifier), identifierleft, identifierright))
        | strings                       (mark_expression src_map (STRING(strings), stringsleft, stringsright))


strings:  STRING_CONSTANT               (string_constant)
	| STRING_CONSTANT strings	(string_constant + strings)



exprwcomma:
	  expr 				(expr)
	| exprwcomma COMMA expr 	(mark_expression src_map (BINOP(COMMA, exprwcomma, expr), exprwcommaleft, exprright))

opexpr:					(EMPTY_EXPR)
	| exprwcomma			(exprwcomma)


argumentexprlist:
	 expr				(singleton_seq expr)
	| argumentexprlist COMMA expr   (add_to_seq(expr, argumentexprlist))

typename:
	  specifierqualifierlist  	(specifierqualifierlist)
	| specifierqualifierlist abstractdeclarator
					(#1 (ctype_decr_to_type_name (specifierqualifierlist, abstractdeclarator)))

declarationspecifiers:
          typespecifier reservedeclarationspecifier
                                        (add_specifier (typespecifier,
						        reservedeclarationspecifier))
        | declarationmodifiers typespecifier reservedeclarationspecifier
                                        (add_all (declarationmodifiers,
                                                  add_specifier (typespecifier,
							         reservedeclarationspecifier)))

reservedeclarationspecifier:
                                        (unknown)
    | reservedeclarationspecifier
      specifierqualifierreserved
                                        (   {   my { qualifiers, specifiers } = specifierqualifierreserved;

					        decltype = { qualifiers, specifiers, storage => [] };

	   				        add_all (decltype, reservedeclarationspecifier);
                                            }
                                        )
    | reservedeclarationspecifier
      storageilkspecifier
                                        (add_storage (storageilkspecifier,
                                                      reservedeclarationspecifier))

specifierqualifierreserved:
          typespecifierreserved       ({ qualifiers => [], specifiers => [typespecifierreserved] })
        | typequalifier               ({ qualifiers => [typequalifier], specifiers => [] })
        | structorunionspecifier      ({ qualifiers => [], specifiers => [structorunionspecifier] })
        | enumspecifier               ({ qualifiers => [], specifiers => [enumspecifier] })

declarationmodifiers:
          storageilkspecifier
                                        ({ storage  =>  [storageilkspecifier],
					  qualifiers  =>  [],
					  specifiers  =>  [] })
        | declarationmodifiers storageilkspecifier
                                        (add_storage(storageilkspecifier, declarationmodifiers))
        | typequalifier
                                        ({ specifiers  =>  [],
	 				  storage  =>  [], 
					  qualifiers  =>  [typequalifier] })
        | declarationmodifiers typequalifier
                                        (add_qualifier(typequalifier, declarationmodifiers))

specifierqualifierlist:
      typespecifier
      reservedspecifierqualifiers
                                        (   {   my { specifiers, qualifiers } = reservedspecifierqualifiers;

	                                        { specifiers => typespecifier ! specifiers, qualifiers };
                                            }
                                        )
						       
    | typequalifierlist
      typespecifier
      reservedspecifierqualifiers
					(   {   my { specifiers, qualifiers } = reservedspecifierqualifiers;

						{   specifiers => typespecifier ! specifiers
						,   qualifiers => typequalifierlist@qualifiers
						};
                                            }
                                        )

reservedspecifierqualifiers:
                                        ({ qualifiers => [], specifiers => [] })
    | reservedspecifierqualifiers
      specifierqualifierreserved
                                        (   {   my { specifiers => s1, qualifiers => q1 } = reservedspecifierqualifiers;
					        my { specifiers => s2, qualifiers => q2 } = specifierqualifierreserved;

                                                { specifiers => s1@s2, qualifiers => q1@q2 };
                                            }
                                        )
		
typequalifierlist:
          typequalifier                 ([typequalifier])

	| typequalifier
          typequalifierlist 
                                        (typequalifier ! typequalifierlist)

typespecifier:
          typespecifierreserved		(typespecifierreserved)
        | structorunionspecifier	(structorunionspecifier)
        | enumspecifier    		(enumspecifier)
        | TYPE_NAME			(TYPEDEF_NAME type_name)

typespecifierreserved:
	  VOID				(VOID)
        | CHAR 				(CHAR)
        | SHORT 			(SHORT)
	| INT  				(INT)
	| LONG				(LONG)
        | FLOAT				(FLOAT)
	| DOUBLE			(DOUBLE)
	| SIGNED			(SIGNED)
	| UNSIGNED			(UNSIGNED)


structorunionspecifier:
          structorunion LCURLY structdeclarationlist RCURLY
	       (STRUCT { is_struct => structorunion, tag_opt => NULL, members => seq_to_list structdeclarationlist } )
		
        | structorunion IDENTIFIER LCURLY structdeclarationlist RCURLY
	     (STRUCT{ is_struct => structorunion, tag_opt => THE identifier, members => seq_to_list structdeclarationlist } )

        | structorunion TYPE_NAME LCURLY structdeclarationlist RCURLY
	     (STRUCT{ is_struct => structorunion, tag_opt => THE type_name, members => seq_to_list structdeclarationlist } )

        | structorunion IDENTIFIER 	(STRUCT_TAG { is_struct => structorunion, name => identifier } )

        | structorunion TYPE_NAME 	(STRUCT_TAG { is_struct => structorunion, name => type_name } )

	  /* humor me: consider true for struct */
structorunion:
	  STRUCT 			(TRUE)
	| UNION				(FALSE)

structdeclarationlist:
	  structdeclaration		(singleton_seq structdeclaration)
        | structdeclarationlist structdeclaration
					(add_to_seq(structdeclaration, structdeclarationlist))

structdeclaration:
	specifierqualifierlist structdeclaratorlist SEMICOLON
					((specifierqualifierlist, seq_to_list structdeclaratorlist))

    | typequalifierlist
      notypestructdeclaratorlist
      SEMICOLON
                                        (   {    ct = { qualifiers => typequalifierlist, specifiers => [] };

					         (ct, seq_to_list notypestructdeclaratorlist);
					    }
                                        )

structdeclaratorlist:

      structdeclarator			(singleton_seq structdeclarator)

    | structdeclaratorlist
      COMMA
      structdeclarator
					(add_to_seq(structdeclarator, structdeclaratorlist))

notypestructdeclaratorlist:

      notypestructdeclarator		(singleton_seq notypestructdeclarator)

    | notypestructdeclaratorlist
      COMMA
      structdeclarator
					(add_to_seq(structdeclarator, notypestructdeclaratorlist))

structdeclarator:
	  declarator			(declarator, EMPTY_EXPR)
	| COLON expr			(EMPTY_DECR, expr)
	| declarator COLON expr		(declarator, expr)

notypestructdeclarator:
	  notypedeclarator		(notypedeclarator, EMPTY_EXPR)
	| COLON expr			(EMPTY_DECR, expr)
	| notypedeclarator COLON expr	(notypedeclarator, expr)

typequalifier:
	  CONST				(CONST)
	| VOLATILE			(VOLATILE)

enumspecifier:
          ENUM_T LCURLY enumeratorlist trailingcomma RCURLY
		(ENUM{ tag_opt => NULL, enumerators => seq_to_list enumeratorlist, trailing_comma => trailingcomma } )

        | ENUM_T IDENTIFIER LCURLY enumeratorlist trailingcomma RCURLY 
		(ENUM{ tag_opt => THE(identifier), enumerators => seq_to_list enumeratorlist, trailing_comma => trailingcomma } )

	| ENUM_T TYPE_NAME LCURLY enumeratorlist trailingcomma RCURLY 
		(ENUM{ tag_opt => THE(type_name), enumerators => seq_to_list enumeratorlist, trailing_comma => trailingcomma } )
        
        | ENUM_T IDENTIFIER		(ENUM_TAG(identifier))

        | ENUM_T TYPE_NAME		(ENUM_TAG(type_name))


enumeratorlist:

      enumeratorlist
      COMMA
      enumerator 
					(add_to_seq(enumerator, enumeratorlist))

    | enumerator			(   {   (type_defs::add_no_tdef (#1 (enumerator)));

					        singleton_seq enumerator;
                                            }
                                        )

enumerator:
	  IDENTIFIER			((identifier, parse_tree::EMPTY_EXPR))
	| IDENTIFIER EQUALS expr	(identifier, expr)

storageilkspecifier: 
	  EXTERN 			(EXTERN)
        | STATIC 			(STATIC)
	| AUTO				(AUTO)
        | REGISTER			(REGISTER)
	| TYPEDEF                       (TYPEDEF)

trailingcomma:				(FALSE)
	| COMMA				(TRUE)
 
initdeclaratorlist:
	  initdeclarator		(singleton_seq initdeclarator)
	| initdeclaratorlist COMMA initdeclarator
					(add_to_seq(initdeclarator, initdeclaratorlist))

initdeclarator:
	  declarator			((declarator, EMPTY_EXPR))
	| declarator EQUALS initializer (declarator, initializer)

notypeinitdeclaratorlist:
          notypeinitdeclarator         (singleton_seq notypeinitdeclarator)
        | notypeinitdeclaratorlist COMMA initdeclarator
                                       (add_to_seq(initdeclarator, notypeinitdeclaratorlist))

notypeinitdeclarator:
          notypedeclarator             ((notypedeclarator, EMPTY_EXPR))
        | notypedeclarator EQUALS initializer
                                        (notypedeclarator, initializer)

declarator:
          aftertypedeclarator          (aftertypedeclarator)
        | notypedeclarator             (notypedeclarator)

aftertypedeclarator:
	  aftertypedirectdeclarator		(aftertypedirectdeclarator)
	| pointer aftertypedirectdeclarator	(apply_pointer(pointer, aftertypedirectdeclarator))

notypedeclarator:
          notypedirectdeclarator      (notypedirectdeclarator)
        | pointer notypedirectdeclarator 
                                        (apply_pointer(pointer, notypedirectdeclarator))

parmdeclarator:
          parmdirectdeclarator        (parmdirectdeclarator)
        | pointer parmdirectdeclarator
                                        (apply_pointer(pointer, parmdirectdeclarator))

pointer:
	  TIMES				(POINTER_DECR(EMPTY_DECR))
	| TIMES typequalifierlist
                                        (POINTER_DECR(loop_qd(typequalifierlist, EMPTY_DECR)))
	| TIMES pointer			(POINTER_DECR(pointer))
	| TIMES typequalifierlist pointer
					(POINTER_DECR(loop_qd(typequalifierlist, pointer)))

aftertypedirectdeclarator:
 	  TYPE_NAME			(mark_declarator src_map (VAR_DECR type_name, type_nameleft, type_nameright))
	| LPAREN aftertypedeclarator RPAREN		
					(aftertypedeclarator)
	| aftertypedirectdeclarator  LBRACE RBRACE %prec DOT
					(ARRAY_DECR (aftertypedirectdeclarator, EMPTY_EXPR))
	| aftertypedirectdeclarator LBRACE expr RBRACE %prec DOT
					(ARRAY_DECR (aftertypedirectdeclarator, expr))
	| aftertypedirectdeclarator LPAREN RPAREN		%prec DOT
					(FUNC_DECR (aftertypedirectdeclarator, NIL))
	| aftertypedirectdeclarator LPAREN parametertypelist RPAREN		 %prec DOT
					(FUNC_DECR (aftertypedirectdeclarator, parametertypelist))
	| aftertypedirectdeclarator LPAREN identlist RPAREN		%prec DOT
					(FUNC_DECR (aftertypedirectdeclarator,
					    map (fn (x, y, z) = (unknown, mark_declarator src_map (VAR_DECR x, y, z))) (seq_to_list identlist)))

notypedirectdeclarator:
	  IDENTIFIER			(mark_declarator src_map (VAR_DECR identifier, identifierleft, identifierright))
	| LPAREN notypedeclarator RPAREN		
					(notypedeclarator)
	| notypedirectdeclarator LBRACE RBRACE %prec DOT
					(ARRAY_DECR (notypedirectdeclarator, EMPTY_EXPR))
	| notypedirectdeclarator LBRACE expr RBRACE  %prec DOT
					(ARRAY_DECR (notypedirectdeclarator, expr))
	| notypedirectdeclarator LPAREN RPAREN	 %prec DOT	
					(FUNC_DECR (notypedirectdeclarator, NIL))
	| notypedirectdeclarator LPAREN parametertypelist RPAREN	 %prec DOT	
					(FUNC_DECR (notypedirectdeclarator, parametertypelist))
	| notypedirectdeclarator LPAREN identlist RPAREN	 %prec DOT	
					(FUNC_DECR (notypedirectdeclarator,
 						   map (fn (x, y, z) = (unknown, mark_declarator src_map (VAR_DECR x, y, z))) (seq_to_list identlist)))

parmdirectdeclarator:
 	  TYPE_NAME			(mark_declarator src_map (VAR_DECR type_name, type_nameleft, type_nameright))
	| parmdirectdeclarator LBRACE RBRACE  %prec DOT
					(ARRAY_DECR (parmdirectdeclarator, EMPTY_EXPR))
	| parmdirectdeclarator LBRACE expr RBRACE  %prec DOT
					(ARRAY_DECR (parmdirectdeclarator, expr))
	| parmdirectdeclarator LPAREN RPAREN		 %prec DOT
					(FUNC_DECR (parmdirectdeclarator, NIL))
	| parmdirectdeclarator LPAREN parametertypelist RPAREN	 %prec DOT	
					(FUNC_DECR (parmdirectdeclarator, parametertypelist))
	| parmdirectdeclarator LPAREN identlist RPAREN	 %prec DOT	
					(FUNC_DECR (parmdirectdeclarator,
						    map (fn (x, y, z) = (unknown, mark_declarator src_map (VAR_DECR x, y, z))) (seq_to_list identlist)))

initializer:
	  expr				(expr)
        | LCURLY initializerlist trailingcomma RCURLY
					(mark_expression src_map (INIT_LIST(seq_to_list initializerlist), lcurlyleft, rcurlyright))

initializerlist:
          initializer			(singleton_seq initializer)
        | initializerlist COMMA initializer 
					(add_to_seq(initializer, initializerlist))

declarationlist:
          declaration		        (singleton_seq(mark_declaration src_map (declaration,
									      declarationleft,
								              declarationright)))
	| declarationlist declaration	(add_to_seq(mark_declaration src_map (declaration,
							            	  declarationleft,
									  declarationright),
						  declarationlist))
	  
identlist:
	  IDENTIFIER			(singleton_seq (identifier, identifierleft, identifierright))
	| identlist COMMA IDENTIFIER	(add_to_seq((identifier, identifierleft, identifierright), identlist))

/* Put function name in the current scope and parameter names in a pushed scope. */
fdefdeclaration:

      notypedeclarator
                                        (   {   insert_func_name(notypedeclarator);
					        type_defs::push_scope();
					        insert_func_params(notypedeclarator);
					        (unknown, notypedeclarator);
                                            }
                                        )
    | declarationspecifiers
      declarator
	                                (   {   insert_func_name(declarator);
					        type_defs::push_scope();
					        insert_func_params(declarator);
					        (declarationspecifiers, declarator);
                                            }
                                        )

    | declarationmodifiers
      notypedeclarator
	                                (   {   insert_func_name(notypedeclarator);
					        type_defs::push_scope();
					        insert_func_params(notypedeclarator);
					        (declarationmodifiers, notypedeclarator);
                                            }
                                        )

functiondefinition:

      fdefdeclaration compoundstatement
                                        (   {   type_defs::pop_scope();

						FUNCTION_DEF
						   { ret_type  =>  #1 fdefdeclaration,
						    fun_decr  =>  #2 fdefdeclaration,
						    kr_params  =>  [],
						    body  =>  compoundstatement};
                                            }
                                        )
					
    | fdefdeclaration
      declarationlist
      compoundstatement
                                        (   {   type_defs::pop_scope();

						FUNCTION_DEF 
						   { ret_type  =>  #1 fdefdeclaration,
						    fun_decr  =>  #2 fdefdeclaration,
						    kr_params  =>  seq_to_list declarationlist,
						    body  =>  compoundstatement};
                                            }
                                        )
					
abstractdeclarator:

      pointer				(apply_pointer (pointer, EMPTY_DECR))

    | directabstractdeclarator		(directabstractdeclarator)

    | pointer
      directabstractdeclarator		(apply_pointer(pointer, directabstractdeclarator))

directabstractdeclarator:
	  LPAREN abstractdeclarator RPAREN	(abstractdeclarator) 
        | LBRACE RBRACE 			(ARRAY_DECR(EMPTY_DECR, EMPTY_EXPR))
        | LBRACE expr RBRACE 			(ARRAY_DECR(EMPTY_DECR, expr))
        | directabstractdeclarator LBRACE RBRACE
						(ARRAY_DECR (directabstractdeclarator, EMPTY_EXPR))
        | directabstractdeclarator LBRACE expr RBRACE 
						(ARRAY_DECR (directabstractdeclarator, expr))
        | LPAREN RPAREN				(FUNC_DECR (EMPTY_DECR, NIL))
        | LPAREN parametertypelist RPAREN	(FUNC_DECR (EMPTY_DECR, parametertypelist))
        | directabstractdeclarator LPAREN RPAREN
						(FUNC_DECR (directabstractdeclarator, NIL))
        | directabstractdeclarator LPAREN parametertypelist RPAREN 
						(FUNC_DECR (directabstractdeclarator, parametertypelist))

parametertypelist:

      parameterlist	                        (seq_to_list parameterlist)

    | parameterlist
      COMMA
      ELIPSIS
				(   {   decltype =  {   specifiers => [ELLIPSES],
                                                        qualifiers => [],
                                                        storage    => []
                                                    };

	        		        (seq_to_list parameterlist) @ [(decltype, ELLIPSES_DECR)];
                                    }
                                )

parameterlist:
	parameterdeclaration	
                                (singleton_seq(#1 parameterdeclaration,
                                              mark_declarator src_map (#2 parameterdeclaration,
							             parameterdeclarationleft,
								     parameterdeclarationright)))
        | parameterlist COMMA parameterdeclaration 
	                        (add_to_seq((#1 parameterdeclaration,
	                                           mark_declarator
	                                            src_map 
                                                     (#2 parameterdeclaration,
						      parameterdeclarationleft,
						      parameterdeclarationright)),
					  parameterlist))

/* Decided not a push and pop a scope at the parameterdeclarations, because we
 * are not going to directly plug these names in the tdef table. If this is just
 * a function declaration, the names here do not matter to the tdef table. If
 * this will be part of func definition, we put all these names in tdef table at
 * proper scope correctly, later on.
 * Note: We miss syntax errors like int f(int foo, foo bar);, if foo was a typename
 */
parameterdeclaration:
          declarationspecifiers  notypedeclarator
					((declarationspecifiers, notypedeclarator))
        | declarationspecifiers  parmdeclarator
					((declarationspecifiers, parmdeclarator))

        | declarationspecifiers 	/* this case can arise for function prototypes */
					((declarationspecifiers, EMPTY_DECR))

        | declarationspecifiers  abstractdeclarator
					((declarationspecifiers, abstractdeclarator))

        | declarationmodifiers  notypedeclarator
                                       ((declarationmodifiers, notypedeclarator))

        | declarationmodifiers  abstractdeclarator
                                       ((declarationmodifiers, abstractdeclarator))

pushScope:
                                        (type_defs::push_scope())

popScope:
                                        (type_defs::pop_scope())




##  Copyright (c) 1998 by Lucent Technologies 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
