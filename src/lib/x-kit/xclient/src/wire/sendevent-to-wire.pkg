## sendevent-to-wire.pkg
#
# Encode X SendEvent values in wire
# (network bytestring) format.
#
# Currently we implement:
#
#     fun encode_send_selection_notify		# Respond to a selection request.
#     fun encode_send_unmap_notify		# Tell window manager to unmap a toplevel window.
#
# These get used in (respectively):
#
#     src/lib/x-kit/xclient/src/window/selection-imp.pkg
#     src/lib/x-kit/xclient/src/window/window.pkg
#
# See also:
#     src/lib/x-kit/xclient/src/wire/value-to-wire.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6


stipulate
    package g   = geometry;				# geometry		is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    package xt  = xtypes;				# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package ts  = xserver_timestamp;			# xserver_timestamp	is from   src/lib/x-kit/xclient/src/wire/xserver-timestamp.pkg
    #
    package w8a =  rw_unt8_vector;			# rw_unt8_vector	is from   src/lib/std/src/rw-unt8-vector.pkg
    package w8v =     unt8_vector;			# unt8_vector		is from   src/lib/std/src/unt8-vector.pkg
    package v2w = value_to_wire;			# value_to_wire		is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
herein

    package sendevent_to_wire: Sendevent_To_Wire {	# Sendevent_To_Wire	is from   src/lib/x-kit/xclient/src/wire/sendevent-to-wire.api

	stipulate
	    # We need to treat requests as modifiable
	    # for initialization purposes, but we don't
	    # want them to be modifiable afterwords:
	    #
	    my ro2rw:  unt8_vector::Vector -> rw_unt8_vector::Rw_Vector
		=
		unsafe::cast;

	    encode_push_event
		=
		v2w::encode_push_event;

	    event_offset = 12;

	    fun put8        (buf, i, w) =  w8a::set (ro2rw buf, i+event_offset, w);
	    fun put_signed8 (buf, i, x) =  put8 (buf, i, unt8::from_int x);

	    fun put16 (buf, i, x)
		=
		pack_big_endian_unt16::set (ro2rw buf, i / 2 + event_offset / 2, x);

	    fun put_signed16 (buf, i, x)
		=
		put16 (buf, i, large_unt::from_int x);


	    fun put32 (buf, i, x)
		=
		pack_big_endian_unt32::set (ro2rw buf, i / 4 + event_offset / 4, x);

	    fun put_word32   (buf, i, x) = put32 (buf, i, unt::to_large_unt x);
	    fun put_signed32 (buf, i, x) = put32 (buf, i, large_unt::from_int x);

	    fun put_bool (buf, i, FALSE) =>  put8 (buf, i, 0u0);
		put_bool (buf, i, TRUE ) =>  put8 (buf, i, 0u1);
	    end;

	    fun put_buttons (buf, i, xt::MOUSEBUTTON_STATE unt)
		=
		put16 (buf, i, unt32::from_int (unt::to_int unt));		# There must be a better way to do this conversion...

	    fun put_button  (buf, i, xt::MOUSEBUTTON button)
		=
		put_signed8 (buf, i, button);

	    fun put_xid (buf, i, xt::XID n)
		=
		put_word32 (buf, i, n);

	    fun put_null_or_xid (buf, i, NULL)            =>  put_word32 (buf, i, 0u0);
		put_null_or_xid (buf, i, THE (xt::XID n)) =>  put_word32 (buf, i, n);
	    end;

	    fun put_atom (buf, i, xt::XATOM n)
		=
		put_word32 (buf, i, n);

	    fun put_null_or_atom (buf, i, NULL)              =>  put_word32 (buf, i, 0u0);
		put_null_or_atom (buf, i, THE (xt::XATOM n)) =>  put_word32 (buf, i, n);
	    end;

	    fun put_timestamp (buf, i, xt::CURRENT_TIME)                         =>  put32 (buf, i, 0u0);
		put_timestamp (buf, i, xt::TIME_STAMP (ts::XSERVER_TIMESTAMP t)) =>  put32 (buf, i, t);
	    end;

	    # Event codes:
	    #
	    package event {
		key_press_xevent	= 0u2:  unt8::Unt;
		key_release_xevent	= 0u3:  unt8::Unt;
		button_press_xevent	= 0u4:  unt8::Unt;
		button_release_xevent	= 0u5:  unt8::Unt;
		motion_notify	        = 0u6:  unt8::Unt;
		enter_notify_xevent	= 0u7:  unt8::Unt;
		leave_notify_xevent	= 0u8:  unt8::Unt;
		focus_in_xevent		= 0u9:  unt8::Unt;
		focus_out_xevent	= 0u10:  unt8::Unt;
		keymap_notify	        = 0u11:  unt8::Unt;
		expose			= 0u12:  unt8::Unt;
		graphics_expose		= 0u13:  unt8::Unt;
		no_expose		= 0u14:  unt8::Unt;
		visibility_notify	= 0u15:  unt8::Unt;
		create_notify	        = 0u16:  unt8::Unt;
		destroy_notify		= 0u17:  unt8::Unt;
		unmap_notify	        = 0u18:  unt8::Unt;
		map_notify		= 0u19:  unt8::Unt;
		map_request		= 0u20:  unt8::Unt;
		reparent_notify		= 0u21:  unt8::Unt;
		configure_notify	= 0u22:  unt8::Unt;
		configure_request	= 0u23:  unt8::Unt;
		gravity_notify		= 0u24:  unt8::Unt;
		resize_request		= 0u25:  unt8::Unt;
		circulate_notify	= 0u26:  unt8::Unt;
		circulate_request	= 0u27:  unt8::Unt;
		property_notify		= 0u28:  unt8::Unt;
		selection_clear		= 0u29:  unt8::Unt;
		selection_request	= 0u30:  unt8::Unt;
		selection_notify	= 0u31:  unt8::Unt;
		colormap_notify		= 0u32:  unt8::Unt;
		client_message		= 0u33:  unt8::Unt;
		mapping_notify		= 0u34:  unt8::Unt;
	    };

	    fun put_event_code (msg, code)
		=
		put8 (msg, 0, code);

	    fun put_detail_code (msg, code)
		=
		put8 (msg, 1, code);

	herein

	    # For SendEvent proper, see:
            #     p27   http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    #     p126  http://mythryl.org/pub/exene/X-protocol-R7.pdf


	    # Event wire encodings are documented in
	    #       p 150-157  http://mythryl.org/pub/exene/X-protocol-R7.pdf

	    # See   p88 http://mythryl.org/pub/exene/X-protocol-R7.pdf	
	    #
	    fun encode_send_selection_notify
		{ send_event_to, propagate, event_mask,
                  requestor, selection, target, property, timestamp
                }
		=
		{   msg =  encode_push_event { send_event_to, propagate, event_mask };

		    put_event_code   (msg, event::selection_notify);
		    put_timestamp    (msg,  4, timestamp);
		    put_xid          (msg,  8, requestor);
		    put_atom         (msg, 12, selection);
		    put_atom         (msg, 16, target   );
		    put_null_or_atom (msg, 20, property );

		    msg;
		};

	    # See   p84 http://mythryl.org/pub/exene/X-protocol-R7.pdf	
	    #
	    fun encode_send_unmap_notify
		{ send_event_to, propagate, event_mask,
                  event, window, from_configure
                }
		=
		{   msg = encode_push_event { send_event_to, propagate, event_mask };

		    put_event_code (msg, event::unmap_notify);
		    put_xid        (msg,  4, event          );
		    put_xid        (msg,  8, window         );
		    put_bool       (msg, 12, from_configure );

		    msg;
		};

	    # For semantics       see   p77  (81)   http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    # For binary encoding see  p151 (155)   http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    #
	    fun encode_send_button_press_xevent
		  { send_event_to, propagate, event_mask,
		    #
                    timestamp,
                    root_window,
		    event_window,	# Window handling the mouse-button click event.
		    child_window,	# Child of event window containing the click point. NULL if none such exists.
		    root_x,		# Mouse position on root window at time of button click.
		    root_y,
		    event_x,		# Mouse position on recipient window at time of button click.
		    event_y,
		    button,		# Mouse button just clicked down.
		    buttons		# Mouse button state before buttonclick.
					# We should support modifier keys as well as mouse keys here. XXX BUGGO FIXME.
                  }
		=
		{   msg = encode_push_event { send_event_to, propagate, event_mask };

		    same_screen = TRUE;		# I'm pretending multiple-screen X servers do not exist.

		    put_event_code  (msg, event::button_press_xevent	);
		    put_button      (msg,  1, button			);			# Mouse button being clicked.
		    put_timestamp   (msg,  4, timestamp			);
		    put_xid         (msg,  8, root_window		);
		    put_xid         (msg, 12, event_window		);
		    put_null_or_xid (msg, 16, child_window		);
		    put_signed16    (msg, 20, root_x			);
		    put_signed16    (msg, 22, root_y			);
		    put_signed16    (msg, 24, event_x			);
		    put_signed16    (msg, 26, event_y			);
		    put_buttons     (msg, 28, buttons			);			# Supposed keys-and-buttons state before the click.
		    put_bool        (msg, 30, same_screen		);

		    msg;
		};

	    # For semantics       see   p77  (81)   http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    # For binary encoding see  p151 (155)   http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    #
	    fun encode_send_button_release_xevent
		  { send_event_to, propagate, event_mask,
		    #
                    timestamp,
                    root_window,
		    event_window,	# Window handling the mouse-button release event.
		    child_window,	# Child of event window containing the release point. NULL if none such exists.
		    root_x,		# Mouse position on root window at time of button release.
		    root_y,
		    event_x,		# Mouse position on recipient window at time of button release.
		    event_y,
		    button		# Mouse button just released.
                  }
		=
		{   msg = encode_push_event { send_event_to, propagate, event_mask };

		    # Layout is identical to the button-press case
		    # except that it is missing the final two fields,
		    # 'buttons' and 'same_screen':
		    #
		    put_event_code  (msg, event::button_press_xevent	);
		    put_button      (msg,  1, button			);			# Mouse button being released.
		    put_timestamp   (msg,  4, timestamp			);
		    put_xid         (msg,  8, root_window		);
		    put_xid         (msg, 12, event_window		);
		    put_null_or_xid (msg, 16, child_window		);
		    put_signed16    (msg, 20, root_x			);
		    put_signed16    (msg, 22, root_y			);
		    put_signed16    (msg, 24, event_x			);
		    put_signed16    (msg, 26, event_y			);

		    msg;
		};
	end;	# stipulate
    };		# package sendevent_to_wire
end;		# stipulate 


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1992 by AT&T.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
