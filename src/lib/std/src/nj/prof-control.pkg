## prof-control.pkg

# Compiled by:
#     src/lib/std/src/Base-imp.make6

# This package implements the interface to the run-time system's profiling
# support library.  It is not meant for general use.


package profiling_control: (weak)  Profiling_Control {		# Profiling_Control	is from   src/lib/std/src/nj/prof-control.api


    package ci= unsafe::c_interface;		# unsafe	is from   src/lib/std/src/unsafe/unsafe.pkg

    my set_timer:  Bool -> Void
	  = ci::c_function "Lib7-Prof" "setTimer";

    my get_quantum:  Void -> Int
	  = ci::c_function "Lib7-Prof" "getQuantum";

    my set_time_array' :  Null_Or( Rw_Vector( Int ) ) -> Void
	  = ci::c_function "Lib7-Prof" "setTimeArray";

    prof_mode   = REF FALSE;	#  Controls profile instrumentation 
    timing_mode = REF FALSE;	#  Controls profile timer 

    times = REF (rw_vector::make_rw_vector (0, 0));

    fun get_timing_mode () = *timing_mode;

    # Set the timer count rw_vector

    fun set_time_array arr = {
	  if *timing_mode  set_time_array'(THE arr); fi;
	  times := arr;};

    fun get_time_array () = *times;

    fun reset_time_array ()
        =
        {   fun zero a
                =
                rw_vector::modify  (fn _ = 0)  a;
	  
	    zero *times;
	};
    
    fun profile_on ()
        =
        if (not *timing_mode)
	    timing_mode := TRUE;
            set_time_array'(THE *times);
            set_timer TRUE;
        fi;

    fun profile_off ()
        =
        if *timing_mode
            set_timer FALSE;
            set_time_array' NULL;
            timing_mode := FALSE;
	fi;

     Compunit = UNIT  {
	base: Int,
	size: Int,
	counts: rw_vector::Rw_Vector( Int ),
	names: String
      };
			   
    runtime_index = 0;
    minor_gc_index = 1;
    major_gc_index = 2;
    other_index = 3;
    compile_index = 4;
    number_of_predefined_indices = 5;

    my current:  Ref( Int )
       =
       core::assembly::prof_current;

    my _ = {
	  set_time_array (rw_vector::make_rw_vector (number_of_predefined_indices, 0));
	  current := other_index;};

    fun increase n
        =
        {   old = get_time_array();
	  
	    if (n > rw_vector::length old)

                  new = rw_vector::make_rw_vector (n+n, 0);
		
		  rw_vector::copy { di=>0, to=>new, from => old };
		  set_time_array new;

             fi;
	};

    units = REF [UNIT {
	    base => 0,
	    size => number_of_predefined_indices,
	    counts => rw_vector::make_rw_vector (number_of_predefined_indices, 0),
	    names => "\
		\Run-time System\n\
		\Minor GC\n\
		\Major GC\n\
		\Other\n\
		\Compilation\n"
	  } ];

    # Count the number of newlines in a string:
    fun newlines s =
	char_vector::fold_left (fn ('\n', n) => n + 1;  (_, n) => n; end ) 0 s;

    fun register names
        =
        {   list = *units;
	    my UNIT { base, size, ... } = list::head list;
	    count = newlines names;
	    a = rw_vector::make_rw_vector (count, 0);
	    b = base+size;

	    increase (b+count);
	    units := UNIT { base=>b, size=>count, counts=>a, names } ! list;
	    (b, a, current);
	};

    my _ =  core::profile_register := register;

    fun reset () = {
	  fun zero a = rw_vector::modify (fn _ => 0; end ) a;
	  
	    reset_time_array();
	    list::apply (fn UNIT { counts, ... } => zero counts; end ) *units;
	  };
 
    # Space profiling hooks:

    space_profiling = REF FALSE;

    my space_prof_register
       :
       Ref( (unsafe::unsafe_chunk::Chunk, String) -> unsafe::unsafe_chunk::Chunk)
       =
       unsafe::cast core::profile_sregister;

};




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1996 AT&T Research.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
