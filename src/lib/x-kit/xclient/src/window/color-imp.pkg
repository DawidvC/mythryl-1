## color-imp.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6


# The color imp manages colors for a given screen.

stipulate
    include threadkit;								# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package rc  =  range_check;							# range_check		is from   src/lib/x-kit/xclient/src/stuff/range-check.pkg
    package xok =  xsocket;							# xsocket		is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package v2w =  value_to_wire;						# value_to_wire		is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;						# wire_to_value		is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xt  =  xtypes;							# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
herein

    package color_imp: (weak)  Color_Imp {					# Color_Imp		is from   src/lib/x-kit/xclient/src/window/color-imp.api

	exception NO_COLOR_CELL;

        Rgb = rgb::Rgb;

	# Color specifications.
	# Eventually, this will be extended to R5
	# device independent color specifications.
	#
	Color_Spec
	  #
	  = CMS_NAME  String
	  #
	  | CMS_RGB  { red:   Unt,
		       green: Unt,
		       blue:  Unt
		     }
	  ;

#	white_rgb = rgb::from_unts (0uxffff, 0uxffff, 0uxffff);
#	black_rgb = rgb::from_unts (0ux0000, 0ux0000, 0ux0000);

	fun color_from_floats colortriple
	    =
	    rgb::from_floats colortriple;


	Reply_Mail
	  = REPLY_ERROR
	  | REPLY_COLOR  Rgb
          ;

	Color_Imp
	    =
	    COLOR_IMP
	      { plea_slot:     Mailslot( Color_Spec ),
		reply_slot:    Mailslot( Reply_Mail ),
		black:  Rgb,
		white:  Rgb
	      };

									    # monomorphic_hash_table_g	is from   src/lib/src/monomorphic-hash-table-g.pkg
	# Tables mapping RGB values to colors:
	# 
	package rgbtable
	    =
	    monomorphic_hash_table_g (

		Hash_Key = Rgb;

		fun same_key (k1:  Hash_Key, k2)
		    =
		    rgb::same (k1, k2);

		fun hash_value rgb
		    =
		    {   (rgb::to_unts rgb)
			    ->
			    (red, green, blue);

		        red + unt::(<<) (green, 0u1) + unt::(<<) (blue, 0u2);
		    };
	    );

	Rgb_Table
	    =
	    rgbtable::Hash_Table( Rgb );

	# Tables mapping color names to colors 
	#
	Cname_Key = (String, Unt);

	fun make_cname_key s
	    =
	    {   s' = string::translate
			 (string::from_char o char::to_lower)
			 s;

		(s', hash_string::hash_string s');
	    };

	package cname_table
	    =
	    monomorphic_hash_table_g (

		Hash_Key = Cname_Key;

		fun same_key ((s1, h1)
		    :
		    Hash_Key, (s2, h2))
		    =
		    (h1 == h2) and (s1 == s2);

		fun hash_value (_, h)
		    =
		    h;
	    );

	Cname_Table
	    =
	    cname_table::Hash_Table( Rgb );

	# Create a color imp for a given screen.
	# Currently, this manages access
	# to the default colormap of the screen.
	# NOTE: once colors are finalized chunks
	# we will need to have a pixel-to-color map
	# to guarantee that each pixel has only one color chunk.
	#
	fun make_color_imp (
		display::XDISPLAY { xsocket, ... },
		display::XSCREEN { default_colormap, black_rgb8, white_rgb8, ... }
	    )
	    =
	    {   exception NOT_FOUND;

		my rgb_table:  Rgb_Table
			    =  rgbtable::make_table (64, NOT_FOUND);

		rgb_ins  =   rgbtable::set rgb_table;
		rgb_find =   rgbtable::find   rgb_table;

		my cname_table:  Cname_Table
			      =  cname_table::make_table (64, NOT_FOUND);

		cname_ins  =   cname_table::set cname_table;
		cname_find =   cname_table::find   cname_table;

		request_reply =   xok::request_reply xsocket;

		fun allocate_named_color cname
		    =
		    {   msg =   v2w::encode_alloc_named_color { cmap => default_colormap, name => cname };

			w2v::decode_alloc_named_color_reply (do_mailop (request_reply msg));
		    };

		fun allocate_rgbcolor rgb
		    =
		    {   msg =   v2w::encode_alloc_color { cmap => default_colormap, color => rgb };

			w2v::decode_alloc_color_reply (do_mailop (request_reply msg));
		    };

		fun find_color_by_name cname
		    =
		    {   key =   make_cname_key cname;

			case (cname_find key)
			    #		      
			    THE c => c;
			    #
			    NULL =>
				{   my { pixel, visual_rgb, ... }
					=
					allocate_named_color  cname;

				    c = visual_rgb;

				    cname_ins (key, c);
				    rgb_ins (visual_rgb, c);
				    c;
				};
			esac;

		    };		# fun findColorByName 

		fun find_color_by_rgb rgb
		    =
		    case (rgb_find rgb)

			THE c =>   c;

			NULL =>
			    {   my { pixel, visual_rgb }
				    =
				    allocate_rgbcolor rgb;

				c =   visual_rgb;

				rgb_ins (rgb, c);

				if (not (rgb::same (rgb, visual_rgb)))
				    #
				    rgb_ins (visual_rgb, c);
				fi;

				c;
			    };

		    esac;


		fun do_plea (CMS_NAME cname)               =>   find_color_by_name cname;
		    do_plea (CMS_RGB { red, green, blue }) =>   find_color_by_rgb (rgb::from_unts (red, green, blue));
		end;

		plea_slot = make_mailslot ();
		reply_slot   = make_mailslot ();

		fun imp_loop ()
		    =
		    for (;;) {

			result
			    =
			    REPLY_COLOR  (do_plea  (take  plea_slot))
			    except
				_ = REPLY_ERROR;

			give  (reply_slot,  result);
		    };

		black = rgb::from_floats (0.0, 0.0, 0.0);
		white = rgb::from_floats (1.0, 1.0, 1.0);

		rgb_ins (black, black);
		rgb_ins (white, white);
		xtracing::xspawn("color_imp", imp_loop);
		COLOR_IMP { plea_slot, reply_slot, black, white };
	    };								# fun make_color_imp

	exception BAD_RGB;

	fun valid_rgb  { red, green, blue }
	    =
	    rc::valid_word16  red      and
	    rc::valid_word16  green    and
	    rc::valid_word16  blue;

	fun check_rgbval c
	    =
	    if   (not (valid_rgb c)   )   raise exception BAD_RGB;   fi;

	fun check_rgb  rgb
	    =
	    {   (rgb::to_unts rgb)
		    ->
		    (red, green, blue);

                check_rgbval { red, green, blue };
		rgb;
	    };

	stipulate

	    fun get (COLOR_IMP { plea_slot, reply_slot, ... }, color_spec)
		=
		{   give  (plea_slot,  color_spec);

		    case (take  reply_slot)
			#		  
			REPLY_COLOR c =>   c;
			REPLY_ERROR   =>   raise exception  NO_COLOR_CELL;
		    esac;
		};
	herein

	    fun get_color cs (spec as (CMS_RGB rgb)) => { check_rgbval rgb; get (cs, spec);};
		get_color cs spec => get (cs, spec);
	    end;
	end;

	fun black_of (COLOR_IMP { black, ... } ) = black;
	fun white_of (COLOR_IMP { white, ... } ) = white;

	fun rgb_of_color rgb = rgb;

	fun same_color
            ( rgb_1,
	      rgb_2
	    )
	    =
	    rgb8::same (rgb8::from_rgb rgb_1, rgb8::from_rgb rgb_2);

    };				# package color_imp 

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1992 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
