## xsocket-to-topwindow-router.pkg
#
# Primary functionality
# =====================
#
# For the big picture, see the dataflow diagram in:
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# We receive X events from the xsession xbuf_imp
# and decide what action to take for them.  The
# xbuf_imp just breaks the X event bytestream up
# into individual messages;  we are the first link
# in the chain which actually responds to X events
# on a semantic level.
#
# Typically we route an X event to the toplevel
# window containing the relevant widget.
# 
# To do this we maintain a
#
#     window_id_to_window_info_map
#
# which tracks all windows created by the application,
# keyed by their X-server-assigned IDs, so that we can
# translate the xid in the event to the corresponding
# window for delivery.
#
# In particular we track, for each window, the route
# needed to reach it down the window hierarchy, and
# deliver X events down that route, thus giving each
# ancestor of the target widget a chance to rewrite
# the event. 
#
# We find out about newly created toplevel windows via our
#
#     note_new_topwindow
#
# fn, which is called by the topwindow-creation functions
#     make_simple_top_window
#     make_simple_popup_window
#     make_transient_window
# in
#     src/lib/x-kit/xclient/src/window/window.pkg
#      
# We find out about newly created subwindows via
#     CREATE_NOTIFY
# xevents from the X server, and about destroyed
# windows (toplevel and subwindow both) via
#     DESTROY_NOTIFY
# xevents from the X server.
#
# There are also a few X events which we divert to
# specialized imps for processing:
#
#  o  The following three X events get redirected
#     to our selection imp:
#         SELECTION_CLEAR
#         SELECTION_REQUEST
#         SELECTION_NOTIFY
#
#  o  The following X events get redirected
#     to our property imp:
#         PROPERTY_NOTIFY
#
#
# Secondary functionality
# =======================
#
# This file also implements a facility to
# freeze selected windows, with draw commands
# to them queueing up until they are unlocked:
# See make_overlay_buffer in
#     src/lib/x-kit/xclient/src/window/draw-imp.pkg  
#
# The idea might have been to allow XOR-implemented
# rubber-banding selection to work without anomalies
# due to the window contents changing between draw
# and undraw calls.
#
# The lock_window_tree entrypoint is called
# nowhere in the codebase, so this is apparently
# code that was just being phased in when
# development ceased.
#

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6



# TODO			XXX BUGGO FIXME
#   - refresh the keymap on ModifierMappingNotifyXEvt and KeyboardMappingNotifyXEvt
#     events.
#   - think about the relation of locks and changes in the tree structure
#     also locking already locked windows.


stipulate
    package xt  = xtypes;				# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  = event_types;				# event_types		is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package dy  = display;				# display		is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xok = xsocket;				# xsocket		is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package ge =  geometry;				# geometry		is from   src/lib/x-kit/xclient/src/window/geometry.pkg
herein
    package xsocket_to_topwindow_router: (weak)  Xsocket_To_Topwindow_Router {		# Xsocket_To_Topwindow_Router	is from   src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router.api

	include threadkit;								# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

	Envelope_Route
	  = ENVELOPE_ROUTE_END  xtypes::Window_Id
	  | ENVELOPE_ROUTE     (xtypes::Window_Id, Envelope_Route)
	  ;

	stipulate

	    package plea {
		#
		Mail
		  = NOTE_NEW_TOPWINDOW (xt::Window_Id, ge::Window_Site)
		  | LOCK_WINDOW         xt::Window_Id
		  | UNLOCK_WINDOW       xt::Window_Id
		  | IS_WINDOW_LOCKED    xt::Window_Id
		  ;
	    };

	    Window_Info
		=
		WINDOW_INFO
		  {
                    window_id:    xt::Window_Id,					# 29-bit X id for this particular window.
		    route:        Envelope_Route,					# Path needed to reach this window, starting at its topwindow.
		    parent_info:  Null_Or( Window_Info ),
		    #
		    children:     Ref(  List(Window_Info) ),
		    lock:         Ref( Bool ),
		    site:	  Ref( Null_Or( ge::Box )),
		    #
		    to_topwindow_slot:   Mailslot( (Envelope_Route, et::x::Event) )	# Where to send events headed for this window.
		  };

	    # The various things we can
	    # do with a given X event:
	    #
	    Xevent_Action
	      #	
	      = SEND_TO_WINDOW                        xt::Window_Id			# Forward event to given window via all of its ancestors from topwindow down.
	      | NOTE_SITE_CHANGE_AND_SEND_TO_WINDOW  (xt::Window_Id, ge::Box)		# Forward event to given window via all of its ancestors from topwindow down.
	      | NOTE_WINDOW_DESTRUCTION               xt::Window_Id
	      | SEND_TO_KEYMAP_IMP							# This appears to be unused at present.
	      | SEND_TO_WINDOW_PROPERTY_IMP
	      | SEND_TO_SELECTION_IMP
	      | SEND_TO_ALL_WINDOWS							# So everyone hears about changes in modifier key, keyboard and pointer mappings.
	      | IGNORE
	      | NOTE_NEW_WINDOW
                  { parent_window_id:   xt::Window_Id,
		    created_window_id:  xt::Window_Id,
		    box:                ge::Box 
		  }
	      ;


	    # Discard instances of an X-event that
	    # are the product of SubstructureNotify,
	    # instead of StructureNotify.
	    #
	    fun ignore_substructure_notify_xevents (window_id1, window_id2)
		=
		if (window_id1 == window_id2)  SEND_TO_WINDOW window_id1;
		else                           IGNORE;
		fi;

	    # Decide what action to take for given X event.  Here
	    #
	    #     event_window_id
	    #
	    # is the window corresponding to the widget which
	    # should actually handle the event, as determined
	    # by the X server;  the X server algorithm is
	    # described on pages 76-77 of
	    #
	    #     http://mythryl.org/pub/exene/X-protocol-R6.pdf
	    #
	    fun pick_xevent_action (et::x::KEY_PRESS      { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::KEY_RELEASE    { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::BUTTON_PRESS   { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::BUTTON_RELEASE { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::MOTION_NOTIFY  { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::ENTER_NOTIFY   { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::LEAVE_NOTIFY   { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::FOCUS_IN       { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;
		pick_xevent_action (et::x::FOCUS_OUT      { event_window_id, ... } ) =>  SEND_TO_WINDOW event_window_id;

#		pick_xevent_action (et::x::KeymapNotify {, ... } ) = 
#		pick_xevent_action (et::x::GraphicsExpose ?? 
#		pick_xevent_action (et::x::NoExpose {, ... } ) =
#		pick_xevent_action (et::x::MapRequest {, ... } ) =
#		pick_xevent_action (et::x::ConfigureRequest {, ... } ) =
#		pick_xevent_action (et::x::ResizeRequest {, ... } ) =
#		pick_xevent_action (et::x::CirculateRequest {, ... } ) =

		pick_xevent_action (et::x::EXPOSE { exposed_window_id, ... } ) =>  SEND_TO_WINDOW  exposed_window_id;


		pick_xevent_action (et::x::VISIBILITY_NOTIFY { changed_window_id, ... } ) =>  SEND_TO_WINDOW  changed_window_id;

		pick_xevent_action (et::x::CREATE_NOTIFY { parent_window_id, created_window_id, box, ... } )
		    =>
		    NOTE_NEW_WINDOW { parent_window_id, created_window_id, box };

		pick_xevent_action (et::x::DESTROY_NOTIFY { event_window_id, destroyed_window_id, ... } )
		    =>
		    event_window_id == destroyed_window_id
			##
                        ??  NOTE_WINDOW_DESTRUCTION  event_window_id	# Remove window from registry. 
			::  SEND_TO_WINDOW                event_window_id;	# Report to parent that child is dead. 

		pick_xevent_action (et::x::UNMAP_NOTIFY { event_window_id, unmapped_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, unmapped_window_id);

		pick_xevent_action (et::x::MAP_NOTIFY { event_window_id, mapped_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, mapped_window_id);


		pick_xevent_action (et::x::REPARENT_NOTIFY _)
		    =>
		    IGNORE;

		pick_xevent_action (et::x::CONFIGURE_NOTIFY { event_window_id, configured_window_id, box, ... } )
		    =>
		    case (ignore_substructure_notify_xevents (event_window_id, configured_window_id))
			#
			IGNORE           => IGNORE;
			SEND_TO_WINDOW _ => NOTE_SITE_CHANGE_AND_SEND_TO_WINDOW (configured_window_id, box);
		    esac;


		pick_xevent_action (et::x::GRAVITY_NOTIFY { event_window_id, moved_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, moved_window_id);


		pick_xevent_action (et::x::CIRCULATE_NOTIFY { event_window_id, circulated_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, circulated_window_id);


		pick_xevent_action (et::x::PROPERTY_NOTIFY   _) => SEND_TO_WINDOW_PROPERTY_IMP;    # We may have other uses of PropertyNotify someday.
		pick_xevent_action (et::x::SELECTION_CLEAR   _) => SEND_TO_SELECTION_IMP;
		pick_xevent_action (et::x::SELECTION_REQUEST _) => SEND_TO_SELECTION_IMP;
		pick_xevent_action (et::x::SELECTION_NOTIFY  _) => SEND_TO_SELECTION_IMP;

		pick_xevent_action (et::x::COLORMAP_NOTIFY { window_id, ... } ) => SEND_TO_WINDOW window_id;
		pick_xevent_action (et::x::CLIENT_MESSAGE  { window_id, ... } ) => SEND_TO_WINDOW window_id;

		pick_xevent_action  et::x::MODIFIER_MAPPING_NOTIFY     => SEND_TO_ALL_WINDOWS;
		pick_xevent_action (et::x::KEYBOARD_MAPPING_NOTIFY _)  => SEND_TO_ALL_WINDOWS;
		pick_xevent_action  et::x::POINTER_MAPPING_NOTIFY      => SEND_TO_ALL_WINDOWS;

		pick_xevent_action e => {
		   xgripe::warning (string::cat [
		     "[xsocket-to-topwin: unexpected ", xevent_to_string::xevent_name e, " event]\n"]);
		   IGNORE;};
	      end;
    #  +DEBUG 

	# Define a tracelogging version of
	#
	#     pick_xevent_action
	#
	stipulate

	    xid_to_string = xtype_to_string::xid_to_string;

	    fun xevent_action_to_string (SEND_TO_WINDOW w)
		    =>
		    ("SEND_TO_WINDOW(" + xid_to_string w + ")");

	        xevent_action_to_string (NOTE_SITE_CHANGE_AND_SEND_TO_WINDOW (w,_))
		    =>
		    ("NOTE_SITE_CHANGE_AND_SEND_TO_WINDOW(" + xid_to_string w + ")");

		xevent_action_to_string (NOTE_NEW_WINDOW { parent_window_id, created_window_id, box } )
		    =>
		    string::cat
		      [
			"NOTE_NEW_WINDOW { parent=",  xid_to_string  parent_window_id,
			      ", new_window=",  xid_to_string created_window_id,
			"}"
		      ];

		xevent_action_to_string (NOTE_WINDOW_DESTRUCTION w) => ("NOTE_WINDOW_DESTRUCTION(" + xid_to_string w + ")");
		xevent_action_to_string SEND_TO_KEYMAP_IMP               => "SEND_TO_KEYMAP_IMP";
		xevent_action_to_string SEND_TO_WINDOW_PROPERTY_IMP      => "SEND_TO_WINDOW_PROPERTY_IMP";
		xevent_action_to_string SEND_TO_SELECTION_IMP            => "SEND_TO_SELECTION_IMP";
		xevent_action_to_string SEND_TO_ALL_WINDOWS                      => "SEND_TO_ALL_WINDOWS";
		xevent_action_to_string IGNORE                    => "IGNORE";
	    end;

	herein

	    pick_xevent_action
		=
		fn xevent
		    =
		    {   xevent_action =  pick_xevent_action  xevent;

			xtracing::print_if xtracing::winreg_tracing .{
			    #
			    cat [ "xsocket_to_topwindow_router: ", xevent_to_string::xevent_name  xevent,
                                  " => ", xevent_action_to_string xevent_action
                                ];
			};

			xevent_action;
		    };
	end;
    #  -DEBUG 

	herein

	    Xsocket_To_Topwindow_Router
		=
		XSOCKET_TO_TOPWINDOW_ROUTER 
		  {
		    plea_slot:    Mailslot( plea::Mail ),
		    reply_slot:   Mailslot( Mailop( (Envelope_Route, et::x::Event) ) ),
		    lock_slot:    Mailslot( Bool )
		  };



	    stipulate

		fun set_window_subtree_locks_to
			(bool: Bool)	
		    =
		    set
		    where
			fun set (WINDOW_INFO { lock, children, ... } )
			    =
			    {   lock := bool;
				set_list *children;
			    }

			also
			fun set_list (wd ! r)
				=>
				{   set wd;
				    set_list r;
				};

			    set_list []
				=>
				();
			end;
		    end;
	    herein

		lock_tree   =  set_window_subtree_locks_to   TRUE;
		unlock_tree =  set_window_subtree_locks_to   FALSE;

	    end;

	    # This is called exactly one place, in
	    #     src/lib/x-kit/xclient/src/window/xsession.pkg
	    #
	    fun make_xsocket_to_topwindow_router
		{
		  display => dy::XDISPLAY { xsocket, ... },
		  keymap_imp,
		  to_window_property_imp_slot,
		  to_selection_imp_slot
		}
		=
		{
    #		/* testing: ddeboer, fall 2004. *
    #		rn = *rcref
    #		(file::print ("Started registry " + (int::to_string rn) + "\n");
    #			      rcref:= *rcref + 1)
    #		* end testing. */

		    xevent_in'
			=
			xok::wait_for_xevent  xsocket;

		    plea_slot  =   make_mailslot ();
		    reply_slot =   make_mailslot ();
		    lock_slot  =   make_mailslot ();

		    plea_in'   =   take'  plea_slot;
								    # hash_xid	is from   src/lib/x-kit/xclient/src/stuff/hash-xid.pkg
		    window_id_to_window_info_map =  hash_xid::make_map ();
		    #
		    get_info  =  hash_xid::get     window_id_to_window_info_map;
		    set_info  =  hash_xid::set     window_id_to_window_info_map;
		    drop_info =  hash_xid::remove  window_id_to_window_info_map;

		    fun do_plea (plea::NOTE_NEW_TOPWINDOW  (window_id, window_site))
			    =>
			    {   # Log a new top-level window:

				to_topwindow_slot = make_mailslot ();

				set_info
				  ( window_id,
				    WINDOW_INFO
				      {
					window_id,
					to_topwindow_slot,
					route       =>  ENVELOPE_ROUTE_END  window_id,
					parent_info =>  NULL,
					children    =>  REF [],
					lock        =>  REF FALSE,
					site	    =>  REF NULL
				      }
				  );

				give  (reply_slot,  take'  to_topwindow_slot);
			    };

		       do_plea (plea::LOCK_WINDOW   window_id) =>   lock_tree (get_info  window_id);
		       do_plea (plea::UNLOCK_WINDOW window_id) => unlock_tree (get_info  window_id);

		       do_plea (plea::IS_WINDOW_LOCKED window_id)
			   =>
			   {   (get_info  window_id)
				   ->
				    WINDOW_INFO { lock, ... };

			       give  (lock_slot,  *lock);
			   };
		    end;

		    fun note_new_subwindow (parent_window_id, child_window_id, box)
			=
			{
			    (get_info  parent_window_id)
				-> 
				parent_info as WINDOW_INFO { route, to_topwindow_slot, children, lock, ... };

			    fun extend_route (ENVELOPE_ROUTE_END window_id)      =>  ENVELOPE_ROUTE (window_id, ENVELOPE_ROUTE_END child_window_id);
				extend_route (ENVELOPE_ROUTE (window_id, route)) =>  ENVELOPE_ROUTE (window_id, extend_route route);
			    end;

			    child_route = extend_route route;

			    child_info
				=
				WINDOW_INFO
				  {
				    window_id   =>  child_window_id,
				    route       =>  child_route,
				    site        =>  REF (THE box),
				    parent_info =>  THE parent_info,
				    children    =>  REF [],
				    lock        =>  REF *lock,
				    to_topwindow_slot
				  };

			    children := child_info ! *children;

			    set_info (child_window_id, child_info);
			};


		    fun note_site_change (window_id, box)
			=
			{   (get_info window_id) ->  WINDOW_INFO { site, ... };

			    site := THE box;
			}
			except
			    hash_xid::XID_NOT_FOUND = ();

		    fun route_xevent_per_window_info (e, WINDOW_INFO { route, to_topwindow_slot, ... } )
			= 
			give  (to_topwindow_slot, (route, e));


		    fun route_xevent_to_window_id (xevent, window_id)
			=
			route_xevent_per_window_info (xevent, get_info window_id)
			except
			    hash_xid::XID_NOT_FOUND = ();

		    fun do_xevent xevent
			=
			case (pick_xevent_action xevent)
			    #
			    SEND_TO_WINDOW window_id
				=>
				route_xevent_to_window_id (xevent, window_id);

			    NOTE_SITE_CHANGE_AND_SEND_TO_WINDOW (window_id, box)
				=>
				{   note_site_change (window_id, box);
				    route_xevent_to_window_id (xevent, window_id);
				};

			    NOTE_NEW_WINDOW { parent_window_id, created_window_id, box }
				=>
				{   note_new_subwindow (parent_window_id, created_window_id, box);
				    #
				    route_xevent_to_window_id (xevent, parent_window_id);
				};

			    NOTE_WINDOW_DESTRUCTION  window_id
				=>
				case (drop_info  window_id)
				    #
				    (window_info as WINDOW_INFO { parent_info => THE (WINDOW_INFO { children, ... } ), ... } )
					=>
					{   fun remove_child ((window_info' as WINDOW_INFO { window_id => window_id', ... } ) ! rest)
						    =>
						    if (window_id' == window_id)  rest;
						    else                          (window_info' ! (remove_child rest));
						    fi;

						remove_child []
						    =>
						    {   xgripe::warning "[xsocket-to-topwin: missing child]";
							[];
						    };
					    end;

					    children
						:=
						remove_child *children;

					    route_xevent_per_window_info (xevent, window_info);
					};

				    window_info
					=>
					route_xevent_per_window_info (xevent, window_info);
				esac;

			    SEND_TO_KEYMAP_IMP
				=>
				{   xgripe::warning "[xsocket-to-topwin: unexpected SEND_TO_KEYMAP_IMP]";
				    ();
				};

			    SEND_TO_WINDOW_PROPERTY_IMP  =>  give  (to_window_property_imp_slot, xevent);
			    SEND_TO_SELECTION_IMP        =>  give  (to_selection_imp_slot,       xevent);

			    IGNORE => ();

			    SEND_TO_ALL_WINDOWS
				=>
				apply (fn (_, window_info) = route_xevent_per_window_info (xevent, window_info))
				      (hash_xid::list  window_id_to_window_info_map);
			esac;

		    mailop =  choose [
				  plea_in'   ==>  do_plea,
				  xevent_in' ==>  do_xevent
			      ];

		    # fun loop () = {   do_mailop mailop; loop(); };
	  /* DEBUG */ fun loop () = {   xtracing::print_if xtracing::winreg_tracing .{ "xsocket_to_topwindow_router: loop: Top."; };
				        do_mailop mailop;
				        loop();
				    };

		    xtracing::make_thread  "xsocket-to-topwin"  loop;

		    XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, reply_slot, lock_slot };
		};										# fun make_xsocket_to_topwindow_router


	    # Add 'topwindow' to    window_id_to_window_info_map
	    # and return the event slot through which we will feed
	    # X events to that window and its subwindows.
	    #
	    # This function is called (only) from    make_topwindow_to_widget_router   in
	    #
	    #     src/lib/x-kit/xclient/src/window/topwindow-to-widget-router.pkg
	    #
	    fun note_new_topwindow
                  ( XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, reply_slot, ... },
                    topwindow_id,
		    site
                  )
		=
		{   give  (plea_slot,  plea::NOTE_NEW_TOPWINDOW (topwindow_id, site));
		    #
		    take   reply_slot;
		};

	    # This is nowhere called:
	    #
	    fun lock_window_tree (XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, reply_slot, ... }, window)
		=
		{   give (plea_slot, plea::LOCK_WINDOW window);

		    .{  give (plea_slot, plea::UNLOCK_WINDOW window);  };
		};

	    # This gets called exactly one place, in
	    #
	    #     src/lib/x-kit/xclient/src/window/draw-imp.pkg
	    #
	    fun window_is_locked (XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, lock_slot, ... }, window)
		=
		{   give (plea_slot, plea::IS_WINDOW_LOCKED window);
		    #
		    take lock_slot;
		};
	end;					# stipulate
    };						# package xsocket_to_topwindow_router
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
