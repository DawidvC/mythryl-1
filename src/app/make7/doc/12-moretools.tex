% -*- latex -*-

\section{Extending the tool set}
\label{sec:moretools}

make7's tool set is extensible: new tools can be added by writing a few
lines of code.  The necessary hooks for this are provided by a
package {\tt tools} which is exported by the {\tt \$smlnj/make7/tools.make6}
library.

\subsection{Adding simple shell-command tools}
\label{sec:addshellilk}

If the tool is implemented as a ``typical'' shell command, then all
that needs to be done is a single call of:

\begin{verbatim}
  tools::note_standard_shell_command_tool
\end{verbatim}

For example, suppose you have made a
new, improved version of Mythryl-Yacc (``New-Mythryl-Yacc'') and want to
register it under a ilk called {\tt nmlyacc}.  Here is what you
write:

\begin{verbatim}
  my _ = tools::note_standard_shell_command_tool
    { tool = "New-Mythryl-Yacc",
      ilk = "nmlyacc",
      suffixes = ["ngrm", "ny"],
      command_standard_path = "bin/new-mythryl-yacc",
      template = NULL,
      extension_style =
          tools.EXTEND [("sig", THE "sml", fn _ => NULL),
                        ("sml", THE "sml", fn x => x)],
      dflopts = [] }
\end{verbatim}

This code can be packaged as a make7 library and loaded via {\tt make7.make}
or {\tt make7.load\_plugin}.  ({\tt make7.autoload} is not enough because of
its lazy nature which prevents the required side-effects to occur.)
Alternatively, the code could also be entered at the interactive top
level after loading library {\tt \$smlnj/make7/tools.make6}.

In our example, the shell command name for our tool is {\tt
new-mythryl-yacc}.  When looking for this command in the filesystem, make7
first tries to treat it as a path anchor (see
section~\REF{sec:anchor:env}).  For example, suppose {\tt new-mythryl-yacc} is
mapped to {\tt /bin}.  In this case the command to be
invoked would be {\tt /bin/new-mythryl-yacc}.  If path anchor resolution
fails, then the command name will be used as-is.  Normally this
causes the shell's path search mechanism to be used as a fallback.

{\tt tools::note_standard_shell_command_tool} creates the ilk and installs the
tool for it.  The arguments must be specified as follows:

\begin{description}
\item[tool] a descriptive name of the tool (used in error messages);
type: {\tt String}
\item[ilk] the name of the ilk; the string must not contain
upper-case letters; type: {\tt String}
\item[suffixes] a list of file name suffixes that let make7 automatically
recognize files of the ilk; type: {\tt String list}
\item[command_standard_path] the command string from above; type: {\tt String}. This can be either an absolute path {\tt /bin/foo} or a ROOT-relative path {\tt bin/foo}.
\item[template] an optional string that describes how the command line
is to be constructed from pieces; \\
The string is taken verbatim except for embedded \% format specifiers:
  \begin{description}\setlength{\itemsep}{0pt}
  \item[\%c] the command name (i.e., the elaboration of {\tt command_standard_path})
  \item[\%s] the source file name in native pathname syntax
  \item[\%$n$t] the $n$-th target file in native pathname syntax; \\
    ($n$ is specified as a decimal number, counting starts at $1$, and
    each target file name is constructed from the corresponding {\tt
    extension_style} entry; if $n$ is $0$ (or missing), then all
    targets---separated by single spaces---are inserted;
    if $n$ is not in the range between $0$ and the number of available
    targets, then {\bf \%$n$t} expands into itself) 
  \item[\%$n$o] the $n$-th tool parameter; \\
    (named sub-option parameters are ignored;
     $n$ is specified as a decimal number, counting starts at $1$;
     if $n$ is $0$ (or missing), then all options---separated by single
     spaces---are inserted;
     if $n$ is not in the range between $0$ and the number of available
     options, then {\bf \%$n$o} expands into itself) 
  \item[\%$x$] the character $x$ (where $x$ is neither {\bf c}, nor
    {\bf s}, {\bf t}, or {\bf o})
  \end{description}
If no template string is given, then it defaults to {\tt "\%c \%s"}.
\item[extension_style] a specification of how the names of files
generated by the tool relate to the name of the tool input file;
type: {\tt tools.extension_style}. \\
Currently, there are two possible cases:
\begin{enumerate}
\item ``{\tt tools.EXTEND} $l$'' says that if the tool source file is
{\it file} then for each suffix {\it suffix} in {\tt (map \#1 $l$)} there
will be one tool output file named {\it file}{\tt .}{\it suffix}.  The
list $l$ consists of triplets where the first component specifies the
suffix string, the second component optionally specifies the
member ilk name of the corresponding derived file, and the
third component is a function to calculate tool options for the 
target from those of the source. (Argument and result type of these
functions is {\tt tools.toolopts option}.)
\item ``{\tt tools.REPLACE }$(l_1, l_2)$'' says that given the
base name {\it base} there will be one tool output file {\it base}{\tt
.}{\it suffix} for each suffix {\it suffix} in {\tt (map \#1 $l_2$)}.  Here,
{\it base} is determined by the following rule: If the name of the
tool input file has a suffix that occurs in $l_1$, then {\it base} is
the name without that suffix.  Otherwise the whole file name is taken
as {\it base} (just like in the case of {\tt tools.EXTEND}).  As with
{\tt tools.EXTEND}, the second components of the elements of $l_2$ can
optionally specify the member ilk name of the corresponding derived
file, and the third component maps source options to target options.
\end{enumerate}
\item[dflopts] a list of tool options which is used for
substituting {\bf \%$n$o} fields in {\tt template} (see above) if no
options were specified.  (Note that the value of {\tt dflopts} is never
passed to the option mappers in {\tt tools.EXTEND} or {\tt
tools. REPLACE}.)  Type: {\tt tools.toolopts}.
\end{description}

Examples for the {\tt EXTEND} expansion style are tools such as
Mythryl-Yacc and Mythryl-Lex, while others, e.g., ML-Burg, use the {\tt REPLACE}
style (see section~\REF{sec:builtin-tools}).

\subsection{Adding other ilks}

Adding a new ilk whose behavior is not covered by the mechanism
described in section~\REF{sec:addshellilk} is not complicated
either, but it requires a bit more code.

\subsubsection{Filename abstractions}

make7 represents filenames as something that could be called a {\em
filename closure}.  Essentially, what this means is that not only a
string is being remembered but also the context in which to interpret
the string.  For a relative path, context information is the directory
in which it is to be interpreted; for an anchored path, the context
takes care of the anchoring.

The {\tt tools} module provides two abstract types related to this
filename abstraction:

\begin{verbatim}
  type presrcpath
  type srcpath
\end{verbatim}

Since many tools invoke external shell commands or perform other
operation on physical files, it is often necessary to obtain an actual
native filename string from an abstract path:

\begin{verbatim}
  my nativeSpec : srcpath -> String
  my nativePreSpec : presrcpath -> String
\end{verbatim}

It is important to remember that these two functions frequently return
relative filenames, and such relative names must be interpreted from
within the right directory.  This ``right'' directory is the directory
that contains the make7 description file on whose behalf the tool's rule
was invoked.  Rules that perform physical operations on files whose
names result from {\tt nativeSpec} or {\tt nativePreSpec} must
therefore first switch to that directory.  See the discussion of the
{\tt context} argument to rule functions below.

Strings that can potentially be used as pathnames are being passed
around as records containing a {\tt name}- and a {\tt make_path} field.
The {\tt name} field contains the string itself while {\tt make_path}
is a ``suspended'' abstract version of the path.

A fresh pathmaker can be constructed from native strings using {\tt
native2pathmaker}, which like {\tt context} is also an argument to
rule functions.  This function takes care of interpreting relative
strings within the correct context.  (For this, it is not even
necessary to first switch the current working directory.)

Recall that filenames that appear in description files can be written
using either ``standard'' or ``native'' syntax.  The field {\tt name}
will, thus, contain a string that can be in either of these two forms.
However, make7 will pass an {\tt make_path} function that accounts for these
syntactic differences and which also takes care of interpreting the
string in the correct context.

When new name specifications are constructed by the tool, the
appropriate {\tt make_path} function must be provided.  For most tools
this will be a value constructed by applying {\tt native2pathmaker} to
some native filename string (because most tools internally operate on
native paths).

As shown above, there are two abstract path types: {\tt presrcpath}
and {\tt srcpath}.  The former can represent both directory names and
source file names, the latter can represent only source file names.
To convert from {\tt presrcpath} to {\tt srcpath}, use function {\tt
tools.srcpath}:
\begin{verbatim}
  my srcpath : presrcpath -> srcpath
\end{verbatim}
This function enforces make7's rule that there has to be at least one arc
in every such name (i.e., that it cannot be just an anchor).

One can also construct a new abstract path from an existing path by
adding arcs at the end.  The constructed path will share its internal
context with the old one.

\begin{verbatim}
  my augment : presrcpath -> String list -> presrcpath
\end{verbatim}

The list of strings must contain simple pathname arcs.

\subsubsection{Adding a ilk and its rule}

The interface to add arbitrary ilks is the routine {\tt
tools.registerIlk}:

\begin{verbatim}
  my registerIlk : ilk * rule -> Void
\end{verbatim}

Here, type {\tt ilk} is simply synonymous to {\tt String}; a ilk
string is the name of the ilk to be registered.  It must not contain
upper-case letters:

\begin{verbatim}
  type ilk = String
\end{verbatim}

Type {\tt rule} is a function type.  It describes the rule function
that make7 will invoke for every member of the new ilk. The rule
function is responsible for invoking the auxiliary mechanism necessary
to bring its targets up-to-date.  The function result of the rule
function describes to make7 what the targets are.  Thus, the function
maps the {\em specification} of the given member to its (partial) {\em
expansion}:

\begin{verbatim}
  type rule =
    { spec: spec,
      native2pathmaker: String -> pathmaker,
      context: rulecontext,
      defaultIlkOf: fnspec -> ilk option } ->
    partial_expansion
\end{verbatim}

The specification {\tt spec} consists of the name of the member
together with a function to produce its corresponding abstract
path (should that be necessary), the member's optional ilk (in case
it had been given explicitly), its tool options, and a boolean flag
that tells whether this member was the result of another tool:

\begin{verbatim}
  type spec = { name: String,
                make_path: pathmaker,
                ilk: ilk option,
                tool_options: toolopts option,
                derived: Bool }
\end{verbatim}

\begin{description}
\item[name:] The name is the verbatim member string from the
description file.  Be sure not to use this string directly as a file
name (although some tools might use it directly for purposes other
than file names).  Instead, first convert it to an abstract path (see
{\tt make_path} below) and then convert back to a {\em native} file name
string using one of {\tt nativeSpec} or {\tt nativePreSpec}.
\item[make_path] This is a function of type {\tt pathmaker} that produces
an abstract pathname corresponding to {\tt name}.  make7 will pass in different
functions here depending on whether {\tt name} was given in make7's
standard pathname syntax or in the underlying operating system's
native syntax.
\begin{verbatim}
  type pathmaker = Void -> presrcpath
\end{verbatim}
\item[ilk:] This argument carries the ilk name if such a ilk
name was explicitly specified.  If the ilk was inferred from the
member name, then it will be set to {\tt NULL}.
\item[opts:] Tool options are represented by a data package
resembling Lisp lists:
\begin{verbatim}
  type fnspec = { name: String, make_path: pathmaker }
  enum toolopt =
      STRING of fnspec
    | SUBOPTS of { name: String, opts: toolopts }
  withtype toolopts = toolopt list
\end{verbatim}
The nesting of {\tt SUBOPTS} reflects the nesting of sub-option lists
in the member's tool option specification.
Again, names which are potentially to be interpreted as file names are
represented by their original specification string and a function {\tt
make_path} to get the corresponding abstract path, thereby taking
care of interpreting the name according to its respective syntactic
rules and its context. (Type {\tt fnspec} is a slimmed-down version of
type {\tt spec}.  It also appears as the argument type of function
{\tt defaultIlkOf}.  See below.)
\item[derived:] This flag is set to {\tt true} if the source file
represented by the specification is the result of a another, earlier
tool invocation.
\end{description}

The other three arguments of a rule function are {\tt native2pathmaker},
{\tt context}, and {\tt defaultIlkOf}:

\begin{description}
\item[native2pathmaker:] This function takes a string and produces a
function of the same type as {\tt make_path} above.  When the rule
constructs the specifications for its result files, it must provide
the corresponding {\tt make_path} functions for those.  Since most tools
internally operate on native pathnames, these {\tt make_path} functions
will have to be constructed using {\tt native2pathmaker}.
\item[context:] The context argument of a rule represents the
directory that contains the make7 description file on whose behalf the
rule was invoked.  It is represented as a higher-order function that
invokes its function argument after temporarily setting the working
directory to the context directory and returns the result of this
invocation after restoring the original working directory.  Not all
rules require such a temporary change of directories, but those that
do should encapsulate all their work into a local function and then
pass this function to the context.
\begin{verbatim}
  type rulefn = Void -> partial_expansion
  type rulecontext = rulefn -> partial_expansion
\end{verbatim}
\item[defaultIlkOf:] This function can be used to directly invoke
make7's internal ilkification mechanism, taking advantage of any
registered classifiers.  The argument to be passed is of type {\tt
fnspec}, i.e., a record consisting of a name string and a function to
convert the string to its corresponding abstract path.
\end{description}

A (full) {\em expansion} consists of three lists: a list of source files,
a list of make7 files, and a list of {\em sources}.  A partial expansion
is a full expansion together with a list of specifications that still
need to be expanded further.

\begin{verbatim}
  type expansion =
    { source_files: (srcpath * sharing.request * setup) list,
      make7_files: (srcpath * Version.t option * Renamings) list,
      sources: (srcpath * { ilk: ilk, derived: Bool}) list
    }

  type partial_expansion = expansion * spec list
\end{verbatim}

A rule always returns a partial expansion.  make7 will derive a full
expansion by repeatedly applying rules until the list of pending
specification becomes empty.

Most rules (except those for ilks {\tt sml} and {\tt cm}) leave the
lists {\tt source_files} and {\tt make7_files} empty.  A tool that produces an
source file or a make7 description file as output should put a
specification for this file into the specification list of a partial
expansion, letting the rules for ilks {\tt sml} and {\tt cm} take
care of the rest.  At this point we will therefore not dwell on
explanations for the types of these two fields.

The {\tt sources} field is used to implement {\tt make7.sources} (see
section~\REF{sec:makedepend:support}).  Therefore, the rule should
include here every file that it consumes if its implementer wishes to
have it reported by {\tt make7.sources}.  (Do not include source files
that are {\em produced} by the rule because those will be reported by
subsequent rules.)

\subsubsection{Reporting errors from tools}

When a rule encounters an error, it should raise the following
exception, setting {\tt tool} to a string describing the current tool
and {\tt msg} to a diagnostic string describing the nature of the
error:

\begin{verbatim}
  exception TOOL_ERROR of { tool: String, msg: String }
\end{verbatim}

\subsubsection{Adding a classifier}

A classifier is a mechanism that enables make7 to infer a member's ilk
from its name.  Classifiers are invoked if no explicit ilk was
given.  make7 supports two kinds of classifiers: suffix classifiers and
general classifiers.

\begin{verbatim}
  enum filename_classifier =
      FILENAME_SUFFIX_CLASSIFIER of String -> ilk option
    | GENERAL_FILENAME_CLASSIFIER of { name: String, makeFilename: Void -> String } ->
                        ilk option
\end{verbatim}

Most of the time classifiers look at the file name suffix as their only
clue.  This idea is captured by {\tt FILENAME\_SUFFIX\_CLASSIFIER} which carries a
partial function from suffixes to ilk names.  The function should
return {\tt NULL} if it does not know about the given argument suffix.

The {\tt GENERAL\_FILENAME\_CLASSIFIER} constructor carries a similar function---the
difference being that the entire member name is passed to it.
Moreover, the function can also invoke the {\tt makeFilename} argument to
obtain a native filename string.  This string can at this point be
used to perform actual filesystem operations.

Invocation of {\tt makeFilename} may raise exceptions, usually due to
syntax errors in {\tt name} that prevent it from being interpreted as
a filename.  Tools that use {\tt makeFilename} should therefore be prepared
to handle such exceptions.

Moreover, it is advisable not to over-use this feature, and not to
perform extensive filesystem processing in order to perform
ilkification.  Otherwise the presence of this classifier might cause
considerable overhead.

By the way, suffix classifiers could be implemented as general
classifiers, but using {\tt FILENAME\_SUFFIX\_CLASSIFIER} for them is slightly more
efficient.  make7 extracts the suffix from the name only once and applies
all suffix classifier before ever considering any generic classifier.
If some suffix classifier succeeds, there will be no overhead caused
by any generic classifier.

Function {\tt tools.standardFilenameSuffixClassifier} is a simple wrapper around {\tt
FILENAME\_SUFFIX\_CLASSIFIER} and produces a classifier that looks for precisely
one suffix string.

\begin{verbatim}
  my standardFilenameSuffixClassifier : { suffix: String, ilk: ilk } -> classifier
\end{verbatim}

Classifiers are registered with make7 by invoking {\tt
tools.note_filename_classifier}:

\begin{verbatim}
  my note_filename_classifier : classifier -> Void
\end{verbatim}

\subsubsection{Miscellaneous}

Package {\tt tools} also provides a number of other types and
functions with the purpose of making it easier to write rule
functions.

\noindent{\bf Filename extension:} Many tools derive the names of
their targets from the name of their source.  As discussed in
section~\REF{sec:addshellilk}, make7 provides some support for this via
values of type {\tt extension_style}:

\begin{verbatim}
  type tooloptcvt = toolopts option -> toolopts option
  enum Extension_Style =
      EXTEND of (String * ilk option * tooloptcvt) list
    | REPLACE of String list * (String * ilk option * tooloptcvt) list
\end{verbatim}

These values can not only be passed to {\tt
tools.registerStandardShellCommmandTool} but also be used to let make7 perform name
extension directly.  To do so, one must invoke function {\tt
tools.extendFilename}:

\begin{verbatim}
  my extendfilename : Extension_Style
                    -> (String * toolopts option)
                    -> (String * ilk option * toolopts option) list
\end{verbatim}

\noindent{\bf Checking time stamps:} A tool can check whether a given
source file is older than all of its corresponding target files.

\begin{verbatim}
  my outdated : String -> String list * String -> Bool
\end{verbatim}

In a call {\tt (tools.outdated $t$ ($l$, $s$))}, $t$ is the name of
the tool, $l$ is the list of targets (as native file names),
and $s$ is the source (also as a native file name).

An alternative way of checking for outdated sources (in the style of
the Noweb-tool; see section~\REF{sec:builtin-tools:noweb}) is the
following:

\begin{verbatim}
  my outdated' : String ->
                  { sourceFileName: String, timestampFileName: String, targetFileName: String } -> Bool
\end{verbatim}

The idea here is that if both {\tt targetFileName} and {\tt timestampFileName}
exist, then {\tt targetFileName} is considered outdated if {\tt
timestampFileName} is older than {\tt sourceFileName}.
Otherwise, if {\tt targetFileName} exists but {\tt
timestampFileName} does not, then {\tt targetFileName} is considered
outdated if it is older than {\tt sourceFileName}.
If {\tt targetFileName} does not exist, then it is always
considered outdated.

\noindent{\bf File- and directory-creation:}  To open a text file for
output in such a way that all directories leading up to it are created
when they do not already exist, use {\tt tools.open_text_output}:

\begin{verbatim}
  my open_text_output : String -> file.Output_Stream
\end{verbatim}

To create the same directories without opening the file (and without
even creating it if it does not exist), use function {\tt
tools::make_all_directories_on_path}:

\begin{verbatim}
  my make_all_directories_on_path : String -> Void
\end{verbatim}

Note that the string passed to {\tt make_all_directories_on_path}
is still the name of a file!

\noindent{\bf Option processing:}  For simple tools, the following
function for ``parsing'' tool options can be useful:

\begin{verbatim}
  my parse_options :
      { tool : String, keywords : String list, options : toolopts } ->
      { matches : String -> toolopts option, restoptions : String list }
\end{verbatim}

Given a list of accepted keywords, this function scans the tool
options and collects occurrences of sub-option lists labelled by one
of these keywords.  Any sub-option list that is not recognized and any
keyword that occurs more than once will be rejected as an error.  The
result consists of a function {\tt matches} that can be uses to query
each of the keywords.  The function also collects and returns all the
{\tt STRING} options.

\noindent{\bf Issuing diagnostics:} Functions {\tt tools.say} and {\tt
tools.vsay} both take a list of strings and output the concatenation
of these strings to the compiler's standard control output stream
(i.e., usually {\tt file.stdout}).  The difference between {\tt say}
and {\tt vsay} is that the former works unconditionally while the
latter is controlled by {\tt make7.control.verbose} (see
section~\REF{sec:registers}).

\noindent{\bf Anchor-configurable strings:} Mainly for the purpose of
implementing anchor-configurable names for auxiliary shell commands
(such as {\tt mythryl-yacc}), one can invoke {\tt tools::make_command_name}:

\begin{verbatim}
  my make_command_name : String -> String
\end{verbatim}

If $m$ is a path anchor that points to $d$, then {\tt (make_command_name $m$)}
returns $d${\tt /}$m$; otherwise it returns $m$.

\subsection{Plug-in Tools}
\label{sec:plugintools}

\subsubsection{Automatically loaded, global plug-in tools}

If make7 encounters a member ilk name $c$ that it does not know about,
then it tries to load a plugin module named {\tt \$/}$c${\tt
-tool.make6}.  If it sees a file whose name ends in suffix $s$ for which
no explicit member ilk has been specified in the make7 description file
and for which automatic member ilkification fails, it will try to
load a plugin module named {\tt \$/}$s${\tt -ext.make6}.  The so-loaded
module can then register the required tool, thereby enabling make7 to
successfully deal with the previously unknown member.

This mechanism makes it possible for new tools to be added by simply
placing appropriately named plug-in libraries in some convenient place
and making the corresponding adjustments to the anchor environment.
In other words, description files {\tt \$/}$c${\tt -tool.make6} and {\tt
\$/}$s${\tt -ext.make6} that correspond to general-purpose tools should
be registered either by modifying the global or the local path
configuration file or by directly invoking functon {\tt
make7.anchor.anchor} (see section~\REF{sec:api:anchors}).  Actual
description files for the tools' implementations can then be placed in
arbitrary locations.

\subsubsection{Explicitly loaded, local plug-in tools}
\label{sec:localtools}

Some projects might want to use their own special-purpose tools for
which a global installation is not convenient or not appropriate.  In
such a case, the project's description file can explicitly demand the
tool to be registered temporarily.  This is the purpose of the special
tool ilk {\tt tool}.  Example:

\begin{verbatim}
Library
    package Foo
is
    bar-tool.make6 : tool
    foo.b : bar
\end{verbatim}

Here, the member whose ilk is {\tt tool} (i.e, {\tt bar-tool.make6})
must be the make7 description file of the tool's implementation.  The
difference to ilk {\tt cm} is that the so-specified library does not
become part of the current project but is loaded and linked
immediately via {\tt make7.load\_plugin}, causing one or more new ilks
and their classifiers to be registered.

If we assume that loading {\tt bar-tool.make6} causes a ilk {\tt bar}
to be registered with its associated rule (e.g., by invoking {\tt
tools::note_standard_shell_command_tool}), the ilk name {\tt bar} will be
available for all subsequent members of the current description file.
Likewise, classifiers (e.g., filename suffixes) registered by {\tt
bar-tool.make6} will also be available.

The effect of registering ilks and classifiers using ilk {\tt
tool} lasts until the end of the current description file and is
restricted to that file.  This means that other description files that
also want to use ilk {\tt bar} will have to have their own {\tt
tool} entry.\footnote{Note that make7 cannot enforce that the tool
library actually register a ilk or a classifier.  Any side-effects
other than registering ilks or classifiers are beyond make7's control
and will not be undone once processing the current description file is
complete.}

Local tool ilks and suffixes temporarily override any equally-named
global ilks or suffixes, respectively.

\subsubsection{Locally declared suffixes}
\label{sec:localsuffixes}

It is sometimes convenient to locally add another recognized filename
suffix to an already registered ilk.  This is the purpose of the
special tool ilk {\tt suffix}.  For example, a programmer who has
named all source files in such a way that file names end in {\tt .ml}
could write near the beginning of the description file:

\begin{verbatim}
    ml : suffix (sml)
\end{verbatim}

For the remainder of the current description file, all such {\tt
.ml}-files will now be treated as members of ilk {\tt sml}.
