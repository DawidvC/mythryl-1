## iconifiable-widget.pkg
#
# Widget for "iconizing" another widget.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.make6






###           "The true mystery of the world
###            is the visible, not the invisible."
###
###                       -- Oscar Wilde


stipulate
    include threadkit;						# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package d3 =  three_d;					# three_d		is from   src/lib/x-kit/widget/lib/three-d.pkg
    package mr =  xevent_mail_router;				# xevent_mail_router	is from   src/lib/x-kit/widget/basic/xevent-mail-router.pkg
    package w  =  widget;					# widget		is from   src/lib/x-kit/widget/basic/widget.pkg
    package wa =  widget_attribute;				# widget_attribute	is from   src/lib/x-kit/widget/lib/widget-attribute.pkg
    #
    package xc =  xcore;					# xcore			is from   src/lib/x-kit/xclient/xcore.pkg
    package xd =  xdraw;					# xdraw			is from   src/lib/x-kit/xclient/xdraw.pkg
    package xf =  xfont;					# xfont			is from   src/lib/x-kit/xclient/xfont.pkg
    package xg =  xgeometry;					# xgeometry		is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi =  xinput;					# xinput		is from   src/lib/x-kit/xclient/xinput.pkg
    package xw =  xwindow;					# xwindow		is from   src/lib/x-kit/xclient/xwindow.pkg
herein

    package iconifiable_widget: (weak)  Iconifiable_Widget {	# Iconifiable_Widget	is from   src/lib/x-kit/widget/wrapper/iconifiable-widget.api

	Plea_Mail
	  #	
	  = GET_SIZE_CONSTRAINT    Oneshot_Maildrop( w::Widget_Size_Preference )
	  #	
	  | DO_REALIZE  { kidplug:  xi::Kidplug,
			  window:   xc::Window,
			  size:     xg::Size
			}
	  ;

	Iconifiable_Widget
	    =
	    ICONIFIABLE_WIDGET
	      { widget:     w::Widget,
		plea_slot:  Mailslot( Plea_Mail )
	      };

	default_font = "-Adobe-Helvetica-Bold-R-Normal--*-120-*";

	min_border_width = 4;
	light_border_width  = 2;

	pady  =  2;				# Padding above and below label.
	space = 10; 			# Spacing between light and label.


	attributes
	    =
	    [ (wa::border_width,   wa::INT,    wa::INT_VAL 10),
	      (wa::label,          wa::STRING, wa::STRING_VAL ""),
	      (wa::font,           wa::FONT,   wa::STRING_VAL default_font),
	      (wa::color,          wa::COLOR,  wa::NO_VAL),
	      (wa::background,     wa::COLOR,  wa::STRING_VAL "white"),
	      (wa::foreground,     wa::COLOR,  wa::STRING_VAL "black"),
	      (wa::select_color,   wa::COLOR,  wa::STRING_VAL "black")
	    ];

	fun make_font_info font
	    =
	    {   my  { ascent  => font_ascent,
		      descent => font_descent
		    }
		    =
		    xf::font_high font;

		(font, font_ascent, font_descent);
	    };

	fun make_text_label (s, font)
	    =
	    {   my xf::CHAR_INFO { left_bearing, right_bearing, ... }
		    =
		    .overall_info (xf::text_extents font s);

		(s, left_bearing, right_bearing);
	    };

	fun size_of_label ((s, lb, rb), (_, fa, fd))
	    =
	    xg::SIZE { wide =>  rb - lb + 2,
		       high =>  fa + fd
		     };

	fun set_light_width (_, fonta, fontd)
	    =
	    (80 * (fonta+fontd)) / 100;

	Result = { child:     w::Widget,
		   shades:    w::Shades,

		   fontinfo: (xc::Font, Int, Int),
		   label:    (String, Int, Int),

		   fg:        xc::Color,
		   bg:        xc::Color,
		   on_color:  xc::Color,

		   light_size:    Int,
		   pady:          Int,
		   border_width:  Int
		 };

	fun make_result (root, view, args) child
	    =
	    {   attributes = w::find_attribute (w::attributes (view, attributes, args));

		my fontinfo as (f, _, _)
		    =
		    make_font_info (wa::get_font (attributes wa::font));

		label =  make_text_label (wa::get_string (attributes wa::label), f);

		border_width     =  wa::get_int   (attributes wa::border_width);

		foreground_color =  wa::get_color (attributes wa::foreground);
		background_color =  wa::get_color (attributes wa::background);
		select_color     =  wa::get_color (attributes wa::select_color);

		color = case (wa::get_color_opt (attributes wa::color))   
			    #
			    THE color =>  color; 
			    _         =>  background_color;
			esac;

		light_size = set_light_width fontinfo;

		  { child,
		    fontinfo,
		    label,
		    fg => foreground_color,
		    bg => background_color,
		    pady,
		    shades => w::shades root color,
		    light_size,
		    border_width => int::max (border_width, min_border_width),
		    on_color => select_color
		  };
	    };

	fun drawfn (dr, xg::SIZE { wide, high },  v: Result)
	    =
	    {   v.fontinfo ->  (font, font_ascent, font_descent);

		font_high = font_ascent + font_descent;

		txt_pen =  xd::make_pen [xd::FOREGROUND (xc::rgb8_from_rgb (xc::rgb_of_color v.fg))];
		on_pen  =  xd::make_pen [xd::FOREGROUND (xc::rgb8_from_rgb (xc::rgb_of_color v.on_color))];

		fun draw_light (is_on, relief)
		    =
		    {   light_size = v.light_size;

			col = v.border_width;
			row = v.pady + (font_high - light_size) / 2;

			box =  xg::BOX
				 { col, row,
				   wide => light_size,
				   high => light_size
				 };

			arg = { box, relief, width => light_border_width };

			shades = v.shades;

			if is_on
			    #
			    xd::fill_box  dr  on_pen  box;

			    d3::draw_box  dr  arg  shades;
			else
			    d3::draw_filled_box  dr  arg  shades;
			fi;
		    };

		fun draw_groove ()
		    =
		    {   bw = v.border_width;

			my  xg::SIZE { wide => label_wide, ... }
			    =
			    size_of_label (v.label, v.fontinfo);

			light_size = v.light_size;

			y = v.pady + (font_high / 2);
			rht = high - y - (bw / 2);

			box =  xg::BOX { col=>bw / 2, row=>y, wide=>wide-bw, high=>rht };

			clr_box
			    =
			    xg::BOX
			      { col  => bw + light_size,
				row  => v.pady,
				wide => space + label_wide,
				high => font_high
			      };

			arg = { box, width=>2, relief=>w::GROOVE };

			d3::draw_box dr arg v.shades;

			xd::clear_box dr clr_box;
		    };

		fun draw_label ()
		    =
		    {   light_size = v.light_size;

			v.fontinfo ->  (font, font_ascent, _);
			v.label    ->  (s, lb, _);

			col = v.border_width + light_size + space - lb + 1;
			row = v.pady + font_ascent + 1;

			xd::draw_transparent_string
                            dr
                            txt_pen
                            font
                            (xg::POINT { col, row }, s);
		    };

		fun init ()
		    =
		    {   xd::clear_drawable  dr;
			draw_groove ();
			draw_label ();
		    };

		fun draw (do_init, is_open, down)
		    =
		    {   if do_init   init();   fi; 

			draw_light
			  ( is_open,
			    down ?? w::SUNKEN :: w::RAISED
			  );
		    };

		  draw;
	      };

	Mouse_Event = MOUSE_EVENT_DOWN
		    | MOUSE_EVENT_UP  Bool
		    ;

	fun mouse_p (m, m_slot)
	    =
	    loop ()
	    where
		fun down_loop is_in
		    = 
		    case (xi::envelope_contents (do_mailop m))
			#
			xi::MOUSE_LAST_UP _ =>  give  (m_slot,  MOUSE_EVENT_UP is_in);
			xi::MOUSE_LEAVE _   =>  down_loop  FALSE;
			xi::MOUSE_ENTER _   =>  down_loop  TRUE;
			_                   =>  down_loop  is_in;
		    esac; 

		fun loop ()
		    =
		    for (;;) {
			#
			case (xi::envelope_contents (do_mailop m))    
			    #
			    xi::MOUSE_FIRST_DOWN { button, ... }
				=>
				{   give  (m_slot,  MOUSE_EVENT_DOWN);
				    #
				    down_loop TRUE;
				};

			    _ => ();
			esac;
		    };
	    end;

	fun adjust (w::INT_PREFERENCE { start_at, step_by, min_steps, ideal_steps, max_steps }, low)
	    =
	    {   fun adj (l, mn)
		    =
		    if (l >= low)   mn;
		    else            adj (l+step_by, mn+1);
		    fi;

		min_steps = adj (start_at+min_steps*step_by, min_steps);
		ideal_steps = int::max (ideal_steps, min_steps);

		max_steps
		    =
		    case max_steps    
			#
			THE m => THE (int::max (m, ideal_steps));
			NULL => NULL; 
		    esac;

		w::INT_PREFERENCE { start_at, step_by, min_steps, ideal_steps, max_steps };
	    };


	fun bounds (result:  Result, is_open)
	    =
	    {
		fun inc_base (w::INT_PREFERENCE { start_at, step_by, min_steps, ideal_steps, max_steps }, extra)
		    =
		    w::INT_PREFERENCE { start_at=>start_at+extra, step_by, min_steps, ideal_steps, max_steps };

		my  xg::SIZE { wide, high }
		    =
		    size_of_label (result.label, result.fontinfo );

		my { col_preference, row_preference }
		    =
		    w::size_preference_of  result.child;

		xextra =  2*result.border_width;

		topwid =  xextra + result.light_size + wide + space;

		col_preference
		    =
		    if (w::minimum_length col_preference >= topwid)         col_preference;
		    else                                            adjust (col_preference, topwid);
		    fi;

		yextra = 2*result.pady + result.border_width + high;

		row_preference
		    =
		    if is_open  inc_base (row_preference, yextra);
		    else        w::tight_preference yextra;
		    fi;

		{ col_preference =>  inc_base (col_preference, xextra),
		  row_preference
		}; 
	    };


	fun realize ( { kidplug, window, size }, result:  Result, plea')
	    =
	    {   mslot =  make_mailslot ();

		rcvm  =  take'  mslot;

		kidplug ->  xi::KIDPLUG { to_mom=>myco, ... };

		my { kidplug, momplug }
		    =
		    xi::make_widget_cable ();

		my  xi::KIDPLUG { from_other', from_mouse', ... }
		    =
		    xi::ignore_keyboard  kidplug;

		fun child_box (xg::SIZE { wide, high } )
		    =
		    {   bw = result.border_width;

			result.fontinfo ->  (_, font_ascent, font_descent);

			yoff =  result.pady + font_ascent + font_descent;

			xg::BOX
			  { col  => bw,
			    row  => yoff,

			    wide => int::max (1, wide-bw-bw),
			    high => int::max (1, high-yoff-bw)
			  };
		    };

		crect = child_box size;

		cwin =  w::make_child_window  (window,  crect,  w::args_of result.child);

		my  { kidplug => ckidplug,
                      momplug => cmomplug
                    }
		    =
		    xi::make_widget_cable ();

		cmomplug ->  xi::MOMPLUG { from_kid'=>childco, ... };

		dr =  xd::drawable_of_window  window;


		fun handle_co (xi::REQ_RESIZE, is_open)
			=> 
			if is_open  do_mailop (myco xi::REQ_RESIZE); fi;

		   handle_co (xi::REQ_DESTRUCTION, _)
		       => 
		       {   xw::destroy_window cwin;
			   do_mailop (myco xi::REQ_DESTRUCTION);
		       };
		end;


		fun do_mom (xi::ETC_RESIZE (xg::BOX { wide, high, ... } ), me)
			=>
			{   size =  xg::SIZE { wide, high };

			    if (#1 me)
				#
				xw::move_and_resize_window  cwin  (child_box size);
			    fi;
			    (#1 me, #2 me, drawfn (dr, size, result));
			};

		    do_mom (xi::ETC_REDRAW _, me as (is_open, down, drawfn))
			=>
			{ drawfn (TRUE, is_open, down); me;};

		    do_mom (_, me)
			=>
			me;
		end;


		fun do_plea (GET_SIZE_CONSTRAINT reply_1shot, is_open)
			=> 
			set  (reply_1shot,  bounds (result, is_open));

		    do_plea _ => ();
		end;


		fun handle_mouse_event (MOUSE_EVENT_DOWN, (is_open, _, drawfn))
			=>
			{   drawfn (FALSE, is_open, TRUE);

			    (is_open, TRUE, drawfn);
			};

		    handle_mouse_event (MOUSE_EVENT_UP TRUE, (is_open, _, drawfn))
			=>
			{   if is_open  xw::hide_window  cwin;
			    else        xw::show_window  cwin;
			    fi; 

			    do_mailop (myco xi::REQ_RESIZE);
			    drawfn (FALSE, not is_open, FALSE);

			    (not is_open, FALSE, drawfn);
			};

		    handle_mouse_event (MOUSE_EVENT_UP FALSE, (is_open, _, drawfn))
			=>
			{   drawfn (FALSE, is_open, FALSE);

			    (is_open, FALSE, drawfn);
			};
		end;


		fun main me
		    =
		    select [
			plea'       ==>  (fn r        =  { do_plea (r,#1 me);  main me;}),
			from_other' ==>  (fn envelope =    main (do_mom (xi::envelope_contents envelope, me))),
			rcvm        ==>  (fn m        =    main (handle_mouse_event (m, me))),
			childco     ==>  (fn c        =  { handle_co (c,#1 me); main me;})
		    ];

		    make_thread "iconifiable_widget" .{
			#
			mouse_p (from_mouse', mslot);
		    };

		    mr::route_pair (kidplug, momplug, cmomplug);

		    w::realize_fn

			result.child

			{ kidplug =>  ckidplug, 
			  window  =>  cwin,
			  size    =>  xg::size_of_box  crect
			};

		    main (FALSE, FALSE, drawfn (dr, size, result));
	      };

	fun init (result:  Result, plea')
	    =
	    loop ()
	    where
		fun do_plea (GET_SIZE_CONSTRAINT reply_1shot) =>   set (reply_1shot, bounds (result, FALSE));
		    do_plea (DO_REALIZE arg        ) =>   realize (arg, result, plea');
		end;

		fun loop ()
		    =
		    for (;;) {
			do_plea (do_mailop plea');
		    };
	    end;

	fun make_iconifiable_widget (root_window, view, args) widget
	    =
	    {   plea_slot =  make_mailslot ();
		result    =  make_result (root_window, view, args) widget;

		fun size_preference_thunk_of ()
		    =
		    {   reply_1shot = make_oneshot_maildrop ();

			give (plea_slot, GET_SIZE_CONSTRAINT reply_1shot);

			get reply_1shot;
		    };

		w = w::make_widget {
			  root_window,
			  size_preference_thunk_of,
			  args    =>  fn ()  =  { background => THE result.bg },
			  realize =>  fn arg =  give (plea_slot, DO_REALIZE arg)
			};

		make_thread "iconifiable_widget init" .{
		    #
		    init  (result,  take' plea_slot);
		};

		ICONIFIABLE_WIDGET { widget=>w, plea_slot };
	    };

	fun as_widget (ICONIFIABLE_WIDGET { widget, ... } )
	    =
	    widget;

    };			# package iconifiable_widget

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
