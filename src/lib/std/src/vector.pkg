## vector.pkg

# Compiled by:
#     src/lib/std/src/stdlib-core.make6



###              "Hunger is the handmaid of genius."
###
###                             -- Mark Twain,
###                                "Following the Equator"



package vector: (weak)  Vector {		# Vector	is from   src/lib/std/src/vector.api


/*
    my (op +)  = inline_t::default_int::(+)
    my (op <)  = inline_t::default_int::(<)
    my (op >=) = inline_t::default_int::(>=)
*/

    # Fast add/subtract avoiding
    # the overflow test:
    #
    infix val --- +++ ;

    fun x --- y =  inline_t::unt31::copyt_int31 (inline_t::unt31::copyf_int31 x - inline_t::unt31::copyf_int31 y);
    fun x +++ y =  inline_t::unt31::copyt_int31 (inline_t::unt31::copyf_int31 x + inline_t::unt31::copyf_int31 y);

    Vector(X) =  Vector(X);

    max_len =  core::max_length;

    fun check_len n
        =
	if (inline_t::default_int::ltu  (max_len, n))
	    #            
            raise exception exceptions::SIZE;
        fi;

    fun from_list l
	=
	{
	    # No list can be longer than
            # what is representable as Int: 
	    #
	    fun len ([],  n) => n;
		len ([_], n) => n +++ 1;
		len (_ ! _ ! r, n) => len (r, n +++ 2);
            end;

	    n = len (l, 0);

	    check_len n;

	    if (n == 0)   assembly::vector0;
	    else          assembly::a::create_v (n, l);
            fi;
	};

    fun tabulate (0, _)
            =>
            assembly::vector0;

        tabulate (n, f)
	    =>
	    {   fun tab i
                    =
                    if   (i == n)
                         [];
                    else f i ! tab (i+++1);   fi;

		check_len n;
		assembly::a::create_v (n, tab 0);
	    };
    end;

    my length:  Vector( X ) -> Int     =  inline_t::poly_vector::length;

    # Note:  The (_[])   enables   'vec[index]'           notation;
    #        The (_[]:=) enables   'vec[index] := value'  notation;

    my get:    (Vector( X ), Int) -> X =  inline_t::poly_vector::check_sub;
    my (_[]):  (Vector( X ), Int) -> X =  inline_t::poly_vector::check_sub;

    unsafe_get = inline_t::poly_vector::get;

    # A utility function 
    fun reverse ([], l) => l;
        reverse (x ! r, l) => reverse (r, x ! l);
    end;

/*
    fun extract (v, base, optLen) = let
	  len = length v
	  fun newVec n = let
		fun tab (-1, l) = assembly::a::create_v (n, l)
		  | tab (i, l) = tab (i - 1, inline_t::poly_vector::get (v, base+i) ! l)
		in
		  tab (n - 1, [])
		end
	  in
	    case (base, optLen)
	     of (0, NULL) => v
	      | (_, THE 0) => if ((base < 0) or (len < base))
		  then raise exception exceptions::SUBSCRIPT
		  else assembly::vector0
	      | (_, NULL) => if ((base < 0) or (len < base))
		    then raise exception exceptions::SUBSCRIPT
		  else if (len == base)
		    then assembly::vector0
		    else newVec (len - base)
	      | (_, THE n) =>
		  if ((base < 0) or (n < 0) or (len < (base+n)))
		    then raise exception exceptions::SUBSCRIPT
		    else newVec n
	    #  end case 
	  end
*/

    fun cat [v] => v;
	cat vl => {
	   #  get the total length and flatten the list 
	   fun len ([], n, l) => { check_len n; (n, reverse (l, [])); };
	      len (v ! r, n, l) => {
		   n' = inline_t::poly_vector::length v;
		   fun explode (i, l) =
		       if (i < n' ) explode (i+++1, unsafe_get (v, i) ! l); else l;fi;

		   len (r, n +++ n', explode (0, l));
	       }; end;

	     case (len (vl, 0, []))
               
	        (0, _) => assembly::vector0;
		(n, l) => assembly::a::create_v (n, l);
             esac;
	   };
    end;

    fun keyed_apply f vec
	=
	{   len = length vec;

	    fun apply i
                =
		if   (i < len)
                    
                     f (i, unsafe_get (vec, i));
                     apply (i +++ 1);
                fi;

	    apply 0;
	};

    fun apply f vec = {
	len = length vec;
	fun apply i =
	    if (i < len ) f (unsafe_get (vec, i)); apply (i +++ 1); fi;
    
	apply 0;
    };

    fun keyed_map f vec
	=
	{   len = length vec;

	    fun mapf (i, l)
                =
		if   (i < len)
                    
                     mapf (i +++ 1, f (i, unsafe_get (vec, i)) ! l);
		else
                     assembly::a::create_v (len, reverse (l, []));
                fi;

	    if   (len > 0)
                
                 mapf (0, []);
            else
                 assembly::vector0;
            fi;
	};

    fun map f vec
        =
	{   len =  length vec;

	    fun mapf (i, l)
                =
		if   (i < len)
                    
                     mapf (i+1, f (unsafe_get (vec, i)) ! l);
		else
                     assembly::a::create_v (len, reverse (l, []));
                fi;

	    if   (len > 0)
                
                 mapf (0, []);
            else
                 assembly::vector0;
            fi;
	};

    fun set (v, i, x)
        =
	keyed_map
            (fn (i', x') =   i == i' ??  x  ::  x')
            v;

    (_[]:=)  =  set;

    fun keyed_fold_left f init vec
        =
	fold (0, init)
        where
	    len =  length vec;

	    fun fold (i, a)
                =
		if   (i >= len)
                    
                     a;
                else
                     fold (i +++ 1, f (i, unsafe_get (vec, i), a));
                fi;
	end;

    fun fold_left f init vec
	=
	fold (0, init)
	where
	    len =  length vec;

	    fun fold (i, a)
		=
		if   (i >= len)
		    
		     a;
		else
		     fold (i +++ 1,   f (unsafe_get (vec, i), a));
		fi;

	end;

    fun keyed_fold_right f init vec
	=
	fold (length vec --- 1, init)
	where
	    fun fold (i, a)
		=
		if   (i < 0)
		    
		     a;
		else
		     fold (i --- 1,  f (i, unsafe_get (vec, i), a));
		fi;

	end;

    fun fold_right f init vec
	=
	fold (length vec --- 1, init)
	where
	    fun fold (i, a)
		=
		if   (i < 0)
		    
		     a;
		else
		     fold (i --- 1,  f (unsafe_get (vec, i), a));
		fi;
	end;

    fun findi p vec
	=
	fnd 0
	where
	    len =  length vec;

	    fun fnd i
		=
		if   (i >= len)
		    
		     NULL;
		else
		     x =  unsafe_get (vec, i);

		     if   (p (i, x))
                         
                          THE (i, x);
                     else
                          fnd (i +++ 1);
                     fi;
		fi;
	end;

    fun find p vec
	=
	fnd 0
	where
	    len =  length vec;

	    fun fnd i
                =
		if   (i >= len)
                    
                     NULL;
		else
                     x =  unsafe_get (vec, i);

		     if    (p x)
                         
                          THE x;
                     else
                          fnd (i +++ 1);
                     fi;
		fi;
	end;

    fun exists p vec
	=
	ex 0
	where
	    len = length vec;

	    fun ex i
		=
		i < len  and   (p (unsafe_get (vec, i))  or  ex (i +++ 1));

	end;

    fun all p vec
	=
	al 0
	where
	    len =  length vec;

	    fun al i
		=
		i >= len   or   (p (unsafe_get (vec, i))  and  al (i +++ 1));
	end;

    fun collate c (v1, v2)
	=
	col 0
	where
	    l1 =  length v1;
	    l2 =  length v2;

	    l12 =   inline_t::int31::min (l1, l2);

	    fun col i
		=
		if   (i >= l12)
		    
		     int_guts::compare (l1, l2);
		else
		     case (c (unsafe_get (v1, i), unsafe_get (v2, i)))
		       
			  EQUAL   =>  col (i +++ 1);
			  unequal =>  unequal;
		     esac;
		fi;
	end;

};	#  package vector 


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
