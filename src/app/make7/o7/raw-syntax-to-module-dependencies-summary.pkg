## Convert RAW_SYNTAX_TREEs to make7's trimmed version thereof ("module_dependencies_summarys").
## author: Matthias Blume (blume@cs.princeton.edu)
## The copyright notices of the earlier versions are:
##   Copyright (c) 1995 by AT&T Bell Laboratories
##   Copyright (c) 1993 by Carnegie Mellon University,
##                         School of Computer Science
##                         contact: Gene Rollins (rollins+@cs.cmu.edu)

# Compiled by:
#     src/app/make7/Make7.make6

#   The ideas here are based on those found in the original SC and
#   also in an older version of make7 (before 1999).  However, nearly
#   all aspects have been changed radically, and the code has been
#   re-written from scratch.
#
#   The module_dependencies_summarys generated by this module are typically smaller
#   than the "decl"s in SC or old versions of make7.  This should
#   make dependency analysis somewhat faster (but is probably not
#   very noticeable).


api Raw_Syntax_To_Module_Dependencies_Summary {

    convert:  { tree:  raw_syntax::Declaration,				# raw_syntax			is from   src/lib/compiler/front/parse/raw-syntax/raw-syntax.pkg

		err:   error_message::Severity				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
		    -> raw_syntax::Source_Code_Region
		    -> String
		    -> Void
	      }
              ->
	      { module_dependencies_summary:  module_dependencies_summary::Decl,				# module_dependencies_summary			is from   src/app/make7/o7/module-dependencies-summary.pkg
		complain:  Void -> Void
	      };
};

package raw_syntax_to_module_dependencies_summary : Raw_Syntax_To_Module_Dependencies_Summary	{		# Raw_Syntax_To_Module_Dependencies_Summary	is from   src/app/make7/o7/raw-syntax-to-module-dependencies-summary.pkg

    include raw_syntax;
    include module_dependencies_summary;

    package s  =  symbol;						# symbol			is from   src/lib/compiler/front/basics/mlcomp/symbol.pkg
    package sp =  symbol_path;						# symbol_path			is from   src/lib/compiler/front/typecheck-stuff/basics/symbol-path.pkg
    package ss =  symbol_set;						# symbol_set			is from   src/app/make7/util/symbolset.pkg
    package em =  error_message;					# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    Symbol = symbol::Symbol;
    Path   = List( Symbol );

    # The main idea is to collect lists of decl ("dl"s).
    # Normally, a dl will eventually become an argument to seq or par.
    # As an important optimization, we always try to keep any "Ref s"
    # at the front (but we don't try too hard and only do it where
    # it is reasonably convenient).

    # Function composition suitable for fold[lr]-arguments 
    #
    infix val  o' ;
    #
    fun (f o' g) (x, y)
        =
        f (g x, y);

    #  Add the head of a symbol path to a given set: 
    #
    fun s_add_p ([], set)
            =>
            set;

        s_add_p (head ! _, set)
            =>
            ss::add (set, head);
    end;

    # Same as s_addP except we ignore paths of length 1
    # because they do not involve module access:
    #
    fun s_add_mp ([],       set) =>   set;			#  Can this happen at all?  XXX BUGGO FIXME
	s_add_mp ([only],   set) =>   set;			#  no module name here 
	s_add_mp (head ! _, set) =>   ss::add (set, head);
    end;

    #  Add a reference to a symbol to a dl: 
    #
    fun dl_add_sym (symbol, [])         =>   [REF (ss::singleton symbol)];
	dl_add_sym (symbol, REF s ! dl) =>    REF (ss::add   (s, symbol)) ! dl;
	dl_add_sym (symbol, dl)         =>    REF (ss::singleton symbol)  ! dl;
    end;

    #  Add the first element of a path to a dl: 
    #
    fun dl_add_p ([], d)
            =>
            d;

        dl_add_p (head ! _, d)
            =>
            dl_add_sym (head, d);
    end;

    # Add the first element of a path to a dl
    # -- except if that element is the only
    # one on the path:

    fun dl_add_mp ([],       dl) =>  dl;
	dl_add_mp ([only],   dl) =>  dl;
	dl_add_mp (head ! _, dl) =>  dl_add_sym (head, dl);
    end;

    #  Given a set of module references, add it to a decl list: 
    #
    fun dl_add_s (s, dl)
        =
	if   (ss::is_empty s)
            
             dl;
	else
             case dl
	       
	         []           =>  [REF s];
  	         REF s' ! dl' =>   REF (ss::union (s, s')) ! dl';
	         _            =>   REF s ! dl;
             esac;
        fi;

    #  Make a SEQ node when necessary: 
    #
    fun seq []     =>   REF ss::empty;
	seq [only] =>   only;
	seq l      =>   SEQ l;
    end;

    #  Make a PAR node when necessary and stick it in front of a given dl: 

    fun parcons ([], d)     =>   d;
	parcons ([only], d) =>   only ! d;
	parcons (l, d)      =>   PAR l ! d;
    end;

    # Given a "bind list", stick a parallel BIND in front of a given dl.
    # While doing so, if a REF occured at the front of the dl, move it
    # past the bind list (shrinking it appropriately).

    fun parbindcons (bl, REF s ! d)
	    =>
	    {   bs =   ss::add_list (ss::empty, map #1 bl);

		dl_add_s (ss::difference (s, bs), parcons (map BIND bl, d));
	    };

       parbindcons (bl, d)
	   =>
	   parcons (map BIND bl, d);
    end;

    #  Split initial ref set from a decl list: 

    fun split_dl []          =>   (ss::empty, []);
	split_dl (REF s ! d) =>   (s, d);
	split_dl d           =>   (ss::empty, d);
    end;

    #  Join two definition sequences: 

    fun join_dl ([],      d) =>   d;
	join_dl ([REF s], d) =>   dl_add_s (s, d);
	join_dl (h ! t, d) =>   h ! join_dl (t, d);
    end;

    #  Local definitions: 

    fun local_dl ([],        b, d) =>   join_dl (b, d);
	local_dl (REF s ! t, b, d) =>   dl_add_s (s, local_dl (t, b, d));
	local_dl (l,         b, d) =>   LOCAL (seq l, seq b) ! d;
    end;

    #  Build a 'let' expression: 

    fun letexp (dl, (s, e))
        =
	case (split_dl dl)
	  
	    (s', [])
                =>
                (ss::union (s', s), e);

	    (s', dl')
		=>
		{   dl'' =   if   (ss::is_empty s)
			         
                                  dl';
			     else
                                  reverse (dl_add_s (s, reverse dl'));
                             fi;

		   (s', LET (dl'', e));
		};
        esac;

    #  Making an IGN1 where necessary ... 

    fun ign (      p1,         NULL) =>   p1;
        ign ((s1, e1), THE (s2, e2)) =>   (ss::union (s1, s2), IGN1 (e1, e2));
    end;

    #  Open cancels Decl: 

    fun use (DECL dl, dl') =>  join_dl (dl, dl');
        use (e, dl)        =>  OPEN e ! dl;
    end;

    #  Generate a set of "parallel" namings 

    fun parbind f l d
        =
        {   my (s, bl)
                =
                fold_left f (ss::empty, []) l;

	    dl_add_s (s, parbindcons (bl, d));
	};

    #  Get the ref set from a type: 

    fun ty_s (TYPE_VARIABLE_TYPE _, set)                      =>   set;
	ty_s (TYPE_CONSTRUCTOR_TYPE (cn, l), set)        =>   s_add_mp (cn, fold_left ty_s set l);

	ty_s (RECORD_TYPE l, set)                        =>   fold_left (ty_s o' #2) set l;
	ty_s (TUPLE_TYPE  l, set)                        =>   fold_left ty_s set l;

	ty_s (SOURCE_CODE_REGION_FOR_TYPE (arg, _), set) =>   ty_s (arg, set);
    end;

    #  ... from a type option 

    fun tyopt_s (NULL,  set) =>   set;
        tyopt_s (THE t, set) =>   ty_s (t, set);
    end;

    #  ... from a pattern 

    fun pat_s (VARIABLE_IN_PATTERN p, set) => s_add_mp (p, set);

	pat_s (RECORD_PATTERN { definition, ... }, set)
	    =>
	    fold_left (pat_s o' #2) set definition;

	pat_s (   ( LIST_PATTERN   l
		  | TUPLE_PATTERN  l
		  | VECTOR_PATTERN l
		  | OR_PATTERN     l
		  ),

		  set
              )
	    =>
	    fold_left pat_s set l;

	pat_s (PRE_FIXITY_PATTERN l, set)
            =>
            fold_left (pat_s o' .item) set l;

	pat_s (APPLY_PATTERN { constructor, argument }, set)
	    =>
	    pat_s (constructor, pat_s (argument, set));

	pat_s (TYPE_CONSTRAINT_PATTERN { pattern, type_constraint }, set)
	    =>
	    pat_s (pattern, ty_s (type_constraint, set));

	pat_s (AS_PATTERN { variable_pattern, expression_pattern }, set)
	    =>
	    pat_s (variable_pattern, pat_s (expression_pattern, set));

	pat_s (SOURCE_CODE_REGION_FOR_PATTERN (arg, _), set)
	    =>
	    pat_s (arg, set);

	pat_s ((               WILDCARD_PATTERN
		|       INT_CONSTANT_IN_PATTERN _
		|       UNT_CONSTANT_IN_PATTERN _
		|    STRING_CONSTANT_IN_PATTERN _
		| CHAR_CONSTANT_IN_PATTERN _
		), set)
	    =>
	    set;
    end;

    #  ... from an exception naming: 

    fun eb_s (NAMED_EXCEPTION           { exception_symbol=>exn, exception_type=>etype }, set) =>   tyopt_s (etype, set);
        eb_s (DUPLICATE_NAMED_EXCEPTION { exception_symbol=>exn, equal_to=>edef  },       set) =>   s_add_mp (edef, set);
        eb_s (SOURCE_CODE_REGION_FOR_NAMED_EXCEPTION (arg, _),                            set) =>   eb_s (arg, set);
    end;

    #  ... 
    fun dbrhs_s (ENUM_CONSTRUCTORS l, set)
            =>
            fold_left (tyopt_s o' #2) set l;

        dbrhs_s (REPLICAS cn, set)
            =>
            s_add_mp (cn, set);
    end;

    fun db_s (NAMED_ENUM { type_constructor, type_variables, right_hand_side=>rhs, is_lazy }, set)
            =>
            dbrhs_s (rhs, set);

        db_s (SOURCE_CODE_REGION_FOR_NAMED_DATATYPE (arg, _), set)
            =>
            db_s (arg, set);
    end;

    fun tb_s (NAMED_TYPE { type_constructor, definition, type_variables }, set)
            =>
            ty_s (definition, set);

        tb_s (SOURCE_CODE_REGION_FOR_NAMED_TYPE (arg, _), set)
            =>
            tb_s (arg, set);
    end;

    #  Get a dl from an expression: 

    fun exp_dl (VARIABLE_IN_EXPRESSION p, d)
            =>
            dl_add_mp (p, d);

        exp_dl (IMPLICIT_THUNK_PARAMETER p, d)	# These should have been expanded to VARIABLE_IN_EXPRESSION by now.
            =>
	    {   exception       IMPOSSIBLE;
		raise exception IMPOSSIBLE;
            };

	exp_dl (FN_EXPRESSION rl, d)
            =>
            fold_right rule_dl d rl;

	exp_dl (PRE_FIXITY_EXPRESSION l, d)
            =>
            fold_right (exp_dl o' .item) d l;

	exp_dl (APPLY_EXPRESSION { function, argument }, d)
	    =>
	    exp_dl (function, exp_dl (argument, d));

	exp_dl (OBJECT_FIELD_EXPRESSION { object, field }, d)
	    =>
	    exp_dl (object, d);

	exp_dl (CASE_EXPRESSION { expression, rules }, d)
	    =>
	    exp_dl (expression, fold_right rule_dl d rules);

	exp_dl (LET_EXPRESSION { declaration, expression }, d)
	    =>
	    local_dl (dec_dl (declaration, []), exp_dl (expression, []), d);

	exp_dl ( ( SEQUENCE_EXPRESSION l
		  | LIST_EXPRESSION     l
		  | TUPLE_EXPRESSION    l
		  | VECTOR_EXPRESSION   l
		  ), d)
	    =>
	    fold_left exp_dl d l;

	exp_dl (RECORD_EXPRESSION l, d)
            =>
            fold_left (exp_dl o' #2) d l;

	exp_dl (RECORD_SELECTOR_EXPRESSION _, d)
            =>
            d;

	exp_dl (TYPE_CONSTRAINT_EXPRESSION { expression, constraint }, d)
	    =>
	    dl_add_s (ty_s (constraint, ss::empty), exp_dl (expression, d));

	exp_dl (EXCEPT_EXPRESSION { expression, rules }, d)
	    =>
	    exp_dl (expression, fold_left rule_dl d rules);

	exp_dl (RAISE_EXPRESSION e, d)
	    =>
	    exp_dl (e, d);

	exp_dl (IF_EXPRESSION { test_case, then_case, else_case }, d)
	    =>
	    exp_dl (test_case, exp_dl (then_case, exp_dl (else_case, d)));

	exp_dl ((AND_EXPRESSION (e1, e2) | OR_EXPRESSION (e1, e2)), d)
	    =>
	    exp_dl (e1, exp_dl (e2, d));

	exp_dl (WHILE_EXPRESSION { test, expression }, d)
            =>
            exp_dl (test, exp_dl (expression, d));

	exp_dl (SOURCE_CODE_REGION_FOR_EXPRESSION (arg, _), d)
            =>
            exp_dl (arg, d);

	exp_dl ((     INT_CONSTANT_IN_EXPRESSION _
		 |    UNT_CONSTANT_IN_EXPRESSION _
		 |  FLOAT_CONSTANT_IN_EXPRESSION _
		 | STRING_CONSTANT_IN_EXPRESSION _
		 |   CHAR_CONSTANT_IN_EXPRESSION _
		 ), d)
            =>
            d;
    end 

    also
    fun rule_dl (CASE_RULE { pattern, expression }, d)
        =
	dl_add_s (pat_s (pattern, ss::empty), exp_dl (expression, d))

    also
    fun pattern_clause_dl (PATTERN_CLAUSE { patterns => p, result_type => t, expression => e }, d)
        =
	dl_add_s (fold_left (pat_s o' .item) (tyopt_s (t, ss::empty)) p,
		exp_dl (e, d))

    also
    fun named_function_dl (NAMED_FUNCTION { pattern_clauses, is_lazy, kind, null_or_type }, d)
            =>
            case null_or_type
            THE type => dl_add_s (ty_s (type, ss::empty), fold_right pattern_clause_dl d pattern_clauses);
            NULL     =>                                   fold_right pattern_clause_dl d pattern_clauses ; 
            esac; 

        named_function_dl (SOURCE_CODE_REGION_FOR_NAMED_FUNCTION (arg, _), d)
            =>
            named_function_dl (arg, d);
    end 

    also
    fun lib7_pattern_clause_dl (NADA_PATTERN_CLAUSE { pattern => p, result_type => t, expression => e }, d)
        =
	dl_add_s (   fold_left
                        pat_s (tyopt_s (t, ss::empty)) [p],  #  XXX BUGGO FIXME Since [p] is (obviously!) always a length-1 list, the logic can probably be simplified here. 
		        exp_dl (e, d)
                )

    also
    fun lib7_named_function_dl (NADA_NAMED_FUNCTION (l, _), d)
            =>
            fold_right lib7_pattern_clause_dl d l;

        lib7_named_function_dl (SOURCE_CODE_REGION_FOR_NADA_NAMED_FUNCTION (arg, _), d)
            =>
            lib7_named_function_dl (arg, d);
    end 

    also
    fun vb_dl (NAMED_VALUE { pattern, expression, is_lazy }, d)
	    =>
	    dl_add_s (pat_s (pattern, ss::empty), exp_dl (expression, d));

        vb_dl (SOURCE_CODE_REGION_FOR_NAMED_VALUE (arg, _), d)
            =>
            vb_dl (arg, d);
    end 

    also
    fun field_dl (NAMED_FIELD symbol, d)
	    =>
	    d;	# 2009-02-23 CrT: Quick hack so it will compile.  Might even be correct.

        field_dl (SOURCE_CODE_REGION_FOR_NAMED_FIELD (arg, _), d)
            =>
            field_dl (arg, d);
    end 

    also
    fun rvb_dl (NAMED_RECURSIVE_VALUE { variable_symbol, expression, null_or_type, ... }, d)
	    =>
	    dl_add_s (tyopt_s (null_or_type, ss::empty), exp_dl (expression, d));

        rvb_dl (SOURCE_CODE_REGION_FOR_RECURSIVELY_NAMED_VALUE (arg, _), d)
            =>
            rvb_dl (arg, d);
    end 

    also
    fun spec_dl (SOURCE_CODE_REGION_FOR_API_ELEMENT (arg, _), d)
            =>
            spec_dl (arg, d);

        spec_dl (PACKAGES_IN_API l, d)
	    =>
	    {   #  strange case - optional: package, mandatory: api 
		fun one ((n, g, c), (s, bl))
		    =
		    {   my (s', e)
			    =
			    sigexp_p g;

			s'' =   ss::union (s, s');

			case c
			  
			     NULL  =>  (s'', (n, e) ! bl);
			     THE p =>  (s'', (n, IGN1 (VARIABLE (sp::SYMBOL_PATH p), e)) ! bl);
			esac;
		    };

		my (s, bl)
		    =
		    fold_right one (ss::empty, []) l;

		dl_add_s (s, parbindcons (bl, d));
	    };

        spec_dl (TYPE_CONSTRUCTORS_IN_API (l, _), d)
	    =>
	    {   fun one_s ((_, _, THE t), s)
		    =>
		    ty_s (t, s);

		   one_s (_, s)
		    =>
		    s; end;

		dl_add_s (fold_left one_s ss::empty l, d);
	    };

        spec_dl (GENERICS_IN_API l, d)
	    =>
	    {   fun one ((n, g), (s, bl))
		    =
		    {   my (s', e) =   generic_api_expression_p g;

			(ss::union (s, s'), (n, e) ! bl);
		    };

		my (s, bl) =   fold_right one (ss::empty, []) l;

		dl_add_s (s, parbindcons (bl, d));
	    };

        spec_dl (VALUES_IN_API l, d)
            =>
            dl_add_s (fold_left (ty_s o' #2) ss::empty l, d);

        spec_dl (ENUM_CONSTRUCTORS_IN_API { datatype_constructors, with_type_constructors }, d)
	    =>
	    dl_add_s (fold_left db_s (fold_left tb_s ss::empty with_type_constructors) datatype_constructors, d);

	spec_dl (EXCEPTIONS_IN_API      l, d)
            =>
            dl_add_s (fold_left (tyopt_s o' #2) ss::empty l, d);

	spec_dl (PACKAGE_SHARING_IN_API l, d)
            =>
            fold_left dl_add_p d l;

	spec_dl (TYPE_SHARING_IN_API    l, d)
            =>
            dl_add_s (fold_left s_add_mp ss::empty l, d);

	spec_dl (IMPORT_IN_API g, d)
	    =>
	    {   my (s, e)
                    =
                    sigexp_p g;

		dl_add_s (s, use (e, d));
	    };
    end 

    also
    fun sigexp_p (API_BY_NAME s)
            =>
            (ss::empty, VARIABLE (sp::SYMBOL_PATH [s]));

        sigexp_p (API_WITH_WHERE_SPECS (g, whspecs))
	    =>
	    {   fun one_s (WHERE_TYPE (_, _, type), s)  =>  ty_s (type, s);
		    one_s (WHERE_PACKAGE (_, p), s)       =>  s_add_p (p, s);
                end;

		my (s, e) =   sigexp_p g;

		(fold_left one_s s whspecs, e);
	    };

        sigexp_p (API_DEFINITION l)
	    =>
	    {   my (s, d) =   split_dl (fold_right spec_dl [] l);

		(s, DECL d);
	    };

        sigexp_p (SOURCE_CODE_REGION_FOR_API (arg, _))
            =>
            sigexp_p arg;
   end 

   also
   fun generic_api_expression_p (GENERIC_API_BY_NAME s)
	    =>
	    (ss::empty, VARIABLE (sp::SYMBOL_PATH [s]));

        generic_api_expression_p (GENERIC_API_DEFINITION { parameter, result } )
	    =>
	    letexp (fold_right fparam_d [] parameter, sigexp_p result);

        generic_api_expression_p (SOURCE_CODE_REGION_FOR_GENERIC_API (arg, _))
	    =>
	    generic_api_expression_p arg;
    end 

    also
    fun fparam_d ((nopt, g), d)
        =
        {   my (s, e) =   sigexp_p g;

	    case nopt
	      
	         NULL  =>  dl_add_s (s, use (e, d));
	         THE n =>  dl_add_s (s, BIND (n, e) ! d);
            esac;
	}

    also
    fun sigexpc_p NO_PACKAGE_CAST
            =>
            NULL;

        sigexpc_p (    WEAK_PACKAGE_CAST g
                  | PARTIAL_PACKAGE_CAST g
                  |  STRONG_PACKAGE_CAST g
                  )
            =>
            THE (sigexp_p g);
    end 

    also
    fun generic_api_expressionc_p NO_PACKAGE_CAST
            =>
            NULL;

        generic_api_expressionc_p (     WEAK_PACKAGE_CAST fg
                                  |  PARTIAL_PACKAGE_CAST fg
                                  |   STRONG_PACKAGE_CAST fg
                                  )
            =>
            THE (generic_api_expression_p fg);
    end 

    also
    fun fctexp_p (GENERIC_BY_NAME (p, c))
	    =>
	    ign ((ss::empty, VARIABLE (sp::SYMBOL_PATH p)), generic_api_expressionc_p c);

        fctexp_p (GENERIC_DEFINITION { parameters, body, constraint } )
	    =>
	    letexp (fold_right fparam_d [] parameters,
		    ign (pkgexp_p body, sigexpc_p constraint));

        fctexp_p (CONSTRAINED_CALL_OF_GENERIC (p, l, c))
	    =>
	    {   fun one ((str, _), (s, el))
		    =
		    {   my (s', e) =   pkgexp_p str;

			(ss::union (s, s'), e ! el);
		    };

		my  (s, el)
		    =
		    fold_left one (ss::empty, []) l;

		my  (s', e)
		    =
		    ign ((ss::empty, VARIABLE (sp::SYMBOL_PATH p)), generic_api_expressionc_p c);

		(ss::union (s, s'), fold_left IGN1 e el);
	    };

        fctexp_p (LET_IN_GENERIC  (bdg, b))
	    =>
	    letexp (dec_dl (bdg, []), fctexp_p b);

        fctexp_p (SOURCE_CODE_REGION_FOR_GENERIC (arg, _))
	    =>
	    fctexp_p arg;
    end 

    also
    fun pkgexp_p (PACKAGE_BY_NAME p)
	    =>
	    (ss::empty, VARIABLE (sp::SYMBOL_PATH p));

	pkgexp_p (PACKAGE_DEFINITION declaration)
	    =>
	    {   my  (s, dl)
		    =
		    split_dl (dec_dl (declaration, []));

		(s, DECL dl);
	    };

	pkgexp_p (PACKAGE_CAST (s, c))
	    =>
	    ign (pkgexp_p s, sigexpc_p c);

	pkgexp_p (CALL_OF_GENERIC (p, l) | INTERNAL_CALL_OF_GENERIC (p, l))
	    =>
	    {   fun one ((str, _), (s, el))
		    =
		    {   my (s', e) =   pkgexp_p str;

			(ss::union (s, s'),   e ! el);
		    };

		my   (s, el)   =   fold_left one (ss::empty, []) l;

		(s, fold_left IGN1 (VARIABLE (sp::SYMBOL_PATH p)) el);
	    };

	pkgexp_p (LET_IN_PACKAGE (bdg, b))
	    =>
	    letexp (dec_dl (bdg, []), pkgexp_p b);

	pkgexp_p (SOURCE_CODE_REGION_FOR_PACKAGE (s, _))
	    =>
	    pkgexp_p s;
    end 

    also
    fun dec_dl (VALUE_DECLARATIONS             (l, _), d) =>  fold_left  vb_dl                    d l;
        dec_dl (FIELD_DECLARATIONS             (l, _), d) =>  fold_left  field_dl                 d l;
	dec_dl (RECURSIVE_VALUE_DECLARATIONS   (l, _), d) =>  fold_left  rvb_dl                   d l;
	dec_dl (FUNCTION_DECLARATIONS          (l, _), d) =>  fold_left  named_function_dl        d l;
	dec_dl (NADA_FUNCTION_DECLARATIONS     (l, _), d) =>  fold_left  lib7_named_function_dl   d l;
	dec_dl (TYPE_DECLARATIONS               l,     d) =>  dl_add_s  (fold_left tb_s ss::empty l, d);

	dec_dl (ENUM_DECLARATIONS { datatype_constructors, with_type_constructors }, d)
	    =>
	    dl_add_s (fold_left db_s (fold_left tb_s ss::empty with_type_constructors) datatype_constructors, d);

	dec_dl (ABSTRACT_TYPE_DECLARATIONS { abstract_type_constructors, with_type_constructors, body }, d)
	    =>
	    dl_add_s (fold_left db_s (fold_left tb_s ss::empty with_type_constructors) abstract_type_constructors,
		     dec_dl (body, d));

	dec_dl (EXCEPTION_DECLARATIONS l, d)
            =>
            dl_add_s (fold_left eb_s ss::empty l, d);

	dec_dl ( PACKAGE_DECLARATIONS l, d)
	    =>
	    parbind one l d
            where
	        fun one (SOURCE_CODE_REGION_FOR_NAMED_PACKAGE (arg, _), x)
			=>
			one (arg, x);

		    one (NAMED_PACKAGE { name_symbol=>name, definition=>def, constraint, kind }, (s, bl))
			=>
			{   my (s', e) =   ign (pkgexp_p def, sigexpc_p constraint);

			    (ss::union (s, s'), (name, e) ! bl);
			};
                end;
	    end;

	dec_dl (GENERIC_DECLARATIONS l, d)
	    =>
	    {   fun one (SOURCE_CODE_REGION_FOR_NAMED_GENERIC (arg, _), x)
		    =>
		    one (arg, x);

		   one (NAMED_GENERIC { name_symbol=>name, definition=>def }, (s, bl))
		    =>
		    {   my (s', e) =   fctexp_p def;

			(ss::union (s, s'), (name, e) ! bl);
		    }; end;

		parbind one l d;
	    };

	dec_dl (API_DECLARATIONS l, d)
	    =>
	    {   fun one (SOURCE_CODE_REGION_FOR_NAMED_API (arg, _), x)
		    =>
		    one (arg, x);

		   one (NAMED_API { name_symbol=>name, definition=>def }, (s, bl))
		    =>
		    {   my (s', e) =   sigexp_p def;

			(ss::union (s, s'), (name, e) ! bl);
		    }; end;

		parbind one l d;
	    };

	dec_dl (GENERIC_API_DECLARATIONS l, d)
	    =>
	    {   fun one (SOURCE_REGION_FOR_NAMED_GENERIC_API (arg, _), x)
		    =>
		    one (arg, x);

		   one (NAMED_GENERIC_API { name_symbol=>name, definition=>def }, (s, bl))
		    =>
		    {   my (s', e) =   generic_api_expression_p def;

			(ss::union (s, s'), (name, e) ! bl);
		    }; end;

		parbind one l d;
	    };

	dec_dl (LOCAL_DECLARATIONS (bdg, body), d)
	    =>
	    local_dl (dec_dl (bdg, []), dec_dl (body, []), d);

	dec_dl (SEQUENTIAL_DECLARATIONS l, d)
            =>
            fold_right dec_dl d l;

	dec_dl (INCLUDE_DECLARATIONS l, d)
            =>
            parcons (map (OPEN o VARIABLE o sp::SYMBOL_PATH) l, d);

	dec_dl (OVERLOADED_VARIABLE_DECLARATION (_, t, l, x), d)
	    =>
	    dl_add_s (ty_s (t, ss::empty), fold_left exp_dl d l);

	dec_dl (FIXITY_DECLARATIONS _, d)
            =>
            d;

	dec_dl (SOURCE_CODE_REGION_FOR_DECLARATION (arg, _), d)
            =>
            dec_dl (arg, d);
    end;

    fun c_dec d
        =
        seq (dec_dl (d, []));

    fun convert { tree, err }
        =
        {   # Build a function that will complain (once you call it)
	    # about any existing restriction violations
	    #
	    fun complain_cm region
		=
		{   fun same_reg (LOCAL_DECLARATIONS (_, body), k)
			    =>
			    same_reg (body, k);

			same_reg (SEQUENTIAL_DECLARATIONS l, k)
			    =>
			    fold_left same_reg k l;

			same_reg (INCLUDE_DECLARATIONS _, k)
			    =>
			    (fn ()
                                =
                                {   k ();
				    err em::ERROR region "toplevel use";
				}
			    );

			same_reg (SOURCE_CODE_REGION_FOR_DECLARATION (arg, region), k)
			    =>
			    complain_cm  region  (arg, k);

			same_reg ( ( PACKAGE_DECLARATIONS _
				   | GENERIC_DECLARATIONS _
				   | API_DECLARATIONS _
				   | GENERIC_API_DECLARATIONS _
				   ),

                                   k
                                 )
			    =>
			    k;

			same_reg (_, k)
			    =>
			    (fn ()
				=
				{   k ();
				    err em::WARNING region "definition not tracked by make7";
				}
			    );
		    end;

		    same_reg;
		};

	    fun warn0 ()
                =
                ();

	    complain =   complain_cm (0, 0) (tree, warn0);

	    {   complain,
                module_dependencies_summary => c_dec tree
            };
	};
};


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright (c) 1999 by Lucent Technologies, Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
