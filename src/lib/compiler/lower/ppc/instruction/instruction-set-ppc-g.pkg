## instruction-set-ppc-g.pkg
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "ppc/ppc.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/lower/make7/ppc.make6

# We are invoked from:
# 
#     src/lib/compiler/codegen/ppc/ppc-codetree.pkg

generic package instruction_set_ppc_g (

    codetree:	 Codetree			# Codetree		is from   src/lib/compiler/lower/codetree/codetree.api
)

: (weak) Instruction_Set_Ppc			# Instruction_Set_Ppc	is from   src/lib/compiler/lower/ppc/instruction/instruction-set-ppc.api

{
    package cells = ppccells;			# ppccells		is from   src/lib/compiler/lower/ppc/instruction/ppc-cells.pkg
    package cb = cells_basis;			# cells_basis		is from   src/lib/compiler/lower/instruction/cells-basis.pkg

    package codetree = codetree;
    package t        = codetree;

    package region = t::region;
    package constant = t::constant;

    Gpr = Int;
    Fpr = Int;
    Ccr = Int;
    Crf = Int;

    Spr
      = XER
      | LR
      | CTR;

    Operand
      = REG_OP  cells_basis::Cell
      | IMMED_OP  Int
      | LABEL_OP  t::Labexp;

    Addressing_Mode = (cells_basis::Cell, Operand);

    Ea
      = DIRECT  cells_basis::Cell
      | FDIRECT  cells_basis::Cell
      | DISPLACE  { base: cells_basis::Cell, disp: t::Labexp, mem: region::Region };

    Load
      = LBZ
      | LBZE
      | LHZ
      | LHZE
      | LHA
      | LHAE
      | LWZ
      | LWZE
      | LDE
      | LBZU
      | LHZU
      | LHAU
      | LWZU
      | LDZU;

    Store
      = STB
      | STBE
      | STH
      | STHE
      | STW
      | STWE
      | STDE
      | STBU
      | STHU
      | STWU
      | STDU;

    Fload
      = LFS
      | LFSE
      | LFD
      | LFDE
      | LFSU
      | LFDU;

    Fstore
      = STFS
      | STFSE
      | STFD
      | STFDE
      | STFSU
      | STFDU;

    Cmp
      = CMP
      | CMPL;

    Fcmp
      = FCMPO
      | FCMPU;

    Unary
      = NEG
      | EXTSB
      | EXTSH
      | EXTSW
      | CNTLZW
      | CNTLZD;

    Funary
      = FMR
      | FNEG
      | FABS
      | FNABS
      | FSQRT
      | FSQRTS
      | FRSP
      | FCTIW
      | FCTIWZ
      | FCTID
      | FCTIDZ
      | FCFID;

    Farith
      = FADD
      | FSUB
      | FMUL
      | FDIV
      | FADDS
      | FSUBS
      | FMULS
      | FDIVS;

    Farith3
      = FMADD
      | FMADDS
      | FMSUB
      | FMSUBS
      | FNMADD
      | FNMADDS
      | FNMSUB
      | FNMSUBS
      | FSEL;

    Bo
      = TRUE
      | FALSE
      | ALWAYS
      | COUNTER  { eq_zero: Bool, cond: Null_Or( Bool ) };

    Arith
      = ADD
      | SUBF
      | MULLW
      | MULLD
      | MULHW
      | MULHWU
      | DIVW
      | DIVD
      | DIVWU
      | DIVDU
      | AND
      | OR
      | XOR
      | NAND
      | NOR
      | EQV
      | ANDC
      | ORC
      | SLW
      | SLD
      | SRW
      | SRD
      | SRAW
      | SRAD;

    Arithi
      = ADDI
      | ADDIS
      | SUBFIC
      | MULLI
      | ANDI_RC
      | ANDIS_RC
      | ORI
      | ORIS
      | XORI
      | XORIS
      | SRAWI
      | SRADI;

    Rotate
      = RLWNM
      | RLDCL
      | RLDCR;

    Rotatei
      = RLWINM
      | RLWIMI
      | RLDICL
      | RLDICR
      | RLDIC
      | RLDIMI;

    Ccarith
      = CRAND
      | CROR
      | CRXOR
      | CRNAND
      | CRNOR
      | CREQV
      | CRANDC
      | CRORC;

    Bit
      = LT
      | GT
      | EQ
      | SO
      | FL
      | FG
      | FE
      | FU
      | FX
      | FEX
      | VX
      | OX;

    Xerbit
      = SO64
      | OV64
      | CA64
      | SO32
      | OV32
      | CA32;

    Cr_Bit = ((cells_basis::Cell), Bit);

    Base_Instruction
      = LL   { ld: Load, rt: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | LF   { ld: Fload, ft: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | ST   { st: Store, rs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | STF  { st: Fstore, fs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | UNARY  { oper: Unary, rt: cells_basis::Cell, ra: cells_basis::Cell, rc: Bool, oe: Bool }
      | ARITH  { oper: Arith, rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell, rc: Bool, oe: Bool }
      | ARITHI  { oper: Arithi, rt: cells_basis::Cell, ra: cells_basis::Cell, im: Operand }
      | ROTATE  { oper: Rotate, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: cells_basis::Cell, mb: Int, me: Null_Or( Int ) }
      | ROTATEI  { oper: Rotatei, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: Operand, mb: Int, me: Null_Or( Int ) }
      | COMPARE  { cmp: Cmp, l: Bool, bf: cells_basis::Cell, ra: cells_basis::Cell, rb: Operand }
      | FCOMPARE  { cmp: Fcmp, bf: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell }
      | FUNARY  { oper: Funary, ft: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool }
      | FARITH  { oper: Farith, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool }
      | FARITH3  { oper: Farith3, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, fc: cells_basis::Cell, rc: Bool }
      | CCARITH  { oper: Ccarith, bt: Cr_Bit, ba: Cr_Bit, bb: Cr_Bit }
      | MCRF  { bf: cells_basis::Cell, bfa: cells_basis::Cell }
      | MTSPR  { rs: cells_basis::Cell, spr: cells_basis::Cell }
      | MFSPR  { rt: cells_basis::Cell, spr: cells_basis::Cell }
      | LWARX  { rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell }
      | STWCX  { rs: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell }
      | TW  { to: Int, ra: cells_basis::Cell, si: Operand }
      | TD  { to: Int, ra: cells_basis::Cell, si: Operand }
      | BC  { bo: Bo, bf: cells_basis::Cell, bit: Bit, address: Operand, lk: Bool, fall: Operand }
      | BCLR  { bo: Bo, bf: cells_basis::Cell, bit: Bit, lk: Bool, labels: List( label::Label ) }
      | BB  { address: Operand, lk: Bool }
      | CALL  { def: cells::Cellset, uses: cells::Cellset, cuts_to: List( label::Label ), mem: region::Region }
      | SOURCE  { }
      | SINK  { }
      | PHI  { }

    also
    Instruction
      = LIVE  { regs: cells::Cellset, spilled: cells::Cellset }
      | DEAD  { regs: cells::Cellset, spilled: cells::Cellset }
      | COPY  { kind: cells_basis::Cellkind, 
		size_in_bits: Int,          #  in bits 
		dst: List( cells_basis::Cell ),
		src: List( cells_basis::Cell ),
		tmp: Null_Or(  Ea ) /* NULL if |dst| == { src| == 1 */
	      }
      | NOTE  { instruction: Instruction,
		note:        note::Note
	      }
      | BASE_INSTRUCTION  Base_Instruction;


    ll       = BASE_INSTRUCTION o LL;
    lf       = BASE_INSTRUCTION o LF;

    st       = BASE_INSTRUCTION o ST;
    stf      = BASE_INSTRUCTION o STF;

    unary    = BASE_INSTRUCTION o UNARY;
    arith    = BASE_INSTRUCTION o ARITH;

    arithi   = BASE_INSTRUCTION o ARITHI;
    rotate   = BASE_INSTRUCTION o ROTATE;
    rotatei  = BASE_INSTRUCTION o ROTATEI;

    compare  = BASE_INSTRUCTION o COMPARE;
    fcompare = BASE_INSTRUCTION o FCOMPARE;

    funary   = BASE_INSTRUCTION o FUNARY;
    farith   = BASE_INSTRUCTION o FARITH;
    farith3  = BASE_INSTRUCTION o FARITH3;

    ccarith  = BASE_INSTRUCTION o CCARITH;

    mcrf     = BASE_INSTRUCTION o MCRF;
    mtspr    = BASE_INSTRUCTION o MTSPR;
    mfspr    = BASE_INSTRUCTION o MFSPR;

    lwarx    = BASE_INSTRUCTION o LWARX;
    stwcx    = BASE_INSTRUCTION o STWCX;

    tw       = BASE_INSTRUCTION o TW;
    td       = BASE_INSTRUCTION o TD;

    bc       = BASE_INSTRUCTION o BC;
    bclr     = BASE_INSTRUCTION o BCLR;
    bb       = BASE_INSTRUCTION o BB;
    call     = BASE_INSTRUCTION o CALL;

    source   = BASE_INSTRUCTION o SOURCE;
    sink     = BASE_INSTRUCTION o SINK;
    phi      = BASE_INSTRUCTION o PHI;

};

