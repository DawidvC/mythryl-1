## typecheck-package-language.pkg

# Compiled by:
#     src/lib/compiler/front/typechecker/typecheck.make6



# This module is the core of the typechecker.
#
# Typechecking is essentially a matter of converting the raw syntax tree,
# which contains both declarative and executable content, into a deep
# syntax tree containing the executable content and a symbol table
# containing the declarative content.
#
# The two return values from our (sole) typecheck_declaration() entrypoint
# are that deep sytax tree and that symbol table.
#
# We get called by
#
#     src/lib/compiler/front/typechecker/typecheck/typecheck-toplevel-statement-g.pkg
#
# after it has finished its special-casing of
# toplevel stuff (see file-top comments in it
# for a broader overview), and we in turn hand
# off such subtasks as typechecking of apis,
# types and core language stuff to
#
#     src/lib/compiler/front/typechecker/typecheck/typecheck-api.pkg
#     src/lib/compiler/front/typechecker/typecheck/typecheck-type.pkg
#     src/lib/compiler/front/typechecker/typecheck/typecheck-core-language.pkg
#     src/lib/compiler/front/typechecker/typecheck/typecheck-stuff.api
#     src/lib/compiler/front/typechecker/typecheck/typecheck-stuff.pkg
#     src/lib/compiler/front/typechecker/modules/api-match-g.pkg
#     src/lib/compiler/front/typechecker/modules/generics-expansion-stuff.pkg
#     src/lib/compiler/front/typechecker/modules/expand-generic-g.pkg
#     src/lib/compiler/front/typechecker/modules/expand-type-constructor.pkg
#     src/lib/compiler/front/typecheck-stuff/modules/module-stuff.api
#     src/lib/compiler/front/typecheck-stuff/modules/module-stuff.pkg
#     src/lib/compiler/front/typechecker/types/unify-and-generalize-types-g.pkg
#     src/lib/compiler/front/typechecker/types/unify-types.pkg
#
# The main package-level constructs in the language are:
#   o  Package definitions.
#   o  Api definitions.
#   o  Generic (package-valued compile-time function) definitions.
#   o  Generic api definitions.
#   o  Generic invocations.
#
# For typechecking purposes, the first four just amount
# to laundry lists of elements to save in the symbol table,
# so for our purposes here, most of the interest -- and
# work -- centers on generic invocation.
#
# A generic is in essence a typed macro, so generic invocation
# amounts to typed macro expansion.  In order to typecheck a
# program, we must do macro expansion on each generic invocation
# in the program, so that we can examine and type-check (and
# eventually do code generation for) the results of each invocation.
#
# To keep track of the macro expansion process and its products, we
# create a shadow-world counterpart of our regular symbols, symbol
# tables, symbol paths &tc.  We call these shadow components
# module_stamps, macroExpansionDictionaries, macroExpansionPaths,
# packageMacroExpansions and so forth.
#
# The package body constituting the body of a generic definition
# gets expanded into a packageMacroExpansion which is given a
# module_stamp as a name, and stored in a typechecker_dictionary.
#
# Nested packages in the generic definition body expand into
# nested typechecked_packages which are accessed via lists of typechecked_package
# stamps called macroExpansionPaths, just as components in regular
# nested packages are accessed via lists of symbols called
# symbol paths.
#
# These typechecked_package datastructures are temporaries internal to the
# typechecker:  the 'typecheck_declaration' entrypoint function in
# this file passes an empty typechecker_dictionary and an empty
# module_path_context down the call hierarchy, and discards the
# corresponding populated ones that are returned to it, since at
# that point their job is done.
#
# The bulk of the typechecked_package datastructure stuff is implemented in:
#
#     src/lib/compiler/front/typecheck-stuff/modules/module.api
#     src/lib/compiler/front/typecheck-stuff/modules/module.pkg
#
#     src/lib/compiler/front/typecheck-stuff/modules/module-path.pkg
#
#     src/lib/compiler/front/typecheck-stuff/modules/typechecker-dictionary.pkg
#     src/lib/compiler/front/typecheck-stuff/modules/typechecker-dictionary.api
#
#     src/lib/compiler/front/typecheck-stuff/modules/module-path-context.pkg
#     src/lib/compiler/front/typechecker/modules/generics-expansion-stuff.pkg
#
# The major routines in this file (occupying about
# the indicated percentages of the file) are:
#
#     10%    extract_symbol_table_contents
#     15%    typecheck_package
#     20%    typecheck_generic
#     10%    typecheck_named_packages
#     30%    typecheck_declaration'
#
# with the latter four being mutually recursive.



###                   "You are in a maze of twisty tunnels, all different."


###                   "The tar pit of software engineering will continue to be sticky for a long time
###                    to come. One can expect the human race to continue attempting systems just
###                    within or just beyond our reach; and software systems are perhaps the most
###                    intricate and complex of man's handiworks. The management of this complex
###                    craft will demand our best use of new languages and systems, our best
###                    adaptation of proven engineering management methods, liberal doses of common
###                    sense, and ... humility to recognize our fallibility and limitations.
###
###                                       -- Frederick Brooks, Jr., The Mythical Man Month



###                   "First quantization is a mystery, but second quantization is a functor!"
###
###                                                              -- Edward Nelson

#

api Typecheck_Package_Language {

    #  Typecheck module-level declarations 
    typecheck_declaration:
       {
	 raw_syntax_declaration:            raw_syntax::Declaration,				# Actual raw syntax to typecheck.
	 symbol_table:                      symbol_table::Symbol_Table,			# Symbol table containing info from all .o7 files we depend on.
	 typechecker_dictionary:            module::Typechecker_Dictionary,

	 syntactic_typechecking_context:    typecheck_stuff::Syntactic_Typechecking_Context,	# TOPLEVEL/API/PKG/GENERIC
	 level:                             Bool,                     				# TRUE iff top-level declaration. 
	 module_path_context:		     module_path_context::Context,

	 path:                              inverse_path::Inverse_Path,
	 source_code_region:                source_map::Source_Code_Region,
	 compile_info:                      typecheck_stuff::Compile_Info
       }
       ->
       { deep_syntax_declaration:           deep_syntax::Declaration,				# Typechecked version of  raw_syntax_declaration.
	 symbol_table:                      symbol_table::Symbol_Table				# Contains (only) stuff from raw_syntax_declaration.
       }; 

     debugging:  Ref(  Bool );

};

# We use a generic to factor out dependencies on highcode.
#
# This generic is invoked once, in
#     src/lib/compiler/front/semantic/typecheck/typecheck-package-language.pkg
#

									# Api_Match				is from   src/lib/compiler/front/typechecker/modules/api-match-g.pkg
									# Unify_And_Generalize_Types		is from   src/lib/compiler/front/typechecker/types/unify-and-generalize-types-g.pkg
     									# api_match				is from   src/lib/compiler/front/semantic/modules/api-match.pkg
									# unify_and_generalize_types		is from   src/lib/compiler/front/semantic/types/unify-and-generalize-types.pkg
generic package
typecheck_package_language_g
    (
      package api_match:                   Api_Match;
      package unify_and_generalize_types:  Unify_And_Generalize_Types;
    )
: (weak)
Typecheck_Package_Language
=
package {

    stipulate

	  package s   = symbol;
	  package ip  = inverse_path;				# inverse_path				is from   src/lib/compiler/front/typecheck-stuff/basics/symbol-path.pkg
	  package sp  = symbol_path;				# symbol_path				is from   src/lib/compiler/front/typecheck-stuff/basics/symbol-path.pkg

	  package rp  = module_path;				# module_path				is from   src/lib/compiler/front/typecheck-stuff/modules/module-path.pkg
	  package mpc = module_path_context;			# module_path_context			is from   src/lib/compiler/front/typecheck-stuff/modules/module-path-context.pkg
	  package td  = typechecker_dictionary;			# typechecker_dictionary		is from   src/lib/compiler/front/typecheck-stuff/modules/typechecker-dictionary.pkg

	  package t   = types;					# types					is from   src/lib/compiler/front/typecheck-stuff/types/types.pkg
	  package tu  = type_stuff;				# type_stuff				is from   src/lib/compiler/front/typecheck-stuff/types/type-stuff.pkg
	  package v   = variables_and_constructors;		# variables_and_constructors		is from   src/lib/compiler/front/typecheck-stuff/deep-syntax/variables-and-constructors.pkg

	  package m   = module;					# module				is from   src/lib/compiler/front/typecheck-stuff/modules/module.pkg
	  package ms  = module_stuff;				# module_stuff				is from   src/lib/compiler/front/typecheck-stuff/modules/module-stuff.pkg
	  package mm  = module_map;				# module_map				is from   src/lib/compiler/front/typecheck-stuff/modules/module-map.pkg

	  package l   = find_in_symbol_table;			# find_in_symbol_table			is from   src/lib/compiler/front/typecheck-stuff/symbol-table/find-in-symbol-table.pkg
	  package ts  = typecheck_stuff;			# typecheck_stuff			is from   src/lib/compiler/front/typechecker/typecheck/typecheck-stuff.pkg
	  package tt  = typecheck_type;				# typecheck_type			is from   src/lib/compiler/front/typechecker/typecheck/typecheck-type.pkg

	  package tcl = typecheck_core_language;		# typecheck_core_language		is from   src/lib/compiler/front/typechecker/typecheck/typecheck-core-language.pkg
	  package ta  = typecheck_api;				# typecheck_api				is from   src/lib/compiler/front/typechecker/typecheck/typecheck-api.pkg
	  package ste = symbol_table_entry;			# symbol_table_entry			is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table-entry.pkg

	  package f   = find_in_symbol_table;			# find_in_symbol_table			is from   src/lib/compiler/front/typecheck-stuff/symbol-table/find-in-symbol-table.pkg
	  package st  = symbol_table;				# symbol_table				is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
	  package em  = error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

	  package pp  = prettyprint;				# prettyprint				is from   src/lib/prettyprint/src/prettyprint.pkg
	  package deep= deep_syntax;				# deep_syntax				is from   src/lib/compiler/front/typecheck-stuff/deep-syntax/deep-syntax.pkg
	  package a   = var_home;				# var_home				is from   src/lib/compiler/front/typecheck-stuff/basics/var-home.pkg

	  package di  = debruijn_index;				# debruijn_index			is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg
	  package ppu = unparse_stuff;				# unparse_stuff				is from   src/lib/compiler/front/typechecker/print/unparse-stuff.pkg

	  package bug = typechecking_debugging;			# typechecking_debugging		is from   src/lib/compiler/front/typechecker/typecheck/typechecking-debugging.pkg
	  package raw = raw_syntax;				# raw_syntax				is from   src/lib/compiler/front/parse/raw-syntax/raw-syntax.pkg

	  package ins = api_match::expand_generic::generics_expansion_stuff;	# "ins" might be "instantiate"

	  include module;

	  expand_oop_syntax_in_package_expression  =  expand_oop_syntax::expand_oop_syntax_in_package_expression;
	  expand_oop_syntax_in_package_expression2 =  expand_oop_syntax2::expand_oop_syntax_in_package_expression;

    herein

        Package_Cast
               =    WEAK_PACKAGE_CAST
               |  STRONG_PACKAGE_CAST
               | PARTIAL_PACKAGE_CAST
               ;

	# Debugging: 
	#
	say         =   control_print::say;
	debugging   =   typechecking_control::typecheck_package_language_debugging;		#  eval:   set_control "typechecker::typecheck_package_language_debugging" "TRUE";



	# To use the above "debugging" flag you might (say) do
        #
        #     linux$ cd src/app/tut/test
        #     linux$ touch test.pkg
        #     linux$ my
        #     eval:  set_control "typechecker::typecheck_package_language_debugging" "TRUE";
        #     eval:  make "test.make6";
        #
        # This will spew debug printouts of various datastructures
        # as the code in this file runs.



	fun if_debugging_say (msg: String)
            =
	    if *debugging 
                say msg;
                say "\n";
            fi;


	fun bug msg
            =
            error_message::impossible("typecheck_package_language: " + msg);


	debug_print
            =
            fn x =  bug::debug_print  debugging  x;



        fun unparse_raw_declaration
            (
              msg:          String,
              declaration:  raw_syntax::Declaration,
              symbol_table: symbol_table::Symbol_Table
            )
            =
            if *debugging
		print "\n";
                print msg;
                pp = prettyprinter::make_file_prettyprinter "/dev/stdout";

                pps = pp.stream;

                unparse_raw_syntax::unparse_declaration
                    (symbol_table, NULL)
                    pps
                    (declaration, 100);

                pp.flush ();
                pp.close ();
		print "\n";
            fi;

        fun prettyprint_raw_declaration
            (
              msg:          String,
              declaration:  raw_syntax::Declaration,
              symbol_table: symbol_table::Symbol_Table
            )
            =
            if *debugging
		print "\n";
                print msg;
                pp = prettyprinter::make_file_prettyprinter "/dev/stdout";

                pps = pp.stream;

                prettyprint_raw_syntax::prettyprint_declaration
                    (symbol_table, NULL)
                    pps
                    (declaration, 100);

                pp.flush ();
                pp.close ();
		print "\n";
            fi;

        fun unparse_deep_declaration
            (
              msg:          String,
              declaration:  deep_syntax::Declaration,
              symbol_table: symbol_table::Symbol_Table
            )
            =
            if *debugging
		print "\n";
                print msg;
                pp = prettyprinter::make_file_prettyprinter "/dev/stdout";

                pps = pp.stream;

                unparse_deep_syntax::unparse_declaration
                    (symbol_table, NULL)
                    pps
                    (declaration, 100);

                pp.flush ();
                pp.close ();
		print "\n";
            fi;

	fun if_debugging_show_package (msg, a_package, symbol_table)
            =
	    {
		bug::with_internals
		    (fn ()
			=
			debug_print
			    ( msg,
			      (fn pps = fn a_package =
				unparse_package_language::unparse_package pps (a_package, symbol_table, 100)
			      ),
			      a_package)
			    );
		if *debugging   print "\n";   fi;
	    };

	fun if_debugging_show_api (msg, an_api, symbol_table)
            =
	    {
		bug::with_internals
		    (fn ()
			=
			debug_print
			    ( msg,
			      (fn pps = fn an_api =
				unparse_package_language::unparse_api pps (an_api, symbol_table, 100)
			      ),
			      an_api)
			    );
		if *debugging   print "\n";   fi;
	    };

#	fun show_symbol_table (msg, symbol_table)
#	    =
#            if *debugging
#		print "\n";
#                print msg;
#                pp = prettyprinter::make_file_prettyprinter "/dev/stdout";
#
#                pps = pp.stream;
#
#                prettyprint_symbol_table::prettyprint_symbol_table
#                    pps
#                    symbol_table;
#
#                pp.flush ();
#                pp.close ();
#		print "\n";
#            fi;


	fun show_generic (msg, a_generic, symbol_table)
            =
	    bug::with_internals
                (fn ()
                    =
	            debug_print
                        ( msg,
			  (fn pps = fn a_generic'
                              =
			      unparse_package_language::unparse_generic pps (a_generic', symbol_table, 100)
                          ),
			  a_generic)
                        );


	# Check if a typechecked_package declaration is empty
        # in order to avoid the unnecessary recompilation
        # bug reported by Matthias Blume (ZHONG)
	#
	fun module_declaration_is_not_empty ( m::EMPTY_GENERIC_EVALUATION_DECLARATION
                                                     | m::SEQUENTIAL_DECLARATIONS []
                                                     )
                =>
                FALSE;

	    module_declaration_is_not_empty _
                =>
                TRUE;
        end;

	fun module_declaration_sequence  declarations
            = 
	    {   nodes
                    =
                    list::filter
                        module_declaration_is_not_empty
                        declarations;

                case nodes
		    []   =>   m::EMPTY_GENERIC_EVALUATION_DECLARATION;
		    _    =>   m::SEQUENTIAL_DECLARATIONS  nodes;
                esac;
	    };


	fun local_module_declaration (d1, d2)
            =
            module_declaration_sequence [d1, d2]; 


	include special_symbols;                	#  A dozen symbols like <parameter> <generic> <genericbody> ... 


	fun strip_source_code_region_info_from_api_naming (
                raw::SOURCE_CODE_REGION_FOR_NAMED_API (
                    api_naming',
                    source_code_region'
                ),
                source_code_region
            )
		=>
		strip_source_code_region_info_from_api_naming (api_naming', source_code_region');

	    strip_source_code_region_info_from_api_naming x
                =>
                x;
        end;

	fun strip_source_code_region_info_from_generic_api_naming
	        (
		  raw::SOURCE_REGION_FOR_NAMED_GENERIC_API (
		    generic_api_naming',
		    source_code_region'
		  ),

		  source_code_region
		)
		=>
		strip_source_code_region_info_from_generic_api_naming (generic_api_naming', source_code_region');

	    strip_source_code_region_info_from_generic_api_naming x
		=>
		x;
        end;

	fun strip_source_code_region_info_from_generic_naming
		(
		    raw::SOURCE_CODE_REGION_FOR_NAMED_GENERIC (
			generic_naming',
			source_code_region'),
		    source_code_region
		)
		=>
		strip_source_code_region_info_from_generic_naming (generic_naming', source_code_region');

	    strip_source_code_region_info_from_generic_naming x
		=>
		x;
        end;

	fun strip_source_code_region_info_from_named_package (
                raw::SOURCE_CODE_REGION_FOR_NAMED_PACKAGE (
                    named_package',
                    source_code_region'
                ),
                source_code_region
            )
		=>
		strip_source_code_region_info_from_named_package (named_package', source_code_region');

	    strip_source_code_region_info_from_named_package x
		=>
		x;
        end;

	# Change of syntactic_typechecking_context on entering a package
        #
	fun enter_package ts::AT_TOPLEVEL
                =>
                ts::IN_PACKAGE;

	    enter_package z
                =>
                z;
        end; 

	# Add mod_id to module_path mappings 
	# for all appropriate elements of a package
	# that has just been typechecked.
	# 
	# If module_path_context is the empty context
	# (rigid), then this is an expensive no-op, so we
	#  test module_path_context first.
	# 
	# But, would this be equivalent to context=INFCT _ ?  XXX BUGGO FIXME  ("INFCT" may be "in functor", i.e., "in generic")
	# 
	# module_path_context is the module_path_context
        # for the interior of the package -- i.e. the package
        # naming's Module_Stamp has been added to the bind_context 
	#
	# map_paths is quite heavyweight right now.      XXX BUGGO FIXME
        # It can be simplified in  several ways.
        # First, all type_constructor stamps don't have to be remapped, 
	# if new type_constructor stamps are mapped by macro_expand, then each map_paths
	# only need to deal with packages and generics.
        # Even dealing with packages and generics can be distributed
        # into the api matching or the instantiation process. (ZHONG)


#	map_paths_phase = (compile_statistics::make_phase "Compiler 033 1-map_paths") 
#	also map_paths x = compile_statistics::do_phase map_paths_phase map_paths0 x


	fun map_paths ( module_path_context,
                        A_PACKAGE { an_api, typechecked_package, ... },
                        flex
                      )
		=>
		map_module_path_context
                    (
                      module_path_context,
                      an_api,
                      typechecked_package,
                      flex
                    );

	    map_paths _ => ();
        end 

	also
	fun map_module_path_context
            (
                module_path_context,
                an_api as API { elements, ... },
                typechecked_package: m::Typechecked_Package,
                flex
            )
		=> 
		{   my { typechecker_dictionary, ... }
                        =
                        typechecked_package;


		    if (not (mpc::is_empty  module_path_context))

			 list::apply  do_element  elements;
		    fi
                    where
			fun do_element (_, TYPE_CONSTRUCTOR_IN_API { module_stamp, ... } )
				=>
				# bind only if type_constructor is flexible -- have to pass flexibility
				# tester  -- but wait! what about a rigid package with a
				# new api? Have to record even rigid packages and generics in
				# case they have new apis 
				#
				case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

				     TYPE_CONSTRUCTOR_ENTRY type_constructor
					 =>
					 case type_constructor

					      t::ERRONEOUS_TYPE_CONSTRUCTOR => ();

					      _   =>
						  {   stamp = tu::type_constructor_stamp type_constructor;

						      if (flex stamp)

							   mpc::bind_type_constructor_path(
							       module_path_context,
							       mm::type_identifier' type_constructor,
							       module_stamp
							   );
						      fi;
						  };
					  esac;


				      ERRONEOUS_ENTRY => ();
				      _ => bug "map_macro_expansion_path_context 1";
				esac;

			    do_element (_, PACKAGE_IN_API { module_stamp, an_api => this_api, ... } )
				=>
				# Map this package (unconditionally, because it may 
				# have a different api) 
				#
				case this_api             #  Don't record ERRONEOUS_API -- error tolerance 

				     API _
					 =>
					 case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

					      PACKAGE_ENTRY nr
						  =>
						  {   i = ms::package_identifier2 (this_api, nr);

						      case (mpc::find_module_path_for_package (module_path_context, i))

							  THE _ => ();

							 _ => {   mpc::bind_module_path (module_path_context, i, module_stamp);

								   map_module_path_context (
								       mpc::enter_open (module_path_context, THE module_stamp),
								       this_api,
								       nr,
								       flex
								   );
							       };
						      esac;
						  };

					     ERRONEOUS_ENTRY => ();

					     _ => bug "map_macro_expansion_path_context 2";

					 esac;

				    ERRONEOUS_API => ();
				esac;


			    do_element (_, GENERIC_IN_API { module_stamp, a_generic_api => this_api, ... } )
				=>
				# Map this generic (unconditionally):
				#
				case this_api

				     GENERIC_API _
					 =>
					 case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

					      GENERIC_ENTRY nr
						  =>
						  {   i = ms::generic_identifier2 (this_api, nr);

						      mpc::bind_generic_path (module_path_context, i, module_stamp);
						  };

					      ERRONEOUS_ENTRY => ();
					      _ => bug "map_macro_expansion_path_context 3";
					 esac;

				     ERRONEOUS_GENERIC_API => ();
				esac;

			    do_element _ => ();
			end;				# fun do_element
		    end;				# where
		};

	    map_module_path_context _ => ();
        end;



	# ASSERT: order of DEFtycs in tycs respects dependencies, i.e. no
	#         DEFINED_TYPE_CONSTRUCTOR refers to tycons occurring after itself. 
	#
	fun bind_new_tycs (ts::IN_GENERIC _, epctxt, make_stamp, dtycs, wtycs, inverse_path, err)
		=> 
		{   fun strip_path path
			=
			{   name_path = ip::INVERSE_PATH [ip::last path];
			    prefix    = ip::last_prefix path;

			    if (not (ip::equal (inverse_path, prefix))   )

				err em::WARNING
					 "Harmless compiler bug: bad type path prefix"
					 em::null_error_body;
			    fi;

			    name_path;
			};

		    vizty   =   (fn type =   #1 (ms::relativize_type              epctxt  type));
		    viztc   =   (fn tc   =   #1 (ms::relativize_type_constructor  epctxt  tc  ));

		    #  This is ok because module_path_context has state; a bit ugly	XXX BUGGO FIXME
		    # 
		    new_dtycs
			=
			case dtycs
			  
			      (t::PRIMITIVE_TYPE_CONSTRUCTOR { kind, ... } ! _)
				  =>
				  case kind
                                    
				       t::DATATYPE { index => 0,  family,  free_type_constructors, stamps, root }
				           =>
					   {   rootev    = make_stamp();
					       rtev_op   = THE rootev;
					       nfreetycs = map viztc free_type_constructors;
					       nstamps   = vector::map (fn _ =  make_stamp()) stamps;

					       map new_datatype dtycs
                                               where
						   fun new_datatype (dt as t::PRIMITIVE_TYPE_CONSTRUCTOR { kind, arity, eq, path, ... } )
							   =>
							   case kind

								t::DATATYPE { index,  ... }
								    =>
								    {   my (module_stamp, rtev)
									    = 
									    if (index == 0)    (rootev,       NULL   );
									    else              (make_stamp(), rtev_op);
									    fi;

									nkind
									    = 
									    t::DATATYPE { index,
											  stamps   => nstamps,
											  free_type_constructors => nfreetycs,
											  root     => rtev,
											  family
										       };

									# The rtev field in DATATYPE indicates
									# how to discover the new stamps when 
									# such datatypes get evalent-ed.
									#
									ndt = t::PRIMITIVE_TYPE_CONSTRUCTOR {
										  arity,
										  eq,
										  kind  => nkind,
										  path  => strip_path path, 
										  stamp => vector::get (nstamps, index),
										  stub  => NULL
									      };


									mpc::bind_type_constructor_path (
									    epctxt,
									    ms::type_identifier dt,
									    module_stamp
									);

									( module_stamp,
                                                                          dt,
                                                                          m::FORMAL_TYPE_CONSTRUCTOR ndt
                                                                        );
								    };

							       _ => bug "unexpected case in new_datatypeyc (1)";
							  esac;

						      new_datatype _ => bug "unexpected case in new_datatypeyc (2)";

						   end;			# fun new_datatype
					       end;			# where	

					   };

				       _ => bug "unexpected tycs in bind_new_tycs (1)";
				 esac;

			    [] => [];

			    _ => bug "unexpected tycs in bind_new_tycs (2)";
                        esac;

		    nwtycs
			= 
			map newtc wtycs
                        where
			    fun newtc (tc as t::DEFINED_TYPE_CONSTRUCTOR {   type_scheme => t::TYPE_SCHEME { arity, body }, 
								 stamp,
								 strict,
								 path
							     }
				      )
				    =>
				    {   module_stamp = make_stamp ();

					mpc::bind_type_constructor_path (epctxt, ms::type_identifier tc, module_stamp);

					ntc = t::DEFINED_TYPE_CONSTRUCTOR {
						  stamp         => make_stamp(),
						  strict, 
						  path          => strip_path path,
						  type_scheme => t::TYPE_SCHEME { arity,  body => vizty body }
					      };

					(   module_stamp,
					    tc,
					    m::FORMAL_TYPE_CONSTRUCTOR ntc
					);
				    };

			        newtc _ => bug "unexpected case in newwtyc";
                            end;
			end;

		    fun bind (   (module_stamp, tc, te)   !   tcs,
				typechecker_dictionary,
				typechecked_package_decs
			    )
			=>
			    bind( tcs,
				  td::set ( typechecker_dictionary,
                                            module_stamp,
					    m::TYPE_CONSTRUCTOR_ENTRY( tc )
					  ),
				  m::TYPE_CONSTRUCTOR_DECLARATION (module_stamp, te) ! typechecked_package_decs
				);

		        bind (NIL, typechecker_dictionary, typechecked_package_decs)
			    =>
			    (    td::mark( make_stamp, typechecker_dictionary ),
				 module_declaration_sequence( reverse typechecked_package_decs )
			    );
                    end;


		    bind(  new_dtycs @ nwtycs,
			   td::empty,
			   []
		    );
		};

	   bind_new_tycs _
               =>
               ( td::empty,
                 m::EMPTY_GENERIC_EVALUATION_DECLARATION
               );
        end;


	###########################################################################
	#                                                                         #
	# Extract API &tc info from a symbol table.                               #
	#                                                                         #
	# Recompute dynamic accesses after the elaboration of a package body,     #
	# replacing the original dynamic access by a SLOT and generating a        #
	# thinning that will be used (in translate) to create the package         #
	# record.                                                                 #
	#                                                                         #
	# Recompute all the dynamic accesses in an dictionary, suppress doubles   #
	# and allocate slots. Components are ordered so that slot allocation is   #
	# independent of the way elaboration is done.                             #
	#                                                                         #
	# Should we use dictionary::fold or dictionary::map?                                  #
	#                                                                         #
	###########################################################################

	fun extract_symbol_table_contents
            (
              symbol_table:						st::Symbol_Table,
	      module_path_context:					module_path_context::Context,
	      syntactic_typechecking_context:				typecheck_stuff::Syntactic_Typechecking_Context,	# TOPLEVEL/API/PKG/GENERIC
	      compile_info as { make_stamp, ... }:			ts::Compile_Info
	    )
	    :
	    ( List( (symbol::Symbol, m::Api_Element ) ),		# api_elements
	      module::Typechecker_Dictionary,				# typechecker_dictionary
	      List( Module_Declaration ),				# module_declarations
	      List( symbol_table_entry::Symbol_Table_Entry ),		# locations
	      Bool							# contains_generic
	    )
            =
	    {   fun get_modulepath_or_null (get, mod_id)
                    =
		    case syntactic_typechecking_context
			ts::IN_GENERIC _ =>  get (module_path_context, mod_id);
			_                =>  NULL;
                    esac;

		relativize
                    =
		    case syntactic_typechecking_context
			ts::IN_GENERIC _ =>  fn type =    #1  (ms::relativize_type  module_path_context  type);
			_                =>  fn x = x;
                    esac;


		# We call this once for each entry in the symbol table.
		#
                # The first argument is the name/entry symbol table pair.
		#
                # The second argument holds the lists etc in which
                # we accumulate extracted symbol table entry
                # information.
                #
                # We discard the 'slot_count' variable when we complete
                # reading all the symbol table entries;  we use it only
                # for assigning successive package record slots to
                # VALUE_IN_API records &tc.
                #
		fun note_named_symbol_table_entry
                    (
                      # Named entry to note:
                      #
                      ( symbol:				symbol::Symbol,
                        symbol_table_entry:		ste::Symbol_Table_Entry
                      ), 

                      # Info from previously noted
                      # named entries:
                      #
		      { named_api_elements:		List( (symbol::Symbol, Api_Element) ),
			typechecker_dictionary:		Typechecker_Dictionary,
			module_declarations:		List( Module_Declaration ),
			symbol_table_entries:		List( ste::Symbol_Table_Entry ),
			slot_count:			Int,
			contains_generic:		Bool
		      }
                    )
                    = 
		    case symbol_table_entry
                      
		         ste::NAMED_VARIABLE( v::ORDINARY_VARIABLE { var_type, path, ... } )
			     =>
			     {   api_element
                                     =
                                     VALUE_IN_API {
                                       type =>  relativize *var_type,
				       slot   =>  slot_count
				     };

				 named_api_elements   = (symbol, api_element) ! named_api_elements;
				 symbol_table_entries = symbol_table_entry    ! symbol_table_entries;
                                 slot_count           = slot_count + 1;

				 { named_api_elements,
				   typechecker_dictionary,
				   module_declarations,
				   symbol_table_entries, 
				   slot_count,
				   contains_generic
				 };
			     };

		         ste::NAMED_CONSTRUCTOR (
				 dcon as t::ENUM_CONSTRUCTOR {
				     symbol => name,
				     const,
				     is_lazy,
				     signature,
				     constructor_type,
				     representation
				 }
			     )
			     =>
			     {   constructor_type = relativize  constructor_type;

				 my  ( representation,
				       symbol_table_entries,
				       slot,
				       slot_count
                                     )
				     =
				     case representation

				         a::EXCEPTION _
					     => 
					     (   a::EXCEPTION (a::null_var_home),
						 symbol_table_entry ! symbol_table_entries, 
						 THE slot_count,
						 slot_count + 1
					     );

					_ => (representation, symbol_table_entries, NULL, slot_count);

                                     esac;

				 a_datatype
                                     =
                                     t::ENUM_CONSTRUCTOR {
				       symbol => name,
				       const,
				       signature,
				       constructor_type,
				       representation,
				       is_lazy
				     };

				 a_datatype = ENUM_CONSTRUCTOR_IN_API { a_datatype,   slot };

				 named_api_elements =  (symbol, a_datatype) ! named_api_elements;

				 { named_api_elements,
				   typechecker_dictionary,
				   module_declarations,
				   symbol_table_entries,
				   slot_count,
				   contains_generic
				 };
			     };

		         ste::NAMED_PACKAGE ( a_package as A_PACKAGE { an_api, typechecked_package, ... } )
			     =>
			     {   modulepath_or_null
                                     =
                                     get_modulepath_or_null (
                                       mpc::find_module_path_for_package,
                                       ms::package_identifier a_package
                                     );

				 my  ( module_stamp,
				       typechecker_dictionary,
				       module_declarations
                                     )
				     =
				     case modulepath_or_null

				         THE [module_stamp]
                                             =>
                                             ( module_stamp,
                                               typechecker_dictionary,
                                               module_declarations
                                             );

					 _   =>
					     (module_stamp, ee, ed)
                                             where
                                                 module_stamp  = make_stamp();

						 ee = td::set (typechecker_dictionary, module_stamp, PACKAGE_ENTRY typechecked_package);

						 ed = case syntactic_typechecking_context

							    ts::IN_GENERIC _
								=> 
								{   package_expression
									= 
									case modulepath_or_null 
									    THE module_path => m::VARIABLE_PACKAGE module_path;
									    _               => m::CONSTANT_PACKAGE typechecked_package;
									esac;

								    (m::PACKAGE_DECLARATION (module_stamp, package_expression, symbol))
								    !
								    module_declarations;
								};

							     _ => module_declarations;
						      esac;
					     end;
                                     esac;

				   api_element
                                       =
                                       PACKAGE_IN_API {
                                         slot       => slot_count,
				         definition => NULL,
				         an_api,
				         module_stamp
				       };

				   named_api_elements   =  (symbol, api_element) ! named_api_elements;
				   symbol_table_entries =   symbol_table_entry   ! symbol_table_entries;
				   slot_count           =   slot_count + 1;

				   contains_generic
				       = 
				       case an_api 
					    API sg =>  contains_generic or sg.contains_generic;
					    _      =>  contains_generic;
                                       esac;

				   { named_api_elements,
				     typechecker_dictionary,
				     module_declarations,
				     symbol_table_entries, 
				     slot_count,
				     contains_generic
				   };
			     };

		         ste::NAMED_GENERIC ( a_generic as GENERIC { a_generic_api, typechecked_generic, ... } )
			     =>
			     {   modulepath_or_null = get_modulepath_or_null (mpc::find_module_path_for_g, ms::generic_identifier a_generic);

				 my  ( module_stamp,
				       typechecker_dictionary,
				       module_declarations
                                     )
				     =
				     case modulepath_or_null

				         THE [x] => (x, typechecker_dictionary, module_declarations);

					 _ => 
					     (x, ee, ed)
                                             where
						 x  = make_stamp();

						 ee = td::set (typechecker_dictionary, x, GENERIC_ENTRY  typechecked_generic);

						 ed = case syntactic_typechecking_context

							   ts::IN_GENERIC _
							       => 
							       {   generic_expression
								       = 
								       case modulepath_or_null 
									   THE module_path =>  m::VARIABLE_GENERIC  module_path;
									   _               =>  m::CONSTANT_GENERIC  typechecked_generic;
								       esac;

								   (m::GENERIC_DECLARATION (x, generic_expression))
								   !
								   module_declarations;
							       };

							   _ => module_declarations;
						      esac;
					     end;		# where
                                     esac;

				 api_element
                                     =
                                     GENERIC_IN_API {
                                       slot   => slot_count,
				       a_generic_api,
				       module_stamp
				     };

				 named_api_elements   =  (symbol, api_element) ! named_api_elements;
				 symbol_table_entries =   symbol_table_entry   ! symbol_table_entries;
				 slot_count           =   slot_count + 1;
				 contains_generic     =   TRUE;

				 { named_api_elements,
				   typechecker_dictionary,
				   module_declarations,
				   symbol_table_entries, 
				   slot_count,
				   contains_generic
				 };
			     };

		         ste::NAMED_TYPE type_constructor
			     =>
			     {   modulepath_or_null = case type_constructor
					     t::ERRONEOUS_TYPE_CONSTRUCTOR =>  NULL;
					     _                 =>  get_modulepath_or_null (
                                                                       mpc::find_module_path_for_type_constructor,
                                                                       ms::type_identifier type_constructor
                                                                   );
                                         esac;

				 my  ( module_stamp,
				       typechecker_dictionary,
				       module_declarations
                                     )
				     =
				     case modulepath_or_null

					 THE [x] => (x, typechecker_dictionary, module_declarations);

					 _ => 
					     (x, ee, ed)
					     where 
						 x  = make_stamp();

						 ee = td::set (typechecker_dictionary, x, TYPE_CONSTRUCTOR_ENTRY type_constructor);

						 ed = case syntactic_typechecking_context

							  ts::IN_GENERIC _
							      => 
							      {   typechecked_type_constructor_expression
								      = 
								      case modulepath_or_null 
									  THE module_path =>  m::TYPE_VARIABLE_TYPE_CONSTRUCTOR  module_path;
									  _               =>  m::CONSTANT_TYPE_CONSTRUCTOR  type_constructor;
								      esac;

								  (m::TYPE_CONSTRUCTOR_DECLARATION (x, typechecked_type_constructor_expression))
								  !
								  module_declarations;
							      };

							  _  => module_declarations;
						      esac;

					     end;			# where
                                     esac;

				 api_element
                                     =
                                     TYPE_CONSTRUCTOR_IN_API {
                                       type_constructor => t::ERRONEOUS_TYPE_CONSTRUCTOR,
				       is_a_replica     => FALSE,
				       scope            => 0,
				       module_stamp
				     };

				 named_api_elements =  (symbol, api_element) ! named_api_elements;

				 # Use of t::ERRONEOUS_TYPE_CONSTRUCTOR above is a hack.
				 #
				 # It relies on the fact that the inferred api
				 # would never be macro expanded or api-matched
				 # against anyway.
				 #
				 # One might wonder what about a generic declaration
				 # with no result api constraint -- the
				 # inferred Generic_Api would contain
				 # t::ERRONEOUS_TYPE_CONSTRUCTOR -- but fortunately
				 # the result api in this Generic_Api
				 # would never be matched against either. (ZHONG)

				 { named_api_elements,
				   typechecker_dictionary,
				   module_declarations,
				   symbol_table_entries,
				   slot_count,
				   contains_generic
				 };
			     };

		        _ => { named_api_elements,
                               typechecker_dictionary,
                               module_declarations,
                               symbol_table_entries,
                               slot_count,
                               contains_generic
                             };
                  esac;					# fun note_named_symbol_table_entry

		  named_symbol_table_entries
                      =
                      st::to_sorted_list (st::consolidate symbol_table);

		  (list::fold_left
                      note_named_symbol_table_entry
                      { named_api_elements     => ([]:		List( (symbol::Symbol, Api_Element) )),
                        typechecker_dictionary => td::empty,
                        module_declarations    => ([]:		List( Module_Declaration )),
                        symbol_table_entries   => ([]:		List( ste::Symbol_Table_Entry )),
                        slot_count             => 0,
                        contains_generic       => FALSE
                      }
                      (named_symbol_table_entries:	List ((symbol::Symbol, symbol_table::Entry)))
                  )
                      ->
                      { named_api_elements,
                        typechecker_dictionary,
                        module_declarations,
                        symbol_table_entries,
                        slot_count,			# Discarded at this point.
                        contains_generic
                      };

	    
                  (   reverse  named_api_elements,
                      typechecker_dictionary,
                      reverse  module_declarations,
                      reverse  symbol_table_entries,
                      contains_generic
                  );
	    };						#  fun extract_symbol_table_contents 

            # 2009-08-10 CrT:
            #    THIS IS NOT WORKING.  It radiated
            #    error conditions into parts of the
            #    backend I do not understand well
            #    enough to modify appropriately.
            # 
            #    I implemented this before I realized
            #    that parts of a package can be selectively
            #    strong-sealed by putting them in a subpackage,
            #    sealing it, and then including it back into
            #    the main package.
            # 
            #    Now that I'm more aware of that hack,
            #    I'm undecided as to whether the PARTIAL_CAST
            #    idea is worth pursuing.
            # 
	    # This is our core hack to implement
            # partial package casting ("sealing").
	    #
            # The only difference between strong and
	    # partial package casting is that strong
	    # package casting hides all package elements
            # not explicitly listed in the api, whereas
	    # partial package casting leaves unmentioned
	    # elements visible and unchanged.
	    #
	    # This function conditionally extends the api
            # with all unmentioned elements from the package,
            # thereby reducing partial package casting to
	    # the already-implemented case of strong package
	    # casting.
            #
	    #
            # Our three input arguments are:
	    #
            #   o The constraining api (if any).
	    #
            #   o The cast operation. We do nothing
            #     unless it is PARTIAL_PACKAGE_CAST.
	    #
            #   o The constrained package.
	    #
            #   o The associated symbol table.
	    #
	    #
            # We return three results:
	    #
            #   o The constraining API, possibly augmented
            #     with new elements.
	    #
            #   o The cast operation, possibly changed
            #     from PARTIAL_PACKAGE_CAST
            #     to    STRONG_PACKAGE_CAST.
	    #
	    fun	maybe_extend_api_to_cover_package
                (
                  constraining_api_or_null:	Null_Or( m::Api ),
                  package_cast:			Package_Cast,			# How to apply constraining API -- strong/weak/partial cast.
                  a_package:			m::Package,
                  symbol_table:                 st::Symbol_Table
                )
                :
	        ( Null_Or( m::Api ),		# constraining_api_or_null
                  Package_Cast,			# package_cast
                  st::Symbol_Table		# symbol_table
                )
		=
		{
		    if *debugging
			case package_cast
			       WEAK_PACKAGE_CAST => print "maybe_extend_api_to_cover_package: This is a WEAK cast.\n";
			     STRONG_PACKAGE_CAST => print "maybe_extend_api_to_cover_package: This is a STRONG cast.\n";
			    PARTIAL_PACKAGE_CAST => print "maybe_extend_api_to_cover_package: This is a PARTIAL cast.\n";
			esac;
		    fi;

		    case package_cast

			PARTIAL_PACKAGE_CAST
			    =>
			    case (constraining_api_or_null, a_package)
				( THE (old_api as API { stamp, name, stub, elements => constraining_elements, closed, symbols, property_list, contains_generic, type_sharing, package_sharing } ),
				  A_PACKAGE  { an_api =>  API { elements => constrained_elements, ... }, ... }
				)
				    =>
				    {    # The difference between PARTIAL_PACKAGE_CAST
					 # and STRONG_PACKAGE_CAST is just that the latter
					 # hides all package elements not explicitly listed
					 # in the API, whereas the former passes through
					 # unchanged all package elements not mentioned
					 # by the api.

{ old_debug_setting = *debugging;
  debugging := TRUE;
		                         if_debugging_show_api          ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --maybe_extend_api_to_cover_package: original api: ",        old_api,   symbol_table);
		                         if_debugging_show_package      ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --maybe_extend_api_to_cover_package: constrained_package: ", a_package, symbol_table);
  debugging := old_debug_setting;
};
fun print_elements  []
        =>
        ();

    print_elements ((symbol, api_element: m::Api_Element) ! rest)
        =>
	{   printf "  api element: %s\n" (s::name symbol);
	    print_elements rest;
	};
end;
printf "Initial constraining elements: \n";  print_elements constraining_elements;
printf "Initial constrained  elements: \n";  print_elements  constrained_elements;

					 constraining_elements
					     =
					     (reverse  constrained_elements)
					     @
                                             constraining_elements;
#					     constraining_elements;
#					     constrained_elements @ constraining_elements;

printf "Final   constraining elements: \n";  print_elements constraining_elements;


					 # We implement that here by adding to the api 'elements'
					 # list all "missing" elements in it present in the package.
					 # With this done, we can then proceed with further processing
					 # exactly as in the STRONG_PACKAGE_CAST case.
					 # We start by sorting both lists:
#
#					 fun elem_eq ((s1, _), (s2, _)) = s::eq        (s1, s2);
#					 fun elem_gt ((s1, _), (s2, _)) = s::symbol_gt (s1, s2);
#
#					 constraining_elements = list_mergesort::sort  elem_gt  constraining_elements;
#					 constrained_elements  = list_mergesort::sort  elem_gt  constrained_elements;
#
#
#					 # We now merge the two sorted lists to produce the new
#					 # constraining_elements list, favoring constraining
#					 # over constrained elements whenever there is a choice:
#					 #
#					 constraining_elements
#					     =
#					     left_favoring_merge( constraining_elements, constrained_elements, [] )
#					     where  
#						 # "s1" == "symbol1", "e1" == "element1" &tc:
#						 #
#						 fun left_favoring_merge (list1 as (e1 ! rest1), list2 as (e2 ! rest2), results)
#							 =>
#							 if   (elem_eq (e1, e2))   left_favoring_merge (rest1, rest2, e1 ! results);
#							 elif (elem_gt (e1, e2))   left_favoring_merge (list1, rest2, e2 ! results);
#							 else                      left_favoring_merge (rest1, list2, e1 ! results);
#							 fi;
#
#						     left_favoring_merge (        [], e2 ! rest2, results) => left_favoring_merge ([], rest2, e2 ! results);
#						     left_favoring_merge (e1 ! rest1,         [], results) => left_favoring_merge (rest1, [], e1 ! results);
#						     left_favoring_merge (        [],         [], results) => reverse results;
#						 end;
#					     end;

					 # Reconstitute the constraining API with
					 # the new elements and symbols lists:
					 #	
					 new_api
                                             =
                                             API { elements => constraining_elements,
                                                   symbols  => map  #1  constraining_elements,
                                                   stamp,
                                                   name,
                                                   stub,
                                                   closed,
                                                   property_list,
                                                   contains_generic,
                                                   type_sharing,
                                                   package_sharing
                                                 };

					 # Old API is still in symbol table,
					 # so we need to override it:
					 #
					 symbol_table
                                             =
                                             case name
                                                 THE symbol => st::bind (symbol, ste::NAMED_API new_api, symbol_table);
                                                 NULL       => symbol_table;
                                             esac; 

                                         { old_debug_setting = *debugging;
                                           debugging := TRUE;
		                           if_debugging_show_api          ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --maybe_extend_api_to_cover_package: extended api: ",        new_api,   symbol_table);
                                           debugging := old_debug_setting;
                                         };
#                                         show_symbol_table ("--maybe_extend_api_to_cover_package: symbol table: ",                   symbol_table)
	                                 if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  maybe_extend_api_to_cover_package.\n";

					 ( THE new_api,
					   STRONG_PACKAGE_CAST,
                                           symbol_table
					 );
				    };

				other => (constraining_api_or_null, package_cast, symbol_table);	# No change.
			    esac;
			other         => (constraining_api_or_null, package_cast, symbol_table);	# No change.
		    esac;

		};


	############################################################################
	#                                                                          #
	# The typecheck_constrained_package function is used to                    #
	# perform api matching on package declarations with package casts.         #
	#                                                                          #
        # The "package_cast" argument  is used to indicate whether the             #
	# package cast is strong, weak or partial.                                 #
	#                                                                          #
	############################################################################
	#
	fun typecheck_constrained_package
            (
	      constrained_package:		m::Package,			# Package to be constrained by api.
              package_cast:                     Package_Cast,			# How to apply constraining API -- strong/weak/partial cast.
	      constraining_api:			m::Api,				# Api to constrain package.

	      package_declaration:     		deep::Declaration,
	      package_expression:    		m::Package_Expression,
	      module_stamp_or_null:		Null_Or( rp::Module_Stamp ),
	      depth:                      	debruijn_index::Depth,
	      typechecker_dictionary:		m::Typechecker_Dictionary,
	      inverse_path:                     inverse_path::Inverse_Path,
	      symbol_table:			st::Symbol_Table,		# Combines both info from all .o7 files we depend on and info from raw-syntax being processed.

	      source_code_region:               source_map::Source_Code_Region,
	      compile_info:                     typecheck_stuff::Compile_Info
	    )
	    :
            ( deep::Declaration,
              m::Package,
              m::Package_Expression
            )
            = 
	    {
		if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_constrained_package/TOP";
                if *debugging
                   case package_cast
                       WEAK_PACKAGE_CAST => print "typecheck_constrained_package: This is a WEAK cast.\n";
                     STRONG_PACKAGE_CAST => print "typecheck_constrained_package: This is a STRONG cast.\n";
                    PARTIAL_PACKAGE_CAST => print "typecheck_constrained_package: This is a PARTIAL cast.\n";
                   esac;
                fi;
		if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package/TOP: constrained_package: ", constrained_package, symbol_table);
		if_debugging_show_api     ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package/TOP: constraining_api: ",    constraining_api,    symbol_table);
                unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package/TOP: unparsing package_declaration deep syntax: ", package_declaration, symbol_table);

                my  { result_declaration          => result_declaration1:           deep::Declaration,
                      result_package              => result_package1:               m::Package,
                      coerced_package_expression  => result_package_expression1:    m::Package_Expression
		    }
		    = 
		    api_match::thin_package							# thin_package		def in    src/lib/compiler/front/typechecker/modules/api-match-g.pkg
                        {
                          constrained_package,			# Check this package
			  constraining_api,			# against this api.

			  module_stamp_or_null,
			  depth,
			  package_expression,
			  typechecker_dictionary,
			  inverse_path,
			  symbol_table,
			  source_code_region,
			  compile_info
			};


		if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package: api_match::thin_package done";
		if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package: result_package1: ", result_package1, symbol_table);
                unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package: unparsing result_declaration1 deep syntax: ", result_declaration1, symbol_table);
                if *debugging
                   case package_cast
                       WEAK_PACKAGE_CAST => print "typecheck_constrained_package: This is a WEAK cast.\n";
                     STRONG_PACKAGE_CAST => print "typecheck_constrained_package: This is a STRONG cast.\n";
                    PARTIAL_PACKAGE_CAST => print "typecheck_constrained_package: This is a PARTIAL cast.\n";
                   esac;
                fi;

                case package_cast

		    WEAK_PACKAGE_CAST
			=>
			( deep::SEQUENTIAL_DECLARATIONS [package_declaration, result_declaration1],
                          result_package1,
                          result_package_expression1
                        );

		    STRONG_PACKAGE_CAST
			=>
			{    my  {  result_declaration => result_declaration2,
				    result_package     => result_package2,
				    result_expression  => result_expression2
				 }
				 = 
				 api_match::cast_package					# cast_package		def in    src/lib/compiler/front/typechecker/modules/api-match-g.pkg
                                     {
                                       constrained_package =>  result_package1,
				       constraining_api,

				       package_expression =>  result_package_expression1, 

				       depth,
				       inverse_path,
				       symbol_table,


				       typechecker_dictionary,
				       source_code_region,
				       compile_info
				     };

			     if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[STRONG_PACKAGE_CAST]: api_match::cast_package done";
			     if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[STRONG_PACKAGE_CAST]: result_package2: ", result_package2, symbol_table);
                             unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[STRONG_PACKAGE_CAST]: unparsing result_declaration2 deep syntax: ", result_declaration2, symbol_table);

			     ( deep::SEQUENTIAL_DECLARATIONS [ package_declaration, result_declaration1, result_declaration2 ],
			       result_package2,
			       result_expression2
			     );
		        };

# XXX BUGGO FIXME 2009-03-22 CrT: This is at the moment just a clone of the above case:
		    PARTIAL_PACKAGE_CAST
			=>
			{   my  { result_declaration => result_declaration2,
				  result_package     => result_package2,
				  result_expression  => result_expression2
				}
				= 
				api_match::cast_package
				    {
				      constrained_package =>  result_package1,
				      constraining_api,

				      package_expression =>  result_package_expression1, 

				      depth,
				      inverse_path,
				      symbol_table,


				      typechecker_dictionary,
				      source_code_region,
				      compile_info
				    };

			     if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[PARTIAL_PACKAGE_CAST]: api_match::cast_package done";
			     if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[PARTIAL_PACKAGE_CAST]: result_package2: ", result_package2, symbol_table);
                             unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_constrained_package[PARTIAL_PACKAGE_CAST]: unparsing result_declaration2 deep syntax: ", result_declaration2, symbol_table);

			    (   deep::SEQUENTIAL_DECLARATIONS [ package_declaration, result_declaration1, result_declaration2 ],
				result_package2,
				result_expression2
			    );
		        };
                esac;
	    };



	# typecheck_package: typecheck the raw package, without api constraint:
	# Several invariants: 
	#     Every package_expression
        #     is now typechecked into a quadruple
	#         ( deep_syntax_tree,
        #           resulting_package_expression,	# Gets folded into module_declarations result.
        #           macro expansion expressions,
        #           delta macro expansion dictionary
        #         )
	#     where the latter was collected while typechecking
        #     the current package expression.
        #
        #     The macro expansion dictionary delta is
	#     designed to deal with LET_IN_PACKAGE
        #     and LET_IN_GENERIC and to maintain the
	#     hidden typechecked_package dictionary context.
	#
	fun typecheck_package
            (
	      package_body_to_typecheck:       raw_syntax::Package_Expression,         		# package body to typecheck
	      name:                            Null_Or( s::Symbol ), 

	      symbol_table:                    st::Symbol_Table,
	      typechecker_dictionary:          m::Typechecker_Dictionary,

	      syntactic_typechecking_context:  ts::Syntactic_Typechecking_Context,
	      module_path_context:             mpc::Context,   

	      module_stamp_v:                  Null_Or( rp::Module_Stamp ),  

	      inverse_path:                    ip::Inverse_Path,
	      source_code_region:              source_map::Source_Code_Region,      

	      compile_info as { make_highcode_variable=>make_var, make_stamp, error_fn, ... }: ts::Compile_Info
            )
	    :
            ( deep::Declaration,
              m::Package,
              m::Package_Expression,
              td::Typechecker_Dictionary
            )
            =
	    {   depth    =  case syntactic_typechecking_context
                                 ts::IN_GENERIC { depth, ... }   => depth;
			         _                               => di::top;
                            esac;

		if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package: " + pkg_name)
                where
                    pkg_name =  case name   THE n =>  s::name n;
			  	            NULL  =>  "<anonymous>";
                                esac;
		end;

		# typecheck_package':
                #     ( raw_syntax::Package_Expression,
		#       Symbol_Table,
		#       Typechecker_Dictionary,
		#       Source_Code_Region
                #     )
		#     ->
                #     ( deep::Declaration
		#       m::Package
		#       m::Package_Expression
		#       td::Typechecker_Dictionary
		#     )
                #
		fun typecheck_package'
                        (
                          raw::PACKAGE_DEFINITION declaration:	raw_syntax::Package_Expression,
                          symbol_table:				st::Symbol_Table,
                          typechecker_dictionary:		m::Typechecker_Dictionary,
                          source_code_region:			source_map::Source_Code_Region
                        )
                        :
                        ( deep::Declaration,			# result_declaration 
		          m::Package,				# result_package
		          m::Package_Expression,		# result_package_expression
		          td::Typechecker_Dictionary
		        )
			=>
			{   # We wind up here for vanilla package declarations.

                            if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_DEFINITION]";

			    # We enter a new module path context
                            # whenever we enter a PACKAGE_DEFINITION:
			    #
			    module_path_context'
                                =
                                mpc::enter_open (
                                    module_path_context,
                                    module_stamp_v
                                );

			    my  ( abstract_declaration:			deep::Declaration,
				  symbol_table':                   	st::Symbol_Table,
				  module_declaration:			Module_Declaration,
				  typechecker_dictionary':		Typechecker_Dictionary
                                )
				= 
				typecheck_declaration' (
				    declaration:			raw_syntax::Declaration,
				    symbol_table:			st::Symbol_Table,
				    typechecker_dictionary,
				    enter_package
                                        syntactic_typechecking_context,
				    TRUE,                               #  toplevel 
				    module_path_context',
				    inverse_path,
				    source_code_region,
				    compile_info
				);

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck[PACKAGE_DEFINITION]: typecheck_declaration' done";
			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_DEFINITION]: calling extract_symbol_table_contents...";

			    my  ( api_elements:				List( (symbol::Symbol, m::Api_Element ) ),
				  typechecker_dictionary'':		module::Typechecker_Dictionary,
				  module_declarations:			List( Module_Declaration ),
				  symbol_table_entries:			List( symbol_table_entry::Symbol_Table_Entry ),
				  contains_generic:			Bool
                                )
				=
				extract_symbol_table_contents (
                                    symbol_table',
                                    module_path_context',
                                    syntactic_typechecking_context,
                                    compile_info
                                );

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_DEFINITION]: extract_symbol_table_contents done";

			    my  ( typechecker_dictionary_local,
				  module_declaration_local
                                )
				=
				case syntactic_typechecking_context

				     ts::IN_GENERIC _
					 => 
					 ( td::mark (make_stamp, td::atop (typechecker_dictionary'', typechecker_dictionary')), 
					   module_declaration_sequence (module_declaration ! module_declarations)
					 );

				    _ => (typechecker_dictionary'', module_declaration);
                                esac;

			    package_expression
				=
				PACKAGE {
				    stamp => m::MAKE_STAMP,

				    module_declaration
                                        =>
                                        module_declaration_local
				};

			    result_package
				= 
				m::A_PACKAGE {

				  an_api,
				  typechecked_package,

				  var_home,
				  inlining_info
				}
                                where

				    symbols =  map  #1  api_elements;

				    an_api
					= 
					m::API {

					  stamp           => make_stamp (),
					  property_list   => property_list::make_property_list (),

					  elements        => api_elements,
					  symbols,

					  name            => NULL,
					  closed          => FALSE,

					  type_sharing    => NIL,
					  stub            => NULL,

					  contains_generic,
					  package_sharing => NIL
					};

				    typechecked_package
					=
					{ stamp         => make_stamp(),      #  Generate package stamp 
					  stub          => NULL,

					  property_list => property_list::make_property_list (),
					  inverse_path,

					  typechecker_dictionary
                                              =>
                                              td::mark (
						  make_stamp,
						  td::atop (
						      typechecker_dictionary_local,
						      typechecker_dictionary
						  )
					      )
					};

				    var_home
                                        =
                                        a::named_var_home (temp_package_id, make_var);

				    inlining_info
                                        =
                                        inlining_information::LIST (map ms::extract_inlining_info  symbol_table_entries);
				end;

			    result_declaration
				= 
				deep::PACKAGE_DECLARATIONS
				    [
				      deep::NAMED_PACKAGE
					{
					  name_symbol =>  temp_package_id,
					  a_package   =>  result_package,
					  definition
					      =>					# body
					      deep::PACKAGE_LET {
						  declaration => abstract_declaration,
						  expression  => deep::PACKAGE_DEFINITION  symbol_table_entries
					      }
					}
				    ];

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_DEFINITION]";


			    ( result_declaration:		deep::Declaration,
                              result_package:			m::Package,
                              package_expression:		m::Package_Expression,
                              td::empty
                            );
			};

 		    typecheck_package'
                        ( raw::CALL_OF_GENERIC (symbol_path, args),
                          symbol_table,
                          typechecker_dictionary,
                          source_code_region
                        )
			=>
			{   package_expression'
				=
				raw::LET_IN_PACKAGE
                                    (
				      raw::PACKAGE_DECLARATIONS
                                          [
					    raw::NAMED_PACKAGE
					      {
						name_symbol => return_id,
						constraint  => raw::NO_PACKAGE_CAST,
						definition  => raw::INTERNAL_CALL_OF_GENERIC (symbol_path, args),
						kind        => raw::PLAIN_PACKAGE
					      }
					  ],

				      raw::PACKAGE_BY_NAME ( [ return_id, result_id ] )
				    );

			    typecheck_package' ( package_expression',
                                        symbol_table,
                                        typechecker_dictionary,
                                        source_code_region
                                      );
			};

		    typecheck_package'
                        (
			  raw::INTERNAL_CALL_OF_GENERIC (symbol_path, [ (arg, b) ] ),
			  symbol_table,
			  typechecker_dictionary,
			  source_code_region
                        )
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[CALL_OF_GENERIC-one]";

			    a_generic
				=
				f::find_generic_via_symbol_path (symbol_table,   sp::SYMBOL_PATH symbol_path,   error_fn  source_code_region);

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[CALL_OF_GENERIC-one]: generic lookup done";
			    show_generic   ("--typecheck_package'[CALL_OF_GENERIC]: generic ", a_generic, symbol_table);

			    rstamp   =   make_stamp();   #  module_stamp for the uncoerced argument

			    my  ( arg_declaration:		deep::Declaration,
				  arg_package:			m::Package,
				  arg_expression:		m::Package_Expression,
				  arg_dee
                                )
				= 
				typecheck_package (
				    arg,				# package body to typecheck
				    NULL,				# name_or_null
				    symbol_table,
				    typechecker_dictionary,
				    syntactic_typechecking_context,
				    module_path_context,
				    THE rstamp,
				    ip::INVERSE_PATH [],
				    source_code_region,
				    compile_info
				);

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[CALL_OF_GENERIC-one]: typecheck arg done";
			    if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[CALL_OF_GENERIC-one]: arg package: ", arg_package, symbol_table);


			    case (a_generic, arg_package)

			         (   (m::ERRONEOUS_GENERIC, _)
				 | (_, m::ERRONEOUS_PACKAGE)
				 )
				     =>
				     {   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[CALL_OF_GENERIC-one]: error generic or arg";

					 ( deep::SEQUENTIAL_DECLARATIONS [],
					   m::ERRONEOUS_PACKAGE,
					   m::CONSTANT_PACKAGE (m::bogus_typechecked_package),
					   td::empty
					 );
				     };

				 ( m::GENERIC   { typechecked_generic, ... },
				   m::A_PACKAGE { typechecked_package =>  arg_typechecked_package,     ... }
				 )
				     =>
				     {    result_dee
					     =
					     td::mark (make_stamp, td::set (arg_dee, rstamp, m::PACKAGE_ENTRY arg_typechecked_package));

						  #  the argument package should be bound to rstamp 

					  generic_expression
					      = 
					      case (mpc::find_module_path_for_g
						       (
							 module_path_context,
							 ms::generic_identifier  a_generic
						   )   )

						   THE module_path =>  VARIABLE_GENERIC module_path;
						   NULL            =>  CONSTANT_GENERIC typechecked_generic;
					      esac;

					  my { result_declaration, result_package, result_expression }
					      = 
					      api_match::apply_generic
						{
						  module_stamp_or_null
						      =>
						      THE rstamp,

						  module_path_context
						      =>
						      mpc::enter_open
							  ( module_path_context,
							    module_stamp_v
							  ),

						  a_generic,
						  generic_expression,

						  arg_package,
						  arg_expression,

						  depth,
						  symbol_table,

						  inverse_path,
						  source_code_region,
						  compile_info
						};

					  if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[CALL_OF_GENERIC-one]: apply_generic done";
					  if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[CALL_OF_GENERIC-one]: result: ", result_package, symbol_table);
					  if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[CALL_OF_GENERIC-one]";

					  (   deep::SEQUENTIAL_DECLARATIONS [ arg_declaration, result_declaration ]:		deep::Declaration,
					      result_package:									m::Package,
					      result_expression:								m::Package_Expression,
					      result_dee
					  );
				      };

				_ => bug "INTERNAL_CALL_OF_GENERIC: one arg";
                            esac;

			};	 #  INTERNAL_CALL_OF_GENERIC - one arg 

		    typecheck_package'
                        ( raw::INTERNAL_CALL_OF_GENERIC (symbol_path, arg ! arglist),
                          symbol_table,
                          typechecker_dictionary,
                          source_code_region
                        )
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package':[CALL_OF_GENERIC-many]";

			    package_expression'
				=
				raw::LET_IN_PACKAGE
                                    (
				      raw::PACKAGE_DECLARATIONS
                                          [
					    raw::NAMED_PACKAGE
                                                {
					          name_symbol =>  hidden_id,
					          constraint  =>  raw::NO_PACKAGE_CAST,
					          definition  =>  raw::INTERNAL_CALL_OF_GENERIC (symbol_path, [arg]),
						  kind        =>  raw::PLAIN_PACKAGE
					        }
				          ],

				      raw::INTERNAL_CALL_OF_GENERIC ( [ hidden_id, generic_id ], arglist)
				    );

			    typecheck_package' (
				package_expression',
				symbol_table,
				typechecker_dictionary,
				source_code_region
			    );
			};                            #  INTERNAL_CALL_OF_GENERIC - multiple args 

		    typecheck_package' (raw::INTERNAL_CALL_OF_GENERIC (symbol_path, []), symbol_table, typechecker_dictionary, source_code_region)
			=>
			bug "typecheck_package::INTERNAL_CALL_OF_GENERIC -- empty arg list";

		    typecheck_package'
                        ( raw::PACKAGE_BY_NAME path,
                          symbol_table,
                          typechecker_dictionary,
                          source_code_region
                        )
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_BY_NAME]";

			    a_package = f::find_package_via_symbol_path (symbol_table, sp::SYMBOL_PATH path,   error_fn  source_code_region);

		#	    if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_BY_NAME]: package: ", a_package, symbol_table);

			    typechecked_package
				= 
				case a_package
				     A_PACKAGE { typechecked_package, ... } =>  typechecked_package;
				     _                                     =>  m::bogus_typechecked_package;			#  error recovery
                                esac;

			    result_expression
				=
				case a_package
				  
				     A_PACKAGE _
					 =>
					 #  if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_BY_NAME]: result_expression/A_PACKAGE"; 
					 #
					 case (mpc::find_module_path_for_package
                                                   (
                                                     module_path_context,
                                                     ms::package_identifier a_package
                                              )    )
					   
					      THE module_path =>   m::VARIABLE_PACKAGE module_path;
					      NULL            =>   m::CONSTANT_PACKAGE typechecked_package;
					 esac;

				    _ => m::CONSTANT_PACKAGE m::bogus_typechecked_package;		#  error recovery
				esac;

			    #  if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_BY_NAME]"; 

			    (   deep::SEQUENTIAL_DECLARATIONS []:		deep::Declaration,
				a_package:					m::Package,
				result_expression:				m::Package_Expression,
				td::empty
			    );
			};

		    typecheck_package'
                        ( raw::LET_IN_PACKAGE (declaration, a_package),
                          symbol_table,
                          typechecker_dictionary,
                          source_code_region
                        )
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[LET_IN_PACKAGE]";

			    my  ( local_abstract_declaration,
				  symbol_table',
				  local_module_declaration,
				  typechecker_dictionary'
                                )
				= 
				typecheck_declaration' (
				    declaration,
				    symbol_table,
				    typechecker_dictionary,
				    syntactic_typechecking_context,
				    TRUE,                               #  toplevel 
				    module_path_context,
				    inverse_path,
				    source_code_region,
				    compile_info
				);

			    # top = TRUE: Don't allow nongeneralized type variables
			    # in local declarations because of bug 905/952.  This is
			    # stricter than necessary.  Could allow top = FALSE
			    # if the body package contains no generics.  To make the
			    # condition more precise, have to synthesize a boolean
			    # attribute indicating presence of generics [dbm]


			    # DAVE? what context to use for the local declarations?
			    # perhaps should null bind_context as for generic body?
			    # perhaps it doesn't matter because of relativization
			    # and the fact that local typechecker_dictionary can't be referred
			    # to from outside.   XXX BUGGO FIXME


			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[LET_IN_PACKAGE]: local typecheck_declaration' done";

			    my  ( body_abstract_declaration:		deep::Declaration,
				  body_package:				m::Package,
				  body_expression:			m::Package_Expression,
				  body_dee
                                )
				= 
				typecheck_package' (
				    a_package,
				    st::atop (symbol_table', symbol_table),
				    td::atop (typechecker_dictionary', typechecker_dictionary),
				    source_code_region
				);

			    result_declaration = deep::SEQUENTIAL_DECLARATIONS [local_abstract_declaration, body_abstract_declaration];
			    result_expression  = m::PACKAGE_LET { declaration => local_module_declaration, expression => body_expression };

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[LET_IN_PACKAGE]: typecheck body pkg done";

			    ( result_declaration:		deep::Declaration,
			      body_package:			m::Package,
			      result_expression:		m::Package_Expression,
			      td::mark
                                ( make_stamp,
				  td::atop_sp (body_dee, typechecker_dictionary')
			        )
			    );
			};

		    typecheck_package'
                        ( raw::PACKAGE_CAST (constrained_package, api_constraint),
                          symbol_table,
                          typechecker_dictionary,
                          source_code_region
                        )
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_CAST]: TOP";

			    my  ( module_stamp_v,
				  module_stamp_or_null
				)
				= 
				case api_constraint 

				     raw::NO_PACKAGE_CAST
					 =>
					 (module_stamp_v, NULL);

				     _   => {   nentv = THE (make_stamp());

						(nentv, nentv);
					    };
				esac;

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: above call to typecheck_body";

			    #  Typecheck the constrained package by itself: 
			    #
			    my  ( abstract_pkg_declaration:		deep::Declaration,
				  a_package:				m::Package,
				  expression:				m::Package_Expression,
				  typechecker_dictionary_additions
                                )
				= 
				typecheck_package (
				    constrained_package,		# package body to typecheck
				    NULL,				# name_or_null.
				    symbol_table,
				    typechecker_dictionary,
				    syntactic_typechecking_context,
				    module_path_context,
				    module_stamp_v,
				    inverse_path,
				    source_code_region,
				    compile_info
				);

			    #  Typecheck the constraining api by itself: 
			    #
                            my  ( constraining_api_or_null,
				  package_cast
                                )
				= 
				{   fun typecheck_api  api_expression
					= 
					ta::typecheck_api {

					    api_expression,
					    symbol_table,

					    name_or_null  =>  NULL,

					    typechecker_dictionary,
					    module_path_context,
					    source_code_region,
					    compile_info
					};

			            if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: above possible call to typecheck_api";

				    my  ( constraining_api_or_null:    Null_Or( m::Api ),
                                          package_cast:                Package_Cast
                                        )
					=
					case api_constraint 
					    raw::WEAK_PACKAGE_CAST     an_api =>   (THE (typecheck_api an_api),     WEAK_PACKAGE_CAST );
					    raw::PARTIAL_PACKAGE_CAST  an_api =>   (THE (typecheck_api an_api),  PARTIAL_PACKAGE_CAST );
					    raw::STRONG_PACKAGE_CAST   an_api =>   (THE (typecheck_api an_api),   STRONG_PACKAGE_CAST );
					    _                                 =>   (NULL,                           WEAK_PACKAGE_CAST );
					esac;

			            if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: below possible call to typecheck_api";


				    ( constraining_api_or_null,
                                      package_cast
                                    );
				};


			    if *debugging
			       case package_cast
				   WEAK_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] above hack: This is a WEAK cast.\n";
				 STRONG_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] above hack: This is a STRONG cast.\n";
				PARTIAL_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] above hack: This is a PARTIAL cast.\n";
			       esac;
			    fi;

                            # If this is a PARTIAL_PACKAGE_CAST,
                            # hack the constraining api to reduce
                            # it to the STRONG_PACKAGE_CAST case:
                            #
			    my (constraining_api_or_null, package_cast, symbol_table)
				=
                                maybe_extend_api_to_cover_package (constraining_api_or_null, package_cast, a_package, symbol_table);

			    if *debugging
			       case package_cast
				   WEAK_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] below hack: This is a WEAK cast.\n";
				 STRONG_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] below hack: This is a STRONG cast.\n";
				PARTIAL_PACKAGE_CAST => print "--typecheck_package'[PACKAGE_CAST] below hack: This is a PARTIAL cast.\n";
			       esac;
			    fi;

			    if_debugging_say          "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: below call to typecheck_body";
                            unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: unparsing abtract_pkg_declaration deep syntax: ", abstract_pkg_declaration, symbol_table);
			    if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: a_package: ", a_package, symbol_table);

			    result_dee
				= 
				case api_constraint 

				    raw::NO_PACKAGE_CAST
					=>
					typechecker_dictionary_additions;

				   _ => case module_stamp_or_null

					    THE tmpev
						=>
						{   typechecked_package
							=
							case a_package

							     m::A_PACKAGE { typechecked_package, ... }
								 =>
								 typechecked_package;

							    _ => m::bogus_typechecked_package;
							esac;

						    td::set (typechecker_dictionary_additions, tmpev, m::PACKAGE_ENTRY typechecked_package);
						};

					     _ => bug "unexpected api_constraint while typechecking constrained package";
					esac;
                                esac;


			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_package'[PACKAGE_CAST]: above possible call to typecheck_constrained_package";

			    # Now typecheck the constrained package
                            # against the constraining api:
			    #
			    my  ( result_declaration:		deep::Declaration,
				  result_package:		m::Package,
				  result_expression:		m::Package_Expression
                                )
				= 
				case constraining_api_or_null

				    NULL
					=> 
					{   if (package_cast != WEAK_PACKAGE_CAST)

						error_fn
						    source_code_region
						    em::ERROR
						    "missing api in abstraction declaration"
						     em::null_error_body;
					    fi;

					    (abstract_pkg_declaration, a_package, expression);
					};

				    THE constraining_api
					=> 
					typecheck_constrained_package (

					    a_package:				m::Package,			# Package to be constrained by api.
					    package_cast:			Package_Cast,			# How to apply API -- strong/weak/partial cast.
					    constraining_api:			m::Api,				# Api to constrain package.

					    abstract_pkg_declaration:     	deep::Declaration,
					    expression:    			m::Package_Expression,

					    module_stamp_or_null,
					    depth,
					    typechecker_dictionary,
					    inverse_path,
					    symbol_table,
					    source_code_region,
					    compile_info
					);
                                esac;


			    if_debugging_say          "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_CAST]: below possible call to typecheck_constrained_package -- DONE";
                            unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_CAST]: unparsing result_declaration deep syntax: ", result_declaration, symbol_table);
			    if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package'[PACKAGE_CAST]: package: ", result_package, symbol_table);

			    ( result_declaration:		deep::Declaration,
			      result_package:			m::Package,
			      result_expression:		m::Package_Expression,
			      result_dee
			    );
			};

		    typecheck_package' (
                        raw::SOURCE_CODE_REGION_FOR_PACKAGE (
                            package_expression',
                            source_code_region'
                        ),
                        symbol_table,
                        typechecker_dictionary,
                        source_code_region
                    )
			=> 
			{   my  ( result_declaration:		deep::Declaration,
				  a_package:			m::Package,
				  result_expression:		m::Package_Expression,
				  result_dee
                                )
				= 
				typecheck_package' (
				    package_expression',
				    symbol_table,
				    typechecker_dictionary,
				    source_code_region'
				);

			    ( deep::SOURCE_CODE_REGION_FOR_DECLARATION (result_declaration, source_code_region'):		deep::Declaration,
			      a_package:											m::Package,
			      result_expression:										m::Package_Expression,
			      result_dee
			    );
			};
                end;				# fun typecheck_package'

		my  ( result_declaration:		deep::Declaration,
                      result_package:			m::Package,
                      result_expression:		m::Package_Expression,
                      result_dee
                    )
                    =
                    typecheck_package' (
                        package_body_to_typecheck:       raw_syntax::Package_Expression,
                        symbol_table:                    st::Symbol_Table,
                        typechecker_dictionary:          m::Typechecker_Dictionary,
                        source_code_region:              source_map::Source_Code_Region
                    );

		if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_package";


		( result_declaration:		deep::Declaration,
		  result_package:		m::Package,
		  result_expression:		m::Package_Expression,
                  result_dee
		);
	    }				#  function typecheck_package 




	#  typecheck_generic: Typecheck a generic, possibly with api constraint: 
	#
	also
	fun typecheck_generic (

	       generic_expression: raw_syntax::Generic_Expression, 

	       curried:       				Bool,
	       name:          				s::Symbol,   
	       symbol_table:  				st::Symbol_Table,

	       typechecker_dictionary:			m::Typechecker_Dictionary,
	       syntactic_typechecking_context:		ts::Syntactic_Typechecking_Context,
	       module_path_context: mpc::Context,

	       inverse_path:				ip::Inverse_Path,
	       source_code_region:			source_map::Source_Code_Region,

	       compile_info as { make_highcode_variable => make_var, make_stamp, error_fn, ... }: 	ts::Compile_Info
            )
	    :
            ( deep::Declaration,
              m::Generic_Expression,
              m::Generic,
              td::Typechecker_Dictionary
            )
            =
	    {   depth = case syntactic_typechecking_context

			    ts::IN_GENERIC { depth, ... }
				 =>
				 depth;

			    _ => di::top;

			esac;

                if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic: " + (s::name name));


		case generic_expression
		  
		    raw::GENERIC_BY_NAME (symbol_path, constraint_expression_or_null)
			=>
			{   a_generic = f::find_generic_via_symbol_path (symbol_table, sp::SYMBOL_PATH symbol_path,  error_fn  source_code_region);

			    case a_generic

				 ERRONEOUS_GENERIC
				     =>
				     ( deep::SEQUENTIAL_DECLARATIONS [],
				       CONSTANT_GENERIC (m::bogus_typechecked_generic),
				       a_generic,
				       td::empty
				     );

				_
				 =>
				 {   uncoerced_expression
					 = 
					 case (mpc::find_module_path_for_g (module_path_context, ms::generic_identifier a_generic))

					 THE  module_path
					     =>
					     VARIABLE_GENERIC  module_path;

					 NULL
					     =>
					      {   typechecked_package
						      =
						      case a_generic
							  GENERIC ft =>   ft.typechecked_generic;
							  _          =>   m::bogus_typechecked_generic;
						      esac;

						  CONSTANT_GENERIC typechecked_package;
					      };
					 esac;


				     case constraint_expression_or_null

					  raw::NO_PACKAGE_CAST
					      =>
					      ( deep::SEQUENTIAL_DECLARATIONS [],
						uncoerced_expression,
						a_generic,
						td::empty
					      );

					  raw::WEAK_PACKAGE_CAST raw_generic_api
					      =>
					      {   name_or_null = THE (anonymous_generic_api_id);

						  a_generic_api
						      = 
						      ta::typecheck_generic_api {

							  generic_api_expression => raw_generic_api,

							  name_or_null,
							  symbol_table,

							  typechecker_dictionary,
							  module_path_context,

							  source_code_region,
							  compile_info
						      };

						  my { result_declaration, result_generic, result_expression }
						      =
						      api_match::match_generic
							  {
							    an_api             =>  a_generic_api,
							    generic_expression =>  uncoerced_expression,

							    a_generic,
							    depth,

							    typechecker_dictionary,
							    inverse_path,

							    symbol_table,
							    source_code_region,
							    compile_info
							  };

						  ( result_declaration,
						    result_expression,
						    result_generic,
						    td::empty
						  );
					      };

					  raw::PARTIAL_PACKAGE_CAST raw_generic_api
					      => 
					      bug "'partial' generic constraints not implemented";   #  XXX BUGGO FIXME 

					  raw::STRONG_PACKAGE_CAST raw_generic_api
					      => 
					      bug "Opaque generic constraints not implemented";   #  XXX BUGGO FIXME 
				     esac;
				 };
			    esac;
			};

		    raw::LET_IN_GENERIC (declaration, a_generic)
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck[LET_IN_GENERIC]";

			    my  ( local_abstract_declaration,
				  symbol_table',
				  local_module_declaration,
				  typechecker_dictionary'
				)
				= 
				typecheck_declaration' (
				    declaration,
				    symbol_table,
				    typechecker_dictionary,
				    syntactic_typechecking_context,
				    TRUE,                               #  top 
				    module_path_context,
				    inverse_path,
				    source_code_region,
				    compile_info
				);

			     # top = TRUE: don't allow nongeneralized type variables
			     # in local declarations because of bug 905/952 [dbm]

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck[LET_IN_GENERIC]: local typecheck_declaration' done";

			    my  ( body_abstract_declaration,
				  body_expression,
				  body_g,
				  body_dee
				)
				= 
				typecheck_generic
                                  ( a_generic,
				    FALSE,                                     #  Curried 
				    name,
				    st::atop (symbol_table', symbol_table),
				    td::atop (typechecker_dictionary', typechecker_dictionary),
				    syntactic_typechecking_context,
				    module_path_context,
				    inverse_path,
				    source_code_region,
				    compile_info
				  );

			    result_deep_syntax_tree     =   deep::SEQUENTIAL_DECLARATIONS [local_abstract_declaration, body_abstract_declaration];

			    result_expression           =   m::LET_GENERIC (local_module_declaration, body_expression);

			    result_typechecker_dictionary  =   td::mark (make_stamp, td::atop_sp (body_dee, typechecker_dictionary'));

			    ( result_deep_syntax_tree,
			      result_expression,
			      body_g,
			      result_typechecker_dictionary
			    );
			};

		    raw::CONSTRAINED_CALL_OF_GENERIC (symbol_path, arglist, constraint)
			=>
			{   generic_expression'
				=
				raw::LET_IN_GENERIC (

				    raw::PACKAGE_DECLARATIONS [

					raw::NAMED_PACKAGE {

					   name_symbol => hidden_id,
					   constraint  => raw::NO_PACKAGE_CAST,
					   definition  => raw::INTERNAL_CALL_OF_GENERIC (symbol_path, arglist),
					   kind        => raw::PLAIN_PACKAGE
					}
				    ],

				    raw::GENERIC_BY_NAME (
					[ hidden_id, generic_id ],
					constraint
				    )
				);

			    typecheck_generic
			      ( generic_expression',
				FALSE,
				name,
				symbol_table,
				typechecker_dictionary,
				syntactic_typechecking_context,
				module_path_context,
				inverse_path,
				source_code_region,
				compile_info
			      );
			};

		    raw::GENERIC_DEFINITION { parameters => [ (parameter_name_or_null, param_sig_expression) ], body, constraint }
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic[GENERIC_DEFINITION]";

			    body = if curried
				       body;
				   else
				       raw::PACKAGE_DEFINITION (
					   raw::PACKAGE_DECLARATIONS [
					       raw::NAMED_PACKAGE {
						   name_symbol => result_id,
						   definition  => body,
						   constraint,
						   kind        => raw::PLAIN_PACKAGE
					       }
					   ]
				       );
				   fi;

			    constraint
				=
				if curried   constraint;
				else         raw::NO_PACKAGE_CAST;
				fi;

			    my (flex,
				depth)
				=
				case syntactic_typechecking_context

				    ts::IN_GENERIC { flex, depth }
					=>
					(flex, depth); 

				    _      /*** Entering generic for first time ***/ 
					=>
					{   base = make_stamp();

					    fun h s
						=
						case (stamp::compare (base, s))
						    LESS =>  TRUE;
						    _    =>  FALSE;
						esac;


					    (h, di::top);
					};
				esac;

			    parameter_name
				=
				case parameter_name_or_null
				    THE n =>  n;
				    NULL  =>  param_id;
				esac;

			    param_typechecked_package_variable
                                =
                                make_stamp ();

			    if_debugging_say (   "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic[GENERIC_DEFINITION]: param_macro_expansion_variable = "
					   +   rp::module_stamp_to_string param_typechecked_package_variable
					   );

			    param_sig
				= 
				ta::typecheck_api {

				    api_expression => param_sig_expression,
				    name_or_null  => NULL,

				    symbol_table,
				    typechecker_dictionary,
				    module_path_context,

				    source_code_region,
				    compile_info
				};

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: param_sig defined";

			    case param_sig

				 ERRONEOUS_API => raise exception em::COMPILE_ERROR;   #  Bail out -- not attempting to recover 

				_ => ();
			    esac;

			    #  Now know that param_sig is defined. 
			    # This creates new stamps, but we don't bother to update the
			    # epcontext, we do that later through map_paths:
			    #
			    my  { typechecked_package    =>  param_typechecked_package,
				  type_constructor_paths =>  param_tps
				}
				=
				ins::do_generic_parameter_api {

				    an_api       => param_sig,

				    inverse_path => ip::INVERSE_PATH (   case parameter_name_or_null
									     NULL => [];
									     _    => [parameter_name];
									 esac
								  ),
				    typechecker_dictionary,
				    source_code_region,
				    depth,
				    compile_info
				};

			    parameter_package
				= 
				{   param_dacc = a::named_var_home (parameter_name, make_var);

				    m::A_PACKAGE {
					an_api             => param_sig,
					typechecked_package => param_typechecked_package, 

					var_home             => param_dacc,			# "dacc" is probably "dynamic access"
					inlining_info      => inlining_information::NULL
				    };
				};

			    if_debugging_say           "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: parameter macro expanded";
			    if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: parameter_package: ", parameter_package, symbol_table);

			    typechecker_dictionary'
				= 
				td::mark (
				    make_stamp,
				    td::set (
					typechecker_dictionary,
					param_typechecked_package_variable,
					m::PACKAGE_ENTRY param_typechecked_package
				    )
				);

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: parameter td::set";

			    symbol_table'
				=
				case parameter_name_or_null

				    NULL   => ms::include_package (symbol_table, parameter_package);

				    THE _ => st::bind (parameter_name, ste::NAMED_PACKAGE parameter_package, symbol_table);
				esac;

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: parameter bound/opened";

			    module_path_context'
				=
				mpc::enter_closed module_path_context;

			    #  Fill in path_dictionary with paths for elements of parameter_package: 
			    #
			    map_paths (mpc::enter_open (module_path_context', THE param_typechecked_package_variable), parameter_package, flex);

			    mpc::bind_module_path (module_path_context', ms::package_identifier parameter_package, param_typechecked_package_variable);

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: module_path_context initialized";

			    # Must typecheck result api before the body is typechecked
			    # so that module_path_context' is not changed:
			    #
			    my  ( module_stamp_v,
				  constraining_api,
				  constraining_api_op
				)
				=
				{   fun typecheck_api x
					=
					ta::typecheck_api {

					    api_expression => x,
					    name_or_null  => NULL,

					    symbol_table                    => symbol_table', 
					    typechecker_dictionary             =>  typechecker_dictionary',
					    module_path_context =>  module_path_context', 

					    source_code_region,
					    compile_info
					};

				    case constraint
					 raw::NO_PACKAGE_CAST             =>   (NULL,               NULL,                          WEAK_PACKAGE_CAST);
					 raw::WEAK_PACKAGE_CAST    an_api =>   (THE (make_stamp()), THE (typecheck_api an_api),    WEAK_PACKAGE_CAST); 
					 raw::PARTIAL_PACKAGE_CAST an_api =>   (THE (make_stamp()), THE (typecheck_api an_api), PARTIAL_PACKAGE_CAST);
					 raw::STRONG_PACKAGE_CAST  an_api =>   (THE (make_stamp()), THE (typecheck_api an_api),  STRONG_PACKAGE_CAST);
				    esac;
				};

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: result api typecheckd";

			    # Adjust the ts::context value; the depth refers to the number
			    # of enclosing generic abstractions. (ZHONG)
			    #
			    depth'   = di::next depth;
			    context' = ts::IN_GENERIC { flex, depth=>depth' };

			    # body_dee is discarded here;
			    # however, it is not discarded
			    # when generic is applied.
			    #
			    my  ( body_abstract_declaration,
				  body_package,
				  body_expression,
				  body_dee			# "dee" == "delta eleboration environment" I think -- additions to typechecking dictionary.
				)
				= 
				typecheck_package (
				  body,
				  NULL,
				  symbol_table',
				  typechecker_dictionary',
				  context',
				  module_path_context',
				  module_stamp_v,
				  ip::INVERSE_PATH [],
				  source_code_region,
				  compile_info
				);


			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: body typecheckd";
			    if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: body_package: ", body_package, symbol_table);



			    #  Constrain by result api, on of:
			    #  
			    #
			    my  ( body_abstract_declaration',
				  body_package',
				  body_expression'
				)
				= 
				case constraining_api

				    NULL => (body_abstract_declaration, body_package, body_expression);

				    THE constraining_api'
					=>
					typecheck_constrained_package (

					    body_package,
					    constraining_api_op,		# match/edit/cast.
					    constraining_api',
					    body_abstract_declaration,
					    body_expression,
					    module_stamp_v,
					    depth',
					    typechecker_dictionary',
					    ip::INVERSE_PATH [],
					    symbol_table', 
					    source_code_region,
					    compile_info
					);
				esac;

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: body constrained";

			    generic_expression
				=
				m::LAMBDA {
				    parameter => param_typechecked_package_variable,
				    body      => body_expression'
				};

			    result_generic
				= 
				{   body_sig'
					=
					case body_package'

					     A_PACKAGE { an_api, ... } =>   an_api;
					    _                          =>   ERRONEOUS_API;
					esac;

				    a_generic_api
					= 
					m::GENERIC_API {

					    kind          => NULL,
					    parameter_api => param_sig, 
					    body_api       => body_sig',

					    parameter_variable  => param_typechecked_package_variable, 
					    parameter_symbol    => parameter_name_or_null
					};

				    typechecked_generic
					=
					{
					    stamp          => make_stamp(),
					    property_list  => property_list::make_property_list (),
					    inverse_path,

					    stub                  => NULL,
					    type_constructor_path => NULL,

					    #  Closure: Using the old typechecked_package dictionary !! XXX BUGGO FIXME 

					    generic_closure => m::GENERIC_CLOSURE {

						parameter_module_stamp =>  param_typechecked_package_variable,
						body_package_expression            =>  body_expression',
						typechecker_dictionary
					    }
					};

				    dacc   =   a::named_var_home (name, make_var);

				    m::GENERIC {   a_generic_api,
						   typechecked_generic,

						   var_home        =>  dacc,
						   inlining_info =>  inlining_information::NULL
					       };
				};

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: result_generic defined";

			    result_declaration
				=
				{   x = deep::GENERIC_DEFINITION { parameter      => parameter_package,
								   parameter_types => param_tps,
								   definition     => deep::PACKAGE_LET {
											declaration => body_abstract_declaration',
											expression  => deep::PACKAGE_BY_NAME body_package'
										    }
								  };

				    deep::GENERIC_DECLARATIONS [ deep::NAMED_GENERIC { name_symbol => name,
										       a_generic   => result_generic,
										       definition  => x
										     }
							       ];
				};

			    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic[GENERIC_DEFINITION]";
			    if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_generic[GENERIC_DEFINITION]: parameter_package: ", parameter_package, symbol_table);

			    (result_declaration, generic_expression, result_generic, td::empty);
			};

		    raw::GENERIC_DEFINITION { parameters => parameter ! lparam, body, constraint }
			=>
			{   generic_expression'
				= 
				raw::GENERIC_DEFINITION {
				    parameters => [ parameter ],
				    body       => raw::PACKAGE_DEFINITION (
						     raw::GENERIC_DECLARATIONS [
							 raw::NAMED_GENERIC {
							     name_symbol => generic_id,
							     definition => raw::GENERIC_DEFINITION {
									      parameters => lparam,
									      body,
									      constraint
									  }
							 }
						     ]
						 ),
				    constraint => raw::NO_PACKAGE_CAST
				};


			    typecheck_generic
                              ( generic_expression',
				TRUE,
				name,
				symbol_table,
				typechecker_dictionary,
				syntactic_typechecking_context,
				module_path_context,
				inverse_path,
				source_code_region,
				compile_info
			      );
			};

		    raw::GENERIC_DEFINITION { parameters => [], ... }
			=>
			bug "typecheck_generic";

		    raw::SOURCE_CODE_REGION_FOR_GENERIC ( generic_expression', source_code_region' )
			=>
			typecheck_generic
                          ( generic_expression',
			    curried,
			    name,
			    symbol_table,
			    typechecker_dictionary,
			    syntactic_typechecking_context,
			    module_path_context,
			    inverse_path,
			    source_code_region',
			    compile_info
			  );
                esac;
	    }                       #  function typecheck_generic 



	#  typecheck_named_packages: typecheck named packages, with api constraint.
	#
	also
	fun typecheck_named_packages (

                named_packages:                   List( raw_syntax::Named_Package ), 			# Declarations being typechecked.
		given_symbol_table:               st::Symbol_Table,					# Symbol table containing info from all .o7 files we depend on.

		typechecker_dictionary0:          m::Typechecker_Dictionary,
		syntactic_typechecking_context:   ts::Syntactic_Typechecking_Context,
		module_path_context:              mpc::Context,

		inverse_path:        ip::Inverse_Path,
		source_code_region:  source_map::Source_Code_Region,

		compile_info as { make_stamp,
                                  make_highcode_variable => make_var,
                                  error_fn,
                                  ...
                                }
                                : 	ts::Compile_Info
            ) 
	    :
            ( deep::Declaration,									# Typechecked version of  named_packages.
              st::Symbol_Table,										# Contains (only) stuff from named_packages.
              m::Module_Declaration,
              Typechecker_Dictionary
            )
            =
	    {   depth =  case syntactic_typechecking_context
			     ts::IN_GENERIC { depth, ... } =>  depth;
			     _                            =>  di::top;
			 esac;


                if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_named_packages";


                (   loop ( named_packages,
                           [],			# declarations accumulate here.
                           st::empty,		# Symbol table to fill out.
                           [],			# generics accumulate here.
                           td::empty		# Generics dictionary to fill out.
                         )
		    except
			td::UNBOUND
			    =
			    {   if_debugging_say
				    (   "@@typecheck_named_packages0 "
				    ); 
				raise exception td::UNBOUND;
			    }
                )
		where
		    fun loop ([], declarations, symbol_table', module_declarations, typechecker_dictionary)
			    => 
			    {
				# We've finished processing our input
				# list of named packages (first arg)
                                # so it is time to wrap up and return
                                # our results:

                                if_debugging_say "list exhausted/AAA in   loop() in  typecheck_named_packages   src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg";

				result_declaration
				    = 
                                    deep::PACKAGE_DECLARATIONS (reverse declarations); 

if_debugging_say "list exhausted/BBB in   loop() in  typecheck_named_packages   src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg";
				module_declaration
				    =
				    case module_declarations

					 [] =>  m::EMPTY_GENERIC_EVALUATION_DECLARATION;
					_   =>  module_declaration_sequence (reverse module_declarations);
				    esac;

if_debugging_say "list exhausted/CCC in   loop() in  typecheck_named_packages   src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg";
				( result_declaration,									# Typechecked deep-syntax version of  named_packages.
				  symbol_table',									# Contains (only) stuff from named_packages.
				  module_declaration,
				  typechecker_dictionary
				);
			    };

			# Peel one named package off our input list
			# (first arg), process it, accumulate the
			# results in our remaining args, and loop:
			#
			loop
                            ( named_package ! remaining_named_packages,								# Input list of raw-syntax named packages.
                              declarations,											# Output list of typechecked deep-syntax packages.
                              symbol_table',											# Contains (only) stuff from input named_packages list.
                              module_declarations,
                              typechecker_dictionary
                            )
			    => 
			    {
 if_debugging_say "list NOT exhausted/AAA in loop() in typecheck_named_packages   in src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg";

				# Discard any source code region info nodes,
				# after noting the current source code region:
				#
				my  ( name:                         symbol::Symbol,
				      constraint:		    raw::Package_Cast( raw::Api_Expression ),
				      package_body_to_typecheck:    raw::Package_Expression,
				      kind:               	    raw::Package_Kind,
				      source_code_region'
				    )
				    =
				    case (strip_source_code_region_info_from_named_package (named_package, source_code_region))

					 (raw::NAMED_PACKAGE { name_symbol, constraint, definition, kind }, region)
					     =>
					     (name_symbol, constraint, definition, kind, region);

					_ => bug "non package namings in typecheck_named_packages";
				    esac;


if_debugging_say ("package " + s::name name + "list NOT exhausted/BBB in loop() in typecheck_named_packages   in  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg");


				# Do OOP syntax expansion:
				#
                                package_body_to_typecheck
				    =
				    case kind

                                        raw::PLAIN_PACKAGE
					    =>
					    package_body_to_typecheck;

                                        raw::CLASS_PACKAGE
					    =>
					    expand_oop_syntax_in_package_expression
					      (
						name,
						package_body_to_typecheck,
						symbol_table::atop
						  ( symbol_table',									# Contains (only) stuff from input named_packages list.
						    given_symbol_table									# Symbol table containing info from all .o7 files we depend on.
						  ),
						source_code_region',
						compile_info
					      );

                                        raw::CLASS2_PACKAGE
					    =>
					    expand_oop_syntax_in_package_expression2
					      (
						name,
						package_body_to_typecheck,
						symbol_table::atop
						  ( symbol_table',									# Contains (only) stuff from input named_packages list.
						    given_symbol_table									# Symbol table containing info from all .o7 files we depend on.
						  ),
						source_code_region',
						compile_info
					      );
				    esac;
	

				# Make a typechecked_package stamp
				# for the current package declaration: 
				#
				rstamp =  make_stamp ();									# We don't always have to do this 



if_debugging_say ("package " + s::name name + "list NOT exhausted/CCC in loop() in typecheck_named_packages   in  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg");
				# module_stamp_v  is the context for evaluating
				# the right-hand-side  of a package declaration:
				#
				my  ( module_stamp_v,
				      module_stamp_or_null,
				      constraining_api_or_null,
				      package_cast
				    )
				    = 
				    {   fun typecheck_api  api_expression
					    = 
					    {
if_debugging_say ("calling ta::typecheck_api  in   package " + s::name name + " list NOT exhausted/DDD in typecheck_api loop() in typecheck_named_packages   in  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg");

                                                constraint_api
						    = 
						    ta::typecheck_api {

							api_expression,								# This is what we're typechecking.

							name_or_null           =>  NULL,
							symbol_table           =>  given_symbol_table,							# Symbol table containing info from all .o7 files we depend on.
							typechecker_dictionary =>  typechecker_dictionary0,

							module_path_context,
							source_code_region,
							compile_info
						    };
if_debugging_say ("back from ta::typecheck_api  in   package " + s::name name + " list NOT exhausted/EEE in typecheck_api loop() in typecheck_named_packages   in  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg");


						# If constraining api didn't typecheck,
						# just pretend it didn't exist:
						#
if_debugging_say ("constraining api " + case constraint_api ERRONEOUS_API => "did NOT"; _ => "DID"; esac + " typecheck  in   package " + s::name name + "list NOT exhausted/FFF in typecheck_api loop() in typecheck_named_packages   in  src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg");
						case constraint_api

						     ERRONEOUS_API =>  NULL;  
						     _             =>  THE constraint_api;
						esac;
					    };

if_debugging_say ("Doing 'constraint' case src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: \n");

					my  ( constraining_api_or_null,
					      package_cast
                                            )
					    =
					    case constraint 

						raw::WEAK_PACKAGE_CAST api_expression
						    =>
						    {   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_named_packages[WEAK_PACKAGE_CAST]: calling typecheck_api\n";
							( typecheck_api  api_expression,
							  WEAK_PACKAGE_CAST
							);
                                                    };

						raw::PARTIAL_PACKAGE_CAST api_expression
						    =>
						    {	if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_named_packages[PARTIAL_PACKAGE_CAST]: calling typecheck_api\n";
							case (typecheck_api  api_expression)
							      NULL  => (NULL, WEAK_PACKAGE_CAST);
							      other => (other, PARTIAL_PACKAGE_CAST);
							esac;
                                                    };

						raw::STRONG_PACKAGE_CAST api_expression
						    =>
                                                    {   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_named_packages[STRONG_PACKAGE_CAST]: calling typecheck_api\n";
							case (typecheck_api  api_expression)
							      NULL  => (NULL, WEAK_PACKAGE_CAST);
							      other => (other, STRONG_PACKAGE_CAST);
							esac;
                                                    };

						_   =>
                                                    {   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_named_packages[(NULL api constraint)]: not calling typecheck_api\n";
                                                        (NULL, WEAK_PACKAGE_CAST);
                                                    }; 

					    esac;


			                if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: DONE 'constraint' case\n";

					#  The temporary anonymous package: 
					#
					my  ( module_stamp_v,
					      module_stamp_or_null
					    )
					    = 
					    case constraining_api_or_null

						NULL => (rstamp, NULL);

						_ => {   new_module_stamp = make_stamp();

							 ( new_module_stamp,
							   THE new_module_stamp
							 );
						     };
					    esac;

					(module_stamp_v, module_stamp_or_null, constraining_api_or_null, package_cast);
				    };


if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: typechecking package body.\n";
				# Typecheck the package body:
				#
				my  ( abstract_package_declaration:      deep::Declaration,
				      a_package:                         m::Package,
				      package_expression:                m::Package_Expression,
				      typechecker_dictionary_additions:  td::Typechecker_Dictionary
				    )
				    = 
				    typecheck_package (

					package_body_to_typecheck,
					THE name,
					given_symbol_table,							# Symbol table containing info from all .o7 files we depend on.
					typechecker_dictionary0,
					syntactic_typechecking_context,
					module_path_context,
					THE module_stamp_v,
					ip::extend (inverse_path, name),
					source_code_region',
					compile_info
				    );

if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: DONE typechecking package body.\n";
				# Check for partially applied curried generic 
				#
				a_package
				    =
				    if   (s::eq (name, return_id))

					 # a_package should be generic application wrapper package
					 # with single package component "result_package"
					 #
					 if case a_package

						 ERRONEOUS_PACKAGE => TRUE;

						_ => case (ms::get_package_symbols a_package)

							 [symbol] => s::eq (symbol, result_id);
							 _        => FALSE;
						     esac;

					    esac


					      a_package;
					 else
					      error_fn
						   source_code_region'
						   em::ERROR
						   (   "package "
						   +   s::name (ip::last inverse_path)
						   +   " defined by partially applied generic"
						   )
						   em::null_error_body;

					       ERRONEOUS_PACKAGE;
					 fi;
				    else
					 a_package;
				    fi;

				if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: typecheck_package done";
                                unparse_deep_declaration ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages after body typechecking: unparsing  abstract_package_declaration deep syntax: ",  abstract_package_declaration, symbol_table');
				if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  unconstrained package: ", a_package, symbol_table');

				# If this is a PARTIAL_PACKAGE_CAST,
				# hack the constraining api to reduce
				# it to the STRONG_PACKAGE_CAST case:
				#
if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: calling maybe_extend_api_to_cover_package.\n";
				my  ( constraining_api_or_null,
                                      package_cast,
                                      symbol_table'										# Contains (only) stuff from input named_packages list.
                                    )
				    =
				    maybe_extend_api_to_cover_package (constraining_api_or_null, package_cast, a_package, symbol_table');
if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: DONE calling maybe_extend_api_to_cover_package.\n";

				# Typecheck an api match.
                                # Notice that we did introduce stamps
                                # during the abstraction matching, but
				# that these stamps are always visible,
				# thus will always be caught by the post
                                # api-matching "map_paths" function call:
				#
				my  ( result_declaration,
				      result_package,
				      result_package_expression
                                    )
				    = 
				    case constraining_api_or_null

					 NULL
					     => 
					     {   case package_cast

						     WEAK_PACKAGE_CAST
							 =>
							 ();

						     PARTIAL_PACKAGE_CAST
							 =>
							  (   error_fn
								  source_code_region'
								  em::ERROR
								  "missing api in partial package cast declaration"
								  em::null_error_body
							  );

						     STRONG_PACKAGE_CAST
							 =>
							  (   error_fn
								  source_code_region'
								  em::ERROR
								  "missing api in strong package cast declaration"
								  em::null_error_body
							  );
						 esac;

				                 if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: NOT calling typecheck_constrained_package";

						 ( abstract_package_declaration,
                                                   a_package,
                                                   package_expression
                                                 );
					     };

					 THE constraint_api
					     => 
					     {
				                 if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: calling typecheck_constrained_package";

						 typecheck_constrained_package (

						     a_package,
						     package_cast,
						     constraint_api,
						     abstract_package_declaration,
						     package_expression, 
						     module_stamp_or_null,
						     depth,
						     typechecker_dictionary0,
						     ip::INVERSE_PATH [ name ], 
						     symbol_table::atop
                                                       ( symbol_table',								# Contains (only) stuff from input named_packages list.
                                                         given_symbol_table							# Symbol table containing info from all .o7 files we depend on.
                                                       ),
						     source_code_region,
						     compile_info
						 );
					    };
				   esac;

				if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: now past typecheck_constrained_package call point.";

				typechecker_dictionary_additions
				    = 
				    case (module_stamp_or_null, constraining_api_or_null)

					 (NULL, NULL)
					     =>
					     typechecker_dictionary_additions;

					 (THE module_stamp, THE _)
					     =>
					     case a_package

						  m::A_PACKAGE { typechecked_package, ... }
						      =>
						      td::set (
							  typechecker_dictionary_additions,
							  module_stamp,
							  m::PACKAGE_ENTRY typechecked_package
						      );

						  _
						      =>
						      td::set (
							  typechecker_dictionary_additions,
							  module_stamp,
							  m::PACKAGE_ENTRY m::bogus_typechecked_package
						      );
					      esac;


					_   => bug "unexpected case in typecheck_named_packages: macro_expansion_dictionary_additions";
				esac;

				if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: constrain done";
				if_debugging_show_package ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: result_package: ", result_package, symbol_table');

				# NOTE: bind_package modifies the var_home field of result_package;
				# this may create packages with same ids but different dynamic
				# accesses --- BUT, we assume that before or during the pickling, 
				# both the dynamic access and the inlining_info will be updated 
				# completely and replaced with proper persistent accesses (ZHONG)
				#
				my  ( bound_package,
				      typechecked_package
                                    )
				    = 
				    case result_package

					 A_PACKAGE { typechecked_package, an_api, var_home, inlining_info }
					     =>
					     ( A_PACKAGE { var_home       => a::named_var_home (name, make_var),
							   typechecked_package,
							   an_api,
							   inlining_info
							 },

					       m::PACKAGE_ENTRY  typechecked_package
					     );

					 _   => ( result_package,
                                                  m::PACKAGE_ENTRY  m::bogus_typechecked_package
                                                );
				    esac;

				if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: bound_package: ", bound_package, symbol_table');

				declarations' = pkg_declaration ! declarations
                                where
				    pkg_declaration
                                        =
                                        deep::NAMED_PACKAGE
					  {
					    name_symbol => name,
					    a_package   => bound_package, 
					    definition  => deep::PACKAGE_LET
                                                             { declaration => result_declaration,
							       expression  => deep::PACKAGE_BY_NAME result_package
							     }
					  };
				end;


				my  ( typechecker_dictionary',
				      module_declarations'
                                    )
				    = 
				    case syntactic_typechecking_context

					 ts::IN_GENERIC { flex, ... }
					     => 
					     {   typechecker_dictionary1 = td::atop_sp (typechecker_dictionary_additions, typechecker_dictionary);
						 typechecker_dictionary2 = td::set     (typechecker_dictionary1, rstamp, typechecked_package);
						 typechecker_dictionary3 = td::mark    (make_stamp, typechecker_dictionary2);

						 if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: about to map_paths bound_package";

						 # We are remapping macro_expansion_paths for elements of
						 # the new package unconditionally, even if
						 # there is no api constraint and the
						 # defining package_expression is PACKAGE_DEFINITION (DAVE).

						 map_paths (
						     mpc::enter_open (module_path_context, THE rstamp),
						     bound_package,
						     flex
						 );

						 if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: map_paths bound_package done";

					         case bound_package

						     A_PACKAGE { an_api, typechecked_package, ... }
							 =>
							 mpc::bind_module_path (
							     module_path_context, 
							     ms::package_identifier2 (an_api, typechecked_package),
							     rstamp
							 );

						     _ => ();
						 esac;



						 ( typechecker_dictionary3,
						   m::PACKAGE_DECLARATION (rstamp, result_package_expression, name)  !  module_declarations
						 );
					     };

					_ => ( typechecker_dictionary,
					       module_declarations
					     );

				    esac;

				if_debugging_show_package("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_named_packages: bound_package: ", bound_package, symbol_table');

				symbol_table'' = st::bind (name, ste::NAMED_PACKAGE bound_package, symbol_table');

				loop (remaining_named_packages, declarations', symbol_table'', module_declarations', typechecker_dictionary');
			    };
		    end;		# fun loop
		end;			# where
	    }                           #  function typecheck_named_packages 



	# typecheck_declaration'(): typecheck an arbitrary package-level declaration: 
	#
	# Typechecking ultimately converts a raw syntax tree into
	#
        #  o  A deep syntax tree holding executable content and
        #  o  Symbol table holding declarative content.
	#
        # Those account for our first two return values here.
	#
        # Our other two return values are internal typechecking
        # information discarded at the completion of this
        # typechecking call;  they track information used during
        # processing of generics.
	#
	also
	fun typecheck_declaration' (

	      raw_syntax_declaration:          raw_syntax::Declaration,				# Declaration being typechecked.
	      symbol_table:                    st::Symbol_Table,				# Symbol table containing info from all .o7 files we depend on.

	      typechecker_dictionary0:         m::Typechecker_Dictionary,
	      syntactic_typechecking_context:  ts::Syntactic_Typechecking_Context,
	      top:                             Bool,

	      module_path_context: 		 mpc::Context,
	      inverse_path:                    ip::Inverse_Path,
	      source_code_region:              source_map::Source_Code_Region,

	      compile_info as { make_stamp, make_highcode_variable=>make_var, error_fn, transform, ... } : ts::Compile_Info
            )
	    :
            ( deep::Declaration,								# Typechecked version of  raw_syntax_declaration.
              st::Symbol_Table,									# Contains (only) stuff from raw_syntax_declaration.
              Module_Declaration,
              Typechecker_Dictionary
            )
            =
	    {   if *debugging

		    unparse_raw_declaration
			(
			  "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration': unparsing declaration raw syntax:\n",
			  raw_syntax_declaration,
			  symbol_table
			);

		    prettyprint_raw_declaration
			(
			  "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration': prettyprinting declaration raw syntax:\n",
			  raw_syntax_declaration,
			  symbol_table
			);
		fi;

		case raw_syntax_declaration

		    raw::PACKAGE_DECLARATIONS named_packages
			=>
			typecheck_named_packages (

			    named_packages,
			    symbol_table,
			    typechecker_dictionary0,
			    syntactic_typechecking_context,
			    module_path_context, 
			    inverse_path,
			    source_code_region,
			    compile_info
			);

		    raw::INCLUDE_DECLARATIONS paths
			=>
			{   err =   error_fn  source_code_region;

			    packages
				=
				map (   fn symbol_list
					   =
					   {   symbol_path   =   sp::SYMBOL_PATH symbol_list;

					       (   symbol_path,
						   f::find_package_via_symbol_path (symbol_table, symbol_path, err)
					       );
					   }
				    )
				    paths;

			    loop (packages, st::empty)
			    where
				fun loop ([], symbol_table')
					=>
					(   deep::INCLUDE_DECLARATIONS packages,
					    symbol_table',
					    m::EMPTY_GENERIC_EVALUATION_DECLARATION,
					    td::empty
					);

				    loop ((_, s) ! r, symbol_table')
					=>
					loop (r, ms::include_package (symbol_table', s));
				end;
			   end;
			};

		    raw::GENERIC_DECLARATIONS named_generics
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic_namings";


			    (   loop (named_generics, NIL, st::empty, NIL, td::empty)
				except
				    td::UNBOUND
					=
					{   if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': GENERIC_DECLARATION"); 
					    raise exception td::UNBOUND;
					}
			    )
			    where
				fun loop ([], declarations, symbol_table', module_declarations, typechecker_dictionary')
					=> 
					{   result_declaration   =   deep::GENERIC_DECLARATIONS (reverse declarations);

					    module_declaration
						  =
						  case module_declarations

						       [] => m::EMPTY_GENERIC_EVALUATION_DECLARATION;

						      _  => module_declaration_sequence (reverse module_declarations);
						  esac;

					    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic_namings";

					    (result_declaration, symbol_table', module_declaration, typechecker_dictionary');
					};

				    loop (generic_naming ! rest, declarations, symbol_table', module_declarations, typechecker_dictionary')
					=> 
					{   my  ( name,
						  definition,
						  source_code_region'
						)
						=
						case (strip_source_code_region_info_from_generic_naming (

							 generic_naming,
							 source_code_region
						     ))

						    (raw::NAMED_GENERIC { name_symbol, definition }, region)
							=>
							(name_symbol, definition, region);

						    _ => bug "non generic namings for GENERIC_DECLARATION generic_namings";
						esac;

					    if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_declaration': generic " + s::name name);

					    #  Dynamic var_home is assigned in typecheck_generic: 

					    my  ( generic_abstract_declaration,
						  generic_expression,
						  a_generic,
						  typechecker_dictionary_additions
						)
						= 
						typecheck_generic(

						    definition,
						    FALSE,                       #  Not curried. 
						    name,
						    symbol_table,
						    typechecker_dictionary0,
						    syntactic_typechecking_context,
						    module_path_context,
						    inverse_path,
						    source_code_region',
						    compile_info
						);

					    # WARNING: bind_generic modifies the var_home field of a_generic; 
					    # this may create generics with same ids but 
					    # different dynamic accesses --- BUT, we assume that 
					    # before or during the pickling, both the dynamic 
					    # var_home and the inlining_info will be updated completely 
					    # and replaced with proper persistent accesses (ZHONG)
					    #
					    my  ( bind_generic,
						  typechecked_generic
						)
						= 
						case a_generic

						    GENERIC { typechecked_generic, a_generic_api, var_home, inlining_info }
						     =>
						     ( GENERIC {
							 var_home       => a::named_var_home (name, make_var),
							 typechecked_generic,
							 a_generic_api,
							 inlining_info
						       },

						       GENERIC_ENTRY  typechecked_generic
						     );

						    ERRONEOUS_GENERIC => (a_generic, ERRONEOUS_ENTRY);
						esac;

					    fb = deep::NAMED_GENERIC { name_symbol => name,
								       a_generic   => bind_generic, 
								       definition  => deep::GENERIC_LET (
											    generic_abstract_declaration,
											    deep::GENERIC_BY_NAME a_generic
										      )
								       };

					    declarations' = fb ! declarations;

					    my  ( typechecker_dictionary'',
						  module_declarations'
						)
						= 
						case syntactic_typechecking_context

						    ts::IN_GENERIC _
							=> 
							{   module_stamp = make_stamp ();

							    case bind_generic

								GENERIC _
								    =>
								    mpc::bind_generic_path (

									module_path_context, 
									ms::generic_identifier bind_generic,
									module_stamp
								    );

								ERRONEOUS_GENERIC => ();
							    esac;

							    typechecker_dictionary1
								=
								td::atop_sp (
								    typechecker_dictionary_additions,
								    typechecker_dictionary'
								);

							    typechecker_dictionary2
								=
								td::set (
								    typechecker_dictionary1,
								    module_stamp,
								    typechecked_generic
								);

							    typechecker_dictionary3
								=
								td::mark (
								    make_stamp,
								    typechecker_dictionary2
								);

							    (   typechecker_dictionary3,

								m::GENERIC_DECLARATION (
								    module_stamp,
								    generic_expression
								)
								!
								module_declarations
							    );
							};


						    _ => (typechecker_dictionary', module_declarations);

						esac;

					    symbol_table'' = st::bind (
								name,
								ste::NAMED_GENERIC bind_generic,
								symbol_table'
							    );


					    loop (rest, declarations', symbol_table'', module_declarations', typechecker_dictionary'');
					};
				end;			# fun loop
			    end;				# where
			};

		    raw::API_DECLARATIONS named_apis
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_api_bs";

			    (   loop (named_apis, NIL, st::empty)
				except
				    td::UNBOUND
					=
					{   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': API_DECLARATION"); 
					    raise exception td::UNBOUND;
					}
			    )
			    where
				fun loop ([], apis, symbol_table')
					=> 
					{
					    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_api_bs";

					    (   deep::API_DECLARATIONS (reverse apis),
						symbol_table',
						m::EMPTY_GENERIC_EVALUATION_DECLARATION,
						td::empty
					    );
					};

				   loop (api_naming ! rest, apis, symbol_table')
				       =>
				       {   my  ( name,
						 definition,
						 source_code_region'
					       )
					       =
					       case (strip_source_code_region_info_from_api_naming (api_naming, source_code_region))

						   (raw::NAMED_API { name_symbol, definition }, region)
						       =>
						       (name_symbol, definition, region);

						    _   => bug "non api namings for API_DECLARATION named_apis";
					       esac;

					   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_declaration': api " + s::name name);

					   an_api
                                               =
                                               ta::typecheck_api
                                                 {
						   api_expression =>  definition,
						   name_or_null   =>  THE name,
						   symbol_table, 

						   typechecker_dictionary =>  typechecker_dictionary0,
						   source_code_region     =>  source_code_region',

						   module_path_context,
						   compile_info
					         };

					   # Process to check well-formedness:
					   #
					   if   (*typechecking_control::macro_expand_sigs)

						ins::do_generic_parameter_api
                                                  {
						    an_api,
						    typechecker_dictionary => td::empty,

						    depth                  => di::top,
						    inverse_path           => inverse_path::empty,
						    source_code_region     => source_code_region',
						    compile_info
						  };

						();
					   fi;

					   if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_declaration'[API_DECLARATIONS]: binding NAMED_API " + (s::name name)); 

					   loop (

					       rest,
					       an_api ! apis,
					       st::bind (name, ste::NAMED_API an_api, symbol_table')
					   );
				       };
				end;			# fun loop
			    end;			# where
			};

		    raw::GENERIC_API_DECLARATIONS generic_api_namings
			=>
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic_named_apis";


			    (   loop (generic_api_namings, NIL, st::empty)
				except
				    td::UNBOUND
					=
					{   if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': GENERIC_API_DECLARATIONS"); 
					    raise exception td::UNBOUND;
					}
			    )
			    where
				fun loop ([], generic_apis, symbol_table')
					=> 
					{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_generic_named_apis";

					    (    deep::GENERIC_API_DECLARATIONS (reverse generic_apis),
						 symbol_table',
						 m::EMPTY_GENERIC_EVALUATION_DECLARATION,
						 td::empty
					    );
					};

				    loop (generic_api_naming ! rest, generic_apis, symbol_table')
					=>
					{   my (name,
						definition,
						source_code_region')
						=
						case (strip_source_code_region_info_from_generic_api_naming
						    ( generic_api_naming,
						      source_code_region
						    ))

						     (raw::NAMED_GENERIC_API { name_symbol=>n, definition=>d }, r)
							 =>
							 (n, d, r);

						     _
							 =>
							 bug "non Generic_Api namings for GENERIC_API_DECLARATIONS generic_named_apis";
						esac;

					    if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  --typecheck_declaration': generic_api " + s::name name);

					    s = ta::typecheck_generic_api {

						    generic_api_expression => definition,

						    name_or_null            => THE name,
						    symbol_table,
						    typechecker_dictionary  => typechecker_dictionary0,

						    module_path_context, 
						    source_code_region      => source_code_region',
						    compile_info
						};

					    loop (
						rest,
						s ! generic_apis,
						st::bind (name, ste::NAMED_GENERIC_API s, symbol_table')
					    );
					};
				end;		# fun loop
			    end;			# where
			};

		    raw::LOCAL_DECLARATIONS (declaration_in, declaration_out)
			=>
			{   top_in
				=
				ts::has_modules declaration_in    or
				ts::has_modules declaration_out;

				# If declaration_in contains a generic declaration (at
				# any nesting depth) we must suppress ungeneralized
				# type variables to avoid bug 905/952.
				#
				# Using TS::has_modules is a cheap conservative approximation
				# to checking for the presence of generic declarations,
				# although it excludes some legal SML 96 programs where
				# packages but not generics are present.


			    my  ( deep_syntax_tree_in,
				  env_in,
				  entdeclaration_in,
				  input_typechecker_dictionary
				)
				=
				typecheck_declaration' (
				    declaration_in,
				    symbol_table,
				    typechecker_dictionary0,
				    syntactic_typechecking_context,
				    top_in,
				    module_path_context,
				    inverse_path,
				    source_code_region,
				    compile_info
				);



			    # ** DAVE? what is the right module_path_context to pass here? XXX BUGGO FIXME **

			    symbol_table' = st::atop (env_in, symbol_table);

			    typechecker_dictionary'
				=
				td::mark (
				    make_stamp,
				    td::atop (input_typechecker_dictionary, typechecker_dictionary0)
				);

			    my  ( deep_syntax_tree_out,
				  env_out,
				  entdeclaration_out,
				  output_typechecker_dictionary
				)
				= 
				typecheck_declaration' (
				    declaration_out,
				    symbol_table',
				    typechecker_dictionary',
				    syntactic_typechecking_context,
				    top,
				    module_path_context,
				    inverse_path,
				    source_code_region,
				    compile_info
				);

			    result_deep_syntax_tree
				=
				deep::LOCAL_DECLARATIONS (deep_syntax_tree_in, deep_syntax_tree_out);

			    my  ( module_declaration,
				  result_typechecker_dictionary
				)
				= 
				case syntactic_typechecking_context 

				    ts::IN_GENERIC _
					=> 
					( local_module_declaration (entdeclaration_in, entdeclaration_out),

					  td::mark (
					    make_stamp,
					    td::atop (output_typechecker_dictionary, input_typechecker_dictionary)
					  )
					);

				   _ => (m::EMPTY_GENERIC_EVALUATION_DECLARATION, td::empty);

				esac;

			    ( result_deep_syntax_tree,
			      env_out,
			      module_declaration,
			      result_typechecker_dictionary
			    );
			};

		    raw::SEQUENTIAL_DECLARATIONS declarations
			=> 
			{   if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_seq_declaration";

			    (   loop (declarations, NIL, st::empty, NIL, td::empty)
				except
				    td::UNBOUND
					=
					{   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': SEQUENTIAL_DECLARATIONS"); 
					    raise exception td::UNBOUND;
					}
			    )
			    where
				fun loop ([], asdeclarations, symbol_table', entdeclarations, typechecker_dictionary')
					=> 
					{   result_deep_syntax_tree
                                                =
                                                deep::SEQUENTIAL_DECLARATIONS (reverse asdeclarations);

					    my  ( module_declaration',
						  typechecker_dictionary''
						)
						= 
						case syntactic_typechecking_context

						    ts::IN_GENERIC _
							=> 
							(   module_declaration_sequence (reverse entdeclarations),
							    typechecker_dictionary'
							);

						    _ => (m::EMPTY_GENERIC_EVALUATION_DECLARATION, td::empty);
						esac;

					    debug_print ("typecheck_seq_declaration - symbols: ", bug::prettyprint_symbol_list, bug::symbol_table_symbols symbol_table');

					    if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_seq_declaration";

					    (result_deep_syntax_tree, symbol_table', module_declaration', typechecker_dictionary'');
					};

				    loop (declaration ! rest, asdeclarations, symbol_table', module_declarations, typechecker_dictionary')
					=> 
					{   symbol_table1   =   st::atop (symbol_table', symbol_table);

					    typechecker_dictionary1
						=
						td::mark (
						    make_stamp,
						    td::atop (typechecker_dictionary', typechecker_dictionary0)
						);

					    my  ( deep_syntax_declaration,
						  symbol_table'',
						  module_declaration,
						  typechecker_dictionary''
						)
						= 
						typecheck_declaration' (
						    declaration,
						    symbol_table1,
						    typechecker_dictionary1,
						    syntactic_typechecking_context,
						    top,
						    module_path_context,
						    inverse_path,
						    source_code_region,
						    compile_info
						);

					    loop (
						rest,
						deep_syntax_declaration ! asdeclarations,
						st::atop (symbol_table'', symbol_table'),
						module_declaration ! module_declarations,
						td::mark (
						    make_stamp,
						    td::atop (typechecker_dictionary'', typechecker_dictionary')
						)
					    );
					};
				end;		# fun loop
			    end;			# where

			};

		    raw::TYPE_DECLARATIONS named_types      # ** ASSERT: the tycons declared are all DEFtycs **
			=>
			(   {   my  ( declaration,
				      symbol_table'
				    )
				    =
				    tt::typecheck_type_declaration (
					named_types,
					symbol_table,
					inverse_path,
					source_code_region,
					compile_info
				    );

				tycs = case declaration

					   deep::TYPE_DECLARATIONS  z
					       =>
					       z;

					   _   =>   bug "typecheck_declaration' for TYPE_DECLARATIONS";
				       esac;

				my  ( typechecker_dictionary',
				      module_declaration
				    )
				    = 
				    bind_new_tycs (
					syntactic_typechecking_context,
					module_path_context,
					make_stamp,
					[],
					tycs,
					inverse_path,
					error_fn  source_code_region
				    );

				( declaration,
				  symbol_table',
				  module_declaration,
				  typechecker_dictionary'
				);
			    }
			    except
				td::UNBOUND
				    =
				    {   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': TYPE_DECLARATIONS");
					raise exception td::UNBOUND;
				    }
			);

		    raw::ENUM_DECLARATIONS (x as { datatype_constructors, with_type_constructors } )
			=>
			case datatype_constructors

			    (raw::NAMED_ENUM { right_hand_side => (raw::ENUM_CONSTRUCTORS _), ... } ) ! _
				 =>
				 {   is_free
					 = 
					 case syntactic_typechecking_context 

					      ts::IN_GENERIC _
						  =>
						  (fn type_constructor
						      =
						      case (mpc::find_module_path_for_type_constructor (
							       module_path_context,
							       ms::type_identifier type_constructor
							   ))

							   THE _ => TRUE; 
							   _     => FALSE;
						      esac

						  );

					     _ => (fn _ = FALSE);
					 esac;


				     my  ( datatype_constructors,
					   with_type_constructors,
					   _,
					   symbol_table'
					 )
					 =
					 tt::typecheck_datatype_declaration (
					     x,
					     symbol_table,
					     [],
					     td::empty,
					     is_free,
					     inverse_path,
					     source_code_region,
					     compile_info
					 );

				     my  ( typechecker_dictionary',
					   module_declaration
					 )
					 = 
					 bind_new_tycs (
					     syntactic_typechecking_context,
					     module_path_context,
					     make_stamp,
					     datatype_constructors,
					     with_type_constructors,
					     inverse_path,
					     error_fn  source_code_region
					 );

				     result_declaration
					 = 
					 deep::ENUM_DECLARATIONS  {  datatype_constructors,  with_type_constructors  };

				     ( result_declaration,
				       symbol_table',
				       module_declaration,
				       typechecker_dictionary'
				     );
				 };

			    (raw::NAMED_ENUM { type_constructor => name,
					       right_hand_side  => raw::REPLICAS symbols,
					       type_variables   => NIL,
					       is_lazy          => FALSE
					     }
					     !
					     NIL
			     )
				=>
				{   fun no_datatype ()
					=
					{   error_fn
						source_code_region
						em::ERROR
						"rhs of enum replication not a enum"
						em::null_error_body;

					    (   deep::SEQUENTIAL_DECLARATIONS [],
						st::empty,
						m::ERRONEOUS_ENTRY_DECLARATION,
						td::empty
					    );
					};

				    case with_type_constructors

					 _ ! _
					     => 
					     {   error_fn
						     source_code_region
						     em::ERROR
						     "withtype not allowed in enum replication"
						     em::null_error_body;

						 (   deep::SEQUENTIAL_DECLARATIONS [],
						     st::empty,
						     m::ERRONEOUS_ENTRY_DECLARATION,
						     td::empty
						 );
					     };

				        []  =>
					   {   type_constructor
						   =
						   l::find_type_constructor_via_symbol_path (
						       symbol_table,
						       sp::SYMBOL_PATH symbols,
						       error_fn  source_code_region
						   );

					       case type_constructor

						    t::PRIMITIVE_TYPE_CONSTRUCTOR { kind => t::DATATYPE _, ... }
							=>
							{   dcons   =   tu::extract_datatype_constructor type_constructor;

							    env_dcons
								=
								fold_left (fn (d as t::ENUM_CONSTRUCTOR { symbol, ... }, e)
									     =
									     st::bind (
										 symbol,
										 ste::NAMED_CONSTRUCTOR d,
										 e
									     )
								      )
								      st::empty dcons;

							    symbol_table'
								=
								st::bind (
								    name,
								    ste::NAMED_TYPE type_constructor, 
								    env_dcons
								);

							    module_stamp = make_stamp();

							    tyc_id
								=
								ms::type_identifier  type_constructor;

							    my  ( ee_dec,
								  ee_env
								)
								=
								case syntactic_typechecking_context

								     ts::IN_GENERIC _
									 =>
									 {   texp
										 =
										 case (mpc::find_module_path_for_type_constructor (module_path_context, tyc_id))

										      NULL              =>   m::CONSTANT_TYPE_CONSTRUCTOR type_constructor;
										     THE module_path   =>   m::TYPE_VARIABLE_TYPE_CONSTRUCTOR module_path; esac;

									     (    m::TYPE_CONSTRUCTOR_DECLARATION (module_stamp, texp),
										  td::set (
										      td::empty,
										      module_stamp,
										      m::TYPE_CONSTRUCTOR_ENTRY type_constructor
										  )
									     );
									 };

								    _ => (m::EMPTY_GENERIC_EVALUATION_DECLARATION, td::empty);
								esac;

							    result_declaration
								=
								deep::ENUM_DECLARATIONS {
								    datatype_constructors => [ type_constructor ],
								    with_type_constructors => [ ]
								};

							    mpc::bind_type_constructor_path (module_path_context, tyc_id, module_stamp);

							    (result_declaration, symbol_table', ee_dec, ee_env);
							};

						  _ => no_datatype ();
					       esac;
					   };
				    esac;
				};

			    _ => {   error_fn
					  source_code_region
					  em::ERROR
					  "argument type variables in enum replication"
					  em::null_error_body;

				      (   deep::SEQUENTIAL_DECLARATIONS [],
					  st::empty,
					  m::ERRONEOUS_ENTRY_DECLARATION,
					  td::empty
				      );
				  };
			esac;


		    raw::ABSTRACT_TYPE_DECLARATIONS x
			=>
			(   {   is_free
				    = 
				    case syntactic_typechecking_context 

					 ts::IN_GENERIC _
					     =>
					     (   fn type_constructor
						    =
						    case (mpc::find_module_path_for_type_constructor (
							     module_path_context,
							     ms::type_identifier type_constructor
							 ))

							 THE _ =>  TRUE; 
							 _     =>  FALSE;
						    esac

					     );

					_ => (fn _ =  FALSE);
				    esac;


				my  ( declaration,
				      symbol_table'',
				      abstract_type_constructors,
				      with_type_constructors
				    )
				    =
				    case (tcl::typecheck_abstract_type_declaration (
					     x,
					     symbol_table,
					     syntactic_typechecking_context,
					     is_free, 
					     inverse_path,
					     source_code_region,
					     compile_info
					 ))

					(d as deep::ABSTRACT_TYPE_DECLARATION x,   e)
					    =>
					    (   d,
						e,
						x.abstract_type_constructors,
						x.with_type_constructors
					    );

					_ => bug "typecheck_declaration': ABSTRACT_TYPE_DECLARATIONS";
				    esac;

				# Potential bug: what about other enum declarations within
				# the body of ABSTRACT_TYPE_DECLARATION ? they are local declarations; but
				# they may not be properly dealt with now ! (ZHONG)  XXX BUGGO FIXME


				#  Note that transform is applied to declaration before type checking: 
				#	
				declaration'
				    =
				    unify_and_generalize_types::unify_and_generalize_types {

					symbol_table     => st::atop (symbol_table'', symbol_table),
					declaration      => transform declaration,

					outside_all_lets => top,
					error_function   => error_fn,
					source_code_region
				    };

				my  ( typechecker_dictionary',
				      module_declaration
				    )
				    = 
				    bind_new_tycs (
					syntactic_typechecking_context,
					module_path_context,
					make_stamp,
					abstract_type_constructors,
					with_type_constructors,
					inverse_path,
					error_fn  source_code_region
				    );

				(   declaration',
				    symbol_table'',
				    module_declaration,
				    typechecker_dictionary'
				);
			    }
			    except
				td::UNBOUND
				=
				{   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': ABSTRACT_TYPE_DECLARATIONS");
				    raise exception td::UNBOUND;
				}
			);

		    raw::SOURCE_CODE_REGION_FOR_DECLARATION (declaration', source_code_region')
			=>
			typecheck_declaration' (
			    declaration',
			    symbol_table,
			    typechecker_dictionary0,
			    syntactic_typechecking_context,
			    top,
			    module_path_context,
			    inverse_path,
			    source_code_region',
			    compile_info
			);

		    declaration
			=>
			(   {   is_free
				    = 
				    case syntactic_typechecking_context 

					ts::IN_GENERIC _
					    =>
					    (   fn type_constructor
						   =
						   case (mpc::find_module_path_for_type_constructor (
							    module_path_context,
							    ms::type_identifier type_constructor
							))

							THE _ => TRUE; 
						       _      => FALSE;
						   esac

					    );

					_ => (fn _ = FALSE);
				    esac;


				my  ( declaration,
				      symbol_table''
				    )
				    =
				    tcl::typecheck_declaration (
					declaration,
					symbol_table,
					is_free, 
					inverse_path,
					source_code_region,
					compile_info
				    )
				    except
					td::UNBOUND
					    =
					    {   if_debugging_say ("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@tcl::typecheck_declaration");
						raise exception td::UNBOUND;
					    };

				if_debugging_say
				    (   "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration'/declaration [after tcl::typecheck_declaration: top=" 
				    +   (bool::to_string top)
				    );

				declaration'   =   transform declaration;

				if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration'/declaration [after transform]";

				declaration''
				    =
				    unify_and_generalize_types::unify_and_generalize_types {

					symbol_table     => st::atop (symbol_table'', symbol_table),
					declaration      => declaration',
					outside_all_lets => top,
					error_function   => error_fn,
					source_code_region
				    }
				    except
					td::UNBOUND
					    =
					    {   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@unify_and_generalize_types");
						raise exception td::UNBOUND;
					    };

				if_debugging_say "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration'/declaration [after unify_and_generalize_types]";

			       ( declaration'',						# Typechecked version of  raw_syntax_declaration.
				 symbol_table'',						# Contains (only) stuff from raw_syntax_declaration.
				 m::EMPTY_GENERIC_EVALUATION_DECLARATION,
				 td::empty
			       );
			   }
			   except
			       td::UNBOUND
				   =
				   {   if_debugging_say("src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  @@typecheck_declaration': Core_Declaration");
				       raise exception td::UNBOUND;
				   }
			);
		esac;
	    };				# fun typecheck_declaration'



            #  The top-level wrapper of the typecheck_declaration' function: 
	    #
	    fun typecheck_declaration {
		    raw_syntax_declaration,				# Declaration being typechecked.
		    symbol_table,
		    typechecker_dictionary,
		    syntactic_typechecking_context,
		    level,
		    module_path_context,
		    path,
		    source_code_region,
		    compile_info
		}
		=
		{
		    if *debugging

			unparse_raw_declaration
			    (
			      "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration: unparsing declaration raw syntax:\n",
			      raw_syntax_declaration,
			      symbol_table
			    );

			prettyprint_raw_declaration
			    (
			      "src/lib/compiler/front/typechecker/typecheck/typecheck-package-language-g.pkg:  typecheck_declaration: prettyprinting declaration raw syntax:\n",
			      raw_syntax_declaration,
			      symbol_table
			    );
		    fi;

                    my  ( deep_syntax_declaration,					# Typechecked version of  raw_syntax_declaration.
                          symbol_table,							# Contains (only) stuff from raw_syntax_declaration.
                          _,
                          _
                        )
			= 
			typecheck_declaration' (
			    raw_syntax_declaration,					# Declaration being typechecked.
			    symbol_table,						# Symbol table containing info from all .o7 files we depend on.
			    typechecker_dictionary,
			    syntactic_typechecking_context,
			    level, 
			    module_path_context,
			    path,
			    source_code_region,
			    compile_info
			);

		    { deep_syntax_declaration,						# Typechecked version of  raw_syntax_declaration.
		      symbol_table							# Contains (only) stuff from raw_syntax_declaration.
		    };
		};
    end;				#  stipulate
};					#  generic package typecheck_package_language_g 










##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 1996 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
