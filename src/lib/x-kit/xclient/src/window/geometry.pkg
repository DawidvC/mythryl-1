## geometry.pkg
#
# The basic geometric types and operations.
#
# This is the library-internal version of this package;
# for the client-visible version see:
#
#     src/lib/x-kit/xclient/xgeometry.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6



					# Xgeometry		is from   src/lib/x-kit/xclient/xgeometry.api
stipulate
    package rc = range_check;		# range_check		is from   src/lib/x-kit/xclient/src/stuff/range-check.pkg
herein

    package geometry {

	stipulate

	    fun min (col: Int, row) =   col < row  ??  col  ::  row;
	    fun max (col: Int, row) =   col > row  ??  col  ::  row;

	herein

	    # Geometric types (from Xlib::h)
	    #
	    Point =
		POINT
		  { col:  Int,
		    row:  Int
		  };

	    Line =  LINE (Point, Point);

	    Size =
		SIZE
		  { wide:  Int,
		    high:  Int
		  };

	    Box =
		BOX
		  { col:  Int,
		    row:  Int,

		    wide:  Int,
		    high:  Int
		  };

	    Arc =
		ARC
		  { col:     Int,
		    row:     Int,

		    wide:    Int,
		    high:    Int,

		    angle1:  Int,
		    angle2:  Int
		  };

	    # The size and position of a window
	    # with respect to its parent:
	    #
	    Window_Site
		=
		WINDOW_SITE
		  { upperleft:     Point,
		    size:          Size,
		    border_width:  Int
		  };

	    # Points:
	    #
	    point_00
		=
		POINT { col => 0,
                        row => 0
                      };

	    fun col_coord_of_pt (POINT { col, ... } ) =  col;
	    fun row_coord_of_pt (POINT { row, ... } ) =  row;

	    fun add_pt (POINT { col=>col1, row=>row1 }, POINT { col=>col2, row=>row2 } ) =  POINT { col=>(col1+col2), row=>(row1+row2) };
	    fun sub_pt (POINT { col=>col1, row=>row1 }, POINT { col=>col2, row=>row2 } ) =  POINT { col=>(col1-col2), row=>(row1-row2) };

	    fun scale_pt (s, POINT { col, row } ) = POINT { col=>s*col, row=>s*row };

	    fun less_than_pt (POINT { col=>col1, row=>row1 }, POINT { col=>col2, row=>row2 } ) =  (col1 <  col2) and (row1 <  row2);
	    fun less_eq_pt   (POINT { col=>col1, row=>row1 }, POINT { col=>col2, row=>row2 } ) =  (col1 <= col2) and (row1 <= row2);

	    # Size operations:
	    #
	    fun add_size (SIZE { wide=>w1, high=>h1 }, SIZE { wide=>w2, high=>h2 } ) =  SIZE { wide=>(w1+w2), high=>(h1+h2) };
	    fun sub_size (SIZE { wide=>w1, high=>h1 }, SIZE { wide=>w2, high=>h2 } ) =  SIZE { wide=>(w1-w2), high=>(h1-h2) };
	    #
	    fun scale_size (s, SIZE { wide, high } ) = SIZE { wide=>s*wide, high=>s*high };
	    fun add_size_to_pt (POINT { col, row }, SIZE { wide, high } ) = POINT { col=>col+wide, row=>row+high };
	    #
	    fun limit_pt (SIZE { wide, high }, POINT { col, row } )
		=
		POINT {
		      col =>  if (col <= 0)  0; elif (col < wide)  col; else (wide - 1); fi,
		      row =>  if (row <= 0)  0; elif (row < high)  row; else (high - 1); fi
		    };

	    # Boxes:
	    #
	    fun make_box (POINT { col, row }, SIZE { wide, high } )
		=
		BOX { col, row, wide, high };


	    fun upperleft_of_box (BOX { col, row, ... } )
		=
		POINT { col, row };


	    fun size_of_box (BOX { wide, high, ... } )
		=
		SIZE { wide, high };


	    fun upperleft_and_size_of_box (BOX { col, row, wide, high } )
		=
		(POINT { col, row }, SIZE { wide, high } );


	    fun lowerright_of_box r
		=
		add_size_to_pt (upperleft_and_size_of_box r);


	    fun clip_point (BOX { col=>min_col, row=>min_row, wide, high }, POINT { col, row } )
		=
		POINT {
		    col => if (col <= min_col)  min_col; elif (col < min_col+wide)  col; else (min_col+wide - 1); fi,
		    row => if (row <= min_row)  min_row; elif (row < min_row+high)  row; else (min_row+high - 1); fi
		  };

	    fun  translate (BOX { col, row, wide, high }, POINT { col=>px, row=>py } ) =  BOX { col=>col+px, row=>row+py, wide, high };
	    fun rtranslate (BOX { col, row, wide, high }, POINT { col=>px, row=>py } ) =  BOX { col=>col-px, row=>row-py, wide, high };

	    fun intersect
		    (BOX { col=>col1, row=>row1, wide=>w1, high=>h1 },
		     BOX { col=>col2, row=>row2, wide=>w2, high=>h2 }
		    )
		=
		(   (col1 < (col2+w2)) and (row1 < (row2+h2))
		and (col2 < (col1+w1)) and (row2 < (row1+h1)));

	    exception INTERSECTION;

	    fun intersection
		    ( BOX { col=>col1, row=>row1, wide=>w1, high=>h1 },
		      BOX { col=>col2, row=>row2, wide=>w2, high=>h2 } )
		=
		{   col = max (col1, col2);
		    row = max (row1, row2);

		    cx = min (col1+w1, col2+w2);
		    cy = min (row1+h1, row2+h2);

		    if (col < cx  and  row < cy)
			 BOX { col, row, wide=>(cx-col), high=>(cy-row) };
		    else
			 raise exception INTERSECTION;
		    fi;
		  };

	    fun union (
		  r1 as BOX { col=>col1, row=>row1, wide=>w1, high=>h1 },
		  r2 as BOX { col=>col2, row=>row2, wide=>w2, high=>h2 }
		)
		=
		if   (w1 == 0  or  h1 == 0)    r2;
		elif (w2 == 0  or  h2 == 0)    r1;
		else

		    col = min (col1, col2);
		    row = min (row1, row2);

		    cx = max (col1+w1, col2+w2);
		    cy = max (row1+h1, row2+h2);

		    BOX { col, row, wide=>(cx-col), high=>(cy-row) };
		fi;


	    fun within (POINT { col=>px, row=>py }, BOX { col, row, wide, high } )
		=
		px >=  col    and
		py >=  row    and
		px < col+wide and
		py < row+high;

	    fun inside
		( BOX { col=>col1, row=>row1, wide=>w1, high=>h1 },
		  BOX { col=>col2, row=>row2, wide=>w2, high=>h2 }
		)
		=
		col1 >= col2        and
		row1 >= row2        and
		col1+w1 <= col2+w2  and
		row1+h1 <= row2+h2;

	    fun bounding_box []
		    =>
		    BOX { col=>0, row=>0, wide=>0, high=>0 };

		bounding_box ((POINT { col, row } ) ! pts)
		    =>
		    bb (col, row, col, row, pts)
		    where
			fun bb (minx, miny, maxx, maxy, [])
				=> 
				BOX { col => minx, row => miny, wide => maxx-minx+1, high => maxy-miny+1 };

			    bb (minx, miny, maxx, maxy, (POINT { col, row } ) ! pts)
				=> 
			       bb (min (minx, col), min (miny, row), max (maxx, col), max (maxy, row), pts);
			end;
		    end;
	    end;

	    fun site_to_box (WINDOW_SITE { upperleft => POINT { col, row }, size => SIZE { wide, high }, ... })
		=
		BOX { col, row, wide, high };


	    # Validation routines:
	    #
	    fun valid_point(POINT { col, row } )  =   rc::valid_signed16 col    and   rc::valid_signed16 row;
	    fun valid_line (LINE (p1, p2))        =       valid_point    p1     and       valid_point    p2;
	    fun valid_size (SIZE { wide, high } ) =   rc::valid16        wide   and   rc::valid16        high;

	    fun valid_box (BOX { col, row, wide, high } )
		=
		rc::valid_signed16 col      and
		rc::valid_signed16 row      and 
		rc::valid16 wide            and
		rc::valid16 high;

	    fun valid_arc (ARC { col, row, wide, high, angle1, angle2 } )
		=
		rc::valid_signed16  col     and
		rc::valid_signed16  row     and 
		rc::valid16  wide           and
		rc::valid16  high           and 
		rc::valid_signed16  angle1  and
		rc::valid_signed16  angle2;

	    fun valid_site (WINDOW_SITE { upperleft, size, border_width } )
		= 
		valid_point  upperleft      and
		valid_size   size           and
		rc::valid16  border_width;

	end;		# stipulate
    };			# package geometry 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
