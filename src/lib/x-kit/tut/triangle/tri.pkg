## tri.pkg

# Compiled by:
#     src/lib/x-kit/tut/triangle/tri.make6

stipulate
    include threadkit;				# threadkit	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package xc  =  xcore;			# xdraw		is from   src/lib/x-kit/xclient/xcore.pkg
    package xd  =  xdraw;			# xdraw		is from   src/lib/x-kit/xclient/xdraw.pkg
    package xf  =  xfont;			# xfont		is from   src/lib/x-kit/xclient/xfont.pkg
    package xg  =  xgeometry;			# xgeometry	is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;			# xinput	is from   src/lib/x-kit/xclient/xinput.pkg
    package xs  =  xselection;			# xselection	is from   src/lib/x-kit/xclient/xselection.pkg
    package xw  =  xwindow;			# xwindow	is from   src/lib/x-kit/xclient/xwindow.pkg
    #
    package che =  cartouche;			# cartouche	is from   src/lib/x-kit/draw/cartouche.pkg
    #
    package ib  =  icon_bitmap;			# icon_bitmap	is from   src/lib/x-kit/tut/triangle/icon-bitmap.pkg
herein

    package tri: Tri {				# Tri		is from   src/lib/x-kit/tut/triangle/tri.api

	min_wide =  300;
	min_high =  300;

	min_sz   =  xg::SIZE { wide => min_wide, high => min_high };

	button_wide = 100;
	button_high =  30;

	button_corner_radius = 8;

	fun button_win_geom (wide, high)
	    =
	    xg::WINDOW_FOOTPRINT
	      {
		upperleft    =>  xg::POINT { col => (wide -  button_wide)/2,
				             row => (high - (button_high+10))
				           },
		size         =>  xg::SIZE  { wide=>button_wide, high=>button_high },
		border_width =>  0
	      };

	fun draw_win_geom (wide, high)
	    =
	    xg::WINDOW_FOOTPRINT
	      {
		border_width => 1,
		upperleft    =>  xg::POINT { col => 5, row => 5 },
		#
		size         =>  xg::SIZE { wide => wide - 10,
				            high => high - (button_high+25)
				          }
	      };

	fun init  display_name
	    =
	    (screen, window, in_dictionary)
	    where
# XXX BUGGO FIXME need xauthentication here:
		xsession =  xc::open_xsession (display_name, NULL);

		screen   =  xc::default_screen_of  xsession;

		win_sz   =  xg::SIZE { wide => 450, high => 400 };

		my (window, in_dictionary, mailslot)			# 2009-12-10 CrT: Had to add 'mailslot' so it would compile.
		    =
		    xw::make_simple_top_window  screen
		      {
			geometry   =>  xg::WINDOW_FOOTPRINT { upperleft => xg::POINT { col=>0, row=>0 }, size=>win_sz, border_width=>1 },
			border     =>  xc::black_of_screen  screen,
			background =>  xc::white_of_screen  screen
		      };

		icon_ro_pixmap
		    =
		    xc::make_ro_pixmap_from_cs_pixmap
			screen
			icon_bitmap::icon_bitmap;

		xw::set_window_manager_properties  window
		  {
		    argv => commandline::get_arguments (),
		    #
		    window_name => THE "Triangle",
		    icon_name   => THE "triangle",
		    #
		    size_hints =>
		      [
			xs::HINT_PPOSITION,
			xs::HINT_PSIZE,
			xs::HINT_PMIN_SIZE min_sz
		      ],
		    nonsize_hints  => [ xs::HINT_ICON_RO_PIXMAP icon_ro_pixmap ],
		    ilk_hints => THE { res_name=>"triangle", res_ilk=>"Triangle" }
		  };

		xw::show_window  window;
	    end;

	fun alloc_windows display_name
	    =
	    {   my (screen, top_win, top_dictionary)
		    =
		    init  display_name;

		my (xg::SIZE { wide, high } )
		    =
		    xc::size_of_window  top_win;

		draw_win
		    =
		    xw::make_simple_subwindow  top_win
		      {
			geometry   => draw_win_geom (wide, high),
			#
			border     => THE (xc::black_of_screen  screen),
			background => THE (xc::white_of_screen  screen)		
		      };

		button_win
		    =
		    xw::make_simple_subwindow  top_win
		      {
			geometry   =>  button_win_geom (wide, high),
			border     =>  NULL,
			background =>  THE (xc::white_of_screen  screen)		
		      };

		xw::show_window  draw_win;
		xw::show_window  button_win;

		{ top_window  => top_win,
		  top_env     => top_dictionary,
		  draw_window => draw_win,
		  but_window  => button_win
		};
	    };


	fun make_button_threads (window, kidplug)
	    =
	    {   make_thread "tri" loop;
		take' reset_slot;
	    }
	    where

		my xi::KIDPLUG { from_mouse', from_other', ... }
		    =
		    xi::ignore_keyboard  kidplug;

		mouse_mailop
		    =
		    from_mouse' ==> xi::envelope_contents;

		cmd_mailop
		    =
		    from_other' ==> xi::envelope_contents;

		drawable =  xd::drawable_of_window  window;

		pen = xd::make_pen
			[
			  xd::FUNCTION xd::OP_COPY,
			  xd::FOREGROUND (xc::black_of_screen  (xw::screen_of_window  window))
			];

		draw_cartouche
		    =
		    che::draw_cartouche  drawable  pen;

		text = "RESET";

		font =  xf::open_font
			    #
			    (xw::xsession_of_window  window)
			    #
			    "9x15";

		text_pt
		    =
		    {   text_width = xf::text_width font text;

			my { ascent, descent }
			    =
			    xf::font_high  font;

			xg::POINT {
			    col => ( button_wide - text_width) / 2,
			    row => ((button_high - (ascent + descent)) / 2) + ascent
			  };
		    };

		draw_string
		    =
		    xd::draw_transparent_string drawable pen font;

		fun redraw ()
		    =
		    {   draw_cartouche
			  {
			    corner_radius =>  button_corner_radius,
			    #
			    box  =>  xg::BOX { col  => 0,
					       row  => 0,
					       #	
					       high => button_high - 1,
					       wide => button_wide - 1
					     }
			  };

			draw_string (text_pt, text);
		    };

		reset_slot = make_mailslot ();

		fun loop ()
		    =
		    {   fun mouse_fn (xi::MOUSE_FIRST_DOWN _)
				=>
				give (reset_slot, ());

			    mouse_fn _
				=>
				();
			end;


			fun cmd_fn (xi::ETC_REDRAW _) =>  redraw ();
			    cmd_fn xi::ETC_OWN_DEATH  =>  ();
			    cmd_fn _	        =>  ();
			end;


			for (;;) {
			    #
			    select [
				mouse_mailop ==> mouse_fn,
				cmd_mailop   ==> cmd_fn
			    ];
			};
		    };

	    end;				# fun make_button_threads 

	fun make_draw_threads (window, reset_mailop, kidplug)
	    =
	    {   make_thread "tri draw mouse"  mouse_thread;
		make_thread "tri draw"       .{ loop []; };
		();
	    }
	    where
		my xi::KIDPLUG { from_mouse', from_other', ... }
		    =
		    xi::ignore_keyboard  kidplug;

		mouse_mailop =    from_mouse' ==> xi::envelope_contents;
		cmd_mailop   =    from_other' ==> xi::envelope_contents;

		draw_slot = make_mailslot ();

		fun mouse_thread ()
		    =
		    for (;;) {
			#
			case (do_mailop  mouse_mailop)
			    #
			    xi::MOUSE_FIRST_DOWN { window_point, ... }
				=>
				give (draw_slot, window_point);

			    _   => ();
			esac;
		    };

		draw_mailop = take' draw_slot;

		drawable = xd::drawable_of_window  window;

		pen = xd::make_pen
			[
			  xd::FUNCTION xd::OP_COPY,
			  xd::FOREGROUND (xc::black_of_screen (xw::screen_of_window  window))
			];

		draw = xd::fill_polygon drawable pen;


		fun draw_triangle (xg::POINT { col, row } )
		    =
		    draw
		      {
			shape => xd::CONVEX_SHAPE,

			verts => [ xg::POINT { col => col,       row => row - 10 },
				   xg::POINT { col => col - 8,   row => row +  6 },
				   xg::POINT { col => col + 8,   row => row +  6 }
				 ]
		      };


		fun loop state
		    =
		    {   fun reset ()
			    =
			    {   xd::clear_drawable  drawable;
				loop [];
			    };


			fun handle_cmd (xi::ETC_REDRAW _)
				=>
				{   xd::clear_drawable  drawable;

				    apply draw_triangle state;

				    loop state;
				};

			    handle_cmd xi::ETC_OWN_DEATH
				=>
				();

			    handle_cmd _
				=>
				loop state;
			end;


			fun draw pt
			    =
			    {   draw_triangle pt;
				loop (pt ! state);
			    };

			select [
			    #
			    reset_mailop ==>  reset,
			    cmd_mailop   ==>  handle_cmd,
			    draw_mailop  ==>  draw
			];
		    };

	    end;					# fun make_draw_threads 

	fun make_top_level_threads { top_window, top_env=>xi::KIDPLUG { from_keyboard', from_mouse', from_other', ... }, but_window, draw_window }
	    =
	    {   make_thread "tri router" router;

		{ but_env  => button_kidplug,
		  draw_env => draw_kidplug
		};
	    }
	    where
		(xi::make_widget_cable ()) ->   { kidplug => button_kidplug, momplug => button_momplug };
		(xi::make_widget_cable ()) ->   { kidplug => draw_kidplug,   momplug => draw_momplug   };
		(xi::make_widget_cable ()) ->   { kidplug,                   momplug                   };

		kidplug
		    =
		    xi::ignore_all  kidplug;

		fun find_cable  envelope
		    =
		    case (xi::route_envelope  envelope)
			#
			xi::TO_SELF _			# Envelope has reached its destination window/widget.
			    =>
			    momplug;

			xi::TO_CHILD msg'			# Envelope needs to be passed on down the widget hierarchy.
			    =>
			    if   (xi::to_window (msg', draw_window))   draw_momplug;
			    elif (xi::to_window (msg',  but_window))   button_momplug;
			    else                                      raise exception FAIL "find_cable";
			    fi;
		    esac;

		keyboard_mailop
		    =
		    from_keyboard'
			==>
			(fn envelope
			    =
			    {   my xi::MOMPLUG { keyboard_sink, ... }
				    =
				    find_cable  envelope;

				do_mailop (keyboard_sink envelope);
			    }
			);

		mouse_mailop
		    =
		    from_mouse'
			==>
			(fn envelope
			    =
			    {   my xi::MOMPLUG { mouse_sink, ... }
				    =
				    find_cable  envelope;

				do_mailop (mouse_sink  envelope);
			    }
			);

		mom_mailop
		    =
		    from_other'
			==>
			(fn envelope
			    =
			    {   my xi::MOMPLUG { other_sink, ... }
				    =
				    find_cable  envelope;

				do_mailop (other_sink  envelope);
			    }
			);

		fun router ()
		    =
		    for (;;) {
			#
			select [ keyboard_mailop,
				    mouse_mailop,
				      mom_mailop
			       ];
		    };

	    end;			# fun make_top_level_threads

	fun triangle display
	    =
	    {   my (x as { but_window, draw_window, ... } )
		    =
		    alloc_windows display;

		my { but_env, draw_env }
		    =
		    make_top_level_threads  x;

		make_draw_threads
		  ( draw_window,
		    make_button_threads (but_window, but_env),
		    draw_env
		  );
	    };

	fun do_it' (flgs, display_name)
	    =
	    {   xtracing::init flgs;

		start_up_thread_scheduler'
		    #
		    (time::from_milliseconds 20)
		    #
		   .{   xtracing::xspawn("triangle",  .{ triangle display_name; } );
			();
		    };
	    };

	fun do_it s
	    =
	    do_it' ([], s);

	fun main (program, server ! _) =>  do_it  server;
	    main _                     =>  do_it  "";
	end;
    };								# package  main 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1992 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
