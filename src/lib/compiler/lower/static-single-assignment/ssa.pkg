# ---------------------------------------------------------------------------
# Machine SSA representation.
#
# -- Allen Leung (leunga@cs.nyu.edu) 
# ---------------------------------------------------------------------------*)

###        "The best way to predict the future is to invent it."
###
###                                       -- Alan Kay


generic package SSA
  (package gc_ssa_props:    SSA_PROPERTIES
   package instruction_properties:   Instruction_Properties
   package format_instruction:  FORMAT_INSTRUCTION
   package translate_codetree_to_target_machine:  Translate_Codetree_To_Target_Machine
   package control_flow_graph:         SSA_FLOWGRAPH
   package dj:          DJ_GRAPH
   package gc_map:       GC_MAP
     sharing SSAProps::I = instruction_properties::I = control_flow_graph::I = FormatInstruction::I = translate_codetree_to_target_machine::I
     sharing translate_codetree_to_target_machine::T = SSAProps::RTL::T
  ) : SSA =
pkg
   package control_flow_graph        = control_flow_graph
   package dom        = dj::Dom
   package dj         = DJ
   package sp         = SSAProps
   package gc_map      = GCMap
   package translate_codetree_to_target_machine = translate_codetree_to_target_machine
   package w          = control_flow_graph::W
   package i          = sp::I
   package c          = i::C
   package rtl        = sp::RTL
   package t          = RTL::T
   package ot         = sp::OT
   package g          = graph
   package a          = rw_vector
   package w8a        = rw_unt8_vector
   package da         = DynArray
   package ha         = sparse_rw_vector
   package l          = graph_layout
   package sl         = sorted_list

   fun error msg = lowcode_error_message::error("SSA", msg)

   # ------------------------------------------------------------------------
   # Flags 
   # ------------------------------------------------------------------------
   showAsm   = LowCodeControl::getFlag "ssa-show-asm" 
   showPos   = LowCodeControl::getFlag "ssa-show-pos"
   debug     = LowCodeControl::getFlag "ssa-debug"   
   listLimit = LowCodeControl::getInt  "ssa-list-limit"  
   my _ = listLimit := 5

   # ------------------------------------------------------------------------
   # Counters (for statistics)
   # ------------------------------------------------------------------------
   replacements    = LowCodeControl::getCounter "ssa-replacements"
   constantsFolded = LowCodeControl::getCounter "ssa-constants-folded"
   branchesFolded  = LowCodeControl::getCounter "ssa-branches-folded"
   moved           = LowCodeControl::getCounter "ssa-instructions-moved"

   # ------------------------------------------------------------------------
   # Basic type definitions used in the SSA form
   # ------------------------------------------------------------------------
   type value  = Int             #  value id 
   type pos    = Int             #  position within a block 
   type block  = graph::node_id   #  Block id 
   type ssa_id = graph::node_id   #  ssa id 
   type rtl    = RTL::rtl         #  RTL 
   type const  = ot::const        #  Constants 
   type cfg = control_flow_graph::cfg            #  Control flow graph 
   type dom = Dom::dominator_tree( control_flow_graph::block, control_flow_graph::edge_info, control_flow_graph::info )
   type nameTable = int_hash_table::Hash_Table  { oldName: c::cell, index: Int }

   # ------------------------------------------------------------------------
   # An SSA op is an instruction 
   # ------------------------------------------------------------------------
   type ssa_op = i::instruction

   # ------------------------------------------------------------------------
   # Information about the SSA graph 
   # ------------------------------------------------------------------------
   enum ssa_info = 
      INFO of
      { cfg:              cfg,
       dom:              cfg -> dom,
       defSiteTable:       da::Rw_Vector( ssa_id ),       
       blockTable:         da::Rw_Vector( block ),
       posTable:           da::Rw_Vector( pos ),
       rtlTable:           da::Rw_Vector( rtl ),
       usesTable:          da::Rw_Vector(  List(  value ) ),
       defsTable:          da::Rw_Vector(  List(  value ) ), 
       succTable:          da::Rw_Vector( List( value graph::edge ) ),
       ssaOpTable:         da::Rw_Vector( ssa_op ),
       cellKindTable:      int_hash_table::Hash_Table( c::cellkind ),
       operandTable:       ot::operandTable,
       nameTable:          Null_Or( nameTable ),
       gcmap:            Null_Or( GCMap::gcmap ),
       nextImmed:        Ref( Int ),
       edgeCount:        Ref( Int ),
       nodeCount:        Ref( Int ),
       garbageNodes:     REF(  List(  ssa_id ) ),
       hasDefUseChains:  Ref( Bool ),
       nodes:            REF( Null_Or { sources: a::Rw_Vector(  List(  ssa_id ) ),
                           phis: a::Rw_Vector(  List(     ssa_id ) ),
                           ops: a::Rw_Vector(  List(      ssa_id ) ),
                           sinks: a::Rw_Vector(  List(    ssa_id ) )
                         } ) ,
       maxPos:           Ref( Int ),
       minPos:           Ref( Int ),
       freqTable:         Ref( Null_Or( a::Rw_Vector( w::freq ) ) )
      }

   type ssa = graph::graph (ssa_op, value, ssa_info)

   exception NoDefSite
   exception NoCellKind

   i2s = int::to_string

   # ------------------------------------------------------------------
   # Hacks to deal with zero registers in the architecture
   # ------------------------------------------------------------------
   R        = c::firstPseudo
   zeroRegs = w8a::rw_vector (R, 0w0)
   my _        = apply (fn k =>
                    case c::zeroReg k of
                      NULL => ()
                    | THE r => w8a::update (zeroRegs, r, 0w1))
                  c::cellkinds

   /*------------------------------------------------------------------
    * Deal with pinned resources
    *------------------------------------------------------------------*/
   pinnedUseTable = w8a::rw_vector (R, 0w0)
   pinnedDefTable = w8a::rw_vector (R, 0w0)
   my _ = apply (fn r => w8a::update (pinnedUseTable, r, 0w1)) sp::pinnedUse
   my _ = apply (fn r => w8a::update (pinnedDefTable, r, 0w1)) sp::pinnedDef

   /*------------------------------------------------------------------------
    * How to create a new SSA graph
    *------------------------------------------------------------------------*/
   fun newSSA { cfg, dom, gcmap, nameTable } =  
   let nextImmed   = REF -1
       defSiteTable  = da::rw_vector (13, -1)
       blockTable    = da::rw_vector (13, -1) 
       posTable      = da::rw_vector (13, -1) 
       rtlTable      = da::rw_vector (13, t::SEQ [])
       usesTable     = da::rw_vector (13, [])
       defsTable     = da::rw_vector (13, [])
       succTable     = da::rw_vector (13, [])
       ssaOpTable    = da::rw_vector (13, instruction_properties::nop())
       cellKindTable = int_hash_table::make_table (13, NoCellKind) 
       operandTable  = ot::create nextImmed
       nodeCount   = REF 0
       edgeCount   = REF 0
       garbageNodes = REF []
       hasDefUseChains = REF FALSE
       info        =
           INFO { cfg             = cfg,
                 dom             = dom,
                 defSiteTable      = defSiteTable,
                 blockTable        = blockTable,
                 posTable          = posTable,
                 rtlTable          = rtlTable,
                 usesTable         = usesTable,
                 defsTable         = defsTable,
                 succTable         = succTable,
                 ssaOpTable        = ssaOpTable,
                 cellKindTable     = cellKindTable,
                 operandTable      = operandTable, 
                 nameTable         = nameTable,
                 gcmap           = gcmap,
                 nextImmed       = nextImmed,
                 edgeCount       = edgeCount,
                 nodeCount       = nodeCount,
                 garbageNodes    = garbageNodes,
                 hasDefUseChains = hasDefUseChains,
                 nodes           = REF NULL,
                 maxPos          = REF 0,
                 minPos          = REF 0,
                 freqTable         = REF NULL
               }
       /*--------------------------------------------------------------------
        * Graph methods 
        *--------------------------------------------------------------------*/
       fun nop _ = ()
       fun unimplemented title = error("unimplemented: "$title)
       entries    = REF []
       exits      = REF []
       newNodes   = REF []
       fun order () = *nodeCount
       fun size ()  = *edgeCount
       fun capacity () = da::length ssaOpTable
       fun new_id () = 
           case *newNodes of 
             []   => da::length ssaOpTable
           | h . t => (newNodes := t; h)

       fun garbage_collect ()
           =
          (newNodes := *newNodes @ *garbageNodes); garbageNodes := [])

       fun add_edge (e as (i, j, r))
           = 
           (edgeCount := *edgeCount + 1;
            da::update (succTable, i, (i, j, r) . da::sub (succTable, i))
           )
       fun set_out_edges (n, es) = unimplemented "set_out_edges" 
       fun set_in_edges (n, es) = unimplemented "set_in_edges" 
       fun add_node n = unimplemented "add_node" 

       #  Invariant: all uses of these nodes must have already been removed! 
       and remove_node n = 
       if da::sub (blockTable, n) < 0 then () #  Already removed 
       else let fun removeUses([], c) = c
                  | removeUses (v . vs, c) = 
                    if v < 0 then removeUses (vs, c)
                    else
                    let i = da::sub (defSiteTable, v)
                    in  if i == n then removeUses (vs, c)
                        else 
                        let fun filterEdges([], es', c) = (es', c)
                              | filterEdges((e as (i, j, _)) . es, es', c) =
                                if j == n then filterEdges (es, es', c - 1)
                                else filterEdges (es, e . es', c)
                            es = da::sub (succTable, i)
                            my (es, c) = filterEdges (es, [], c)
                        in  da::update (succTable, i, es);
                            removeUses (vs, c)
                        end
                    end 
                uses = da::sub (usesTable, n)
                size = removeUses (uses, *edgeCount)
            in  edgeCount := size - length (da::sub (succTable, n));
                nodeCount := *nodeCount - 1;
                garbageNodes := n . *garbageNodes; 
                da::update (blockTable, n, -1);
                da::update (usesTable, n, []);
                da::update (defsTable, n, []);
                da::update (succTable, n, [])
            end      
       
       fun set_entries ns = entries := ns
       fun set_exits ns = exits := ns
       fun get_entries () = *entries
       fun get_exits () = *exits
       fun get_succ n = map #2 (da::sub (succTable, n))
       fun get_pred n = 
           let defSite = da::baseArray defSiteTable
               fun collect ([], preds) = preds
                 | collect (v . vs, preds) = 
                   if v < 0 then collect (vs, preds)
                   else let n = a::sub (defSite, v)
                        in  collect (vs, n . preds) end
           in  collect (da::sub (usesTable, n), []) end 
       fun get_nodes () =
       let block  = da::baseArray blockTable
           ssaOps = da::baseArray ssaOpTable
           n      = da::length blockTable
           fun collect (i, nodes) =  
               if i >= 0 then 
                 collect (i - 1, 
                   if a::sub (block, i) >= 0 then 
                     (i, a::sub (ssaOps, i)) . nodes else nodes)
               else nodes
       in  collect (n - 1, []) end

       fun get_edges () =  
       let next = da::baseArray succTable
           n    = da::length succTable
           fun collect (i, edges) = 
               if i >= 0 then 
                  collect (i - 1, list::revAppend (a::sub (next, i), edges))
               else edges
       in  collect (n - 1, []) end

       fun out_edges n = da::sub (succTable, n)
       fun in_edges n =
       let defSite = da::baseArray defSiteTable
           fun collect ([], edges) = edges
             | collect (v . vs, edges) = 
               if v < 0 then collect (vs, edges)
               else let n' = a::sub (defSite, v)
                    in  collect (vs, (n', n, v) . edges) end
       in  collect (da::sub (usesTable, n), []) end
       fun has_edge (i, j) = list::exists (fn (_, k, _) => j = k) (da::sub (succTable, i))
       fun has_node n = da::sub (blockTable, n) >= 0
       fun node_info n = da::sub (ssaOpTable, n)

       fun forall_nodes f =
       let block  = da::baseArray blockTable
           ssaOps = da::baseArray ssaOpTable
           n      = a::length block
           fun apply i =  
               if i >= n then () else
               (if a::sub (block, i) >= 0 then f (i, a::sub (ssaOps, i)) 
                apply (i+1))  
       in  apply 0 end

       fun forall_edges f =
       let next = da::baseArray succTable
           n    = a::length next
           fun loop i = if i >= n then () else (iter (a::sub (next, i)); loop (i+1))
           and iter [] = ()
             | iter (e . es) = (f e; iter es)
       in  loop 0 end

   in  g::GRAPH
         { name            = "SSA",
          graph_info      = info,
          new_id          = new_id,
          add_node        = add_node,
          add_edge        = add_edge,
          remove_node     = remove_node,
          set_in_edges    = set_in_edges,
          set_out_edges   = set_out_edges,
          set_entries     = set_entries,
          set_exits       = set_exits,
          garbage_collect = garbage_collect,
          nodes           = get_nodes,
          edges           = get_edges,
          order           = order,
          size            = size,
          capacity        = capacity,
          out_edges       = out_edges,
          in_edges        = in_edges,
          next            = get_succ,
          prior            = get_pred,
          has_edge        = has_edge,
          has_node        = has_node,
          node_info       = node_info,
          entries         = get_entries,
          exits           = get_exits,
          entry_edges     = fn _ => [],
          exit_edges      = fn _ => [],
          forall_nodes    = forall_nodes,
          forall_edges    = forall_edges
         }
   end  

   /*------------------------------------------------------------------------
    * Extract info from the SSA graph
    *------------------------------------------------------------------------*/
   fun info (g::GRAPH ssa) = let my INFO info = ssa.graph_info in info end
   fun dom SSA = 
   let my { cfg, dom, ... } = info SSA   #  extracts the dominator 
   in  dom cfg end
   fun cfg SSA = .cfg (info SSA)				# Extracts the control_flow_graph 
   fun immed SSA = ot::int(.operandTable (info SSA))		# Create a new operand 
   # fun label SSA = ot::label(.operandTable (info SSA)) 	# Create a new label 
   fun const SSA = ot::const(.operandTable (info SSA))		# Look up const values 
   fun operand SSA = ot::operand(.operandTable (info SSA))

   fun maxVariable SSA = c::maxCell()        #  maximum number of ssa names 

   fun numberOfOperands SSA  #  number of operands 
       =
       let my { nextImmed, ... } = info SSA
       in  -(*nextImmed) - 1
       end

   /*------------------------------------------------------------------------
    * Reserve n nodes of storage in all the dynamic tables.
    *------------------------------------------------------------------------*/
   fun reserve SSA n = 
   let my { defsTable, usesTable, ssaOpTable, rtlTable, 
            blockTable, posTable, succTable, ... } = info SSA
   in  /* if *debug then
           print("[SSA: reserving "$i2s n$" nodes]\n")
         */
       da::expandTo (defsTable, n);
       da::expandTo (usesTable, n);
       da::expandTo (ssaOpTable, n);
       da::expandTo (rtlTable, n);
       da::expandTo (blockTable, n);
       da::expandTo (posTable, n);
       da::expandTo (succTable, n)
   end

   /*------------------------------------------------------------------------
    * Extract the raw tables.  
    * These should only be used when the optimization guarantees that
    * no new ssa ops are added to the graph, since that may involve resizing
    * these tables, rendering them obsolete.  
    *------------------------------------------------------------------------*/
   fun defSiteTable SSA = da::baseArray(.defSiteTable (info SSA))
   fun blockTable SSA = da::baseArray(.blockTable (info SSA))
   fun posTable SSA = da::baseArray(.posTable (info SSA))
   fun rtlTable SSA = da::baseArray(.rtlTable (info SSA))
   fun usesTable SSA = da::baseArray(.usesTable (info SSA))
   fun defsTable SSA = da::baseArray(.defsTable (info SSA))
   fun succTable SSA = da::baseArray(.succTable (info SSA))
   fun ssaOpTable SSA = da::baseArray(.ssaOpTable (info SSA))
   fun cellKindTable SSA = .cellKindTable (info SSA)
   fun operandTable SSA = .operandTable (info SSA)
   fun maxPos SSA = .maxPos (info SSA)
   fun minPos SSA = .minPos (info SSA)

   /*------------------------------------------------------------------------
    * Look up information (the safe way)
    *------------------------------------------------------------------------*/
   fun defSite G = let t = .defSiteTable (info G) in fn v => da::sub (t, v) end 
   fun block G = let t = .blockTable (info G) in fn n => da::sub (t, n) end 
   fun rtl G = let t = .rtlTable (info G) in fn n => da::sub (t, n) end 
   fun uses G = let t = .usesTable (info G) in fn n => da::sub (t, n) end
   fun defs G = let t = .defsTable (info G) in fn n => da::sub (t, n) end
   fun freqTable G =
       case .freqTable (info G) of
         REF (THE t) => t
       | t as REF NULL =>
         let my g::GRAPH cfg = cfg G
             N = cfg.capacity ()
             freqTable = a::rw_vector (N, 0)
         in  cfg.forall_nodes (fn (n, n') =>
                 a::update (freqTable, n, *(control_flow_graph::freq n')));
             t := THE freqTable;
             freqTable
         end

   /*------------------------------------------------------------------------
    * Pretty printing a value
    *------------------------------------------------------------------------*/

   fun prInt i
       =
       if i < 0   then "-" + i2s(-i) 
                  else       i2s i

   fun prIntInf i
       =
       if integer::sign i < 0   then   "-" + integer::to_string (integer::(-_) i) 
                                else         integer::to_string i

   fun showVal SSA = 
   let my { nameTable, cellKindTable, gcmap, ... } = info SSA
       const = const SSA
       cellKind = int_hash_table::find cellKindTable
       cellKind = fn r => case cellKind r of THE k => k | NULL => c::GP 

       #  Display gc type if a gc map is present 
       showGC = 
           case gcmap of
             NULL => (fn r => "")
           | THE gcmap => 
             let get = int_hash_table::lookup gcmap
             in  fn r => ":" + GCMap::gc::to_string (get r) except _ => ":?" end

       #  Display fancy name if a name table is present 
       translate =
           case nameTable of
             NULL =>     (fn (k, v) => c::to_string k v)
           | THE table => 
             let get = int_hash_table::lookup table
             in  fn (k, v) => 
                    let my { oldName, index } = get v
                    in  c::to_string k oldName + "." + i2s index end
                    except _ => (c::to_string k v)
             end

       #  Look up name 
       fun lookupName v = 
       let k = cellKind v
           gcType = if k == c::MEM or k == c::CTRL then "" else showGC v
       in  translate (k, v) + gcType end

       #  Show a value 
       fun show v = 
           if v >= 0 then lookupName v
           else (case const v of
                  sp::ot::INT i => prInt i
                | sp::ot::INTINF i => prIntInf i
                | sp::ot::OPERAND operand => "v" + i2s(-v)
                # | sp::ot::LABEL l => label::nameOf l
                ) except sp::ot::NoConst => "?" + i2s(-v)
   in  show end

   /*------------------------------------------------------------------------
    * Pretty printing an ssa op 
    *------------------------------------------------------------------------*/
   fun showOp SSA = 
   let my { usesTable, defsTable, ssaOpTable, rtlTable, succTable, 
            blockTable, posTable, cellKindTable, ... } = info SSA
       K       = *listLimit 
       showVal = showVal SSA
       cfg     = cfg SSA
       regmap  = control_flow_graph::regmap cfg
       asm     = FormatInstruction::to_string (*(control_flow_graph::annotations cfg))
                                         (c::lookup regmap)
       fun block b = "b" + i2s b
       fun blockOf ssa_id = block (da::sub (blockTable, ssa_id))
       cellKindOf = int_hash_table::find cellKindTable
       cellKindOf = 
           fn r => case cellKindOf r of THE k => k | NULL => c::GP 

       fun listify (vs, rs) =
       let fun h r = c::to_string (cellKindOf r) r
           fun g (v, r) = showVal v + "=" + h r
           fun f (_,[],[])       = ""
             | f (0, vs, rs)       = "\n   " + f (K, vs, rs)
             | f (n,[v],[r])     = g (v, r)
             | f (n, v . vs, r . rs) = g (v, r) + ", " + f (n - 1, vs, rs)
             | f _ = error "showOp::listify"
       in  f (K, vs, rs) end

       fun listify2 ([b],[v])     = "[" + block b + "]" + showVal v
         | listify2 (b . bs, v . vs) = "[" + block b + "]" + showVal v + ", " + listify2 (bs, vs)
         | listify2 _ = ""

       fun show ssa_id = 
       let ssa_op  = da::sub (ssaOpTable, ssa_id) 
           defs    = da::sub (defsTable, ssa_id)
           uses    = da::sub (usesTable, ssa_id)
           rtl     = da::sub (rtlTable, ssa_id)
       in  case rtl of
             t::PHI { preds, ... } => 
               showVal (hd defs) + " := phi(" + listify2 (preds, uses) + ")"
           | t::SINK { block=b, liveOut, ... } => 
               "sink[" + block b + "](" + listify (uses, liveOut) + ")"
           | t::SOURCE { block=b, liveIn, ... } => 
                #  Only pretty print the registers that are currently live 
               let edges = da::sub (succTable, ssa_id)
                   fun isLive r = list::exists (fn (_, _, r') => r = r') edges
                   fun collect ([], [], ds', rs') = (reverse ds', reverse rs') 
                     | collect (d . ds, r . rs, ds', rs') =
                       if isLive d then collect (ds, rs, d . ds', r . rs')
                       else collect (ds, rs, ds', rs')
                   my (defs, liveIn) = collect (defs, liveIn, [], [])
               in  "source[" + block b + "](" + listify (defs, liveIn) + ")"
               end
           | _ => 
              let fun def v = showVal (list::nth (defs, v))
                  fun use v = showVal (list::nth (uses, v))
                  ssa = RTL::rtlToString rtl
                  /* ssa = .statement
                               (RTL::showRTL { def=def, uses=uses,
                                            region_def=def, region_use=uses } ) rtl
                   */

                  ssa = if *showPos then 
                               ssa + " #" + prInt (da::sub (posTable, ssa_id))  
                            else ssa
              in  if *showAsm then asm ssa_op + " [" + ssa + "]" else ssa end
       end
   in  show
   end

   /*------------------------------------------------------------------------
    * Pretty printing the rtl
    *------------------------------------------------------------------------*/
   fun showRTL SSA = RTL::rtlToString

   /*------------------------------------------------------------------------
    * Generate a renamed variable.  Propagate cellkind and gc type information
    *------------------------------------------------------------------------*/
   fun newRenamedVariable SSA = 
   let my { nameTable, cellKindTable, gcmap, ... } = info SSA
       lookupCellKind = int_hash_table::lookup cellKindTable
       addCellKind    = int_hash_table::set cellKindTable
       updateGC =
           case gcmap of
             NULL   => (fn (r, r') => r')
           | THE m => 
             let lookup = int_hash_table::lookup m
                 add    = int_hash_table::set m
             in  fn (r, r') => (add (r', lookup r) except _ => (); r') 
             end
       fun newVariable r =
       let r' = c::newVariable r
       in  addCellKind (r', lookupCellKind r) except _ => () ;
           updateGC (r, r')
       end

   in  case nameTable of
         NULL => newVariable
       | THE nameTable =>
         let enterName = int_hash_table::set nameTable
             exception NoIndex
             indexTable  = int_hash_table::make_table (31, NoIndex)
             addIndex  = int_hash_table::set indexTable
             findIndex = int_hash_table::find indexTable
             findIndex = 
                 fn r => case findIndex r of THE i => i | NULL => 0
             fun newVarKeepName r = 
             let r' = newVariable r
                 i  = findIndex r
             in  addIndex (r, i+1);
                 enterName (r', { oldName=r, index=i } );
                 r'
             end
         in  newVarKeepName 
         end
   end

   /*------------------------------------------------------------------------
    * Generate variable.  Propagate gc type information only.
    *------------------------------------------------------------------------*/
   fun newVariable SSA = 
   let my { gcmap, ... } = info SSA
   in  case gcmap of
          NULL => c::newVariable
        | THE m => 
          let lookup = int_hash_table::lookup m
              add    = int_hash_table::set m
          in  fn r => let r' = c::newVariable r
                      in  add (r', lookup r) except _ => (); r' end
          end
   end

   /*------------------------------------------------------------------------
    * Create a new SSA op.  The node must not already exist.
    *------------------------------------------------------------------------*/
   fun newOp SSA =
   let my { defSiteTable, nodeCount, ... } = info SSA
       defsTable  = defsTable SSA 
       usesTable  = usesTable SSA
       ssaOpTable = ssaOpTable SSA
       blockTable = blockTable SSA
       posTable   = posTable SSA
       rtlTable   = rtlTable SSA

       fun new { id, instruction, rtl, defs, uses, block, pos } = 
       let fun addDefSite [] = ()
              | addDefSite (r . rs) =
                (# print("defSite[" + showVal SSA r + "]=" + i2s id + "\n");
                 da::update (defSiteTable, r, id); 
                 addDefSite rs
                )
       in  nodeCount := *nodeCount + 1;
           addDefSite defs;
           a::update (rtlTable, id, rtl);
           a::update (defsTable, id, defs);
           a::update (usesTable, id, uses);
           a::update (ssaOpTable, id, instruction);
           a::update (blockTable, id, block);
           a::update (posTable, id, pos);
           # print("[" + i2s id + "] = " + showOp SSA id + "\n"); 
           ()
       end
   in  new end

   /*------------------------------------------------------------------------
    * Iterators 
    *------------------------------------------------------------------------*/
   fun forallNodes SSA f =
   let blockTable = blockTable SSA
       n = a::length blockTable 
       fun loop (i) = 
           if i >= n then () else 
           (if a::sub (blockTable, i) >= 0 then f i  loop (i+1))
   in  loop 0 end

   fun foldNodes SSA f x =
   let my { blockTable, ... } = info SSA
       n         = da::length blockTable
       blockTable  = da::baseArray blockTable
       fun fold (i, x) =
           if i < n then fold (i+1, if a::sub (blockTable, i) >= 0 then f (i, x) else x)
           else x
   in  fold (0, x) end
  
   /*------------------------------------------------------------------------
    * Insert edges
    *------------------------------------------------------------------------*/
   fun computeDefUseChains SSA =
   let usesTable    = usesTable SSA
       succTable    = succTable SSA
       defSiteTable = defSiteTable SSA
       blockTable   = blockTable SSA
       n = a::length succTable
       fun iter (i, size) =
       if i < n then
       let fun addEdges([], size) = size
             | addEdges (v . vs, size) =
               if v < 0 then addEdges (vs, size)
               else let j = a::sub (defSiteTable, v) 
                    in  /* print (i2s i + " -> " + i2s j + "\n"  + 
                              showOp SSA i + "->" + showOp SSA j + " ("  + 
                              showVal SSA v + " " + i2s v + ")\n"); */
                        a::update (succTable, j, (j, i, v) . a::sub (succTable, j));
                        addEdges (vs, size+1)
                    end
           uses = a::sub (usesTable, i)
       in  iter (i+1, addEdges (uses, size))
       end
       else size

       numberOfEdges = iter (0, 0)
       my { edgeCount, defsTable, ... } = info SSA
   in  edgeCount := numberOfEdges
   end

   /*------------------------------------------------------------------
    * Function to remove useless phi-node from the graph
    *------------------------------------------------------------------*/
   fun removeUselessPhiFunctions (SSA as g::GRAPH ssa) =
   let usesTable     = usesTable SSA
       defsTable     = defsTable SSA
       rtlTable      = rtlTable SSA
       succTable     = succTable SSA
       blockTable    = blockTable SSA
       defSiteTable  = defSiteTable SSA
       onWorklist  = w8a::rw_vector (ssa.capacity (), 0w0)
       my { nodeCount, edgeCount, ... } = info SSA
       showVal = showVal SSA
       showOp  = showOp SSA

       #  Replace all uses of t defined by phi-node i to t' 
       fun removeUselessNode (i, t, t', WL) =
       let /* print("Useless [" + i2s i + "] " + showOp i + " "  + 
                             showVal t + " -> " + showVal t' + "\n"); */
           i' = a::sub (defSiteTable, t')
           fun processEdges([], es_i', size, WL) = (es_i', size, WL)
             | processEdges((i, j, t) . es_i, es_i', size, WL) =
                #  remove self loops; 
               if i == j
               then processEdges (es_i, es_i', size - 1, WL)
               else
               let fun renameUses [] = []
                     | renameUses (v . vs) =
                        (if v == t then t' else v) . renameUses vs
                   WL = case a::sub (rtlTable, j) of
                      t::PHI _ =>
                         if w8a::sub (onWorklist, j) == 0w0 then
                           (w8a::update (onWorklist, j, 0w1); j . WL)
                         else WL
                    | _ => WL
                   uses_j = a::sub (usesTable, j)
               in  #  print("\t" + showOp j + " =>\n\t"); 
                   a::update (usesTable, j, renameUses uses_j);
                   #  print (showOp j + "\n"); 
                   processEdges (es_i, (i', j, t') . es_i', size, WL)
               end

            #  Filter i from the use sites of i' 
            fun filterI([], es_i', size) = (es_i', size)
              | filterI((e as (i', k, _)) . es, es_i', size) = 
                if k == i then filterI (es, es_i', size - 1)
                else filterI (es, e . es_i', size)

            es_i  = a::sub (succTable, i)
            es_i' = a::sub (succTable, i')
            my (es_i', size) = filterI (es_i', [], *edgeCount)
            my (es_i', size, WL) = processEdges (es_i, es_i', size, WL)
       in   edgeCount := size;
            nodeCount := *nodeCount - 1;
            a::update (succTable, i', es_i');
            #  Remove node i 
            a::update (succTable, i,  []);
            a::update (defsTable, i,  []);
            a::update (usesTable, i,  []);
            a::update (blockTable, i, -1);
            WL
       end

       fun processWorkList [] = ()
         | processWorkList (i . WL) =
           let w8a::update (onWorklist, i, 0w0)
               #  print("Processing " + i2s i + "\n") 
               if a::sub (blockTable, i) < 0 then error (i2s i)
                       else ()
               my [t] = a::sub (defsTable, i)
               s   = a::sub (usesTable, i)
                #  Check if i is useless 
               fun loop ([], t') = removeUselessNode (i, t, t', WL)
                 | loop (v . vs, t') =
                   if v == t then loop (vs, t')
                   else if t' == -1 then loop (vs, v)
                   else WL #  not useless 
               WL = loop (s, -1)
           in  processWorkList WL end

       fun collectPhis (i, WL) =
           (case a::sub (rtlTable, i) of
              t::PHI _ => (w8a::update (onWorklist, i, 0w1); i . WL)
           | _ => WL
           )

       WL = foldNodes SSA collectPhis []

   in  processWorkList (WL)
   end

   /*------------------------------------------------------------------------
    * Remove all nodes.
    * Note: no duplicates allowed.
    *------------------------------------------------------------------------*/
   fun removeAllNodes SSA nodes =
   let succTable  = succTable SSA
       defsTable  = defsTable SSA
       usesTable  = usesTable SSA
       blockTable = blockTable SSA
       my { edgeCount, nodeCount, garbageNodes, ... } = info SSA 
       fun removeAll([], nodes, edges, garbage) = 
            (nodeCount := nodes; edgeCount := edges; garbageNodes := garbage)
         | removeAll (n . ns, nodes, edges, garbage) =
           if a::sub (blockTable, n) < 0 
           then removeAll (ns, nodes, edges, garbage)
           else
           let outEdges = a::sub (succTable, n)
           in  nodeCount := *nodeCount - 1;
               a::update (blockTable, n, -1);
               a::update (usesTable, n, []);
               a::update (defsTable, n, []);
               a::update (succTable, n, []);
               removeAll (ns, nodes - 1, edges - length outEdges, n . garbage)
           end      
   in  removeAll (nodes,*nodeCount,*edgeCount,*garbageNodes) 
   end
 
   /*------------------------------------------------------------------------
    * Replace all use of one value with another.  Return TRUE iff
    * all uses of "from" has been replaced by "to".
    * Note: The definition of "from" must dominate all uses of "to", as
    * required by the SSA form.
    *------------------------------------------------------------------------*/
   fun replaceAllUses (SSA as g::GRAPH ssa) =
   let defSiteTable = defSiteTable SSA
       usesTable    = usesTable SSA
       succTable    = succTable SSA
       posTable     = posTable SSA
       rtlTable     = rtlTable SSA
       my { edgeCount, ... } = info SSA

       cellKind = int_hash_table::find (cellKindTable SSA)
       cellKind = fn r => case cellKind r of THE k => k | NULL => c::GP

       fun isReplaceable k = k = c::GP or k = c::FP

       fun replace { from, to, vn } = 
           isReplaceable (cellKind from) and
           let
               old = a::sub (defSiteTable, from)
               new = a::sub (defSiteTable, to)

               /* print("REPLACING " + showOp SSA old  + 
                             "(" + showVal SSA from + ") by "  + 
                             showOp SSA new + "( " + showVal SSA to + ") vn="  + 
                             i2s vn + "\n") */

               # We directly manipulate the graph package here.
               # Since the number of edges does not change, there is
               # no need to update the edge count.

               fun renameUses([], to) = []
                 | renameUses (r . rs, to) = 
                    (if r == from then to else r) . renameUses (rs, to)

               fun removeUse([], es') = es'
                 | removeUse((e as (_, j, r)) . es, es') = 
                   if r == from then
                    #  Rename an argument of j 
                    (replacements := *replacements + 1;
                     if vn < 0 #  is a constant that we are replacing 
                        and 
                         (case a::sub (rtlTable, j) of
                           (t::PHI _ | t::SINK _ ) => TRUE
                         | _ => FALSE
                         ) then
                      #  phi or sink node 
                      (a::update (usesTable, j, renameUses (a::sub (usesTable, j), vn)); 
                       #  print("Replacing constant: " + showOp SSA j + "\n"); 
                       edgeCount := *edgeCount - 1
                      )
                     else #  normal node 
                      (a::update (usesTable, j, renameUses (a::sub (usesTable, j), to));
                       a::update (succTable, new, (new, j, to) . a::sub (succTable, new))
                      );
                     removeUse (es, es')
                    )
                   else 
                    removeUse (es, e . es')

               edges = removeUse (a::sub (succTable, old), []) 
           in  a::update (succTable, old, edges);
               TRUE
           end
           
   in  replace
   end

   /*------------------------------------------------------------------------
    * Replace the definition of value by const.  This will change the
    * instruction that defines value to a constant computation instruction.
    * Return TRUE iff this operation is successful.
    *------------------------------------------------------------------------*/
   fun foldConstant SSA =
   let constOf = const SSA
       showOp  = showOp SSA
       my { edgeCount, posTable, defsTable, usesTable, succTable, rtlTable, ssaOpTable,
            defSiteTable, minPos, blockTable, ... } = info SSA 
       fun fold { value, const } = 
           let i    = da::sub (defSiteTable, value)
               defs = da::sub (defsTable, i)
           in  case (defs, constOf const) of
                 ([_], sp::ot::INT imm) => #  only one value defined; okay 
                  if (case da::sub (usesTable, i) of
                        [v] => v < 0  #  Already a constant! don't fold 
                      | _   => FALSE) then FALSE
                  else
                  let #  Remove existing incoming edges 
                      fun removeUses [] = ()
                        | removeUses (v . vs) = 
                          if v < 0 then removeUses vs else
                          let j = da::sub (defSiteTable, v)
                              fun rmv ([], es') = es'
                                | rmv((e as (j, k, _)) . es, es') = 
                                  if k == i then rmv (es, es') 
                                  else (edgeCount := *edgeCount - 1; 
                                        rmv (es, e . es'))
                              succ_j = da::sub (succTable, j)
                          in  da::update (succTable, j, rmv (succ_j, []));
                              removeUses vs
                          end

                      #  print("REPLACING " + showOp i + " -> "); 
                      instruction   = instruction_properties::loadImmed { t=value, immed=imm }
                      oldRtl  = da::sub (rtlTable, i)
                      da::update (ssaOpTable, i, instruction)
                      newRtl  = sp::RTLProps::rtl instruction
                      da::update (rtlTable, i, newRtl)
                      oldUses = da::sub (usesTable, i)
                  in  removeUses (oldUses);
                      #  now has only one input! 
                      da::update (usesTable, i, [const]); 
                      
                      /* If the instruction used to be a phi-node or
                       * a source node, find an appropriate place for
                       * this new instruction.
                       */
                      case oldRtl of
                         (t::PHI _ | t::SOURCE _) =>
                         let newPos = *minPos 
                         in  minPos := *minPos - 128;
                             da::update (posTable, i, newPos)
                         end
                      | _ => () #  keep the same position 
                      ;
                      /* print (showOp i + "\n");
                      apply (fn (_, j, _) => print ("\t" + showOp j + "\n")) 
                           (da::sub (succTable, i)); */
                      TRUE
                  end
              | _ => FALSE #  Can't fold 
           end
   in  fold 
   end 

   /*------------------------------------------------------------------------
    * Move an instruction from one block to another
    *------------------------------------------------------------------------*/
   fun moveOp SSA = 
   let posTable     = posTable SSA
       blockTable   = blockTable SSA
       defSiteTable = defSiteTable SSA
       usesTable    = usesTable SSA
       succTable    = succTable SSA
       rtlTable     = rtlTable SSA
       showOp     = showOp SSA
       showVal    = showVal SSA
      
       my { maxPos, minPos, ... } = info SSA

       fun mv { id, block } = 
       let moved := *moved + 1
           fun earliest ([], pos) = pos
             | earliest (v . vs, pos) =
               if v < 0 then earliest (vs, pos)
               else let j   = a::sub (defSiteTable, v)
                        b_j = a::sub (blockTable, j)
                    in  if block == b_j then
                          (case a::sub (rtlTable, j) of
                             t::PHI _ => earliest (vs, pos)
                          | _ => earliest (vs, int::max (pos, a::sub (posTable, j)))
                          )
                        else
                          earliest (vs, pos)
                    end
           fun latest ([], pos) = pos
             | latest((_, j, _) . es, pos) =
               let b_j = a::sub (blockTable, j)
               in  if block == b_j then
                      (case a::sub (rtlTable, j) of
                         t::PHI _ => latest (es, pos)
                       | _ => latest (es, int::min (pos, a::sub (posTable, j)))
                      )
                   else
                      latest (es, pos)
               end

           fun sanityCheck (lo, hi)  =
               if lo > hi then
               let fun prOp j =
                   let b_j   = a::sub (blockTable, j)
                       pos_j = a::sub (posTable, j)
                   in  print("\t" + showOp j + " in block "  + 
                                    i2s b_j + ":" + i2s pos_j + "\n")
                   end
                   fun prUse v = 
                       if v < 0 then print("\t" + showVal v + "\n")
                       else let j = a::sub (defSiteTable, v)
                            in  prOp j
                            end
                   fun prDef(_, j, _) = prOp j
               in  print "Uses=\n"; apply prUse (a::sub (usesTable, id));
                   print "Defs=\n"; apply prDef (a::sub (succTable, id));
                   error("move " + showOp id + " lo=" + i2s lo  + 
                            " hi=" + i2s hi + " block=" + i2s block)
               end 
               else ()


           uses = a::sub (usesTable, id)
           lo   = earliest (uses, *minPos)
           hi   = latest (a::sub (succTable, id), *maxPos)
           pos  = if *minPos == lo then (maxPos := *maxPos + 128; hi - 1)
                      else if *maxPos == hi then (minPos := *minPos - 128; lo+1)
                      else (minPos := *minPos - 128; 
                            maxPos := *maxPos + 128;
                            sanityCheck (lo, hi);
                            (lo + hi) div 2
                           )
       in  a::update (blockTable, id, block);
           a::update (posTable, id, pos)
       end
   in  mv
   end

   /*------------------------------------------------------------------------
    * Set the target of a conditional branch as TRUE or FALSE.
    * This removes the branch and eliminates all unreachable code.
    *------------------------------------------------------------------------*/
   fun setBranch (SSA as g::GRAPH ssa) =
   let my { cfg, ssaOpTable, blockTable, nodeCount, ... } = info SSA
       fun set { id, cond } = 
       let b = da::sub (blockTable, id)
           jmp = control_flow_graph::setBranch (cfg, b, cond)
       in  ssa.remove_node id;
           da::update (ssaOpTable, id, jmp);
           da::update (blockTable, id, b);
           nodeCount := *nodeCount + 1;
           branchesFolded := *branchesFolded + 1
       end
   in  set 
   end

   /*------------------------------------------------------------------------
    * Make sure that none of the tables have been resized
    *------------------------------------------------------------------------*/
   fun noResize SSA f x =
   let b = blockTable SSA
       d = defSiteTable SSA
       fun check () =
        (if b != blockTable SSA then error "node tables have changed" 
         if d != defSiteTable SSA then error "variable table has changed" else ()
        )
   in  let y = f x in check(); y  end
       except e => (check(); raise exception e)
   end
    

   /*------------------------------------------------------------------------
    * Signal that an SSA has been changed
    *------------------------------------------------------------------------*/
   fun changed SSA = 
   let my { nodes, ... } = info SSA
   in  nodes := NULL end

   /*------------------------------------------------------------------------
    * Linearize the representation
    *------------------------------------------------------------------------*/
   fun nodes SSA =
   let my { nodes, ... } = info SSA
   in  case *nodes of
         THE nodes => nodes
       | NULL => let n = linearizeNodes SSA
                 in  nodes := THE n; n end
   end

   and linearizeNodes SSA = 
   let my g::GRAPH cfg = cfg SSA
       N = cfg.capacity ()

       blockTable = blockTable SSA
       posTable   = posTable SSA
       rtlTable   = rtlTable SSA

       sinks   = a::rw_vector (N,[])
       sources = a::rw_vector (N,[])
       phis    = a::rw_vector (N,[])
       ops     = a::rw_vector (N,[]) 

       fun ins (n) = 
       let b = a::sub (blockTable, n) 
       in  if b >= 0 then
             let table = 
                 case a::sub (rtlTable, n) of
                   t::PHI _ => phis
                 | t::SINK _ => sinks
                 | t::SOURCE _ => sources
                 | _ => ops
             in  a::update (table, b, n . a::sub (table, b))
             end
           
           ins (n - 1)
       end
       fun byPos (a, b) = a::sub (posTable, a) > a::sub (posTable, b)
   in  ins (a::length blockTable - 1) except (SUBSCRIPT|INDEX_OUT_OF_BOUNDS) => ();
       a::modify (list_mergesort::sort byPos) ops;
       { sinks=sinks, sources=sources, phis=phis, ops=ops }
   end


   /*------------------------------------------------------------------------
    * Graphical Viewing
    *------------------------------------------------------------------------*/
   fun viewAsCFG SSA = 
   let cfg = cfg SSA
       my { graph, node, edge } = control_flow_graph::viewStyle cfg
       showOp = showOp SSA
       my { sinks, sources, phis, ops } = nodes SSA
       fun node (b, b') = 
       let instrs = a::sub (sources, b) @ 
                        a::sub (phis, b) @
                        a::sub (ops, b) @
                        a::sub (sinks, b) 
           text = string::cat (map (fn i => showOp i + "\n") instrs)
       in  [l::LABEL (control_flow_graph::headerText b'  +  text)]
       end
   in  l::makeLayout
         { graph = graph,
           node  = node,
           edge  = edge
         } cfg
   end

   fun viewAsSSA SSA = 
   let showOp  = showOp SSA
       showVal = showVal SSA
       fun graph _    = []
       fun node (i, _)  = [l::LABEL (showOp i)]
       fun edge (_, _, v) = [l::COLOR "red", l::LABEL (showVal v)]
   in  l::makeLayout
        { graph = graph,
          node  = node,
          edge  = edge
        } SSA
   end

   /*------------------------------------------------------------------------
    * Consistency checking
    *------------------------------------------------------------------------*/
   fun consistencyCheck (SSA as g::GRAPH ssa) = 
   let defSiteTable = defSiteTable SSA
       usesTable    = usesTable SSA
       defsTable    = defsTable SSA
       rtlTable     = rtlTable SSA
       blockTable   = blockTable SSA
       succTable    = succTable SSA
       posTable     = posTable SSA
       Dom        = dom SSA
       showOp     = showOp SSA
       showVal    = showVal SSA
       dominates  = Dom::dominates Dom

       hasError = REF FALSE 

       fun posOf i = 
           case a::sub (rtlTable, i) of
             t::PHI _ =>  -10000000
           | _       => a::sub (posTable, i)
 
       fun bug (i, msg) = 
          (print("ERROR [b" + i2s (a::sub (blockTable, i)) + ":p" + i2s (posOf i)  + 
                 ":" + i2s i + "] " + showOp i + ": " + msg + "\n");
           hasError := TRUE
          )

       fun checkDefs i =
       let defs = a::sub (defsTable, i)
       in  apply (fn r => 
                let i' = a::sub (defSiteTable, r) 
                in  if i != i' then
                       bug (i, "wrong def site " + i2s i' + " for "  + 
                           showVal r) 
                    else ()
                end)
               defs
       end

       fun checkBlock (i, block) = 
           if a::sub (blockTable, i) != block then bug (i, "wrong block") else ()

       fun printEdge (i, j, r) =
           print("\t" + i2s i + " -> " + i2s j + " " + showVal r + "\n")

       fun domTest (i, j, r) = 
       let b_i = a::sub (blockTable, i)
           b_j = a::sub (blockTable, j)
       
           ok = 
              case a::sub (rtlTable, j) of
                t::PHI { preds, ... } =>
                 let fun scan (p . preds, v . vs) = 
                         r = v and dominates (b_i, p) or scan (preds, vs)
                       | scan _ = FALSE
                 in  scan (preds, a::sub (usesTable, j)) end
              |  _ => if b_i == b_j then posOf i < posOf j
                      else dominates (b_i, b_j)
       in  if ok then () 
           else bug (i, showVal r  + 
                    " does not dominate " + showOp j  + 
                    " b" + i2s (a::sub (blockTable, j)) + " p" + i2s (posOf j))
       end

       fun checkEdges i =
           let defs = a::sub (defsTable, i)
               edges = a::sub (succTable, i)
               fun checkEdge (i', j', r) = 
                   (if i' != i then bug (i, "bad edge source") 
                    if a::sub (blockTable, j') < 0 then
                      bug (i, "use in node " + i2s j' + " is dead") 
                    if not (list::exists (fn r' => r == r') defs) then
                      bug (i, showVal r + " is not a definition") 
                    if not (list::exists (fn r' => r == r') 
                              (a::sub (usesTable, j'))) then 
                      bug (i, showOp j' + " has no use of " + showVal r) 
                    domTest (i', j', r)
                   )
           in  apply checkEdge edges
           end

       fun showVals (title, rs) =
            print (title + "=" + fold_right (fn (r, "") => showVal r 
                                    | (r, s) => showVal r + ", " + s) "" rs  + 
                  " (" + i2s (length rs) + ")\n")

       fun checkLiveIn (i, liveIn) =
           let defs = a::sub (defsTable, i)
               n    = length defs
               m    = length liveIn
           in  if n != m then 
                  (bug (i, "|liveIn| != |defs|");
                   showVals("liveIn", liveIn);
                   showVals("defs", defs)
                  )
               else () 
           end

       fun checkLiveOut (i, liveOut) =
           let uses = a::sub (usesTable, i)
               n    = length uses
               m    = length liveOut
           in  if n != m then 
                  (bug (i, "|liveOut| != |uses|");
                   showVals("liveOut", liveOut);
                   showVals("uses", uses)
                  )
               else () 
           end

       fun checkNode (i, _) =
           case a::sub (rtlTable, i) of
             t::PHI { preds, block } => checkPhi (i, preds, block)
           | t::SOURCE { liveIn, block } => checkSource (i, liveIn, block)
           | t::SINK { liveOut, block } => checkSink (i, liveOut, block)
           | _ => checkOp i

       and checkPhi (i, preds, block) = 
           (checkBlock (i, block);
            checkDefs i;
            checkEdges i;
            let n = length preds
                m = length (a::sub (usesTable, i))
            in  if m != n then
                  bug (i, "|preds|=" + i2s n + " |uses|=" + i2s m)
                else ()
            end
           )

       and checkSource (i, liveIn, block) =
           (checkBlock (i, block);
            checkLiveIn (i, liveIn);
            if length (a::sub (usesTable, i)) != 0 then
               bug (i, "|uses| != 0")
            
            checkDefs i;
            checkEdges i
           )

       and checkSink (i, liveOut, block) =
           (checkBlock (i, block);
            checkLiveOut (i, liveOut);
            if length (a::sub (defsTable, i)) != 0 then
               bug (i, "|defs| != 0")
            
            if length (a::sub (succTable, i)) != 0 then
               (bug (i, "|succs| != 0" );
                apply printEdge (a::sub (succTable, i))
               )
            
            checkDefs i;
            checkEdges i
           )

       and checkOp (i) =
           (checkDefs i;
            checkEdges i
           )

   in  ssa.forall_nodes checkNode;
       if *hasError then error "SSA graph is corrupted" else ()
   end
end









##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

