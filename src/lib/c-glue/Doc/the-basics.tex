\documentclass{article}
   \usepackage{sml}
   \usepackage{alltt}
   \usepackage{html}

   \include{macros}

   \title{The Basics of SML/NJ FFILib}
\begin{document}
   \maketitle

\section{Introduction}

    I'll assume you already know how to use \mlnlffigen\ and its runtime 
interface library (packages \Sml{C, ZString}, etc.)  
If not, please first read
the file {\tt src/lib/c-glue-lib/Doc/mini-tutorial.txt} which comes with
the c-glue-lib package.

    You can contact Matthias Blume 
\htmladdnormallink{\tt blume@research.bell-labs.com}{mailto:blume@research.bell-labs.com} questions concerning these tools.

\section{Conventions}

   How we do things in SMLNJ-FFILIB is slightly different than how 
{\em c-glue-maker} does them.  So it's important you know the differences.

\subsection{Light versus heavy interface}

   Only the ``light'' interface is provided in SMLNJ-FFILIB.
This means all ``C'' objects in this library do not carry any runtime 
information.  While this makes some operations, such as array subscripting, 
less convenient for the users, usually the difference is not that important.
The light interface seem to stress the SML/NJ compiler less, which is
important since the libraries contain a massive amount of code.

\subsection{Runtime Type Information}

   I have pruned out almost all generated runtime type information 
from the libraries.  I only keep them around for array subscripting.  
Again, this keep the libraries lighter.

\subsection{Naming convention}

\begin{enumerate}
    \item  All functions named \Sml{foo} in C are callable from
         the package \Sml{foo.f} (not \Sml{F_foo.f} as normally
      generated by in \mlnlffigen)

         In addition, if the function has named arguments, an alternative
         version \Sml{foo.g} is also available.

    \item  A package or union named \Sml{Foo} is translated into
         a package exactly named \Sml{Foo} in ML 
       (not \Sml{S_Foo} or \Sml{U_Foo} as in normal \mlnlffigen\ code.)

    \item  Some exceptions:

     \begin{enumerate}
       \item When the names clash with ML's package names or keywords,
           we add a tick at the end.
       \item When the name is prefixed by a \Sml{_} (which is illegal in ML),
           we retain \mlnlffigen\ name mangling convention.
    \end{enumerate}
\end{enumerate}

\subsection{How to make your own}

   Here are the general steps of adding your own libraries to this package.

Let's say you have new library called widgets with a main include file
called {\tt "widgets.h"}.

\begin{enumerate}
   \item Create a new directory {\tt widgets}.

   \item  Cd to this directory and run {\tt ../config/init-ffi}
        This will create three files:

     \begin{description}
      \item[widgets.cm] --- main cm file
      \item[make.pkg]   --- program to run to create the nicely ``wrapped''
                            version of your library 
      \item[Makefile]   --- drives everything
     \end{description}

   \item Edit {\tt Makefile} and 
        {\tt make.pkg} to get the system to create the library
        in the form you want.  Sorry, I have no documentation to this at the
        moment.
        You may look at the other directories to get some general idea.
        When all else fails, you can always track me down by email.
    
        A comment on the file {\tt make.pkg}.  It contains the recipe for 
        transforming the stuff generated by c-glue-maker into a nicer 
        form for actual use.  For simple stuff, the default is usually enough.  
        But for truly complex stuff, just as Gtk -- with its fake object 
        orientation -- the transformations can be quite complex.   
    
        There are two libraries that you can use to help you out.  
        The first is {\em ML-Grinder}, 
       which is just a very quick and dirty set  
        of transformations on a SML Ast.  Read the api in 
        ml-grinder/ml-grinder.api to get an idea.  The Ast is actually defined
        in the library {\tt \$mlrisc-tools} in the directories under 
         {\tt src/MLRISC/Tools}.
        It is intentionally kept very simple; you cannot use it to write
        a real ML compiler.  But for writing code generator generator it
        is very adequate.
    
        The second library is {\em FFI-Packager}, which is somewhat more
        specific to the task of hacking on c-glue-maker generated code.
        Of particular interest is the package \Sml{ffi_transforms}.
        It contains a bunch of combinators for performing transformations
        on generated ffi functions. 

   \item  You can test out the build by doing:
   
\begin{verbatim} 
    make cleanall testrebuild
\end{verbatim} 
    
        Things will probably not work out the first time.  Just repeat from 3.
    
   \item  When everything works out, you can cd to the directory config and run
    
\begin{verbatim} 
    make-targets > targets
\end{verbatim}
        \noindent to update the set of targets.   
         The script requires {\em rpm}, however.
        I would appreciate it if anyone can make it work with Debian's 
        packager.
    
        You can always add the target by hand to {\em targets} file.
\end{enumerate}
\end{document} 
