## xsocket.pkg
#
# Manage binary socket I/O to an X server for an X client.
#
# This code implements the low-level I/O of the X-protocol,
# sending and receiving actual bytestrings from the socket
# connected to the X server.
#
# This includes batching multiple outgoing requests
# per network packet, breaking the incoming bytestream
# into individual replies, matching replies to outstanding
# requests, and collapsing multiple expose events into
# single messages for ease of later processing.
#
# We do not here handle the work of actually encoding and
# decoding wire-format binary bytestrings;  those tasks
# are handled by
#
#     src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#     src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
#
# Together with those two packages, xsocket.pkg
# provides the X server communication layer used by the
# various x-kit imps (server threads) such as:
# 
#     src/lib/x-kit/xclient/src/wire/display.pkg
#     src/lib/x-kit/xclient/src/wire/sendevent-to-wire.pkg
#     src/lib/x-kit/xclient/src/wire/window-io.pkg
#
#     src/lib/x-kit/xclient/src/window/color-imp.pkg
#     src/lib/x-kit/xclient/src/window/cursor.pkg
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#     src/lib/x-kit/xclient/src/window/draw-imp.pkg
#     src/lib/x-kit/xclient/src/window/font-imp.pkg
#     src/lib/x-kit/xclient/src/window/graphics-context-imp.pkg
#     src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/keymap-imp.pkg
#     src/lib/x-kit/xclient/src/window/rw-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/selection-imp.pkg
#     src/lib/x-kit/xclient/src/window/window.pkg
#
#     src/lib/x-kit/xclient/src/iccc/atom-imp.pkg
#     src/lib/x-kit/xclient/src/iccc/window-property.pkg
#     src/lib/x-kit/xclient/src/iccc/atom.pkg
#
#
# In this file we implement the xsession inbuf,
# outbuf, sequencer and xbuf imps.  For the big
# picture refer to the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# NOTE: the implementation of 'close' doesn't really work,
# since the socket may end up being closed before the
# output buffer is actually flushed (race condition). XXX BUGGO FIXME


# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6






###        "The X server has to be the biggest program
###         I've ever seen that doesn't do anything for you."
###
###                                -- Ken Thompson 


							# event_types		is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
							# xerrors		is from   src/lib/x-kit/xclient/src/wire/xerrors.pkg

package xsocket: (weak)  Xsocket			# Xsocket		is from   src/lib/x-kit/xclient/src/wire/xsocket.api
{
    include threadkit;					# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

    package u   = unt;					# unt			is from   src/lib/std/unt.pkg
#   package wv8 = rw_unt8_vector;			# rw_unt8_vector	is from   src/lib/std/src/rw-unt8-vector.pkg
    package v8  = unt8_vector;				# unt8_vector		is from   src/lib/std/src/unt8-vector.pkg

    package g   = geometry;				# geometry		is from   src/lib/x-kit/xclient/src/window/geometry.pkg

    exception LOST_REPLAY;
    exception ERROR_REPLY  xerrors::Xerror;

    empty_v
        =
        v8::from_list [];

    fun new_buf size
        =
        rw_unt8_vector::make_rw_vector (size, 0u0);

    buf_size = 2048;

    # Time to wait before flushing a non-empty output buffer 
    #
    flush_time_out'
        =
        timeout_in' (time::from_milliseconds 50);

    # Client pleas to sequencer: by clients 
    #
    Plea_Mail
      = PLEA_FLUSH
      | PLEA_QUIT
      | PLEA             v8::Vector
      | PLEA_AND_CHECK  (v8::Vector, Mailslot( Reply_Mail ))
      | PLEA_REPLY      (v8::Vector, Mailslot( Reply_Mail ))
      | PLEA_REPLIES    (v8::Vector, Mailslot( Reply_Mail ), (v8::Vector -> Int))
      | PLEA_EXPOSURES  (v8::Vector, Oneshot_Maildrop (Void -> List( g::Box ) ))


    # Replies from the sequencer to client requests 
    #
    also
    Reply_Mail
      = REPLY_LOST			#  The reply was lost somewhere in transit.
      | REPLY        v8::Vector		#  A normal reply.
      | REPLY_ERROR  v8::Vector		#  The server returned an error message.
      ;

    # Messages from the sequencer to the output buffer 
    #
    Outbuf_Mail
      = OUTBUF_FLUSH
      | OUTBUF_QUIT
      | OUTBUF_MAIL  v8::Vector
      ;

#  +DEBUG 
    max_chars_to_trace_per_send
	=
	NULL;			# Show complete message.
#	THE 4;			# First four bytes -- this is what Reppy had.

    max_chars_to_trace_per_read
	=
	NULL;			# Show complete message.
#	THE 8;			# First eight bytes -- this is what Reppy had.

    # Convert "abc" -> "61.62.63." etc:
    #
    fun string_to_hex s
	=
	string::translate
	    (fn c =  string_conversion::pad_left '0' 2 (int::format string_conversion::HEX (char::to_int c)) + ".")
	     s;

    # Show printing chars verbatim, everything
    # else as '.', per hexdump tradition:
    #
    fun string_to_ascii s
	=
	string::translate
	    (fn c =  char::is_print c  ??  string::from_char c  ::  ".")
	    s;

    fun out_msg_to_string OUTBUF_FLUSH
	    =>
	    "OutFlush";

	out_msg_to_string OUTBUF_QUIT
	    =>
	    "OutQuit";

	out_msg_to_string (OUTBUF_MAIL v)
	    =>
	    {   prefix_to_show
		    =
		    byte::unpack_string_vector
                        (unt8_vector_slice::make_slice
                            (v, 0, max_chars_to_trace_per_send)
                        );

		case max_chars_to_trace_per_send
		    #
		    THE n
			=>
			cat [ "Sent to X server: ",   string_to_hex    prefix_to_show,
			      "... == \"",            string_to_ascii  prefix_to_show,
			      "\"... (", int::to_string (v8::length v), " bytes)"
			    ];
		    NULL
			=>
			cat [ "Sent to X server: ",   string_to_hex prefix_to_show,
			      " == \"",               string_to_ascii  prefix_to_show,
			      "\"  (", int::to_string (v8::length v), " bytes)"
			    ];
		esac;
	    };	
    end;

#  -DEBUG 

    # The input stream manager.
    #
    # This monitors the input stream from the X-server
    # and breaks it up into individual messages which
    # are sent on out_slot to be unmarshalled and routed
    # by the sequencer.
    #
    # Each message to the sequencer is a record consisting
    # of the message code and the message data.
    #
    fun inbuf (out_slot, socket) ()
        =
        {   std_msg_size = 32;

	    # Read n bytes from the socket:
            #
	    fun read_vector (n, header)
                =
		read (n, header)
                where
		    fun read (0, [v])
			    =>
			    v;

		        read (0, vl)
			    =>
			    v8::cat (list::reverse vl);

		        read (n, vl)
                            =>
                            {   v = socket::receive_vector (socket, n);

				case (v8::length v)
				    #
				    0   =>  raise exception FAIL "Socket closed"; 	# *** NOTE: we need a more graceful way to signal that the socket has closed!! ** XXX BUGGO FIXME
				    len =>  read (n - len, v ! vl);
				esac;

			    };
                    end;
		end;

	    fun get_msg ()
		=
		{   msg = read_vector (std_msg_size, []);

		    case (v8::get (msg, 0))
			#
			0u1 =>
			    {   # Reply:
				# 
				extra_len = large_unt::to_int_x (pack_big_endian_unt32::get_vec (msg, 1));

				if (extra_len > 0)
				    #
				    { code =>  0u1,
				      msg  =>  read_vector (4 * extra_len, [msg])
				    };
				else
				    { code =>  0u1,
				      msg
				    };
				fi;
			    };

			k => { code => k, msg };
		    esac;
		};

#  +DEBUG 
	    get_msg
		=
	       .{   my (result as { code, msg } )
			=
			get_msg ();

		    xtracing::print_if xtracing::io_tracing
		       .{   prefix_to_show
				=
				byte::unpack_string_vector
                                    (unt8_vector_slice::make_slice (msg, 0, max_chars_to_trace_per_read));


			    case max_chars_to_trace_per_read
				#
				THE n
				    =>
				    cat [ "Read from X server: code=", unt8::to_string code,
                                          "  len=", int::to_string (v8::length msg),
                                          "  body=",                string_to_hex    prefix_to_show,
					  "... == \"",              string_to_ascii  prefix_to_show,
					  "\"..."
					];
				NULL
				    =>
				    cat [ "Read from X server: code=", unt8::to_string code,
                                          "  len=", int::to_string (v8::length msg),
                                          "  body=",                string_to_hex    prefix_to_show,
					  " == \"",                 string_to_ascii  prefix_to_show,
					  "\""
					];
			    esac;
                    };

		    result;
		};
#  -DEBUG 

	    fun loop ()
                =
		for (;;) { 
		    #
                    give (out_slot, get_msg());
                };

	    loop ()
            except
                _ = thread_done ();
	};


    # The output stream manager.
    #
    fun outbuf (in_slot, socket) ()
        =
	loop ([], 0)
        where
            fun quit ()
                =
                {   socket::close socket;
                    thread_done ();
                };

	    fun flush_buf strs
                =
                socket_stuff::send_vector (socket, v8::cat (reverse strs));

#  +DEBUG 
	    flush_buf
		=
		fn strs
		    =
		    {   xtracing::print_if  xtracing::io_tracing
			   .{   cat [
		                    "Flush: ", int::to_string (list::length strs), " msgs, ",
				    int::to_string (list::fold_left (fn (s, n) = v8::length s + n) 0 strs), " bytes."
				];
			   };

			flush_buf strs;
		    };
#  -DEBUG 

	    fun insert (s, (strs, nb))
		=
		{   n = v8::length s;

		    if (n+nb > buf_size)
			#
			flush_buf strs;
			([s], n);
		    else
			(s ! strs, n+nb);
		    fi;
		};

/*****
	  fun loop ([], _) = (case get_mail inCh
	       of OUTBUF_FLUSH => loop([], 0)
		| (OUTBUF_MAIL s) => loop([s], v8::length s)
		| OUTBUF_QUIT => quit())
	    | loop (buf as (strs, _)) = select [
		  wrap (flushTimeOut, fn _ => (flushBuf strs; loop([], 0))),
		  wrap (get_mailop inCh,
		    fn OUTBUF_FLUSH => (flushBuf strs; loop([], 0))
		     | (OUTBUF_MAIL s) => loop (insert (s, buf))
		     | OUTBUF_QUIT => (flushBuf strs; quit()))
		]
*****/
	    fun print_msg  msg
		=
		{   xtracing::print_if  xtracing::io_tracing
		       .{   cat ["outbuf::loop: ", out_msg_to_string msg]; };

		    msg;
		};

	    fun loop (buf, _)
                =
                {   xtracing::print_if xtracing::io_tracing .{
                        cat [ "outbuf::loop: waiting ", int::to_string (list::length buf)];
                    };

		    case buf
			#
			[] =>
                            case (print_msg (take  in_slot))
				#
				OUTBUF_FLUSH =>  loop([], 0);
				OUTBUF_MAIL s =>  loop([s], v8::length s);
				OUTBUF_QUIT  =>  quit ();
			    esac;

		        strs =>
                            select [
				#
                                flush_time_out'
				    ==>
                                    (fn _ = {   flush_buf strs;
                                                loop([], 0);
                                            }
                                    ),

                                (take' in_slot ==> print_msg)
                                    ==>
				    fn OUTBUF_FLUSH => {  flush_buf strs;  loop([], 0);  };
				       OUTBUF_QUIT  => {  flush_buf strs;  quit();       };
				       OUTBUF_MAIL s => loop (insert (s, (buf, 0)));
				    end
			    ];
                    esac;
		};
	end;				# fun outbuf 


    # The sequencer:
    # The sequencer is responsible for matching
    # replies with requests. All requests to the
    # X-server go through the sequencer, as do
    # all messages from the X-server.
    #
    # The sequencer communicates on five fixed channels:
    #
    #   plea_slot    -- request messages from clients
    #   from_x_slot     -- reply, error and mailop messages from the server (via the input buffer)
    #   to_x_slot       -- requests messages to the output buffer
    #   xevent_slot     -- X-events to the X-event buffer
    #   error_sink_slot -- errors to the error handler
    #
    # In addition, the sequencer sends replies
    # to clients on the reply channel that was
    # bundled with the request.
    #
    stipulate

	# The kind of reply that is pending
        # for an outstanding request in the
	# outstanding request queue.
	#
        # We use unsigneds to represent the
	# sequence numbers.
	#
	# ONE_REPLY is the workhorse call:
        #    A request generating a single reply.
        #
        # MULTI_REPLY is a currently unused call
        #    supporting multiple responses to a single request:
        #    we accumulate responses until the (v8::Vector -> Int)
        #    function argument ("remaining") returns 0. 
	#    (The fourth slot is just the reply accumulator.)
	#
        Outstanding_Reply
	  = ERROR_CHECK     (u::Unt, Mailslot( Reply_Mail ))
	  | ONE_REPLY       (u::Unt, Mailslot( Reply_Mail ))
	  | MULTI_REPLY     (u::Unt, Mailslot( Reply_Mail ), (v8::Vector -> Int), List( v8::Vector ))
	  | EXPOSURE_REPLY  (u::Unt, Oneshot_Maildrop( Void -> List( g::Box ) ))
          ;

#  +DEBUG 
	fun seqn_to_string n
            =
            u::format string_conversion::DEC n;

	fun dump_pending_q (seqn, ([], []))
		=>
		xtracing::err_trace .{ cat [ "PendingQ(", seqn_to_string seqn, "): empty\n" ]; };

	    dump_pending_q (seqn, (front, rear))
		=>
		{
		    fun item2s (ERROR_CHECK       (n, _)) => "  ERROR_CHECK #"    + (seqn_to_string n) + "\n";
			item2s (ONE_REPLY         (n, _)) => "  ONE_REPLY #"      + (seqn_to_string n) + "\n";
			item2s (MULTI_REPLY (n, _, _, _)) => "  MULTI_REPLY #"    + (seqn_to_string n) + "\n";
			item2s (EXPOSURE_REPLY    (n, _)) => "  EXPOSURE_REPLY #" + (seqn_to_string n) + "\n";
		    end;

		    fun dump ([], l)    =>  reverse l;
			dump (x ! r, l) =>  dump (r, (item2s x) ! l);
		    end;

		    xtracing::err_trace .{ 

			cat ( "PendingQ("
                            ! (seqn_to_string seqn)
                            ! "):\n"
			    ! (dump (front @ (reverse rear), []))
			    );
		    };
		};
	end;
#  -DEBUG 

	fun seqn_of (ERROR_CHECK    (seqn, _      )) =>  seqn;
	    seqn_of (ONE_REPLY      (seqn, _      )) =>  seqn;
	    seqn_of (MULTI_REPLY    (seqn, _, _, _)) =>  seqn;
	    seqn_of (EXPOSURE_REPLY (seqn, _      )) =>  seqn;
	end;

	fun send_reply arg
	    =
	    {   make_thread "xok reply" .{  give arg;  };
		();
	    };

	fun send_replies (slot, replies)
	    =
	    {   fun loop []
			=>
			();

		    loop (s ! rest)
			=>
			{   give (slot, REPLY s);
			    loop rest;
			};
		end;

		make_thread "xok replies"  .{
		    #
		    loop (reverse replies);
		};

		();
	    };

	fun insert (x, (front, rear))
	    =
	    (front, x ! rear);


	# Synchronize the queue of outstanding
        # requests with the sequence number n.
	#
	# Return the pair (f, q) where:
        #    q  is the synchronized queue.
        #    f  is TRUE iff the head of q has sequence number n.
	#	
	fun sync_outstanding_q (n, q)
	    =
	    scan q
	    where

		fun discard_reply (ERROR_CHECK(_, slot)) => send_reply (slot, REPLY empty_v);
		    discard_reply (ONE_REPLY  (_, slot)) => send_reply (slot, REPLY_LOST);

		    discard_reply (MULTI_REPLY(_, slot, _, []     )) => send_reply   (slot, REPLY_LOST);
		    discard_reply (MULTI_REPLY(_, slot, _, replies)) => send_replies (slot, replies);

		    discard_reply (EXPOSURE_REPLY(_, sync_1shot))
			=>
			set  (sync_1shot,  fn () = raise exception LOST_REPLAY);
		end;


		fun scan (q' as ([], []))
			=>
			(FALSE, q');

		    scan ([], rear)
			=>
			scan (reverse rear, []);

		    scan (q' as ((rpend ! r), rear))
			=>
			{   seqn = seqn_of rpend;

			    if (seqn < n)
				 discard_reply rpend;
				 scan (r, rear);
			    else
				 seqn > n  ??   (FALSE, q')
					   ::   (TRUE,  q');
			    fi;
			};
		  end;
	    end;

	# Extract the outstanding request corresponding
        # to the given reply message (with sequence number n).
	#
	# If all of the expected replies have been received then
	# send the extracted reply to the requesting client.
	#
	fun extract_reply (n, reply, q)
	    =
	    case (sync_outstanding_q (n, q))
		#
	        (TRUE, (ONE_REPLY(_, slot) ! r, rear))
		    =>
		    {   send_reply (slot, REPLY reply);
			(r, rear);
		    };

		(TRUE, (MULTI_REPLY (seqn, slot, remain, replies) ! r, rear))
		    =>
		    if ((remain reply) == 0)
			 send_replies (slot, reply ! replies);
			 (r, rear);
		    else
			 (MULTI_REPLY (seqn, slot, remain, reply ! replies) ! r, rear);
		    fi;

	       _ => 
		    {   # Debug support:
			#	
			dump_pending_q (n, q);
			xgripe::impossible "[xok::extract_reply: bogus pending reply queue]";
		    };
	   esac;


	# Extract the outstanding request corresponding
	# to the given exposure message (with seqence number n).
	#
	fun extract_expose (n, reply, q)
	    =
	    {   case (sync_outstanding_q (n, q))
		    #
		    (TRUE, (EXPOSURE_REPLY(_, sync_1shot) ! r, rear))
			=>
			{    set  (sync_1shot,  fn () = reply);

			     (r, rear);
			};

		    # For now, just drop it.
		    # When the gc-server supports graphics-exposures,
		    # these shouldn't happen:
		    #
		    _ => q;

		esac;

 /* +DEBUG 
 (dumpPendingQ (n, q);
 xgripe::impossible "[xok::extract_expose: bogus pending reply queue]")
 -DEBUG */
	    };

	# Extract the outstanding request
	# corresponding to the given
	# error message (with seqence number n):
	#
	fun extract_err (n, err, q)
	    = 
	    case (sync_outstanding_q (n, q))
		#
		(TRUE, (ERROR_CHECK(_, slot) ! r, rear))
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(r, rear);
		    };

		(TRUE, (ONE_REPLY(_, slot) ! r, rear))
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(r, rear);
		    };

		(TRUE, (MULTI_REPLY(_, slot, _, _) ! r, rear))
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(r, rear);
		    };

		(TRUE, (EXPOSURE_REPLY(_, sync_1shot) ! r, rear))
		    =>
		    {   set  (sync_1shot,  fn () = raise exception ERROR_REPLY (wire_to_value::decode_error err));
			(r, rear);
		    };

		(FALSE, q')
		    =>
		    q';

		_   =>
/* DEBUG */         {   dump_pending_q (n, q);
                        xgripe::impossible "[xok::extract_err: bogus pending reply queue]";
/* DEBUG */         };
	    esac;


	fun sync_with_xevent (n, q)
	    =
	    case (sync_outstanding_q (n, q))
		#
		(TRUE, (ERROR_CHECK(_, slot) ! r, rear))
                    =>
                    {   send_reply (slot, REPLY empty_v);
                        (r, rear);
                    };

		(_, q) => q;
	    esac;

    herein

	fun sequencer
            ( plea_slot,		# Traffic (requests) from client threads.
              from_x_slot,		# Traffic from X server (via buffer thread).
              to_x_slot,		# Traffic to   X server (via buffer thread).
              to_xbuf_slot,		# Traffic (request replies) to client threads.
              error_sink_slot		# Where we send error messages.
            )
            ()
            =
	    loop
              ( 0u0,
                0u0,
                ( [],
                  []
                )
              )
            where

		fun quit ()
                    =
                    {   give (to_x_slot, OUTBUF_QUIT);
                        thread_done ();
                    };

		from_x'  = take'  from_x_slot;
		request' = take'  plea_slot;

		fun send_request (req, (last_in, last_out, pending))
                    =
                    {   give (to_x_slot, OUTBUF_MAIL req);
		        (last_in, last_out+0u1, pending);
                    };

		fun send_request_and_check ((req, reply_slot), (last_in, last_out, pending))
                    =
                    {   n = last_out+0u1;

			give (to_x_slot, OUTBUF_MAIL req);

			(last_in, n, insert (ERROR_CHECK (n, reply_slot), pending));
		    };

		fun send_request_reply ((req, reply_slot), (last_in, last_out, pending))
                    =
                    {   n = last_out+0u1;

			give (to_x_slot, OUTBUF_MAIL req);

			(last_in, n, insert (ONE_REPLY (n, reply_slot), pending));
		    };

		fun send_request_replies ((req, reply_slot, remain), (last_in, last_out, pending))
                    =
                    {   n = last_out+0u1;

			give (to_x_slot, OUTBUF_MAIL req);

			(last_in, n, insert (MULTI_REPLY (n, reply_slot, remain, []), pending));
		    };

		fun send_request_exposures ((req, sync_v), (last_in, last_out, pending))
                    =
                    {   n = last_out+0u1;

			give (to_x_slot, OUTBUF_MAIL req);

			(last_in, n, insert (EXPOSURE_REPLY (n, sync_v), pending));
		    };

	        # Gobble requests w/o blocking
                # and then flush the buffer:
                #
		fun gobble_and_flush arg
                    =
                    {   fun loop arg
                            =
                            case (nonblocking_take  plea_slot)
				#
				THE PLEA_FLUSH           =>  loop arg;
				THE PLEA_QUIT            =>  quit ();

				THE (PLEA           req) =>  loop (send_request           (req, arg));
				THE (PLEA_AND_CHECK req) =>  loop (send_request_and_check (req, arg));

				THE (PLEA_REPLY     req) =>  loop (send_request_reply     (req, arg));
				THE (PLEA_REPLIES   req) =>  loop (send_request_replies   (req, arg));
				THE (PLEA_EXPOSURES req) =>  loop (send_request_exposures (req, arg));

				NULL                        =>  arg;
                            esac;

			result = loop arg;

			give (to_x_slot, OUTBUF_FLUSH);

			result;
		    };

	        # This is the main sequencer loop.  We track
                # the sequence number of the last message in,
                # the sequence number of the last message out,
	        # and the queue of pending requests.
	        #
		fun loop (arg as (last_req_in, last_req_out, pending))
                    =
                    {
		        # Handle a request from a client:
			# 
			fun do_plea PLEA_FLUSH => gobble_and_flush arg;
			    do_plea PLEA_QUIT  => quit();

			    do_plea (PLEA_AND_CHECK req) =>  gobble_and_flush (send_request_and_check (req, arg));
			    do_plea (PLEA_REPLY     req) =>  gobble_and_flush (send_request_reply     (req, arg));
			    do_plea (PLEA_REPLIES   req) =>  gobble_and_flush (send_request_replies   (req, arg));
			    do_plea (PLEA_EXPOSURES req) =>  gobble_and_flush (send_request_exposures (req, arg));

			    do_plea (PLEA req)
                                =>
                                {   give (to_x_slot, OUTBUF_MAIL req);

			            (last_req_in, last_req_out+0u1, pending);
                                };

                        end;

			# Handle a server-message
			# from the input buffer:
			#	
			fun do_from_x { code:  unt8::Unt, msg }
                            =
                            {
				# NOTE: this doesn't work if there are 2**17
                                # outgoing messages between replies/events.
				#
                                # We need to track (last_req_out - last_req_in),
				# and if it gets bigger than some reasonable size,
                                # generate a synchronization (i.e., get_input_focus message).	XXX BUGGO FIXME

				fun get_seq_n ()
				    =
				    {   short_seq_n
					    =
                                            u::from_large_unt (pack_big_endian_unt16::get_vec (msg, 1));

					seqn' = u::bitwise_or
                                                  ( u::bitwise_and (last_req_in, u::bitwise_not 0uxffff),
					            short_seq_n
                                                  );

					seqn' < last_req_in
					  ??  seqn' + 0ux10000		#  NOTE: we should check for (seqn' + 0x10000) > lastReqOut    XXX BUGGO FIXME
					  ::  seqn';
				    };

				case code
				    #
				    0u0 =>  {   # Error message:

				                seqn = get_seq_n();

						give (error_sink_slot, (seqn, msg));

						(seqn, last_req_out, extract_err (seqn, msg, pending));
				      	    };

				    0u1 =>  {	# Reply message:

						seqn = get_seq_n();

				        	(seqn, last_req_out, extract_reply (seqn, msg, pending));
				      	    };

				    0u11 => {	# KeymapNotify event:

				      		give (to_xbuf_slot, (code, msg));

						( last_req_in,
                                                  last_req_out,
						  sync_with_xevent (last_req_in, pending)
						);
                                            };

				    0u13 => {	# GraphicsExpose event:

						seqn = get_seq_n();

						include event_types;

						fun pack (result_list, GRAPHICS_EXPOSE_XEVENT { box, count=>0, ... } )
                                                        =>
						        box ! result_list;

						    pack (result_list, GRAPHICS_EXPOSE_XEVENT { box, ... } )
                                                        =>
						        case (take  from_x_slot)

							    { code => 0u13, msg=>s }
                                                                =>
							        pack (box ! result_list, wire_to_value::decode_graphics_expose s);

							    _   =>
                                                                {   xgripe::warning  "[xok::sequencer: misleading GraphicsExpose count]";

							            box ! result_list;
                                                                };
                                                        esac;
						end;

						boxes = pack ([], wire_to_value::decode_graphics_expose msg);

						( seqn,
						  last_req_out,
						  extract_expose (seqn, boxes, pending)
						);
				            };

				    0u14 => {	# NoExpose event:

						seqn = get_seq_n();

						(seqn, last_req_out, extract_expose (seqn, [], pending));
				      	    };

				    _    => {	# Other event messages:

						seqn = get_seq_n();

						give (to_xbuf_slot, (code, msg));

						(seqn, last_req_out, sync_with_xevent (seqn, pending));
				      	    };
				esac;
			    };						# fun do_from_x

			loop
                          ( select [
				#
			        request' ==>  do_plea,
			        from_x'  ==>  do_from_x
			    ]
                          );
		    };			# fun loop 
	    end;			# fun sequencer 
    end;				# stipulate


    # The X-event buffer **
    #
    # The X-event buffer decodes and buffers X-events.
    # This thread also packs expose events.
    # 
    # It communicates via two mailslots as follows:
    #   from_sequencer_slot      --  raw messages from the sequencer
    #   to_window_registry_slot  --  decoded events to the window registry
    #
    fun xbuf (from_sequencer_slot, to_window_registry_slot)
        =
	route_p
        where

	    include event_types;

	    fun decode (k, s)
                =
                #2 (wire_to_value::decode_xevent (k, s));

	    fun pack_expose_events (e as EXPOSE_XEVENT { window, ... } )
		=
		EXPOSE_XEVENT { window, boxes => pack([], e), count => 0 }
                where
		    fun pack (rl, EXPOSE_XEVENT { boxes, count=>0, ... } )
                            =>
                            boxes@rl;

			pack (rl, EXPOSE_XEVENT { boxes, ... } )
                            =>
			    pack  (boxes @ rl,  decode (take  from_sequencer_slot));

			pack (rl, _)
                            =>
                            {   xgripe::warning "[xok::sequencer: misleading Expose count]";
			        rl;
                            };
		    end;
		end;

	    fun do_xevent (msg, q)
		=
		case (decode msg)
		    #
		    (e as EXPOSE_XEVENT _)
                        =>
                        pack_expose_events e  !  q;

		    e => (e ! q);
		esac;

	    take_xevent' = take'  from_sequencer_slot;

	    fun route_p ()
		=
		loop ([], [])
		where
		    fun loop ([], [])
			    =>
			    loop  (do_xevent  (take  from_sequencer_slot,  []),  []);

			loop ([], rear)
			    =>
			    loop (reverse rear, []);

			loop (front as (x ! rest), rear)
			    =>
			    loop (
				select [
				    #
				    take_xevent'
					==>
					(fn mail = (front, do_xevent (mail, rear))),

				    give' (to_window_registry_slot, x)
					==>
					.{  (rest, rear);  }
				]
			    );
		    end;
		end;
	end;					# fun xbuf


    # The connection:
    #
    Xsocket
        =
        XSOCKET
	  {
	    xsocket_id:  Ref( Void ),

	    xevent_slot:    Mailslot( event_types::Xevent ),
	    plea_slot:      Mailslot( Plea_Mail ),
	    xerror_slot:    Mailslot( (u::Unt, v8::Vector) ),

	    flush:    Void -> Void,
	    close:    Void -> Void
	  };

    # Create the threads and internal mailslots
    # to manage a connection to the X server.
    #
    # We assume that the connection request/reply
    # has already been dealt with.
    #
    # This function is currently called from only
    # one place in
    #     src/lib/x-kit/xclient/src/wire/display.pkg
    #
    fun make_xsocket  socket
        =
        {   inbuf_to_sequencer_slot  = make_mailslot ();
            sequencer_to_outbuf_slot = make_mailslot ();

	    xbuf_to_client_slot      = make_mailslot ();
            sequencer_to_xbuf_slot   = make_mailslot ();

	    client_to_sequencer_slot = make_mailslot ();
            xerror_slot              = make_mailslot ();

#	    expose_strm = make_mailslot ();

	    fun flush_fn ()
                =
                give (client_to_sequencer_slot, PLEA_FLUSH);

	    fun close_fn ()
                =
                {   xtracing::print_if xtracing::io_tracing .{ "close connection."; };

		    flush_fn();

                    give (client_to_sequencer_slot, PLEA_QUIT);
                };
	  
/******
		    make_thread "xok seq"  (sequencer (reqStrm, inStrm, outStrm, xevtMsgStrm, errStrm));
		    make_thread "xok in"   (inbuf (inStrm, socket));
		    make_thread "xok out"  (outbuf (outStrm, socket));
		    make_thread "xok buf"  (xeventBuffer (xevtMsgStrm, xevtStrm));
******/
/* DEBUG */         xtracing::xspawn
		      ( "Sequencer",
                        sequencer
			  ( client_to_sequencer_slot,
			    inbuf_to_sequencer_slot,
			    sequencer_to_outbuf_slot,
			    sequencer_to_xbuf_slot,
			    xerror_slot
			  )
		      );

/* DEBUG */         xtracing::xspawn ("Inbuf",        inbuf  ( inbuf_to_sequencer_slot, socket));
/* DEBUG */         xtracing::xspawn ("Outbuf",       outbuf (sequencer_to_outbuf_slot, socket));
/* DEBUG */         xtracing::xspawn ("XEventBuffer", xbuf   (  sequencer_to_xbuf_slot, xbuf_to_client_slot));

		    XSOCKET
                      { xsocket_id => REF (),

			xevent_slot  => xbuf_to_client_slot,
			plea_slot => client_to_sequencer_slot,
			xerror_slot,

			flush   => flush_fn,
			close   => close_fn
		      };
	  };

    fun close_xsocket (XSOCKET { close, ... } )
        =
        close ();

    fun same_xsocket (XSOCKET { xsocket_id=>a, ... }, XSOCKET { xsocket_id=>b, ... } )
        =
        a == b;

    fun request (XSOCKET { plea_slot, ... } ) s
        =
        give (plea_slot, PLEA s);

    fun reply_wrapper  REPLY_LOST     =>  raise exception LOST_REPLAY;
	reply_wrapper (REPLY_ERROR s) =>  raise exception ERROR_REPLY (wire_to_value::decode_error s);
	reply_wrapper (REPLY s)       =>  s;
    end;


    # NOTE: these should be done using a guard mailop eventually 	XXX BUGGO FIXME

    # This is a workhorse call,
    # request-with-single-reply:
    # 
    fun request_reply (XSOCKET { plea_slot, ... } ) s
        =
        {   reply_slot = make_mailslot ();
	  
	    give (plea_slot, PLEA_REPLY (s, reply_slot));

	    take'  reply_slot
                ==>
                reply_wrapper;
	};

    # Generate a request to the server and
    # check on its successful completion. 
    #
    # The only uses of this I find are:
    #
    #     property::change_property  in
    #         src/lib/x-kit/xclient/src/iccc/window-property.pkg
    #
    #     font_imp::open_font  in
    #         src/lib/x-kit/xclient/src/window/font-imp.pkg
    #     
    # In both cases the idea is to wait for
    # successful completion of the op before
    # continuing.
    #
    fun request_and_check (XSOCKET { plea_slot, ... } ) s
        =
        {   reply_slot1 = make_mailslot ();
            reply_slot2 = make_mailslot ();

	    give (plea_slot, PLEA_AND_CHECK (s, reply_slot1));
	    give (plea_slot, PLEA_REPLY (value_to_wire::request_get_input_focus, reply_slot2));

	    take' reply_slot1
                ==>
		fn (REPLY_ERROR s) =>  raise exception ERROR_REPLY (wire_to_value::decode_error s);
		   _               =>  ();
		end;
	};

    # I cannot find any code which actually uses this:
    #
    fun request_replies
            (XSOCKET { plea_slot, ... } )
            (s, remain)
        =
        {   reply_slot = make_mailslot ();
	  
	    give (plea_slot, PLEA_REPLIES (s, reply_slot, remain));

	    take'  reply_slot
		==>
		reply_wrapper;
	};

    # This is directly used exactly once,
    # by draw_imp::flush_buf, and ultimately
    # used twice, by DOP_COPY_AREA and DOP_COPY_PLANE
    # in draw_imp:
    #
    fun request_with_exposures
	    (XSOCKET { plea_slot, ... } )
	    (s, sync_v)
        =
        {   reply_slot = make_mailslot ();
	  
	    give (plea_slot, PLEA_EXPOSURES (s, sync_v));
	};

    fun flush (XSOCKET { flush, ... } )
        =
        flush ();

    fun wait_for_xevent (XSOCKET { xevent_slot, ... } )
        =
        take'  xevent_slot;

    fun read_xerror     (XSOCKET { xerror_slot,  ... } )
        =
        take  xerror_slot;

};		#  Xok 



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
