api Mdl_Tokens {
    Token (X,Y);
    Semantic_Value;
    eof_t: (X, X) -> Token (Semantic_Value,X);
    asmtext_t: ((String), X, X) -> Token (Semantic_Value,X);
    char_t: ((Char), X, X) -> Token (Semantic_Value,X);
    string_t: ((String), X, X) -> Token (Semantic_Value,X);
    real_t: ((String), X, X) -> Token (Semantic_Value,X);
    intinf: ((integer::Int), X, X) -> Token (Semantic_Value,X);
    int: ((Int), X, X) -> Token (Semantic_Value,X);
    word: ((unt32::Unt), X, X) -> Token (Semantic_Value,X);
    tyvar: ((String), X, X) -> Token (Semantic_Value,X);
    symbol: ((String), X, X) -> Token (Semantic_Value,X);
    id: ((String), X, X) -> Token (Semantic_Value,X);
    exception_t: (X, X) -> Token (Semantic_Value,X);
    equation: (X, X) -> Token (Semantic_Value,X);
    latency: (X, X) -> Token (Semantic_Value,X);
    table: (X, X) -> Token (Semantic_Value,X);
    reservation: (X, X) -> Token (Semantic_Value,X);
    cpu: (X, X) -> Token (Semantic_Value,X);
    resource: (X, X) -> Token (Semantic_Value,X);
    aliasing: (X, X) -> Token (Semantic_Value,X);
    aggregable: (X, X) -> Token (Semantic_Value,X);
    candidate_colon: (X, X) -> Token (Semantic_Value,X);
    padding_colon: (X, X) -> Token (Semantic_Value,X);
    nullified_colon: (X, X) -> Token (Semantic_Value,X);
    delayslot_colon: (X, X) -> Token (Semantic_Value,X);
    rtl_colon: (X, X) -> Token (Semantic_Value,X);
    mc_colon: (X, X) -> Token (Semantic_Value,X);
    asm_colon: (X, X) -> Token (Semantic_Value,X);
    debug_t: (X, X) -> Token (Semantic_Value,X);
    infixr_t: (X, X) -> Token (Semantic_Value,X);
    infix_t: (X, X) -> Token (Semantic_Value,X);
    nonfix_t: (X, X) -> Token (Semantic_Value,X);
    candidate: (X, X) -> Token (Semantic_Value,X);
    backwards: (X, X) -> Token (Semantic_Value,X);
    never: (X, X) -> Token (Semantic_Value,X);
    always: (X, X) -> Token (Semantic_Value,X);
    forwards: (X, X) -> Token (Semantic_Value,X);
    delayslot: (X, X) -> Token (Semantic_Value,X);
    assign: (X, X) -> Token (Semantic_Value,X);
    dependent: (X, X) -> Token (Semantic_Value,X);
    span: (X, X) -> Token (Semantic_Value,X);
    rtl: (X, X) -> Token (Semantic_Value,X);
    assembly: (X, X) -> Token (Semantic_Value,X);
    taken: (X, X) -> Token (Semantic_Value,X);
    branching: (X, X) -> Token (Semantic_Value,X);
    when: (X, X) -> Token (Semantic_Value,X);
    verbatim: (X, X) -> Token (Semantic_Value,X);
    uppercase: (X, X) -> Token (Semantic_Value,X);
    lowercase: (X, X) -> Token (Semantic_Value,X);
    predicated: (X, X) -> Token (Semantic_Value,X);
    pipeline: (X, X) -> Token (Semantic_Value,X);
    endian: (X, X) -> Token (Semantic_Value,X);
    big: (X, X) -> Token (Semantic_Value,X);
    little: (X, X) -> Token (Semantic_Value,X);
    op_t: (X, X) -> Token (Semantic_Value,X);
    open: (X, X) -> Token (Semantic_Value,X);
    include_t: (X, X) -> Token (Semantic_Value,X);
    my_t: (X, X) -> Token (Semantic_Value,X);
    fun_t: (X, X) -> Token (Semantic_Value,X);
    withtype_t: (X, X) -> Token (Semantic_Value,X);
    encoding: (X, X) -> Token (Semantic_Value,X);
    as_t: (X, X) -> Token (Semantic_Value,X);
    formats: (X, X) -> Token (Semantic_Value,X);
    unsigned: (X, X) -> Token (Semantic_Value,X);
    signed: (X, X) -> Token (Semantic_Value,X);
    superscalar: (X, X) -> Token (Semantic_Value,X);
    vliw: (X, X) -> Token (Semantic_Value,X);
    fields: (X, X) -> Token (Semantic_Value,X);
    field_t: (X, X) -> Token (Semantic_Value,X);
    ordering: (X, X) -> Token (Semantic_Value,X);
    cells: (X, X) -> Token (Semantic_Value,X);
    cell: (X, X) -> Token (Semantic_Value,X);
    register: (X, X) -> Token (Semantic_Value,X);
    instruction: (X, X) -> Token (Semantic_Value,X);
    sharing_t: (X, X) -> Token (Semantic_Value,X);
    where_t: (X, X) -> Token (Semantic_Value,X);
    struct: (X, X) -> Token (Semantic_Value,X);
    begin_api: (X, X) -> Token (Semantic_Value,X);
    api_t: (X, X) -> Token (Semantic_Value,X);
    generic_t: (X, X) -> Token (Semantic_Value,X);
    package_t: (X, X) -> Token (Semantic_Value,X);
    let_t: (X, X) -> Token (Semantic_Value,X);
    except_t: (X, X) -> Token (Semantic_Value,X);
    raise_t: (X, X) -> Token (Semantic_Value,X);
    wild: (X, X) -> Token (Semantic_Value,X);
    false: (X, X) -> Token (Semantic_Value,X);
    true: (X, X) -> Token (Semantic_Value,X);
    else_t: (X, X) -> Token (Semantic_Value,X);
    then_t: (X, X) -> Token (Semantic_Value,X);
    if_t: (X, X) -> Token (Semantic_Value,X);
    bits: (X, X) -> Token (Semantic_Value,X);
    par: (X, X) -> Token (Semantic_Value,X);
    darrow: (X, X) -> Token (Semantic_Value,X);
    arrow: (X, X) -> Token (Semantic_Value,X);
    bar: (X, X) -> Token (Semantic_Value,X);
    at: (X, X) -> Token (Semantic_Value,X);
    dotdot: (X, X) -> Token (Semantic_Value,X);
    dot: (X, X) -> Token (Semantic_Value,X);
    colongreater: (X, X) -> Token (Semantic_Value,X);
    colon: (X, X) -> Token (Semantic_Value,X);
    comma: (X, X) -> Token (Semantic_Value,X);
    hash: (X, X) -> Token (Semantic_Value,X);
    locations: (X, X) -> Token (Semantic_Value,X);
    storage: (X, X) -> Token (Semantic_Value,X);
    fn_t: (X, X) -> Token (Semantic_Value,X);
    cellset: (X, X) -> Token (Semantic_Value,X);
    rmeta: (X, X) -> Token (Semantic_Value,X);
    lmeta: (X, X) -> Token (Semantic_Value,X);
    rdquote: (X, X) -> Token (Semantic_Value,X);
    ldquote: (X, X) -> Token (Semantic_Value,X);
    semicolon: (X, X) -> Token (Semantic_Value,X);
    rbrace: (X, X) -> Token (Semantic_Value,X);
    lbrace: (X, X) -> Token (Semantic_Value,X);
    rbracket: (X, X) -> Token (Semantic_Value,X);
    lbracket: (X, X) -> Token (Semantic_Value,X);
    rparen: (X, X) -> Token (Semantic_Value,X);
    lparen: (X, X) -> Token (Semantic_Value,X);
    lhashbracket: (X, X) -> Token (Semantic_Value,X);
    rrbracket: (X, X) -> Token (Semantic_Value,X);
    llbracket: (X, X) -> Token (Semantic_Value,X);
    meld: (X, X) -> Token (Semantic_Value,X);
    not: (X, X) -> Token (Semantic_Value,X);
    deref: (X, X) -> Token (Semantic_Value,X);
    and_t: (X, X) -> Token (Semantic_Value,X);
    times: (X, X) -> Token (Semantic_Value,X);
    dollar: (X, X) -> Token (Semantic_Value,X);
    eq: (X, X) -> Token (Semantic_Value,X);
    type_t: (X, X) -> Token (Semantic_Value,X);
    datatype: (X, X) -> Token (Semantic_Value,X);
    case_t: (X, X) -> Token (Semantic_Value,X);
    of_t: (X, X) -> Token (Semantic_Value,X);
    in_t: (X, X) -> Token (Semantic_Value,X);
    local_t: (X, X) -> Token (Semantic_Value,X);
    end_t: (X, X) -> Token (Semantic_Value,X);
    architecture: (X, X) -> Token (Semantic_Value,X);
};
api Mdl_Lrvals{
    package tokens:  Mdl_Tokens;
    package parser_data: Parser_Data;
    sharing parser_data::token::Token == tokens::Token;
    sharing parser_data::Semantic_Value == tokens::Semantic_Value;
};
