## window.pkg
#
# See also:
#     src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#     src/lib/x-kit/xclient/src/window/rw-pixmap.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6


###                 "The first rule of discovery is to have brains and good luck.
###                  The second rule of discovery is to sit tight and wait till you get a bright idea."
###
###                                                     -- Geore Polya



stipulate
    include threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package at  =  atom;				# atom				is from   src/lib/x-kit/xclient/src/iccc/atom.pkg
    package cs  =  cursors;				# cursors			is from   src/lib/x-kit/xclient/src/window/cursors.pkg
    package di  =  draw_imp;				# draw_imp			is from   src/lib/x-kit/xclient/src/window/draw-imp.pkg
    package dt  =  draw_types;				# draw_types			is from   src/lib/x-kit/xclient/src/window/draw-types.pkg
    package dy  =  display;				# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package e2s =  xerror_to_string;			# xerror_to_string		is from   src/lib/x-kit/xclient/src/to-string/xerror-to-string.pkg
    package et  =  event_types;				# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package ge  =  geometry;				# geometry			is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    package ip  =  iccc_property;			# iccc_property			is from   src/lib/x-kit/xclient/src/iccc/iccc-property.pkg
    package s2w =  sendevent_to_wire;			# sendevent_to_wire		is from   src/lib/x-kit/xclient/src/wire/sendevent-to-wire.pkg
    package sa  =  standard_x11_atoms;			# standard_x11_atoms		is from   src/lib/x-kit/xclient/src/iccc/standard-x11-atoms.pkg
    package sn  =  xsession;				# xsession			is from   src/lib/x-kit/xclient/src/window/xsession.pkg
    package v2w =  value_to_wire;			# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;			# wire_to_value			is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package wio =  window_io;				# window_io			is from   src/lib/x-kit/xclient/src/wire/window-io.pkg
    package wr  =  topwindow_to_widget_router;       	# topwindow_to_widget_router	is from   src/lib/x-kit/xclient/src/window/topwindow-to-widget-router.pkg
    package xok =  xsocket;				# xsocket			is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package xt  =  xtypes;				# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
herein

    package window: (weak)  Window {			# Window			is from   src/lib/x-kit/xclient/src/window/window.api

	Window = dt::Window;

	# Set the value of a property:
	#
	fun set_property (xsession, window_id, name, value)
	    =
	    sn::request  xsession
		#
		(v2w::encode_change_property
		  {
		    window_id,
		    name,
		    property =>  value,
		    mode     =>  xt::REPLACE_PROPERTY
		  }
		);

	# User-level window attributes:
	#
	package a {

	    Window_Attribute
	      #
	      = BACKGROUND_NONE
	      | BACKGROUND_PARENT_RELATIVE
	      | BACKGROUND_RW_PIXMAP   	      dt::Rw_Pixmap
	      | BACKGROUND_RO_PIXMAP          dt::Ro_Pixmap
	      | BACKGROUND_COLOR              rgb::Rgb
	      #
	      | BORDER_COPY_FROM_PARENT
	      | BORDER_RW_PIXMAP       	      dt::Rw_Pixmap
	      | BORDER_RO_PIXMAP              dt::Ro_Pixmap
	      | BORDER_COLOR                  rgb::Rgb
	      #
	      | BIT_GRAVITY                   xt::Gravity
	      | WINDOW_GRAVITY                xt::Gravity
	      #
	      | CURSOR_NONE
	      | CURSOR                        cs::Xcursor
	      ;
	};

	# Window configuration values:
	#
	package c {

	    Window_Config
	      #
	      = ORIGIN      ge::Point
	      | SIZE        ge::Size
	      | BORDER_WID  Int
	      | STACK_MODE                   xt::Stack_Mode
	      | REL_STACK_MODE  (dt::Window, xt::Stack_Mode)
	      ;
	};

	# Extract the Rgb8 from a color:
	#
	fun rgb8_of rgb
	    =
	    rgb8::from_rgb rgb;

	# Map user-level window attributes
	# to internal x-window attributes: 
	#
	fun user_window_attribute_to_internal_window_attribute (a::BACKGROUND_NONE)
		=>
		xt::wa::BACKGROUND_PIXMAP_NONE;

	    user_window_attribute_to_internal_window_attribute (a::BACKGROUND_PARENT_RELATIVE)
		=>
		xt::wa::BACKGROUND_PIXMAP_PARENT_RELATIVE;

	    user_window_attribute_to_internal_window_attribute (a::BACKGROUND_RW_PIXMAP (dt::RW_PIXMAP { id, ... } ))
		=>
		xt::wa::BACKGROUND_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (a::BACKGROUND_RO_PIXMAP (dt::RO_PIXMAP (dt::RW_PIXMAP { id, ... } ))) 
	       => 
		xt::wa::BACKGROUND_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (a::BACKGROUND_COLOR color)
		=>
		xt::wa::BACKGROUND_PIXEL (rgb8_of color);

	    user_window_attribute_to_internal_window_attribute (a::BORDER_COPY_FROM_PARENT)
		=>
		xt::wa::BORDER_PIXMAP_COPY_FROM_PARENT;

	    user_window_attribute_to_internal_window_attribute (a::BORDER_RW_PIXMAP (dt::RW_PIXMAP { id, ... } ))
		=>
		xt::wa::BORDER_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (a::BORDER_RO_PIXMAP (dt::RO_PIXMAP (dt::RW_PIXMAP { id, ... } )))
		=>
		xt::wa::BORDER_PIXMAP id;

	    user_window_attribute_to_internal_window_attribute (a::BORDER_COLOR color)
		=>
		xt::wa::BORDER_PIXEL (rgb8_of color);

	    user_window_attribute_to_internal_window_attribute (a::BIT_GRAVITY g)
		=>
		xt::wa::BIT_GRAVITY g;

	    user_window_attribute_to_internal_window_attribute (a::WINDOW_GRAVITY g)
		=>
		xt::wa::WINDOW_GRAVITY g;

	    user_window_attribute_to_internal_window_attribute (a::CURSOR_NONE)
		=>
		xt::wa::CURSOR_NONE;

	    user_window_attribute_to_internal_window_attribute (a::CURSOR (cs::XCURSOR { id, ... } ))
		=>
		xt::wa::CURSOR id;
	end;


	map_attributes
	    =
	    list::map  user_window_attribute_to_internal_window_attribute;

	standard_xevent_mask
	    =
	    et::mask_of_xevent_list
	      [
		et::n::KEY_PRESS,
		et::n::KEY_RELEASE,
		et::n::BUTTON_PRESS,
		et::n::BUTTON_RELEASE,
		et::n::POINTER_MOTION,
		et::n::ENTER_WINDOW,
		et::n::LEAVE_WINDOW,
		et::n::EXPOSURE,
		et::n::STRUCTURE_NOTIFY,
		et::n::SUBSTRUCTURE_NOTIFY,
                et::n::PROPERTY_CHANGE
	      ];

	popup_xevent_mask
	    =
	    et::mask_of_xevent_list
	      [
		et::n::EXPOSURE,
		et::n::STRUCTURE_NOTIFY,
		et::n::SUBSTRUCTURE_NOTIFY
	      ];

	exception BAD_WINDOW_SITE;

	fun check_site g
	    =
	    if (ge::valid_site g)   g;
	    else                   raise exception  BAD_WINDOW_SITE;
	    fi;

	fun make_simple_top_window (screen as sn::SCREEN { screen=>screen_info, xsession } )
	    =
	    create_fn
	    where 
		screen_info ->  sn::SCREEN_INFO       { xscreen  => dy::XSCREEN { root_window_id, ... }, root_imps, ... };
		root_imps   ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession    ->  sn::XSESSION          { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid ();

		my (kidplug, window, delete_slot)
		    =
		    wr::make_topwindow_to_widget_router
			#
			(screen, root_imps, window_id);

		fun create_fn { site, border_color, background_color }
		    =
		    {
			wio::create_window  xsocket
			  {
			    depth,
			    #
			    window_id,
			    parent_window_id   => root_window_id,
			    #
			    io_class    => xt::INPUT_OUTPUT,
			    visual_id   => xt::SAME_VISUAL_AS_PARENT,
			    #
			    site        => check_site site,
			    #
			    attributes
				=>
				[ xt::wa::BORDER_PIXEL     (rgb8_of  border_color),
				  xt::wa::BACKGROUND_PIXEL  background_color,
				  xt::wa::EVENT_MASK        standard_xevent_mask
				]
			  };


			(window, kidplug, delete_slot);
		    };
	    end;

	fun make_simple_subwindow (dt::WINDOW { window_id=>parent_window_id, screen, draw_fn, screen_depth, ... } )
	    =
	    create_fn
	    where 

		screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... }, ... };

		window_id = next_xid();

		window
		    =
		    dt::WINDOW
                      {
		        window_id,
		        screen,
		        draw_fn,
		        screen_depth
		      };

		screen_depth ->   sn::SCREEN_DEPTH_IMPS { depth, ... };

		fun create_fn { site, border_color, background_color }
		    =
		    {   border_pixel
			    =
			    case border_color
				#
				NULL  =>   xt::wa::BORDER_PIXMAP_COPY_FROM_PARENT;
				THE c =>   xt::wa::BORDER_PIXEL (rgb8_of c);
			    esac;


			background_pixel
			    =
			    case background_color
				#
				NULL  =>   xt::wa::BACKGROUND_PIXMAP_PARENT_RELATIVE;
				THE c =>   xt::wa::BACKGROUND_PIXEL c;
			    esac;


			  wio::create_window   xsocket
                            {
			      window_id,
			      parent_window_id,
			      #	
			      io_class   => xt::INPUT_OUTPUT,
			      depth,
			      #	
			      visual_id  => xt::SAME_VISUAL_AS_PARENT,
			      site       => check_site  site,
			      #	
			      attributes => [
				  border_pixel,
				  background_pixel,
				  xt::wa::EVENT_MASK standard_xevent_mask
				]
			    };

			  window;
		    };
	    end;


	# Create a simple popup window.
	#
	# These are simple windows used for menus
	# and tooltips and such;  they are neither
	# registered with nor decorated by the
	# window manager.  
	#
	# Compare with the plain and transient
	# windows provided by the topwindow package:
	#
	#     src/lib/x-kit/widget/basic/topwindow.pkg
	#
	fun make_simple_popup_window
		(scrn as sn::SCREEN { screen, xsession } )
		{ site, border_color, background_color }
	    =
	    (window, kidplug)
	    where 
		screen    ->  sn::SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, root_imps, ... };
		root_imps ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession  ->  sn::XSESSION    { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid();

		# modified ddeboer, Jul 2004; original: 
		# my (inDict, window) = TopLevelWin::mkTopLevelWinDict (scrn, root_imps, winId)

		my (kidplug, window, delete_slot)
		    =
		    wr::make_topwindow_to_widget_router (scrn, root_imps, window_id);

		wio::create_window  xsocket
                  {
		    window_id,
		    parent_window_id  => root_window_id,
		    #
		    io_class   => xt::INPUT_OUTPUT,
		    depth,
		    #
		    visual_id  => xt::SAME_VISUAL_AS_PARENT,
		    site       => check_site  site,
		    #
		    attributes => [
			xt::wa::OVERRIDE_REDIRECT TRUE,
			xt::wa::SAVE_UNDER TRUE,
			xt::wa::BORDER_PIXEL      (rgb8_of  border_color),
			xt::wa::BACKGROUND_PIXEL  background_color,
			xt::wa::EVENT_MASK        popup_xevent_mask
		      ]
		  };
	    end;

	# Create a simple transient window:
	#
	fun make_transient_window prop_window { site, border_color, background_color }
	    =
	    (window, kidplug)
	    where 

		prop_window ->  dt::WINDOW { window_id=>id, screen=>scrn as sn::SCREEN { screen, xsession }, ... };
		screen      ->  sn::SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, root_imps, ... };

		root_imps   ->  sn::SCREEN_DEPTH_IMPS { depth, ... };
		xsession    ->  sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... };

		window_id = next_xid();

		# modified ddeboer, Jul 2004; original: 
		# my (inDict, window) = TopLevelWin::mkTopLevelWinDict (scrn, root_imps, winId)

		my (kidplug, window, delete_slot)
		    =
		    wr::make_topwindow_to_widget_router (scrn, root_imps, window_id);

		wio::create_window  xsocket
                  {
		    window_id,
		    parent_window_id  => root_window_id,
		    #
		    io_class   => xt::INPUT_OUTPUT,
		    depth,
		    #
		    visual_id  => xt::SAME_VISUAL_AS_PARENT,
		    site       => check_site  site,
		    #
		    attributes => [
			xt::wa::BORDER_PIXEL     (rgb8_of  border_color),
			xt::wa::BACKGROUND_PIXEL background_color,
			xt::wa::EVENT_MASK       standard_xevent_mask
		      ]
		};

		set_property (xsession, window_id, sa::atom_wm_transient_for, ip::make_transient_hint prop_window);

	    end;

	exception INPUT_ONLY;

	fun make_input_only_window  window  (ge::BOX { col, row, wide, high } )
	    =
	    window
	    where  

		window ->   dt::WINDOW { window_id=>parent_window_id, screen, screen_depth, draw_fn, ... };
		screen ->   sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, next_xid, ... }, ... }, ... };

		window_id = next_xid();

		fun draw_fn (arg as (di::DMSG_DESTROY _))
			=>
			draw_fn arg;

		    draw_fn _
			=>
			raise exception INPUT_ONLY;
		end;

		window
		    =
		    dt::WINDOW
		      {
			window_id,
			screen,
			draw_fn,
			screen_depth
		      };

		wio::create_window  xsocket
                  {
		    window_id,
		    parent_window_id,
		    #	
		    io_class   => xt::INPUT_ONLY,
		    depth      => 0,
		    #	
		    visual_id  => xt::SAME_VISUAL_AS_PARENT,
		    attributes => [xt::wa::EVENT_MASK standard_xevent_mask],
		    #
		    site => check_site
				(ge::WINDOW_SITE
				  { upperleft    => ge::POINT { col, row },
				    size         => ge::SIZE { wide, high },
				    border_width => 0
				  }
				)
		};
	    end;


								# commandline		is from   src/lib/std/commandline.pkg
	# Set the standard window-manager
	# properties of a top-level window.
	#
	# This should be done before showing
	# (mapping) the window:
	#
	fun set_window_manager_properties

		window

		{ window_name,
		  icon_name,
		  commandline_arguments,			# Typically from:   commandline::get_arguments ().
		  size_hints,
		  nonsize_hints,
		  class_hints
		}
	    =
	    {   window ->  dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... };

		fun put_property (name, value)
		    =
		    set_property (xsession, window_id, name, value);

		fun put_string_prop (_, NULL)     =>   ();
		    put_string_prop (atom, THE s) =>   put_property (atom, ip::make_string_property s);
		end;

		put_string_prop (sa::atom_wm_name,    window_name);
		put_string_prop (sa::atom_wm_icon_name, icon_name);

		put_property (sa::atom_wm_normal_hints, ip::make_window_manager_size_hints        size_hints);
		put_property (sa::atom_wm_hints,        ip::make_window_manager_nonsize_hints  nonsize_hints);

		case class_hints
		    #	      
		    THE { resource_name, resource_class }
			=>
			put_property
			  ( sa::atom_wm_ilk,
			    ip::make_string_property (string::cat [resource_name, "\000", resource_class])
			  );

		    NULL => ();
		esac;

		case commandline_arguments
		    #	      
		    [] => ();
		    _  => put_property
                            ( sa::atom_wm_command,
                              ip::make_command_hints  commandline_arguments
                            );
		esac;
	    };


	# Set the window-manager protocols for a window:
	#
	fun set_window_manager_protocols window atoml
	    =
	    {   window ->  dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... };

		fun put_property n a
		    =
		    set_property (xsession, window_id, n, ip::make_atom_property a);

		case (at::find_atom  xsession  "WM_PROTOCOLS")
		    #
		    NULL => FALSE;
		    THE protocols_atom => { apply (put_property protocols_atom) atoml; TRUE;};
		esac;
	    };

	# Map window configuration values to a value list:
	#
	fun do_config_val arr
	    =
	    {   fun upd (i, v)
		    =
		    rw_vector::set (arr, i, THE v);


		fn (c::ORIGIN (ge::POINT { col, row } ))
			=>
			{   upd (0, unt::from_int col);
			    upd (1, unt::from_int row);
			};

		   (c::SIZE (ge::SIZE { wide, high } ))
			=>
			{   upd (2, unt::from_int wide);
			    upd (3, unt::from_int high);
			};

		   (c::BORDER_WID wide)
		       =>
		       upd (4, unt::from_int wide);

		   (c::STACK_MODE mode)
			=>
			{   rw_vector::set (arr, 5, NULL);
			    upd (6, v2w::stack_mode_to_wire mode);
			};

		   (c::REL_STACK_MODE (dt::WINDOW { window_id => xt::XID x, ... }, mode))
			=>
			{   upd (5, x);
			    upd (6, v2w::stack_mode_to_wire mode);
			};
		end;
	    };

	do_config_vals
	    =
	    v2w::do_val_list 7 do_config_val;

	fun configure_window (dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... } ) vals
	    =
	    sn::request  xsession
	      ( v2w::encode_configure_window
		  {
		    window_id,
		    vals => do_config_vals vals
		  }
	      );

	fun move_window   window pt   =   configure_window window [c::ORIGIN pt];
	fun resize_window window size =   configure_window window [c::SIZE size];

	fun move_and_resize_window window (ge::BOX { col, row, wide, high } )
	    =
	    configure_window window
	      [ c::ORIGIN (ge::POINT { col,  row  } ),
		c::SIZE   (ge::SIZE  { wide, high } )
	      ];

	# Show ("map") a window:
	#
	fun show_window (dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   sn::request    xsession  (v2w::encode_map_window { window_id } );
		sn::flush_out  xsession;
	    };

	# Hide ("unmap") a window:
	#
	fun hide_window (dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   sn::request    xsession  (v2w::encode_unmap_window { window_id } );

		sn::flush_out  xsession;
	    };

	# Withdraw (unmap and notify window manager) a top-level window 
	#
	stipulate 

	    mask = et::mask_of_xevent_list
                     [ et::n::SUBSTRUCTURE_NOTIFY,
		       et::n::SUBSTRUCTURE_REDIRECT
		     ];
	herein

	    fun withdraw_window (dt::WINDOW { window_id, screen => sn::SCREEN { screen=> sn::SCREEN_INFO { xscreen, ... }, xsession }, ... } )
		=
		{   xscreen ->  dy::XSCREEN { root_window_id, ... };

		    sn::request  xsession
			#
			(s2w::encode_send_unmap_notify
			  {
                            send_event_to  => xt::SEND_EVENT_TO_WINDOW root_window_id,
			    #
			    from_configure => FALSE,
			    propagate      => FALSE,
			    event_mask     => mask, 
			    #
			    event_window_id    =>  root_window_id,
			    unmapped_window_id =>  window_id
			  }
			);

		    sn::flush_out  xsession;
	       };
	end;

	# Destroy a window.
	# We do this via draw_imp to avoid a race
	# with any pending draw requests on the window.
	#
	fun destroy_window (dt::WINDOW { window_id, draw_fn, ... } )
	    = 
	    draw_fn (di::DMSG_DESTROY (di::DESTROY_WINDOW window_id));


	# Map a point in the window's coordinate
	# system to the screen's coordinate system
	#
	fun window_pt_to_screen_pt (dt::WINDOW { window_id, screen, ... } ) pt
	    =
	    {   screen ->  sn::SCREEN { xsession, screen=> sn::SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, ... }, ... };

		my { to_point, ... }
		    =
		    w2v::decode_translate_coords_reply
		      (
			do_mailop
			  (sn::request_reply
			      xsession
			      (v2w::encode_translate_coords { from_window=>window_id, to_window=>root_window_id, from_point=>pt } )
			  )
		      );

		to_point;
	    };


	# Set the window cursor:
	#
	fun set_cursor (dt::WINDOW { window_id, screen, ... } ) c
	    =
	    {   screen -> sn::SCREEN { xsession => sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		cur =  case c
			   #		              
			   THE (cs::XCURSOR { id, ... } ) =>   xt::wa::CURSOR id;
			   NULL                           =>   xt::wa::CURSOR_NONE;
		       esac;

		wio::change_window_attributes  xsocket  (window_id, [cur]);
	    };


	# Set the background color attribute of the window.
        #
        # Note that this does not immediately affect
        # the window's contents, but if it is done
	# before the window is mapped the window will
        # come up with the right color.
	#
	fun set_background_color (dt::WINDOW { window_id, screen, ... } ) color
	    =
	    wio::change_window_attributes  xsocket  (window_id, [color])
	    where 
		screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		color
		    =
		    case color
			#	         
			THE c =>   xt::wa::BACKGROUND_PIXEL (rgb8_of c);
			NULL  =>   xt::wa::BACKGROUND_PIXMAP_PARENT_RELATIVE;
		    esac;
	    end;

	# Set various window attributes 
	#
	fun change_window_attributes (dt::WINDOW { window_id, screen, ... } )
	    =
	    {   screen ->  sn::SCREEN { xsession=>sn::XSESSION { xdisplay => dy::XDISPLAY { xsocket, ... }, ... }, ... };

		change = wio::change_window_attributes  xsocket;

		fn attributes =  change (window_id,  map  user_window_attribute_to_internal_window_attribute  attributes);
	    };

	fun screen_of_window  (dt::WINDOW { screen, ... } )
	    =
	    screen;

	fun xsession_of_window (dt::WINDOW { screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    xsession;

	#  Added ddeboer Jan 2005 
	#  grabKeyboard: we would like a reply of xprottypes::GrabSuccess 
	#
	fun grab_keyboard (dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    0;

	    /* commented out, ddeboer, mar 2005 - this needs reworked.	 XXX BUGGO FIXME
	    let ans = 
		(w2v::decode_grab_keyboard_reply (do_mailop (sn::dpy_pequest_peply xsession
			    (v2w::encode_grab_keyboard { 
				window_id=id, * type XTy::XID *
				owner_events=FALSE, 
				ptr_mode=xt::AsynchronousGrab, 
				kbd_mode=xt::AsynchronousGrab, 
				time=xt::CURRENT_TIME } ))))
		    except Xok::LOST_REPLY => raise exception (xgripe::XERROR "[reply lost]")
			 | (Xok::ERROR_REPLY err) =>
			    raise exception (xgripe::XERROR (e2s::xerror_to_string err))
	    in (case (ans) of
		xt::GrabSuccess => 0
	      | xt::AlreadyGrabbed => 1
	      | xt::GrabInvalidTime => 2
	      | xt::GrabNotViewable => 3
	      | xt::GrabFrozen => 4)
	    end */

	fun ungrab_keyboard (dt::WINDOW { window_id, screen => sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   ans = ( /* w2v::decode_grab_keyboard_reply */

			(do_mailop
			  (sn::request_reply
			    xsession
			    (v2w::encode_ungrab_keyboard
			      { time=>xt::CURRENT_TIME }
		      ) ) ) )
		      except
			  xok::LOST_REPLY      => raise exception (xgripe::XERROR "[reply lost]");
			  xok::ERROR_REPLY err => raise exception (xgripe::XERROR (e2s::xerror_to_string err));
		      end ;

	     #  TODO: figure out what type of reply comes from an ungrab request, and decode it 	XXX BUGGO FIXME
		0;
	    };
						# end added ddeboer 
    };						# Window 
end;						# stipulate


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
