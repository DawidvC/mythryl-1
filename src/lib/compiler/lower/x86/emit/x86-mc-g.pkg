/*
 * WARNING: This file was automatically generated by mdl_g (v3.0)
 * from the machine description file "x86/x86.mdl".
 * DO NOT EDIT this file directly
 */


generic package translate_x86_to_x86_machine_code_g (

    package instruction:  X86INSTR
    package codetree_eval:  Codetree_Eval where T = Instr::T
    package stream:  Instruction_Stream 
    package code_string:  Code_String
)

: Instruction_Emitter

=
pkg
   package i = Instr
   package c = i::C
   package constant = i::Constant
   package t = i::T
   package s = Stream
   package p = s::P
   package w = unt32
   
   #  X86 is little endian 
   
   fun error msg
       =
       lowcode_error_message::error("x86_backend_g", msg)

   fun make_stream _
       =
       let infix && || << >> >>>
	   my op << = W.<<
	   my op >> = W.>>
	   my op >>> = W.>>>
	   my op || = w::bitwise_or
	   my op && = w::bitwise_and
	   itow = w::from_int
	   fun emit_bool FALSE = 0w0:  w::word
	     | emit_bool TRUE = 0w1:  w::word
	   emit_int = itow
	   fun emit_word w = w
	   fun emit_label l = itow (label::addrOf l)
	   fun emit_labexp le = itow (codetree_eval::valueOf le)
	   fun emit_const c = itow (Constant::valueOf c)
	   loc = REF 0

	   #  emit a byte 
	   fun eByte b =
	   let i = *loc in loc := i + 1; code_string::update (i, b) end

	   #  emit the low order byte of a word 
	   #  note: fromLargeWord strips the high order bits! 
	   fun eByteW w =
	   let i = *loc
	   in loc := i + 1; code_string::update (i, unt8::fromLargeWord w) end

	   fun doNothing _ = ()
	   fun fail _ = raise exception FAIL "MCEmitter"
	   fun get_notes () = error "get_notes"

	   fun pseudoOp pOp = p::emitValue { pOp=pOp, loc= *loc, emit=eByte }

	   fun init n = (code_string::init n; loc := 0)


       fun eWord8 w = 
	   let b8 = w
	   in eByteW b8
	   end
       and eWord16 w = 
	   let b8 = w
	       w = w >> 0wx8
	       b16 = w
	   in 
	      ( eByteW b8; 
		eByteW b16 )
	   end
       and eWord32 w = 
	   let b8 = w
	       w = w >> 0wx8
	       b16 = w
	       w = w >> 0wx8
	       b24 = w
	       w = w >> 0wx8
	       b32 = w
	   in 
	      ( eByteW b8; 
		eByteW b16; 
		eByteW b24; 
		eByteW b32 )
	   end
       fun emit_GP r = itow (cells_basis::physicalRegisterNum r)
       and emit_FP r = itow (cells_basis::physicalRegisterNum r)
       and emit_CC r = itow (cells_basis::physicalRegisterNum r)
       and emit_EFLAGS r = itow (cells_basis::physicalRegisterNum r)
       and emit_FFLAGS r = itow (cells_basis::physicalRegisterNum r)
       and emit_MEM r = itow (cells_basis::physicalRegisterNum r)
       and emit_CTRL r = itow (cells_basis::physicalRegisterNum r)
       and emit_CELLSET r = itow (cells_basis::physicalRegisterNum r)
       fun emit_cond (i::EQ) = (0wx4:  unt32::word)
	 | emit_cond (i::NE) = (0wx5:  unt32::word)
	 | emit_cond (i::LT) = (0wxc:  unt32::word)
	 | emit_cond (i::LE) = (0wxe:  unt32::word)
	 | emit_cond (i::GT) = (0wxf:  unt32::word)
	 | emit_cond (i::GE) = (0wxd:  unt32::word)
	 | emit_cond (i::B) = (0wx2:  unt32::word)
	 | emit_cond (i::BE) = (0wx6:  unt32::word)
	 | emit_cond (i::A) = (0wx7:  unt32::word)
	 | emit_cond (i::AE) = (0wx3:  unt32::word)
	 | emit_cond (i::C) = (0wx2:  unt32::word)
	 | emit_cond (i::NC) = (0wx3:  unt32::word)
	 | emit_cond (i::P) = (0wxa:  unt32::word)
	 | emit_cond (i::NP) = (0wxb:  unt32::word)
	 | emit_cond (i::O) = (0wx0:  unt32::word)
	 | emit_cond (i::NO) = (0wx1:  unt32::word)
       and emit_fibinOp (i::FIADDS) = (0wxde, 0)
	 | emit_fibinOp (i::FIMULS) = (0wxde, 1)
	 | emit_fibinOp (i::FICOMS) = (0wxde, 2)
	 | emit_fibinOp (i::FICOMPS) = (0wxde, 3)
	 | emit_fibinOp (i::FISUBS) = (0wxde, 4)
	 | emit_fibinOp (i::FISUBRS) = (0wxde, 5)
	 | emit_fibinOp (i::FIDIVS) = (0wxde, 6)
	 | emit_fibinOp (i::FIDIVRS) = (0wxde, 7)
	 | emit_fibinOp (i::FIADDL) = (0wxda, 0)
	 | emit_fibinOp (i::FIMULL) = (0wxda, 1)
	 | emit_fibinOp (i::FICOML) = (0wxda, 2)
	 | emit_fibinOp (i::FICOMPL) = (0wxda, 3)
	 | emit_fibinOp (i::FISUBL) = (0wxda, 4)
	 | emit_fibinOp (i::FISUBRL) = (0wxda, 5)
	 | emit_fibinOp (i::FIDIVL) = (0wxda, 6)
	 | emit_fibinOp (i::FIDIVRL) = (0wxda, 7)
       and emit_funOp (i::FCHS) = (0wxe0:  unt32::word)
	 | emit_funOp (i::FABS) = (0wxe1:  unt32::word)
	 | emit_funOp (i::FTST) = (0wxe4:  unt32::word)
	 | emit_funOp (i::FXAM) = (0wxe5:  unt32::word)
	 | emit_funOp (i::FPTAN) = (0wxf2:  unt32::word)
	 | emit_funOp (i::FPATAN) = (0wxf3:  unt32::word)
	 | emit_funOp (i::FXTRACT) = (0wxf4:  unt32::word)
	 | emit_funOp (i::FPREM1) = (0wxf5:  unt32::word)
	 | emit_funOp (i::FDECSTP) = (0wxf6:  unt32::word)
	 | emit_funOp (i::FINCSTP) = (0wxf7:  unt32::word)
	 | emit_funOp (i::FPREM) = (0wxf8:  unt32::word)
	 | emit_funOp (i::FYL2XP1) = (0wxf9:  unt32::word)
	 | emit_funOp (i::FSQRT) = (0wxfa:  unt32::word)
	 | emit_funOp (i::FSINCOS) = (0wxfb:  unt32::word)
	 | emit_funOp (i::FRNDINT) = (0wxfc:  unt32::word)
	 | emit_funOp (i::FSCALE) = (0wxfd:  unt32::word)
	 | emit_funOp (i::FSIN) = (0wxfe:  unt32::word)
	 | emit_funOp (i::FCOS) = (0wxff:  unt32::word)
       fun modrm { mod, reg, rm } = eWord8 ((op mod << 0wx6) + ((reg << 0wx3) + rm))
       and reg { opc, reg } = eWord8 ((opc << 0wx3) + reg)
       and sib { ss, index, base } = eWord8 ((ss << 0wx6) + ((index << 0wx3) + base))
       and immed8 { imm } = eWord8 imm
       and immed32 { imm } = eWord32 imm
       and immedOpnd { operand } = 
	   (case operand of
	     i::Immed i32 => i32
	   | i::ImmedLabel le => lambda_expression le
	   | i::LabelEA le => lambda_expression le
	   | _ => error "immedOpnd"
	   )
       and extension { opc, operand } = 
	   (case operand of
	     i::DIRECT r => modrm { mod=3, reg=opc, rm=r }
	   | i::MemReg _ => extension { opc=opc, operand=memReg operand }
	   | i::FDIRECT _ => extension { opc=opc, operand=memReg operand }
	   | i::DISPLACE { base, disp, ... } => 
	     let 
    # #line 475.13 "x86/x86::mdl"
		 immed = immedOpnd { operand=disp }
	     in ()
	     end
	   | i::Indexed { base=NULL, index, scale, disp, ... } => ()
	   | i::Indexed { base=THE b, index, scale, disp, ... } => ()
	   | _ => error "immedExt"
	   )
       and encodeST { prefix, opc, st } = 
	   let st = emit_FP st
	   in eWord16 ((prefix << 0wx8) + ((opc << 0wx3) + st))
	   end
       and encodeReg { prefix, reg, operand } = 
	   let reg = emit_GP reg
	   in 
	      ( emit prefix; 
		immedExt { opc=reg, operand=operand } )
	   end
       and arith { opc1, opc2, src, dst } = 
	   (case (src, dst) of
	     (i::ImmedLabel le, dst) => arith { opc1=opc1, opc2=opc2, src=i::Immed (lambda_expression le), 
		dst=dst }
	   | (i::LabelEA le, dst) => arith { opc1=opc1, opc2=opc2, src=i::Immed (lambda_expression le), 
		dst=dst }
	   | (i::Immed i, dst) => ()
	   | (src, i::DIRECT r) => encodeReg { prefix=opc1 + op3, reg=reg, operand=src }
	   | (i::DIRECT r, dst) => encodeReg { prefix=opc1 + 0wx1, reg=reg, operand=dst }
	   | _ => error "arith"
	   )
	   fun emitter instruction =
	   let
       fun emitInstr (i::NOP) = error "NOP"
	 | emitInstr (i::JMP (operand, list)) = error "JMP"
	 | emitInstr (i::JCC { cond, operand } ) = error "JCC"
	 | emitInstr (i::CALL { operand, defs, uses, return, cutsTo, mem, pops } ) = error "CALL"
	 | emitInstr (i::ENTER { src1, src2 } ) = error "ENTER"
	 | emitInstr (i::LEAVE) = error "LEAVE"
	 | emitInstr (i::RET option) = error "RET"
	 | emitInstr (i::MOVE { mvOp, src, dst } ) = error "MOVE"
	 | emitInstr (i::LEA { r32, address } ) = error "LEA"
	 | emitInstr (i::CMPL { lsrc, rsrc } ) = error "CMPL"
	 | emitInstr (i::CMPW { lsrc, rsrc } ) = error "CMPW"
	 | emitInstr (i::CMPB { lsrc, rsrc } ) = error "CMPB"
	 | emitInstr (i::TESTL { lsrc, rsrc } ) = error "TESTL"
	 | emitInstr (i::TESTW { lsrc, rsrc } ) = error "TESTW"
	 | emitInstr (i::TESTB { lsrc, rsrc } ) = error "TESTB"
	 | emitInstr (i::BITOP { bitOp, lsrc, rsrc } ) = error "BITOP"
	 | emitInstr (i::BINARY { binOp, src, dst } ) = error "BINARY"
	 | emitInstr (i::SHIFT { shiftOp, src, dst, count } ) = error "SHIFT"
	 | emitInstr (i::CMPXCHG { lock, size, src, dst } ) = error "CMPXCHG"
	 | emitInstr (i::MULTDIV { multDivOp, src } ) = error "MULTDIV"
	 | emitInstr (i::MUL3 { dst, src2, src1 } ) = error "MUL3"
	 | emitInstr (i::UNARY { unOp, operand } ) = error "UNARY"
	 | emitInstr (i::SET { cond, operand } ) = error "SET"
	 | emitInstr (i::CMOV { cond, src, dst } ) = error "CMOV"
	 | emitInstr (i::PUSHL operand) = error "PUSHL"
	 | emitInstr (i::PUSHW operand) = error "PUSHW"
	 | emitInstr (i::PUSHB operand) = error "PUSHB"
	 | emitInstr (i::PUSHFD) = error "PUSHFD"
	 | emitInstr (i::POPFD) = error "POPFD"
	 | emitInstr (i::POP operand) = error "POP"
	 | emitInstr (i::CDQ) = error "CDQ"
	 | emitInstr (i::INTO) = error "INTO"
	 | emitInstr (i::FBINARY { binOp, src, dst } ) = error "FBINARY"
	 | emitInstr (i::FIBINARY { binOp, src } ) = error "FIBINARY"
	 | emitInstr (i::FUNARY funOp) = error "FUNARY"
	 | emitInstr (i::FUCOM operand) = error "FUCOM"
	 | emitInstr (i::FUCOMP operand) = error "FUCOMP"
	 | emitInstr (i::FUCOMPP) = error "FUCOMPP"
	 | emitInstr (i::FCOMPP) = error "FCOMPP"
	 | emitInstr (i::FCOMI operand) = error "FCOMI"
	 | emitInstr (i::FCOMIP operand) = error "FCOMIP"
	 | emitInstr (i::FUCOMI operand) = error "FUCOMI"
	 | emitInstr (i::FUCOMIP operand) = error "FUCOMIP"
	 | emitInstr (i::FXCH { operand } ) = error "FXCH"
	 | emitInstr (i::FSTPL operand) = error "FSTPL"
	 | emitInstr (i::FSTPS operand) = error "FSTPS"
	 | emitInstr (i::FSTPT operand) = error "FSTPT"
	 | emitInstr (i::FSTL operand) = error "FSTL"
	 | emitInstr (i::FSTS operand) = error "FSTS"
	 | emitInstr (i::FLD1) = error "FLD1"
	 | emitInstr (i::FLDL2E) = error "FLDL2E"
	 | emitInstr (i::FLDL2T) = error "FLDL2T"
	 | emitInstr (i::FLDLG2) = error "FLDLG2"
	 | emitInstr (i::FLDLN2) = error "FLDLN2"
	 | emitInstr (i::FLDPI) = error "FLDPI"
	 | emitInstr (i::FLDZ) = error "FLDZ"
	 | emitInstr (i::FLDL operand) = error "FLDL"
	 | emitInstr (i::FLDS operand) = error "FLDS"
	 | emitInstr (i::FLDT operand) = error "FLDT"
	 | emitInstr (i::FILD operand) = error "FILD"
	 | emitInstr (i::FILDL operand) = error "FILDL"
	 | emitInstr (i::FILDLL operand) = error "FILDLL"
	 | emitInstr (i::FNSTSW) = error "FNSTSW"
	 | emitInstr (i::FENV { fenvOp, operand } ) = error "FENV"
	 | emitInstr (i::FMOVE { fsize, src, dst } ) = error "FMOVE"
	 | emitInstr (i::FILOAD { isize, ea, dst } ) = error "FILOAD"
	 | emitInstr (i::FBINOP { fsize, binOp, lsrc, rsrc, dst } ) = error "FBINOP"
	 | emitInstr (i::FIBINOP { isize, binOp, lsrc, rsrc, dst } ) = error "FIBINOP"
	 | emitInstr (i::FUNOP { fsize, unOp, src, dst } ) = error "FUNOP"
	 | emitInstr (i::FCMP { i, fsize, lsrc, rsrc } ) = error "FCMP"
	 | emitInstr (i::SAHF) = error "SAHF"
	 | emitInstr (i::LAHF) = error "LAHF"
	 | emitInstr (i::SOURCE {} ) = ()
	 | emitInstr (i::SINK {} ) = ()
	 | emitInstr (i::PHI {} ) = ()
	   in
	       emitInstr instruction
	   end

       fun emit_instruction (i::NOTE { instruction, ... } ) = emit_instruction instruction
	 | emit_instruction (i::INSTRUCTION (i)) = emitter (i)
	 | emit_instruction (i::LIVE _)  = ()
	 | emit_instruction (i::KILL _)  = ()
       | emit_instruction _ = error "emit_instruction"

       in  s::STREAM { begin_cluster=init,
		    pseudoOp=pseudoOp,
		    emit=emit_instruction,
		    end_cluster=fail,
		    define_local_label=doNothing,
		    define_global_label=doNothing,
		    comment=doNothing,
		    end_procedure=doNothing,
		    annotation=doNothing,
		    get_notes
		   }
       end
end

