## instruction-set-sparc-g.pgk
/*
 * WARNING: This file was automatically generated by mdl_g (v3.0)
 * from the machine description file "sparc/sparc.mdl".
 * DO NOT EDIT this file directly
 */

# Compiled by:
#     src/lib/compiler/lower/make7/sparc.make6


# We are invoked from:
#
#     src/lib/compiler/codegen/sun/sparc-codetree.pkg

generic package instruction_set_sparc_g (

    codetree: Codetree				# Codetree	is from   src/lib/compiler/lower/codetree/codetree.api
)

: (weak) Instruction_Set_Sparc			# Instruction_Set_Sparc	is from   src/lib/compiler/lower/sun/instruction/instruction-set-sparc.api

{
    package codetree = codetree;
    package region   = codetree::region;
    package constant = codetree::constant;

    package cells = sparc_cells;		# sparc_cells	is from   src/lib/compiler/lower/sun/instruction/sparc-cells.pkg
    package cb= cells_basis;			# cells_basis	is from   src/lib/compiler/lower/instruction/cells-basis.pkg

    package t = codetree;

    Load
	= LDSB
	| LDSH
	| LDUB
	| LDUH
	| LD
	| LDX
	| LDD;

    Store
      = STB
      | STH
      | ST
      | STX
      | STD;

    Fload
      = LDF
      | LDDF
      | LDQF
      | LDFSR
      | LDXFSR;

    Fstore
      = STF
      | STDF
      | STFSR;

    Arith
      = AND
      | ANDCC
      | ANDN
      | ANDNCC
      | OR
      | ORCC
      | ORN
      | ORNCC
      | XOR
      | XORCC
      | XNOR
      | XNORCC
      | ADD
      | ADDCC
      | TADD
      | TADDCC
      | TADDTV
      | TADDTVCC
      | SUB
      | SUBCC
      | TSUB
      | TSUBCC
      | TSUBTV
      | TSUBTVCC
      | UMUL
      | UMULCC
      | SMUL
      | SMULCC
      | UDIV
      | UDIVCC
      | SDIV
      | SDIVCC
      | MULX
      | SDIVX
      | UDIVX;

    Shift
      = LEFTSHIFT
      | RIGHTSHIFTU
      | RIGHTSHIFT
      | SLLX
      | SRLX
      | SRAX;

    Farith1
      = FI_TOS
      | FI_TOD
      | FI_TOQ
      | FS_TOI
      | FD_TOI
      | FQ_TOI
      | FS_TOD
      | FS_TOQ
      | FD_TOS
      | FD_TOQ
      | FQ_TOS
      | FQ_TOD
      | FMOVS
      | FNEGS
      | FABSS
      | FMOVD
      | FNEGD
      | FABSD
      | FMOVQ
      | FNEGQ
      | FABSQ
      | FSQRTS
      | FSQRTD
      | FSQRTQ;

    Farith2
      = FADDS
      | FADDD
      | FADDQ
      | FSUBS
      | FSUBD
      | FSUBQ
      | FMULS
      | FMULD
      | FMULQ
      | FS_MULD
      | FD_MULQ
      | FDIVS
      | FDIVD
      | FDIVQ;

    Fcmp
      = FCMPS
      | FCMPD
      | FCMPQ
      | FCMPES
      | FCMPED
      | FCMPEQ;

    Branch
      = BN
      | BE
      | BLE
      | BL
      | BLEU
      | BCS
      | BNEG
      | BVS
      | BA
      | BNE
      | BG
      | BGE
      | BGU
      | BCC
      | BPOS
      | BVC;

    Rcond
      = RZ
      | RLEZ
      | RLZ
      | RNZ
      | RGZ
      | RGEZ;

    Cc
      = ICC
      | XCC;

    Prediction
      = PT
      | PN;

    Fbranch
      = FBN
      | FBNE
      | FBLG
      | FBUL
      | FBL
      | FBUG
      | FBG
      | FBU
      | FBA
      | FBE
      | FBUE
      | FBGE
      | FBUGE
      | FBLE
      | FBULE
      | FBO;

    Ea
      = DIRECT  cells_basis::Cell
      | FDIRECT  cells_basis::Cell
      | DISPLACE  { base: cells_basis::Cell, disp: t::Labexp, mem: region::Region };

    Fsize
      = SS
      | DD
      | QQ;

    Operand
      = REG  cells_basis::Cell
      | IMMED  Int
      | LAB  t::Labexp
      | LO  t::Labexp
      | HI  t::Labexp;

    Addressing_Mode = (cells_basis::Cell, Operand);

    Base_Instruction
      = LOAD  { l: Load, d: cells_basis::Cell, r: cells_basis::Cell, i: Operand, mem: region::Region }
      | STORE  { s: Store, d: cells_basis::Cell, r: cells_basis::Cell, i: Operand, mem: region::Region }
      | FLOAD  { l: Fload, r: cells_basis::Cell, i: Operand, d: cells_basis::Cell, mem: region::Region }
      | FSTORE  { s: Fstore, d: cells_basis::Cell, r: cells_basis::Cell, i: Operand, 
	   mem: region::Region }
      | UNIMP  { const22: Int }
      | SETHI  { i: Int, d: cells_basis::Cell }
      | ARITH  { a: Arith, r: cells_basis::Cell, i: Operand, d: cells_basis::Cell }
      | SHIFT  { s: Shift, r: cells_basis::Cell, i: Operand, d: cells_basis::Cell }
      | MOVICC  { b: Branch, i: Operand, d: cells_basis::Cell }
      | MOVFCC  { b: Fbranch, i: Operand, d: cells_basis::Cell }
      | MOVR  { rcond: Rcond, r: cells_basis::Cell, i: Operand, d: cells_basis::Cell }
      | FMOVICC  { size: Fsize, b: Branch, r: cells_basis::Cell, d: cells_basis::Cell }
      | FMOVFCC  { size: Fsize, b: Fbranch, r: cells_basis::Cell, d: cells_basis::Cell }
      | BICC  { b: Branch, a: Bool, label: label::Label, nop: Bool }
      | FBFCC  { b: Fbranch, a: Bool, label: label::Label, nop: Bool }
      | BR  { rcond: Rcond, p: Prediction, r: cells_basis::Cell, a: Bool, label: label::Label, 
	   nop: Bool }
      | BP  { b: Branch, p: Prediction, cc: Cc, a: Bool, label: label::Label, nop: Bool }
      | JMP  { r: cells_basis::Cell, i: Operand, labs: List( label::Label ), nop: Bool }
      | JMPL  { r: cells_basis::Cell, i: Operand, d: cells_basis::Cell, defs: cells::Cellset, 
	   uses: cells::Cellset, cuts_to: List( label::Label ), nop: Bool, mem: region::Region }
      | CALL  { defs: cells::Cellset, uses: cells::Cellset, label: label::Label, cuts_to: List( label::Label ), 
	   nop: Bool, mem: region::Region }
      | TICC  { t: Branch, cc: Cc, r: cells_basis::Cell, i: Operand }
      | FPOP1  { a: Farith1, r: cells_basis::Cell, d: cells_basis::Cell }
      | FPOP2  { a: Farith2, r1: cells_basis::Cell, r2: cells_basis::Cell, d: cells_basis::Cell }
      | FCMP  { cmp: Fcmp, r1: cells_basis::Cell, r2: cells_basis::Cell, nop: Bool }
      | SAVE  { r: cells_basis::Cell, i: Operand, d: cells_basis::Cell }
      | RESTORE  { r: cells_basis::Cell, i: Operand, d: cells_basis::Cell }
      | RDY  { d: cells_basis::Cell }
      | WRY  { r: cells_basis::Cell, i: Operand }
      | RET  { leaf: Bool, nop: Bool }
      | SOURCE  { }
      | SINK  { }
      | PHI  { }

    also
    Instruction
      = LIVE  { regs: cells::Cellset, spilled: cells::Cellset }
      | DEAD  { regs: cells::Cellset, spilled: cells::Cellset }
      | COPY  { kind: cells_basis::Cellkind, 
		size_in_bits: Int,          #  in bits 
		dst: List( cells_basis::Cell ),
		src: List( cells_basis::Cell ),
		tmp: Null_Or(  Ea ) /* NULL if |dst| == { src| == 1 */
	      }
      | NOTE  { instruction: Instruction,
		note:        note::Note
	      }
      | BASE_INSTRUCTION  Base_Instruction;

    load    = BASE_INSTRUCTION o LOAD;
    store   = BASE_INSTRUCTION o STORE;

    fload   = BASE_INSTRUCTION o FLOAD;
    fstore  = BASE_INSTRUCTION o FSTORE;

    unimp   = BASE_INSTRUCTION o UNIMP;
    sethi   = BASE_INSTRUCTION o SETHI;

    arith   = BASE_INSTRUCTION o ARITH;
    shift   = BASE_INSTRUCTION o SHIFT;

    movicc  = BASE_INSTRUCTION o MOVICC;
    movfcc  = BASE_INSTRUCTION o MOVFCC;
    movr    = BASE_INSTRUCTION o MOVR;

    fmovicc = BASE_INSTRUCTION o FMOVICC;
    fmovfcc = BASE_INSTRUCTION o FMOVFCC;

    bicc    = BASE_INSTRUCTION o BICC;
    fbfcc   = BASE_INSTRUCTION o FBFCC;

    br      = BASE_INSTRUCTION o BR;
    bp      = BASE_INSTRUCTION o BP;

    jmp     = BASE_INSTRUCTION o JMP;
    jmpl    = BASE_INSTRUCTION o JMPL;

    call    = BASE_INSTRUCTION o CALL;

    ticc    = BASE_INSTRUCTION o TICC;

    fpop1   = BASE_INSTRUCTION o FPOP1;
    fpop2   = BASE_INSTRUCTION o FPOP2;

    fcmp    = BASE_INSTRUCTION o FCMP;

    save    = BASE_INSTRUCTION o SAVE;
    restore = BASE_INSTRUCTION o RESTORE;

    rdy     = BASE_INSTRUCTION o RDY;
    wry     = BASE_INSTRUCTION o WRY;
    ret     = BASE_INSTRUCTION o RET;

    source  = BASE_INSTRUCTION o SOURCE;
    sink    = BASE_INSTRUCTION o SINK;
    phi     = BASE_INSTRUCTION o PHI;
};

