SMLNJ-FFILIB
------------

1. Introduction

    I'll assume you already know how to use C-GLUE-MAKER and its runtime 
interface library (packages 'c', 'zstring', etc.)  If not, please first read
the file src/lib/c-glue-lib/Doc/mini-tutorial.txt which comes with
the c-glue-lib package.

    You can send Matthias Blume (blume@research.bell-labs.com) questions
concerning these tools.

2. Conventions

   How we do things in SMLNJ-FFILIB is slightly different than how c-glue-maker
does them.  So it's important you know the differences.

2.1. Light versus heavy interface

   Only the "light" interface is provided in SMLNJ-FFILIB.
This means all "C" objects in this library do not carry any runtime 
information.  While this makes some operations, such as array subscripting, 
less convenient for the users, usually the difference is not that important.
The light interface seem to stress the SML/NJ compiler less, which is
important since the libraries contain a massive amount of code.

2.3 Runtime Type Information

   I have pruned out almost all generated runtime type information 
from the libraries.  I only keep them around for array subscripting.  
Again, this keep the libraries lighter.

2.3 Naming convention

     1.  All functions named foo in C are callable from
         the structure foo.f  (not F_foo.f as in c-glue-maker)

         In addition, if the function has named arguments, an alternative
         version foo.g is also available.

     2.  A structure or union named Foo is translated into
         a structure named Foo in ML (not S_Foo or U_Foo as in c-glue-maker)

     3.  Some exceptions:

         o When the names clash with ML's structure names or keywords,
           we add a tick at the end.
         o When the name is prefixed by a _ (which is illegal in ML),
           we retain c-glue-maker name mangling convention.

3. How to make your own

   Here are the general steps of adding your own libraries to this package.

Let's say you have new library called widgets with a main include file
called "widgets.h"

    1.  Create a new directory widgets.

    2.  Cd to this directory and run ../config/init-ffi
        This will create three files:

         widgets.cm     --- main cm file
         make.pkg       --- program to run to create the nicely "wrapped"
                            version of your library 
         Makefile       --- drives everything

    3.  Edit Makefile and make.pkg to get the system to create the library
        in the form you want.  Sorry, I have no documentation to this.
        You may look at the other directories to get some general idea.
        When all else fails, you can always track me down by email.
    
        A comment on the file "make.pkg".  It contains the recipe for 
        transforming the stuff generated by c-glue-maker into a nicer 
        form for actual use.  For simple stuff, the default is usually enough.  
        But for truly complex stuff, just as Gtk -- with its fake object 
        orientation -- the transformations can be quite complex.   
    
        There are two libraries that you can use to help you out.  
        The first is ML-Grinder, which is just a very quick and dirty set  
        of transformations on a SML Ast.  Read the signature in 
        ml-grinder/ml-grinder.api to get an idea.  The Ast is actually defined
        in the library $mlrisc-tools in the directories under src/MLRISC/Tools.
        It is intentionally kept very simple; you cannot use it to write
        a real ML compiler.  But for writing code generator generator it
        is very adequate.
    
        The second library is FFI-Packager, which is somewhat more
        specific to the task of hacking on c-glue-maker generated code.
        Of particular interest is the structure FFITransforms.
        It contains a bunch of combinators for performing transformations
        on generated ffi functions. 

    4.  You can test out the build by doing:
    
            make cleanall testrebuild
    
        Things will probably not work out the first time.  Just repeat from 3.
    
    5.  When everything works out, you can cd to the directory config and run
    
            make-targets > targets
    
        to update the set of targets.   The script requires rpm, however.
        I would appreciate it if anyone can make it work with Debian's 
        packager.
    
        You can always add the target by hand to "targets".
    
Allen Leung (leunga@cs.nyu.edu, leunga@dorsai.org)
