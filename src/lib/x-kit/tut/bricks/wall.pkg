## wall.pkg

# Compiled by:
#     src/lib/x-kit/tut/bricks/bricks.make6


stipulate
    include threadkit;				# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package xc  =  xcore;			# xcore			is from   src/lib/x-kit/xclient/xcore.pkg
    package xg  =  xgeometry;			# xgeometry		is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;			# xinput		is from   src/lib/x-kit/xclient/xinput.pkg
    #
    package bg  =  background;			# background		is from   src/lib/x-kit/widget/wrapper/background.pkg
    package lbl =  label;			# label			is from   src/lib/x-kit/widget/leaf/label.pkg
    package low =  line_of_widgets;		# line_of_widgets	is from   src/lib/x-kit/widget/layout/line-of-widgets.pkg
    package w   =  widget;			# widget		is from   src/lib/x-kit/widget/basic/widget.pkg
    package wt  =  widget_types;		# widget_types		is from   src/lib/x-kit/widget/basic/widget-types.pkg
    #
    package bu  =  brick_util;			# brick_util		is from   src/lib/x-kit/tut/bricks/brick-util.pkg
    package bk  =  brick;			# brick			is from   src/lib/x-kit/tut/bricks/brick.pkg
herein

    package wall: Wall {			# Wall			is from   src/lib/x-kit/tut/bricks/wall.api


	safe_zone = 3;

	fun real_to_rgb (r, g, b)
	    =
	    {   fun scale v
		    =
		    unt::from_int (float::truncate (65535.0 * v));

		    xc::CMS_RGB { red=>scale r, green => scale g, blue => scale b };
	    };

	brick_red   = real_to_rgb (0.970077, 0.291340, 0.066498);
	yellow      = real_to_rgb (1.0, 1.0, 0.0);
	light_grey  = real_to_rgb (0.8, 0.8, 0.8);
	dark_grey   = real_to_rgb (0.2, 0.2, 0.2);
	medium_grey = real_to_rgb (0.7, 0.7, 0.7);
	cyan        = real_to_rgb (0.0, 1.0, 1.0);

	fun left_mouse   (xi::MOUSEBUTTON b) =  b == 1;
	fun right_mouse  (xi::MOUSEBUTTON b) =  b >= 3;
	fun middle_mouse (xi::MOUSEBUTTON b) =  b == 2;

	Request = START                     bu::Difficulty
		| SET_RANGE                 bu::Range
		| GET_DIFFICULTY  Mailslot( bu::Difficulty )
		;

	Wall = WALL { plea_slot:  Mailslot( Request ),
		      widget:     w::Widget
		    };


	fun make_wall_widget (root_window, color, msgwin, bricks)
	    =
	    {   end_spacer =  low::SPACER { min_size=>0,  ideal_size=>0, max_size=>NULL };

		half_brick =  bu::brick_size_h / 2;

		start_spacer
		    =
		    low::SPACER
		      { min_size   =>     half_brick,
			ideal_size =>     half_brick,
			max_size   => THE half_brick
		      };


		fun box_col []
			=>
			[ end_spacer ];

		    box_col (b ! rest)
			=>
			(low::WIDGET (bk::as_widget b)) ! (box_col rest);
		end;


		fun box_row (_, [])
			=>
			[];

		    box_row (y, r ! rest)
			=>
			if (y % 2 == 0)  (low::HZ_CENTER (box_col r))   ! (box_row (y+1, rest));
			else             (low::HZ_CENTER (start_spacer  ! (box_col r))) ! (box_row (y+1, rest));
			fi;
		end;


		wall_view
		    =
		    low::make_line_of_widgets  root_window
		      ( low::VT_CENTER
			  (low::WIDGET msgwin  ! ((box_row (0, bricks)) @ [ end_spacer ]))
		      );

		bg::make_background
		  {
		    widget =>  low::as_widget  wall_view,
		    color  =>  THE color
		  };
	    };

	fun make_wall root_window (x_size, y_size)
	    =
	    {   screen =  w::screen_of  root_window;

		plea_slot  =  make_mailslot ();
		brick_slot =  make_mailslot ();

		cvt_color =  xc::color_of_screen  screen ;

		palette = { brick           =>  cvt_color  brick_red,
			    mark            =>  cvt_color  yellow,
			    concrete        =>  cvt_color  light_grey,
			    #
			    dark_lines      =>  cvt_color  dark_grey,
			    light_lines     =>  cvt_color  medium_grey,
			    highlight_lines =>  cvt_color  cyan
			  };

		no_brick =  bk::new_no_brick  root_window  palette;

		main_msg
		    =
		    "ClickLeft: remove bad bricks. "
		    +
		    "ClickRight or ShiftClickLeft: mark/unmark bricks.";

		msg_area
		   =
		   lbl::make_label  root_window 
		     {
		       label =>  "",
		       font  =>  THE bu::brick_font,
		       align =>  wt::HCENTER,
		       #
		       foreground => NULL, 
		       background => NULL
		     };

		fun set_msg text
		    =
		   lbl::set_label msg_area (lbl::TEXT text);

		fun make_row y
		    =
		    {   fun make_col x
			    =
			    if (x == x_size)
				#
				[];
			    else
				(bk::new_brick  root_window  (xg::POINT { col=>x, row=>y }, brick_slot, palette)) ! (make_col (x+1));
			    fi;

			if (y == y_size)
			    #
			    [];
			else
			    (make_col 0) ! (make_row (y+1));
			fi;
		    };

		bricklist = make_row 0;

		brick = rw_vector::from_list (map rw_vector::from_list bricklist);


		fun brick_at (xg::POINT { col, row } )
		    =
		    rw_vector::get (rw_vector::get (brick, row), col)
		    except
			_ = no_brick;

		widget
		    = 
		    make_wall_widget
		      (
			root_window,
			palette.concrete,
			lbl::as_widget msg_area,
			bricklist
		      );

		stipulate
		    random = rand::make_random  0u1;
		herein
		    fun randx () =  rand::range (0, x_size - 1) (random());
		    fun randy () =  rand::range (0, y_size - 1) (random());
		end;

		fun set_up_game diff
		    =
		    {   range = if (bu::cmp_difficulty (diff, bu::DESPERATE) >= 0)   bu::LONG;
				else                                                bu::SHORT;
				fi;

			fun choose_good ()
			    =
			    {
				good_count
				    = 
				    float::truncate (real (x_size*y_size*(bu::difficulty_probability diff))//100.0);

				fun loop (0, count)
					=>
					count;

				    loop (i, count)
					=>
					{   rx = randx ();
					    ry = randy ();

					    b = brick_at (xg::POINT { col=>rx, row=>ry } );

					    if  (   (rx >= safe_zone   or  ry >= safe_zone)
						and (not (bk::is_good b))
					    )
						bk::set_good b;

						loop (i - 1, count+1);
					    else
						loop (i - 1, count);
					    fi;
					};
				  end;

				  rw_vector::apply
				      (fn row = rw_vector::apply bk::reset row)
				      brick;

				  loop (good_count, 0);
			    };

			good_count = choose_good ();
			bad_count  = x_size*y_size - good_count;

			delta =  bk::show_and_flood (brick_at  xg::point_00,  brick_at);

			set_msg  main_msg;

			(range, bad_count-delta);
		    };

		fun game_lost ()
		    =
		    {   rw_vector::apply (fn row = rw_vector::apply (fn b = bk::end_show (b, brick_at)) row) brick;
			set_msg("OOPS! That was a perfectly good brick!");
			end_game (bu::NORMAL, bu::SHORT);
		    }

		also
		fun game_won ()
		    =
		    {   set_msg("NO BAD BRICKS LEFT! Skateboarding is now safe.");
			end_game (bu::NORMAL, bu::SHORT);
		    }


		also
		fun start_game  difficulty
		    =
		    {   loop (range, bad_bricks)
			except
			    GAME_WON  =>  game_won  ();
			    GAME_LOST =>  game_lost ();
			end;
		    }
		    where
			my (range, bad_bricks)
			    =
			    set_up_game  difficulty;

			exception GAME_LOST;
			exception GAME_WON;

			stipulate

			    diff_name =  bu::difficulty_name  difficulty;

			herein

			    fun game_status (good, unknown, bad)
				=
				if (good == unknown)
				    #
				    set_msg (sprintf "%s  Game:  %d bad bricks left" diff_name bad);
				else
				    set_msg (sprintf "%s  Game:  %d out of %d unknown neighbors are good;   %d bad bricks left"
						     diff_name good unknown bad
					    );
				fi;
			end;

			fun mark_bfn b					# "bfn" may be "bad_fn".
			    = 
			    if (bk::state_of b == bu::UNKNOWN_STATE )
				#
				if (bk::is_good b)   raise exception  GAME_LOST;
				else                 bk::show_and_flood (b, brick_at);
				fi;
			    else
				0;
			    fi; 

			mark_bad =  bk::neighbor_count  mark_bfn;

			fun mark_gfn b					# "gfn" may be "good_fn".
			    =
			    if (bk::state_of b == bu::UNKNOWN_STATE)
				#
				bk::toggle_marking  b;
			    fi;

			mark_good
			    =
			    bk::enumerate_neighbors  mark_gfn;

			fun auto_brick (brick, range)
			    =
			    {   bad =  bk::neighbor_bad_count (brick, range, brick_at);
				ok  =  bk::neighbor_ok_count  (brick, range, brick_at);

				my (unknown, good)
				    = 
				    case range
					#
					bu::SHORT => ( 6 - (bad + ok), bu::state_val  (bk::state_of  brick));
					_         => (18 - (bad + ok), bk::neighbor_good_count (brick, bu::LONG, brick_at));
				    esac;

				if   (unknown == 0)           0;
				elif (good <= ok)             mark_bad  (brick, range, brick_at);
				elif (unknown == good - ok)   mark_good (brick, range, brick_at);  0;
				else                          0;
				fi;
			    };

			fun brick_action (mbttn, b, me as (range, badcnt))
			    =
			    if (right_mouse mbttn)
				 #
				 bk::toggle_marking b;
				 me;

			    elif (bk::state_of b != bu::OK_STATE)

				if (bk::is_good b)
				    #
				    raise exception  GAME_LOST;
				else
				    delta = if (bk::state_of b == bu::UNKNOWN_STATE)
						 #
						 bk::show_and_flood (b, brick_at);
						 #
					    elif (left_mouse mbttn or bu::cmp_difficulty (difficulty, bu::HARD) < 0)
						 #
						 auto_brick (b, bu::SHORT);
					    else auto_brick (b, bu::LONG );
					    fi;

				    badcnt' = badcnt - delta;

				    game_status (0, 0, badcnt');

				    if (badcnt' == 0)   raise exception  GAME_WON;
				    else                (range, badcnt');
				    fi;
				fi;

			  else
			      me;
			  fi;

			fun adjust_range (m, me as (_, badcnt))
			    =
			    if (bu::cmp_difficulty (difficulty, bu::DESPERATE) < 0 
			    or  left_mouse m
			    )                       (bu::SHORT, badcnt);
			    elif (middle_mouse m)   (bu::LONG,  badcnt);
			    else                    me;
			    fi;

			fun brick_highlight_on (b, me as (range, badcnt))
			    =
			    if (bk::is_shown b)
				#
				bk::enumerate_neighbors
				   bk::highlight_on
				   (b, range, brick_at);

				if (range == bu::LONG)
				    #
				    bk::set_text (b, int::to_string (bk::neighbor_good_count (b, bu::LONG, brick_at)));
				fi;


				bad =  bk::neighbor_bad_count (b, range, brick_at);
				ok  =  bk::neighbor_ok_count  (b, range, brick_at);

				my (unknown, good)
				    = 
				    case range
					#
					bu::SHORT => ( 6 - (bad + ok),  bu::state_val (bk::state_of b));
					_         => (18 - (bad + ok),  bk::neighbor_good_count (b, bu::LONG, brick_at));
				    esac;

				game_status (good - ok, unknown, badcnt);

				me;
			    else
				me;
			    fi;


			fun brick_highlight_off (b, me as (range, _))
			    =
			    if (bk::is_shown b)
				#
				bk::enumerate_neighbors
				    bk::highlight_off
				    (b, range, brick_at);

				if (range == bu::LONG)
				    #
				    bk::set_text (b, int::to_string (bk::neighbor_good_count (b, bu::SHORT, brick_at)));
				fi;

				me;
			    else
				me;
			    fi;


			fun handle_brick (bu::DOWN (m, b), me)
				=> 
				brick_highlight_on (brick_at b, adjust_range (m, me));

			    handle_brick (bu::UP (m, b), me)
				=>
				{   brick = brick_at b;

				    brick_action (m, brick, brick_highlight_off (brick, me));
				};

			    handle_brick (bu::CANCEL b, me)
				=>
				brick_highlight_off (brick_at b, me);
			end;


			fun handle_req (START d, _)           =>  start_game d;
			    handle_req (SET_RANGE r', (_, b)) =>  (r', b);
			    handle_req (GET_DIFFICULTY c, s)  => { give (c, difficulty);   s; };
			end;   


			fun loop (me as (r, bad))
			    =
			    loop (
				#
				select [
				    #
				    take' plea_slot
					==>
					(fn msg = handle_req (msg, me)),

				    take' brick_slot
					==>
					(fn msg = handle_brick (msg, me))
				]
			    );

		  end					# fun start_game

		also
		fun end_game (me as (d, r))
		    =
		    {   fun handle_req (START d', _)          =>   start_game d';
			    handle_req (SET_RANGE r', (d, _)) =>   end_game (d, r');
			    handle_req (GET_DIFFICULTY c, s)  => { give (c, d);   end_game s;  };
			end; 	

			select [
			    #
			    take' plea_slot
				==>
				(fn msg = handle_req (msg, me)),

			    take' brick_slot
				==>
				(fn _ = end_game me)
			];
		     };


		make_thread  "wall"  .{
		    #
		    end_game (bu::NORMAL, bu::SHORT);
		    ();
		};

		WALL { widget, plea_slot };
	    };


	fun as_widget (WALL { widget, ... } )
	    =
	    widget;

	fun start_game (WALL { plea_slot, ... }, d)
	    =
	    give (plea_slot, START d);

	fun difficulty_of (WALL { plea_slot, ... } )
	    =
	    {   reply_slot = make_mailslot ();

		give (plea_slot, GET_DIFFICULTY reply_slot);

		take reply_slot;
	    };

	fun set_range (WALL { plea_slot, ... }, range)
	    =
	    give (plea_slot, SET_RANGE range);

    };					#  package wall 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1996 AT&T Research.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
