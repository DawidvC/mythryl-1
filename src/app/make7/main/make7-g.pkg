## make7-g.pkg
## Author: Matthias Blume (blume@cs.princeton.edu)

# Compiled by:
#     src/app/make7/Make7.make6


# This module constitutes our standard
# 
#     make7 application + compiler + interactive system
#
# which is to say, what winds up as the
#
#     bin/mythryld
#
# "executable" (heap image).
#
# We use this application to make+compile everything
# -except- itself.  (Compiling mythryd7 itself involves
# special cases which are handled by the special
#
#        src/app/make7/make-compiler/make-compiler-g.pkg
#
# facility.)
#
# This is the module that actually puts together
# the contents of the
#     package make7
# people find in $ROOT/src/lib/core/make7/full.make6, which is to
# say, the set of make7::* types, functions and values
# visible from the mythryld prompt at runtime.
#
# For example, if you run
#     bin/mythryld
# and then enter
#     make7::make7_state::show_toplevel (); 
# at the interactive prompt, you'll invoke the
# show_toplevel fun defined in this file, which
# lists all toplevel symbols.
#
# The code in this file is almost all lightweight
# stuff -- commandline switch parsing and top-level
# glue logic hooking together functionality implemented
# elsewhere.
#
# The major functionality imvoked here is doing the treewalks
# of the sourcefile dependency walk so as to compile no sourcefile
# until all files it depends upon have been compiled, making the
# type information &tc in those files available.  This process is
# somewhat obscured by the "server" facility to allow compiling
# multiple sourcefiles in parallel using multiple Unix subprocesses
# (optionally on separate machines).  This facility appears broken.
#
# The actual treewalk functionality is largely implemented in
#
#     src/app/make7/compile/compile-treewalk-g.pkg
#     src/app/make7/compile/linking-treewalk-g.pkg
#
#
# generic invocation context:
#
#     The generic we define is invoked (only) in
#
#         src/lib/core/internal/make7-0.pkg
#
#     which consists of the single statement
#
#        package make7_0 = make7_g (package compiler_client_interface = compiler_client_interface)
#
#     make7_0 is used in four places (lumping all the make-compiler/platform files together):
#
#         src/lib/core/make-compiler/x86-unix.pkg:    load_plugin = make7_0::load_plugin
#         src/lib/core/internal/boot-dictionary.pkg:  package boot_dictionary = boot_dictionary_g
#         src/lib/core/make7/make7.pkg:               package make7 :> Make7 = make7_0::make7
#         src/lib/core/make7/tools.pkg:               package tools :> Tools = make7_0::tools
#
# generic argument:
#
#     "compiler_client_interface" is defined by
#
#             package compiler_client_interface = X86CCallBackend
#         in
#             src/lib/core/compiler/x86-with-unix-call-conventions.pkg
#
#         which gets conditionally included by
#
#             src/lib/core/compiler/current.make6
#
#         (The above is for "x86-linux";
#          other platforms are similar.)
#
#
#
# Runtime invocation context:
#
#     The two most important runtime
#     entrypoints in this file are our
#	    make
#	    compile
#     functions, which are respectively invoked by typing
#          make    "foobar.make6"
#          compile "foobar.make6"
#     at the interactive prompt.
#
#
#
#     We also export a 'set_up_make7' function which becomes
#     make7_0::init courtesy of our generic invocation in
#
#         src/lib/core/internal/make7-0.pkg
#
#     and which is then passed as 'cminit'
#
#         by  src/lib/core/internal/boot-dictionary.pkg
#         to  src/lib/core/internal/boot-dictionary-g.pkg
#
#     to become part of -its- 'init' function,
#     which is invoked by 
#
#         src/lib/core/internal/main.pkg
#
#     shortly before dumping the heap image which
#     generates the compiler "executable" heap image.



###            "The most crucial difference is not that
###             the good programmers are better at getting
###             out of trouble, but that the poor ones are
###             better at getting into it."



generic package   make7_g (

    package compiler_client_interface
        :
        Compiler_Client_Interface;			# Compiler_Client_Interface		is from   src/lib/compiler/toplevel/backend/compiler-client-interface.api
)
{
    stipulate

	package e  = compiler_table_set;		# compiler_table_set			is from   src/lib/compiler/toplevel/compiler-state/compiler-table-set.pkg
	package de = linking_table;			# linking_table				is from   src/lib/compiler/execution/linking-table/linking-table.pkg

	package cs = compiler_state;			# compiler_state			is from   src/lib/compiler/toplevel/interact/compiler-state.pkg
	package s  = symbol;				# symbol				is from   src/lib/compiler/front/basics/mlcomp/symbol.pkg
	package em = error_message;			# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

	package p  = winix::path;			# winix					is from   src/lib/std/winix.pkg
	package f  = winix::file;
	package dg = intra_library_dependency_graph;	# intra_library_dependency_graph	is from   src/app/make7/depend/intra-library-dependency-graph.pkg
	package lg = inter_library_dependency_graph;	# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg
	package im = int_map;				# int_map				is from   src/app/make7/util/int-map.pkg
	package ad = anchor_dictionary;			# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg

	os = host_info::get_os_kind ();			# lib7					is from   src/lib/std/lib7.pkg

        # Set platform to "x86-linux" or such:		# filename_policy			is from   src/app/make7/main/filename-policy.pkg
	#
	platform
            =
            cat [
                compiler_client_interface::architecture_name,		# "ppc", "sparc" or "x86".
                "-",
                filename_policy::os_kind_to_string os
            ];

        # Set up a little dictionary defining
        # half a dozen platform properties
        # like architecture ("x86" or such):
        #
	package host_properties
            =
            host_properties_g (				# host_properties_g			is from   src/app/make7/main/host-properties-g.pkg

                architecture_name =  compiler_client_interface::architecture_name;		# "ppc", "sparc" or "x86".
		os                =  os;
		abi_variant       =  compiler_client_interface::abi_variant;
            );


        # 'seed_libraries_index' gets set by read_picklehash_map (below) from
        #
        #     build7.seed-libraries/LIBRARY_CONTENTS
        #
        # and constitutes our master index to the complete
        # contents of the build7.seed-libraries/* directory
        # tree.
        #
	seed_libraries_index
            =
            REF (source_path_map::empty: source_path_map::Map(  int_map::Map(    e::Linking_Table ) ));
            #  XXX BUGGO FIXME more mutable global state :( 

							# source_path_map			is from   src/app/make7/paths/srcpathmap.pkg
							# int_map				is from   src/app/make7/util/int-map.pkg
	package freezefile_map
            =
            freezefile_map_g ();			# freezefile_map_g			is from   src/app/make7/freezefile/freezefile-map-g.pkg


        #  XXX BUGGO FIXME more mutable global state :( 

	read_eval_print_from_stream_hook
            =
            REF   (fn _ =  raise exception FAIL "read_eval_print_from_stream_hook not initialized")   :   Ref( file::Input_Stream -> Void );


        # 2008-02-24 CrT:  This is a quick hack to get the eval definition
        #                  from where I can get it to where I want it.  A
        #                  cleaner mechanism would be cool. XXX BUGGO FIXME.
        #
        #                  (I don't intend ever changing this pointer
        #                  once set, so this is not really an example
        #                  of problematic global state.)
        #
        my eval_hook : Ref(String -> Void)
                     = REF (fn _ = ());


	package   compile_treewalk
            =
            compile_treewalk_g (			# compile_treewalk_g		is from   src/app/make7/compile/compile-treewalk-g.pkg

		package   compiler_client_interface =  compiler_client_interface;
		package   freezefile_map          =  freezefile_map;

		fun read_eval_print_from_stream   stream
		    =
		    *read_eval_print_from_stream_hook   stream;

		compile_in_subprocess
		    =
		    compile_client::compile   o   ad::encode;

							# compile_client			is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
							# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg
	    );

	package   oh7_file_cache
            =
            oh7_file_cache_g (				# oh7_file_cache_g			is from   src/app/make7/compile/oh7-file-cache-g.pkg

                architecture_name = compiler_client_interface::architecture_name;
            );


	package   linking_treewalk
            =
            make_link_treewalk_g (		# linking_treewalk_g		def in    src/app/make7/compile/linking-treewalk-g.pkg

                package   oh7_file_cache = oh7_file_cache;

		seed_libraries_index = seed_libraries_index;
            );

        stipulate

	    find_set_of_o7_files_for_executable
                =	
	        find_set_of_o7_files_for_executable::find_set_of_o7_files_for_executable;
	herein
	    make_bootlist
		=
		.l   o   find_set_of_o7_files_for_executable   (fn p =  p);
	end;

							# find_set_of_o7_files_for_executable	is from   src/app/make7/make-compiler/find-set-of-o7-files-for-executable.pkg
							# compile_client			is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
							# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg

	fun set_up_servers (lg::LIBRARY { library_path, ... } )
		=>
		compile_client::make {
		    platform,
		    project  => ad::encode library_path
		};

	   set_up_servers lg::ERROR_LIBRARY
		=>
		();
        end;

        # This is the 'runner' function
        # for the 'compile' function implementing
        #     make7::compile "foo.make6"
	#
	fun runner_for_compile
                make7_state
                library              			#  Freshly read in by make7file::build_interlibrary_dependency_graph_from_make7file_tree 
            =
            {
                set_up_servers  library;

		fun store _
                    =
                    ();

		my { symbol_and_inlining_tables => my_library, ... }
                    =
                    compile_treewalk::walk_inter_library_dependency_graph (

                        linking_treewalk::evict,
                        store,
                        library
                    );

		not_null (compile_client::with_servers (fn () =  my_library make7_state))
		before
                    linking_treewalk::cleanup make7_state;
	    };

							# linking_treewalk_g			def in    src/app/make7/compile/linking-treewalk-g.pkg
							# walk_inter_library_dependency_graph		def in    src/app/make7/compile/compile-treewalk-g.pkg
							# evict						def in    src/app/make7/compile/linking-treewalk-g.pkg

        # This is the 'runner' function for the 'load' function implementing
        #     make7::make "foo.make6"
	# It combines the actions of "compile" and "exec".
	# When successful, it combines the results
	# (thus forming a full dictionary) and adds
        # it to the toplevel dictionary.
	#
	fun runner_for_make
# MUSTDIE add_namings is probably part of the problem:
                add_namings              #  Bool: 'TRUE' for regular commandline make, 'FALSE' when called from load_plugin' 
                make7_state
                (parsed_makefile as lg::LIBRARY library_record)       #  The result of make7file::build_interlibrary_dependency_graph_from_make7file_tree (foo.make6) 
            =>
            {   library_record
                    ->
                    { required_privileges, ... };


		my { cache_oh7_file, get }
                    =
                    oh7_file_cache::make ();	# oh7_file_cache is defined at top of file.
                                                # new	def in    src/app/make7/compile/oh7-file-cache-g.pkg

		set_up_servers  parsed_makefile;


                # Both of the next two calls return
                # fates, which must be called
                # with a make7_state argument in order
                # to actually yield a useful result:
		#
		my { symbol_and_inlining_tables    => compile_fate, ... }
                    =
                    compile_treewalk::walk_inter_library_dependency_graph (
                        linking_treewalk::evict,
                        cache_oh7_file,
                        parsed_makefile
                    );

		my { linking_table => linking_fate, ... }
                    =
                    linking_treewalk::make_treewalk (
                        parsed_makefile,
                        .contents o get
                    );
							# linking_treewalk_g	def in    src/app/make7/compile/linking-treewalk-g.pkg


		case (compile_client::with_servers
                         .{   compile_fate  make7_state;   })
		  
		     NULL => FALSE;

		     THE { symbol_table, inlining_table }
			 =>
                         {
			     # Before executing the code, we announce the privileges
			     # that are being invoked.  For the time being, we assume
			     # that everybody has every conceivable privilege, but at
			     # the very least we announce which ones are being used:
			     #
			     linking_treewalk::cleanup  make7_state;

							# linking_treewalk_g	def in    src/app/make7/compile/linking-treewalk-g.pkg
							# string_set		is from   src/lib/src/string-set.pkg

			     # 2009-03-29 CrT: Commented out because
			     # currently this is just useless noise:

#			     if   (not (string_set::is_empty  required_privileges))
#			          
#                                  file::vsay ("          src/app/make7/main/make7-g.pkg:   $Execute: Required privileges are:\n" .
#				      map
#                                          (fn s =  ("                                            " + s + "\n"))
#                                          (string_set::vals_list required_privileges));
#                             fi;


			     case (linking_fate  make7_state)
			       
				  NULL => FALSE;

				  THE linking_table
				      =>
				      {   if add_namings

					       compiler_table_set_differences
						   =
						   e::make_compiler_table_set { 
						       symbol_table,
						       linking_table,
						       inlining_table
						   };


					       top_level               =  cs::top_level ();
					       base_compiler_table_set =  top_level.get ();

					       new_compiler_table_set
						   =
						   e::concatenate_compiler_table_sets (
						       compiler_table_set_differences,
						       base_compiler_table_set
						   );

					       top_level.set  new_compiler_table_set;
					       file::vsay ["          src/app/make7/main/make7-g.pkg:   New names added.\n"];
					  fi;

					  TRUE;
				      };
			     esac;
			 };
                esac;
	    };

            runner_for_make _ _ lg::ERROR_LIBRARY
	        =>
	        FALSE;
        end;


	package freezefile
	    =							# make_linking_treewalk_g		is from   src/app/make7/compile/linking-treewalk-g.pkg
	    freezefile_g (					# freezefile_g				is from   src/app/make7/freezefile/freezefile-g.pkg

		architecture_name
		    =
                    compiler_client_interface::architecture_name;

		package freezefile_map
                    =
                    freezefile_map;


								# make7_state				is from   src/app/make7/main/make7-state.pkg
								# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg
								# oh7_file_cache_g			def in    src/app/make7/compile/oh7-file-cache-g.pkg
								# compile_treewalk_g 			is from   src/app/make7/compile/compile-treewalk-g.pkg
								# linking_treewalk_g			def in    src/app/make7/compile/linking-treewalk-g.pkg
		# A function which allows
		#
                #     freezefile::write_freezefile
		#
                # to recompile any thawed real library
		# handed to it:
		#
		fun recompile
                        (make7_state:   make7_state::Make7_State)
                        (my_library:    inter_library_dependency_graph::Library)
		    =
		    {   my { cache_oh7_file, get }
			    =
			    oh7_file_cache::make ();

			my { symbol_and_inlining_tables, ... }
			    =
			    compile_treewalk::walk_inter_library_dependency_graph (

				linking_treewalk::evict,
				cache_oh7_file,
				my_library
			    );

			case (symbol_and_inlining_tables  make7_state)
			  
			     NULL  =>  NULL;
			     THE _ =>  THE get;
			esac;
		    };

		get_o7_exports
		    =
		    compile_treewalk::get_o7_exports;
	    );


	# Access to the library-building mechanism
	# is integrated into the .make6 file parser.
        #
	# I'm not sure if this is the cleanest way,
	# but it works well enough.		-- Matthias Blume
	#
	package make7file
	    =
	    make7file_g (				        # make7file_g	def in    src/app/make7/parse/make7file-g.pkg

		package freezefile     =  freezefile;
		package freezefile_map =  freezefile_map;

		fun evict_stale ()
		    =
		    {   compile_treewalk::evict_stale ();
			linking_treewalk::evict_stale ();
		    };
	    );

        include freeze_policy;


	stipulate

	    Primordial_Library_Dependency_Graph
                =
                { primordial_make7file: lg::Library };


	    filename_policy			
                =
                filename_policy::policy;
								# filename_policy	is from   src/app/make7/main/filename-policy.pkg
								# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg

	    primordial_make7file_hook
                =
                REF (NULL: Null_Or( Primordial_Library_Dependency_Graph ));

	herein
	    anchor_dictionary
                =
                ad::dictionary;



	    fun make_standard_source_path  path_string
		=
		ad::file (

                    ad::from_standard

                        { plaint_sink   =>   fn string =  raise exception FAIL string,
                          anchor_dictionary
                        }

			{ path_root =>   ad::cwd (),
                          spec      =>   path_string
                        }
		    );

	    fun show_api  (api_name: String)
		=
		{
		    symbol_table
			=
			compiler_table_set::symbol_table_part
                            (compiler_state::combined ());

		    symbol
                        =
                        symbol::make_api_symbol  api_name;

                    case (symbol_table::get  (symbol_table, symbol))
                      
                         symbol_table_entry::NAMED_API a
                             =>
                             {
				 prettyprint_device
				     =
				     {   consumer  =>  (fn string =  file::write  (file::stdout,  string)),
					 linewidth =>  2000,        # Arbitrary large number.
					 flush     =>  .{ file::flush  file::stdout; }
				     };

				 prettyprint_stream
				     =
				     prettyprint::open_stream  prettyprint_device;

												# unparse_package_language	is from   src/lib/compiler/front/typechecker/print/unparse-package-language.pkg
                                 unparse_package_language::unparse_api
				     prettyprint_stream
                                     (a, symbol_table, /* max prettyprint recursion depth: */ 200);

                                 prettyprint::flush_stream  prettyprint_stream;

                             };

                         _   =>
                             print "    src/app/make7/main/make7-g.pkg:show_api: Improbable failure.\n";
                    esac
                    except
                        unbound
                            =
                            print ("No api " + api_name + " defined at top level.\n");

		};

	    fun show_pkg  (pkg_name: String)
		=
		{
		    symbol_table
			=
			compiler_table_set::symbol_table_part
                            (compiler_state::combined ());

		    symbol
                        =
                        symbol::make_package_symbol  pkg_name;

                    case (symbol_table::get  (symbol_table, symbol))
                      
                         symbol_table_entry::NAMED_PACKAGE a
                             =>
                             {
				 prettyprint_device
				     =
				     {   consumer  =>  (fn string =  file::write  (file::stdout,  string)),
					 linewidth =>  2000,        # Arbitrary large number.
					 flush     =>  .{ file::flush  file::stdout; }
				     };

				 prettyprint_stream
				     =
				     prettyprint::open_stream  prettyprint_device;


                                 unparse_package_language::unparse_package
				     prettyprint_stream
                                     (a, symbol_table, /* max prettyprint recursion depth: */ 200);

                                 prettyprint::flush_stream  prettyprint_stream;

                             };

                         _   =>
                             print "    src/app/make7/main/make7-g.pkg:show_pkg: Improbable failure.\n";
                    esac
                    except
                        unbound
                            =
                            print ("No package " + pkg_name + " defined at top level.\n");

		};
										# symbol_table_entry	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table-entry.pkg
										# symbol_table		is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
										# compiler_table_set	is from   src/lib/compiler/toplevel/compiler-state/compiler-table-set.pkg
										# symbol		is from   src/lib/compiler/front/basics/mlcomp/symbol.pkg
										# symbol_map		is from   src/app/make7/util/symbolmap.pkg
										# compiler_state	is from   src/lib/compiler/toplevel/interact/compiler-state.pkg
										# make7_defaults	is from   src/app/make7/util/make7-defaults.pkg
	    fun show_all ()
                =
                {   symbols =  compiler_state::list_bound_symbols ();

                    descriptions
                        =
                        map
                            symbol::describe
                            symbols;

		    fun pr s
                        =
                        file::say [s, "\n"];

		    file::say ["\nTop-level definitions:\n"];
		    apply pr descriptions;
		};


	    fun show  title_string  filter_fn
                =
                {   symbols  =  compiler_state::list_bound_symbols ();
                    symbols  =  list::filter  filter_fn  symbols;

                    names    =   map
				     symbol::name
				     symbols;

                    sorted_names
			= 
                        list_mergesort::sort
                            string::(>)
                            names;

		    fun pr s
                        =
                        file::say [s, " "];

		    file::say ["\nTop-level ", title_string, " definitions:\n"];
		    apply pr sorted_names;
                    file::say ["\n"];
		};


	    fun show_vals     () =  show  "val"        (fn symbol =  (symbol::name_space symbol  ==  symbol::VALUE_NAMESPACE  ));
	    fun show_apis     () =  show  "api"        (fn symbol =  (symbol::name_space symbol  ==  symbol::API_NAMESPACE    ));
	    fun show_pkgs     () =  show  "pkg"        (fn symbol =  (symbol::name_space symbol  ==  symbol::PACKAGE_NAMESPACE));
	    fun show_types    () =  show  "type"       (fn symbol =  (symbol::name_space symbol  ==  symbol::TYPE_NAMESPACE   ));
	    fun show_generics () =  show  "generic"    (fn symbol =  (symbol::name_space symbol  ==  symbol::GENERIC_NAMESPACE));


										# unparse_compiler_state	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/unparse-compiler-state.pkg
										# latex_print_compiler_state	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/latex-print-compiler-state.pkg

	    fun dump_api_reference  filename
                =
                unparse_compiler_state::unparse_compiler_state_to_file
                    filename;

	    fun latex_dump_api_reference
                    { directory,
                      filename_prefix,
                      filename_suffix
                    }
                =
                latex_print_compiler_state::latex_print_compiler_state_to_file
                    { directory,
                      filename_prefix,
                      filename_suffix
                    };

	    fun get_primordial_make7file_hook_value ()
                =
                the *primordial_make7file_hook
	        except
                    NULL_OR
                    =
                    raise exception FAIL "src/app/make7/main/make7-g.pkg: primordial_make7file_hook not initialized";

	    fun make7_session  server_mode
                =
                { filename_policy,
		  anchor_dictionary,

		  host_property     => host_properties::symbol_value,
		  platform,

		  keep_going        => make7_defaults::keep_going.get (),
		  server_mode
                };

	    primordial_make7file
                =
                .primordial_make7file  o  get_primordial_make7file_hook_value;

            # Maybe delete picklestrings
            # from memory to save ram:
	    #
	    fun maybe_clear_pickle_cache ()
                =
                if  (make7_defaults::conserve_memory.get ())         #  'FALSE' by default, but user-settable. 

                     make7file::clear_pickle_cache ();
		fi;
									# make7_defaults	is from   src/app/make7/util/make7-defaults.pkg
									# make7file_g		def in    src/app/make7/parse/make7file-g.pkg

            # Construct a build_interlibrary_dependency_graph_from_make7file_tree argument record:
	    #
	    fun parse_arg_0  server_mode  (library_source_index, freeze_policy, make7_file_to_read)
                =
                { make7_file_to_read,                   #  Primary input to build_interlibrary_dependency_graph_from_make7file_tree fn. 

                  load_plugin,
		  library_source_index,

		  make7_session      =>  make7_session  server_mode,
		  freeze_policy,					# See explanation in   src/app/make7/parse/freeze-policy.api

		  primordial_make7file    =>  primordial_make7file (),
		  paranoid           =>  FALSE
		}

	    also
	    fun parse_arg       x =   parse_arg_0 FALSE x

	    also
	    fun server_parse_arg x =   parse_arg_0 TRUE  x

	    also
	    fun run   make_src_path   freeze_policy   runner_fn   makefile_path_string
                =
                # Read in a .make6 makefile and then
                # apply given 'runner_fn' to the result:
		#
                {
                    makefile_path
                        =
                        make_src_path   makefile_path_string;


		    library_source_index
                        =
                        library_source_index::make ();

							# library_source_index	is from   src/app/make7/semant/library-source-index.pkg
							# make7file_g	def in    src/app/make7/parse/make7file-g.pkg

		    {   file::vsay [
                            "          src/app/make7/main/make7-g.pkg:   Running   .make6file    ",
                            makefile_path_string,
                            "\n"
                        ];

#                        show_toplevel ();

			case (make7file::build_interlibrary_dependency_graph_from_make7file_tree
                                 (parse_arg
                                     ( library_source_index,
                                       freeze_policy,
                                       makefile_path
                                     )
                                 ))
                          
			     THE (library, make7_state)
                                 =>
                                 {
                                     runner_fn   make7_state   library;
                                 };

			     NULL
                                 =>
                                 {
                                     FALSE;
                                 };
                        esac;
		    }
		    before
                        maybe_clear_pickle_cache ();
		}


	    also
	    fun load_plugin'  plugin_path
                =
                {   plugin_description
                        =
                        ad::describe  plugin_path;

                    file::vsay [
                        "          src/app/make7/main/make7-g.pkg:  Attempting to load plugin ",
                        plugin_description,
                        "\n"
                    ];

		    library_source_index
                        =
                        library_source_index::make ();

		    succeeded
                        =
                        {   case (make7file::build_interlibrary_dependency_graph_from_make7file_tree (
                                     parse_arg (
                                         library_source_index,
                                         FREEZE_NONE,
                                         plugin_path
                                     )
                                 ))
			      
				THE (group, make7_state)
                                    =>
                                    runner_for_make   FALSE   make7_state   group;

                                NULL
                                    =>
                                    FALSE;
                            esac
			    before
                                maybe_clear_pickle_cache ();
		        }
			except
                            _ = FALSE;

		    if succeeded   file::vsay ["          src/app/make7/main/make7-g.pkg:  plugin ", plugin_description, " loaded successfully]\n"];
		    else           file::vsay ["          src/app/make7/main/make7-g.pkg:  Unable to load plugin ", plugin_description, "\n"];      fi;

		    succeeded;
		}


	    also
	    fun load_plugin  path_root  spec
                = 
                {   fun badname string
                        =
                        file::say ["    src/app/make7/main/make7-g.pkg:  Bad plugin name: '", string, "'\n"];

								# say			is from   src/lib/std/src/io/say.pkg
								# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg
		    prefile
                        =
                        ad::from_standard
			    { anchor_dictionary,
			      plaint_sink => badname
			    }
			    { path_root,
			      spec
			    };

		    load_plugin' (ad::file  prefile);
		};


	    fun cwd_load_plugin  x
                =
                load_plugin (ad::cwd ()) x;



            # This function may be interactively invoked
            # from the commandline as make7::freeze'.
            # (Or as make7::freeze
            # or     make7::freeze1
            # in which the 'recursively' boolean arg is implicit.)
	    #
	    fun freeze'   recursively   root
                =
                {   fun freeze_library_compile_runner  make7_state  g
                        =
                        {   set_up_servers  g;

			    my { all_libraries, ... }
                                =
                                compile_treewalk::walk_inter_library_dependency_graph (
                                    linking_treewalk::evict,
                                    fn _ = (),
                                    g
                                );

								# compile_treewalk		def is    above.
								# compile_treewalk_g	def in    src/app/make7/compile/compile-treewalk-g.pkg
								# linking_treewalk		def is    above.
								# linking_treewalk_g	def in    src/app/make7/compile/linking-treewalk-g.pkg
								# compile_client		is from   src/app/make7/simple-concurrency/unix-compile-client.pkg

			    compile_client::with_servers
                                .{   all_libraries  make7_state;   };
			};


		    fun freeze_library_dummy_runner  make7_state  group
                        =
                        TRUE;



		    fun phase1 ()
                        =
                        run
                            make_standard_source_path
                            FREEZE_NONE
                            freeze_library_compile_runner
                            root;


		    fun phase2 ()
                        =
                        {   compile_treewalk::reset ();                     #  A bit too draconian? 

			    run
                                make_standard_source_path
                                (recursively ?? FREEZE_ALL :: FREEZE_ONE)
                                freeze_library_dummy_runner
                                root;
                        };


		    # Don't bother with the 2-phase thing
		    # if there are no compile servers attached.
		    #
		    # We still need the "with_servers" call to
		    # clean up our queues in case of an
		    # interrupt or error.)

		    if   (compile_client::no_servers ())
		         compile_client::with_servers phase2;
		    else
			 # We do this in two phases:
			 #
			 #    1. Recompile everything without building any libraries
			 #       but potentially using other compile-server processes.
			 #
			 #    2. Do a local library-building run (which should have
			 #       no need to compile anything).

			 phase1 () and phase2 ();
                    fi;
		};



            ##########################################################
            #  These are the entry points that will execute when we   
            #  respectively do    'make7::make      "foobar.make6"; or 
            #                     'make7::compile "foobar.make6";'   
            #  at the interactive prompt:                             
            ##########################################################

	    make      =   run   make_standard_source_path   FREEZE_NONE   (runner_for_make TRUE);
	    compile   =   run   make_standard_source_path   FREEZE_NONE    runner_for_compile;



	    fun to_portable s
                =
                {   gp =   make_standard_source_path   s;

		    fun nativesrc s
                        =
                        {   p = ad::from_standard
				    { plaint_sink  =>   fn s =  raise exception FAIL s,
				      anchor_dictionary
				    }
				    { path_root =>   ad::dir   gp,
                                      spec    =>   s
                                    };

			    ad::os_string'   (ad::file   p);
			};

		    fun mkres (g, pl)
                        =
                        {   graph     => g,
			    imports   => pl,
			    nativesrc
			};

		    null_or::map
			(mkres o to_portable::export)
			(make7file::build_interlibrary_dependency_graph_from_make7file_tree
                            (parse_arg
                                (   library_source_index::make (),
				    FREEZE_NONE,
				    make_standard_source_path s
				)
			    )
			);
		};
								# null_or		is from   src/lib/std/src/null-or.pkg
								# to_portable		is from   src/app/make7/depend/to-portable.pkg
								# library_source_index	is from   src/app/make7/semant/library-source-index.pkg


            # This function is exported to the user interface as
            # make7::sources.  It provides dependency generation
            # support used by 'makedepend7'.
            #
            # According to the manual:
            #
	    #    The 'make7::sources' function can be used to find the
	    #    names of all source files that a given library depends on.
            #
            #    It returns the names of all files involved with
            #    the exception of module_dependencies_summary files and .o7 files.
            # 
	    #    Frozen libraries are represented by their freezefile;
            #    their description file or constituent members are
	    #    NOT listed.
            #
	    #    Normally, the function reports actual file
	    #    names as used for accessing the file system.
            #
            #    For freezefiles this behavior can be
	    #    inconvenient because these names depend on
            #    architecture and operating system.
            #
            #    For this reason, make7::sources accepts an
            #    optional pair of strings that then will be used
            #    in place of the architecture- and OS-specific
            #    part of these names.
            #
            #    If there was some error analyzing the specified
            #    library or sublibrary, make7::sources returns NULL.
            #       Otherwise the result is a list of records, each
            #    carrying a file name, the corresponding ilk, and
            #    information about whether or not the source was
            #    created by some tool:
            #
	    #	       my sources:  { arch: String,   os: String } Null_Or
            #                   -> String
            #                   ->  Null_Or( List { file: String,   ilk: String,   derived: Bool } )
	    #
	    fun sources platform group
                =
                {   policy
                        =
                        case platform
			  
			     NULL                    =>  filename_policy;
			     THE architecture_and_os =>  filename_policy::policy;
                        esac;

								# filename_policy	is from   src/app/make7/main/filename-policy.pkg
								# source_path_set	is from   src/app/make7/paths/srcpathset.pkg

		    fun sources_of ((p, library_thunk
                                                     , _	# MUSTDIE
                                                     ), (v, a))
			=
			{   v' = source_path_set::add (v, p);

			    case (library_thunk ())
			      
				lg::ERROR_LIBRARY
                                    =>
                                    (v', a);

				lg::LIBRARY { real_or_virtual, sources, ... }
				    =>
				    {   fun add (p, x, a)
					    =
					    string_map::set (a, ad::os_string p, x);

					fun sg l
					    =
					    if   (source_path_set::member (v, p))
					        
						 (v, a);
					    else
						 fold_left
						     sources_of
						     (    v',
							  source_path_map::keyed_fold_left add a sources
						     )
						     l;
                                            fi;

					case real_or_virtual
					  
					     lg::VIRTUAL n
                                                 =>
                                                 sg n.sublibraries;

					     lg::REAL { frozen_or_thawed, version }
						 =>
						 case frozen_or_thawed
						    
						      lg::THAWED d => sg d.sublibraries;

						      lg::FROZEN _
							   =>
							   {   f =   ad::os_string   p;

							       my (a, x)
								   =
								   string_map::drop (a, f);

							       freezefile_name
								  =
								  filename_policy::make_freezefile_name
                                                                     policy
								     p;

							       (  v',
								  string_map::set (a, freezefile_name, x)
							       );
							   }; 
						 esac;
                                        esac;
				    };
                            esac;
			};

		    p =  make_standard_source_path group;


		    library_source_index
                        =
                        library_source_index::make ();


		    case (make7file::build_interlibrary_dependency_graph_from_make7file_tree
                             (parse_arg
                                 (   library_source_index,
			             FREEZE_NONE,
			             p
			   ) )   )
		      
			 THE (g, _)
			     =>
			     {   my (_, sm)
				     =
				     sources_of ( ( p,
						   fn () = g
						   , []	# MUSTDIE
						 ),
						 ( source_path_set::empty,
						   string_map::singleton ( ad::os_string p,
									 { ilk     =>  "cm",
									   derived =>  FALSE
									 }
								       )
						 )
					       );

				 fun add (s, { ilk, derived }, l)
				     =
				     { file => s, ilk, derived } ! l;

				 THE (string_map::keyed_fold_left add [] sm);
			     };

			_ => NULL;
		    esac
		    before
                        maybe_clear_pickle_cache ();
		};

	    fun build_executable_heap_image
                    freeze_policy		# FREEZE_NONE/FREEZE_ONE/FREEZE_ALL
                    { setup,			# Always NULL in practice.
                      make7file_to_run,		# Say, "nowhere.make6"
                      wrapper_make7file,	# One-line scratch .make6 file created by bin/build-an-executable-mythryl-heap-image script.
                      heap_filename		# Heapfile to create (i.e., executable), say "nowhere"
                    }
                =
                {   spopt             =   null_or::map make_standard_source_path  setup;
		    make7file_to_run  =   make_standard_source_path  make7file_to_run;
		    wrapper_make7file =   make_standard_source_path  wrapper_make7file;
		    timestamp         =   time_stamp::last_file_modification_time  heap_filename;

									# time_stamp	is from   src/app/make7/paths/timestamp.pkg

		    library_source_index
                        =
                        library_source_index::make ();

		    fun do_make7file p
			=
			case (make7file::build_interlibrary_dependency_graph_from_make7file_tree
                                 (parse_arg
                                     ( library_source_index,
				       FREEZE_NONE,
				       p
				     )
                               ) )
			  
			     THE (g, gp)
                                 =>
                                 if   (runner_for_compile gp g)
				      THE (make_bootlist g);
				 else NULL;                  fi;

			     NULL
                                 =>
                                 NULL;

                       esac;

		    set_up_list
                        =
                        case spopt
			  
			     THE sp =>  the_else (do_make7file sp, []);
			     NULL   =>  [];
                        esac;

		    fun in_setup (i, _)
                        =
                        list::exists
                            (find_set_of_o7_files_for_executable::same_info i  o  #1)
                            set_up_list;

								# list	is from   src/lib/std/src/list.pkg

		    fun do_wrapper ()
			=
			case (do_make7file wrapper_make7file)
			  
			     NULL  =>  NULL;
			     THE l =>  THE (  map #2 ( set_up_list @ list::filter (not o in_setup) l) );
                        esac;

		    case (make7file::build_interlibrary_dependency_graph_from_make7file_tree
                             (parse_arg
                                 ( library_source_index,
                                   freeze_policy,
                                   make7file_to_run
                                 )
                           ) )
		      
			 NULL => NULL;

			 THE (group, make7_state)
			     =>
			     if  (freeze_policy != FREEZE_NONE
			     or	  runner_for_compile  make7_state  group
			     )
				  # If none of the sourcefiles have been
				  # modified since the target was created,
				  # we don't need to rebuild:
				  #
				  case (timestamp, *make7_state.youngest)
				    
				       ( time_stamp::TIMESTAMP target_timestamp,
					 time_stamp::TIMESTAMP source_timestamp
				       )
					   =>
					   if   (time::(<) (target_timestamp, source_timestamp))
					        do_wrapper ();
					   else THE [];   fi;

				       _   =>
                                           do_wrapper ();
				  esac;
			     else
				  NULL;
			     fi;
		    esac
		    before
                        maybe_clear_pickle_cache ();
		};


	    fun redump_heap s:  Void
                =
                fate::resume_fate   *compiler_client_interface::interact::redump_heap_fate   s;


	    fun enter_compile_server_loop ()
                =
                {
                    library_source_index
                        =
                        library_source_index::make ();

		    fun build_interlibrary_dependency_graph_from_make7file_tree  make7_file_to_read
                        =
                        make7file::build_interlibrary_dependency_graph_from_make7file_tree
                            (server_parse_arg
                                ( library_source_index,
                                  FREEZE_NONE,
                                  make7_file_to_read
                                )
                            );

		    .set (host_properties::symbol_value "MAKE7_SERVER_MODE")	# Nothing ever tests for this (unlike CMB_SERVER_MODE and CMB_REBUILD).
                         (THE 1);

										# host_properties_g	def in    src/app/make7/main/host-properties-g.pkg
										# compile_server		is from   src/app/make7/main/compile-server.pkg

		    compile_server::enter_server_loop	# This never returns: it runs the compile-server loop indefinitely, then exit()s.
                    	{
                          anchor_dictionary,
			  build_interlibrary_dependency_graph_from_make7file_tree,

			  platform,				# 'platform' string gives architecture+OS: "x86-linux" or such. 
			  load => make,
			  make_compile_treewalker
                              =>
                              compile_treewalk::make_intra_library_dependency_graph_walker
			};
		};
										# compile_treewalk_g	def in    src/app/make7/compile/compile-treewalk-g.pkg

	    # The following function is essentially the second half
            # of the 'bin/build-an-executable-mythryl-heap-image'
            # (aka sh/_build-an-executable-mythryl-heap-image) script
            # to build an executable heap image file from a .make6 file.
            #
            # The script invokes this function using a
            # ' --build-an-executable-mythryl-heap-image' commandline switch
            # kludged into bin/mythryld.  It probably should be executed
            # via a "'bin/mythryld -e 'your code here()', sort of mechanism,
            # but we haven't implemented that yet.   XXX BUGGO FIXME
	    #
	    fun build_an_executable_mythryl_heap_image  buildargs
		=
		winix::process::exit
		    case buildargs
		       
			 [       make7file_to_run, make7file, heap, o7_files_file, linkargs_file] =>  do_it (NULL,      make7file_to_run, make7file, heap, o7_files_file, linkargs_file);
			 [setup, make7file_to_run, make7file, heap, o7_files_file, linkargs_file] =>  do_it (THE setup, make7file_to_run, make7file, heap, o7_files_file, linkargs_file);

			 _ => { file::say ["bad arguments to --build-an-executable-mythryl-heap-image\n"];
				winix::process::failure;
			      };
		    esac

                where

		    fun do_it (setup, make7file_to_run, wrapper_make7file, heap_filename, o7_files_file, linkargs_file)
			=
			case (build_executable_heap_image
                                 FREEZE_NONE
                                 { setup,
				   make7file_to_run,		# Master .make6 to build the app, e.g. "nowhere.make6"
				   heap_filename,		# "Executable" file to create, e.g. "nowhere"
				   wrapper_make7file		# Scratch one-line .make6 file created by bin/build-an-executable-mythryl-heap-image script.
				 }
                               )
			  
			     NULL   => {  file::say ["Compilation failed.\n"];          winix::process::failure; };
			     THE [] => {  file::say ["Heap was already up-to-date.\n"]; winix::process::success; };

			     THE l
				 =>
				 {   fun wrf (f, l)
					 =
					 {   s =  file::open_for_write  f;

					     fun wr string
						 =
						 file::write (s, string + "\n");

					     file::say ["\n",
						      "          src/app/make7/main/make7-g.pkg:   Creating file '", f, "'\n"
						     ];
					     apply wr l;
					     file::close_output  s;
					     file::say ["\n"];
					 };

				    s =   file::open_for_write  o7_files_file;

				    fun wr str
					=
					file::write (s, str + "\n");

				    n =   length l;

				    fun maxsz (s, n)
					=
					int::max (size s, n);

				    m =  fold_left maxsz 0 l;

				    wrf (o7_files_file,
					 "# This file built by src/app/make7/main/make7-g.pkg: build_an_executable_mythryl_heap_image"
					 ! "# for consumption by src/runtime/main/load-o7-files.c: BuildOh7_FileList."
					 ! "#"
					 ! "# It gives a list of .o7 files to be linked together to form a Lib7 executable (heap image)."
					 ! "#"
					 ! "# Each line after the header specifies one .o7 file to load."
					 ! "#"
					 ! "# The lines are topogically sorted so that no .o7 file depends upon a later one."
					 ! "#"
					 ! "# An .o7 file is specified as either a simple filename, or else as a"
					 ! "# FREEZEFILENAME@OFFSET: LIBRARY_DESCRIPTION triple giving the offset of the"
					 ! "# oh7_file image within some library file, where LIBRARY_DESCRIPTION in turn"
					 ! "# is a MAKE7FILE@OFFSET (SOURCEFILE) triple giving the makefile which created"
					 ! "# the library and the name of the source file which was compiled to produce"
					 ! "# the .o7 file.  (The second OFFSET is redundant with the first.)"
					 ! cat ["FILES=",           int::to_string n ]
					 ! cat ["MAX_LINE_LENGTH=", int::to_string m ]
					 ! ""
					 ! l);

				    wrf (linkargs_file,
					 [cat [" --runtime-o7-files-to-load=", o7_files_file]]);

				    winix::process::success;
				}
				except
                                    _ =  winix::process::failure;
                        esac;

		end;

	    fun reset ()
                =
                { compile_treewalk::reset  ();			# compile_treewalk_g	def in    src/app/make7/compile/compile-treewalk-g.pkg
		  linking_treewalk::reset  ();			# linking_treewalk_g	def in    src/app/make7/compile/linking-treewalk-g.pkg

		  make7file::reset         ();			# build_interlibrary_dependency_graph_from_make7file_tree           is defined above.
		  bare_o7::reset           ();			# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
		  freezefile_map::reset    ();			# freezefile_map           is defined above.
		};

	    # Calling this function is the last
            # thing done by 'set_up_make7'.
            #
            # This means that we, like it, are
            # essentially executed at compiletime
            # rather than runtime:
            #
            #     src/lib/core/internal/main.pkg
            #
            # calls us -before- dumping to disk
            # the heap image which becomes the
            # mythryld "executable":
	    #
	    fun set_up_primordial_make7file_hook (
                    root_directory,		# Contains src/ bin/ sh/ &tc.
                    linking_table,
                    process_commandline
                )  
		=
                {
# print ("src/app/make7/main/make7-g.pkg/set_up_primordial_make7file_hook/AAA: root_directory = " + root_directory + " cwd= " + (posix::current_directory()) + "\n");


                    ##########################################################
		    # Saving an in-memory datastructure to disk is
                    # called "pickling", and the result is called
                    # a "pickle".
                    #
                    # In particular, the .o7 object-code files
                    # produced by the compiler consist of pickles
                    # plus a little relish.
                    #
                    # We identify pickles by 16-byte hashes of their
                    # contents, which we call "picklehashes".
                    #
                    # A library freezefile is essentially a collection
                    # of pickles, and to use it we mainly need to know
                    # which pickles are where, which we express by an
                    # index mapping picklehashes (pickle names) to
                    # byte offsets (pickle locations within the freezefile).
                    #
                    # The file
                    #
                    #     LIBRARY_CONTENTS
                    #
                    # contains one such an index for every freezefile
                    # in the src/* directory tree which is slated for
                    # inclusion in the mythryld executable, in a simple
                    # one-index-per-line text format. For more details,
                    # see its top-of-file comments or the code that creates
                    # it: write_picklehash_map() in
                    #
                    #     src/app/make7/make-compiler/make-compiler-g.pkg: 
                    #
                    # Our next task is to load LIBRARY_CONTENTS into memory.
                    ##########################################################


		    # Construct full pathname for
                    # the LIBRARY_CONTENTS file:
                    #
# print ("src/app/make7/util/make7-g.pkg at picklehash_map_file point: cwd = " + (posix::current_directory()) + "\n");
		    picklehash_map_file
			=
			p::cat (
                            root_directory,					# Contains sh/ bin/ src/ ...
                            make_compiler_defaults::picklehash_map		# "LIBRARY_CONTENTS"
                        );

										# make_compiler_defaults	is from   src/app/make7/make-compiler/make-compiler-defaults.pkg
										# picklehash			is from   src/lib/compiler/front/basics/mlcomp/picklehash.pkg
										# string			is from   src/lib/std/string.pkg
										# source_path_map		is from   src/app/make7/paths/srcpathmap.pkg
										# anchor_dictionary		is from   src/app/make7/paths/anchor-dictionary.pkg

		    fun read_picklehash_map s
                        =
			{   seed_libraries_index
                                :=
                                loop  source_path_map::empty;
			}
                        where

                            fun loop m
                                =
                                {   fun enter (d, pids)
                                        =
					source_path_map::set (

					    m,

					    ad::decode
                                                anchor_dictionary
                                                d,

					    fold_left
                                                enter1
                                                im::empty
                                                pids
					)
                                        where

                                            fun enter1 (spec, pm)
                                                =
                                                {   from_hex = picklehash::from_hex;

						    case (string::tokens  (fn c =  c == ':')  spec)
						      
							 [pos, hexp]
							     =>
							     case (from_hex hexp, int::from_string pos)
							       
								  (THE p, THE i)
								      =>
								      case (de::get linking_table p)
								        
									   NULL      =>  pm;
									   THE chunk =>  im::set (pm, i, de::singleton (p, chunk));
								      esac;


								  _   =>
								      pm;
							     esac;


						         _ => pm;

                                                    esac;
						};
					end;

				    case (file::read_line s)
				      
				         NULL
                                             =>
                                             m;

				         THE line
                                             =>
                                             if (string::get (line, 0) == '#')		# Is it a comment line?
					          loop m;				# Yes, ignore it.
					     else
						  case (string::tokens  char::is_space  line)
						    
						       d ! pids =>   loop (enter (d, pids));
						       _        =>   loop m;
						  esac;
					     fi;
                                    esac;
				};					# fun loop
									# string	is from   src/lib/std/string.pkg

			end;

# print ("src/app/make7/util/make7-g.pkg about to open picklehash_map_file " + picklehash_map_file + ": cwd = " + (posix::current_directory()) + "\n");
                    safely::do
			{
			  open_it  =>  .{ file::open_for_read picklehash_map_file; },
			  close_it =>  file::close_input,
			  cleanup  =>  fn _ =  ()
			}
			read_picklehash_map;

		    primordial_makefile                                #  "$ROOT/src/lib/core/init/init.cmi" 
                        =
                        make_standard_source_path
                            make_compiler_defaults::primordial_makefile;

									# make_compiler_defaults	is from   src/app/make7/make-compiler/make-compiler-defaults.pkg
									# library_source_index		is from   src/app/make7/semant/library-source-index.pkg
									# time_stamp			is from   src/app/make7/paths/timestamp.pkg

		    make7_state
                        =
                        { library_source_index =>  library_source_index::make (),
			  plaint_sink   =>  em::default_plaint_sink (),

			  youngest      => REF time_stamp::ancient,	# Set up to track most recent (known) edit of any sourcefile in the library.
			  make7_session => { filename_policy,
					     anchor_dictionary,
					     host_property     => host_properties::symbol_value,

					     platform,
					     keep_going  => FALSE,
					     server_mode => FALSE
					   }
			};
									# freezefile is defined above, via freezefile_g().
									# load_freezefile	def in    src/app/make7/freezefile/freezefile-g.pkg
		    fun load_primordial_make7file ()
                        =
                        freezefile::load_freezefile

			    { get_library =>   fn _ =  raise exception FAIL "src/app/make7/main/make7-g.pkg: load_primordial_make7file",
			      any_errors  =>   REF FALSE
			    }

			    (   make7_state, 
			        primordial_makefile,
			        NULL			# 'version' info XXX BUGGO DELETME
			        , []	# MUSTDIE
			    );

									# compile_treewalk_g		def in    src/app/make7/compile/compile-treewalk-g.pkg
									# linking_treewalk_g		def in    src/app/make7/compile/linking-treewalk-g.pkg

		    case (load_primordial_make7file ())
		      
		         NULL
                             =>
                             raise exception FAIL "    src/app/make7/main/make7-g.pkg:   Unable to load primordial make7file";

		         THE primordial_make7file
			     =>
			     {   compile_treewalk::reset ();
				 linking_treewalk::reset ();


				 my { exports => compile_treewalk_map, ... }
				     =
				     compile_treewalk::walk_inter_library_dependency_graph (
					 fn _ = fn _ = (),
					 fn _ = (),
					 primordial_make7file
				     );

				 my { exports => linking_treewalk_map, ... }
				     =
				     linking_treewalk::make_treewalk (

					 primordial_make7file,
					 fn _ =  raise exception FAIL "init: get bfc?"
				     );

				 fun get_symbol_treewalk (treewalk_map, symbol)
				     =
				     case ( symbol_map::get (treewalk_map, symbol))
				       
					 NULL         =>  raise exception FAIL "init: bogus init library (1)";
					 THE treewalk =>  treewalk;
				     esac;


										# symbol_map		is from   src/app/make7/util/symbolmap.pkg
										# pervasive_symbol	is from   src/app/make7/main/pervasive-symbol.pkg


				 # Get symbol for "<Pervasive>":
				 #
				 stipulate
				     pervasive_symbol = pervasive_symbol::pervasive_package_symbol;
				 herein
				     pervasive_compile_treewalk = get_symbol_treewalk ( compile_treewalk_map, pervasive_symbol );
				     pervasive_linking_treewalk = get_symbol_treewalk ( linking_treewalk_map, pervasive_symbol );
				 end;


				 fun do_treewalk treewalk
				     =
				     case (treewalk  make7_state)
				       
					  THE r =>  r;
					  NULL  =>  raise exception FAIL "init: bogus init library (2)";
				     esac;

                                 (do_treewalk  pervasive_compile_treewalk)
				     ->
				     { symbol_table        =>  pervasive_symbol_table,
				       inlining_table =>  pervasive_inlining_table
				     };

				 pervasive_linking_table
				     =
				     do_treewalk  pervasive_linking_treewalk;

				 pervasive
				     =
				     e::make_compiler_table_set {
					 symbol_table   =>  pervasive_symbol_table,
					 linking_table  =>  pervasive_linking_table,
					 inlining_table =>  pervasive_inlining_table
				     };

				 fun bare_autoload x
				     =
				     {   file::say ["!* ", x, ": \"autoload\" not available, using \"make\"\n"];
					 make x;
				     };


				 cs::pervasive.set  pervasive;

				 .set (cs::top_level ()) e::null_compiler_table_set;                       #  redundant? XXX BUGGO FIXME 

				 primordial_make7file_hook
                                     :=
                                     THE { primordial_make7file };


# print ("src/app/make7/main/make7-g.pkg invoking 'load_preloads': cwd = '" + (posix::current_directory()) + "\n");
				 # 'load' all the libraries which are
				 # to be preloaded into the final
				 # mythryld executable image:
				 #
                                 preload::load
				     make
				     make_compiler_defaults::libraries_to_preload;

								# preload			is from   src/app/make7/main/preload.pkg
								# make_compiler_defaults	is from   src/app/make7/make-compiler/make-compiler-defaults.pkg

				 THE process_commandline;
			    };
                    esac;
		};		#  fun set_up_primordial_make7file_hook       
	end;			#  stipulate ... in ...


	fun show_controls (getarg, getval, padval) level
	    =
	    {   fun walk indent (control_index::INDEX_TREE rt)
		    =
		    {   include printf_combinator;

			rt -> { help, control_set, subregs, path };

			fun one ci
			    =
			    {   arg = cat
					  (fold_right
					      (fn (s, r) =  s ! "::" ! r)
					      [getarg ci]
					      path
					  );

				value = getval ci;
				size' = size value;

				lw    = *control_print::linewidth;
				padsz = lw - 6 - size arg - indent;

				if   (padsz < size')
				    
				     padsz' = int::max (lw, size' + 8 + indent);

				     format' file::say (sp (indent + 6) o
						      text arg o nl o
						      padval padsz' (text value) o
						      nl);

				else
				     format' file::say (  sp (indent + 6)
						     o  text arg
						     o  padval padsz (text value)
						     o  nl
						     );
				fi;
			    };

			case (control_set, subregs)
			  
			     ([], []) => ();
			     _        => { format' file::say (sp indent o text help o text ":" o nl);
					   apply one control_set;
					   apply (walk (indent + 1)) subregs;
					 };
			esac;
		    };

		fun inc n
		    =
		    n + 1;

						# control_index		is from   src/lib/controls/control-index.pkg
						# basic_control		is from   src/lib/compiler/front/basics/main/basiccontrol.pkg


		walk 2 (control_index::controls
			    (basic_control::top_index, null_or::map inc level));

	    };

	fun show_control_setting  level
	    =
	    show_controls
                (
                  fn ci =  (control::name ci.control + " = "),
		  fn ci =   control::get  ci.control,
		  fn _  =  fn ff = ff
                )
		level;

        fun show_controls' ()
            =
            {   show_control_setting NULL;
                file::say [ "\nTo get a control value interactively:  show_control \"mythryl_parser::show_interactive_result_types\";\n" ];
                file::say [   "To set a control value interactively:  set_control  \"mythryl_parser::show_interactive_result_types\" \"TRUE\";\n" ];
                file::say [   "To do same thing at commandline:       my -Cmythryl_parser::show_interactive_result_types=TRUE\n" ];
            };

        stipulate
					    # control_index	is from   src/lib/controls/control-index.pkg
					    # basic_control	is from   src/lib/compiler/front/basics/main/basiccontrol.pkg
					    # control		is from   src/lib/controls/control.pkg

	    find_control
		=
		control_index::find_control
		    basic_control::top_index;

	    fun split_control_path  path
		=
                string::tokens   (fn c =  c == ':')   path;

        herein

            fun show_control name
                =
                if   (name == "")
                     print "Control name must be non-empty\n";
                else
		     case (find_control (split_control_path name))
		       
			  NULL
			      =>
			      file::say   ["!* no such control: ", name, "\n"];

			  THE control
			      =>
			      print (control::get control + "\n");
		     esac;
                fi; 

	    fun set_control''' name value
                =
		case (find_control (split_control_path name))
		  
		     NULL
			 =>
			 file::say   ["!* no such control: ", name, "\n"];

		     THE control
			 =>
			 control::set (control, value)
			 except
			     control::BAD_VALUE_SYNTAX vse
				 =
				 file::say [ "!* unable to parse value `",
						vse.value,        "' for ",
						vse.control_name, " : ",
						vse.type_name,    "\n"
					      ];
		esac;

	    fun set_control'' name value
                =
		if   (name == "")
		     print "Control name must be non-null\n";
		else set_control''' name value;
		fi;

	    fun set_control'
		    bad		# 
		    is_config	# FALSE
		    spec		# "name=value"
		=
		{
		    my (name, value)
			=
			substring::split_off_prefix   .{ #c != '='; }   spec;

		    name    =   substring::to_string name;

		    value   =   substring::to_string

				    if  (substring::size value > 0)
				         substring::make_slice (value, 1, NULL);
				    else value;
                                    fi;

		    if   (name == "")
		         bad ();
		    else if   is_config

                              set_control''' name value;

			 else
			      if   (value == "")
			          
				   .set  (host_properties::symbol_value name)  (THE 1);

						    # host_properties is defined at top of file.
			      else
				   case (int::from_string  value)
				     
					THE i =>  .set  (host_properties::symbol_value name)  (THE i);
					NULL  =>  bad ();
				   esac;
			      fi;
			 fi;
		    fi;
		};
	end;			# stipulate

	fun set_control  spec
            =
            set_control'
                .{ print "Bad option\n"; }
                TRUE					# is_config
                (substring::from_string spec);		# "name=value"

    herein				#  outermost 'stipulate' 

        # We get called ultimately by
        #     src/lib/core/internal/main.pkg
        # via
        #     src/lib/core/internal/boot-dictionary-g.pkg
        # shortly before it dumps the heap image
        # which becomes our standard mythryld
        # make/compiler executable (see top of file
        # comments for details). 
        #
        # Thus, we essentially do this initialization
        # at the compiler's compiletime rather than
        # at its runtime.
	#
	# Runtime arguments:
	#
	#     read_eval_print_from_stream,
	#	   #
	#          # Ultimately defined in
        #          #     src/lib/compiler/toplevel/interact/read-eval-print-loop-g.pkg
        #          # We pass this to
        #          #     src/app/make7/compile/compile-treewalk-g.pkg
        #          # which uses it to execute pre/post 'setup' sourcecode fragments
        #          # extracted originally from .make6 files.
	#
	#     read_eval_print_from_file
	#	    #
	#	    # Defined in
        #           #   src/lib/compiler/toplevel/interact/interact-g.pkg
        #           # as a wrapper of above.
	#
	#     read_eval_print_from_user
	#	    #
	#	    # Likewise defined in
        #           #   src/lib/compiler/toplevel/interact/interact-g.pkg
	#	    # but as a wrapper for  read_eval_print_from_user  in
        #           #   src/lib/compiler/toplevel/interact/read-eval-print-loop-g.pkg
	#
	fun set_up_make7
	    (   root_directory,					# Contains sh/ bin/ src/ ... 
		linking_table,
		read_eval_print_from_user,
		read_eval_print_from_stream,			# We pass this to compile-treewalk, to evaluate sourcecode fragments.
		read_eval_print_from_file,			# We use this to compile vanilla commandline source files like foo.pkg
		errorwrap
	    )
            =
            {
		fun eval_string  code_string
		    =
		    safely::do {	# This should be a supported, exported 'eval' function.

		      open_it  =>   .{ file::open_string (code_string + " ;;"); },
		      close_it =>   file::close_input,
		      cleanup  =>   fn _  =  ()
		    }
		    read_eval_print_from_stream;

                 eval_hook :=  eval_string;


                # Function to process Unix command-line switches
                # and filename arguments given to mythryld.
                #
                # NB:  Any options starting with --runtime 
                #      will already have been eaten by
                #
                #          src/runtime/main/runtime-options.c
		#
# print ("src/app/make7/main/make7-g.pkg/set_up_make7/AAA: root_directory = " + root_directory + " cwd= " + (posix::current_directory()) + "\n");
                fun process_commandline ()
                    =
                    {   make     = errorwrap (ignore o make    );

			fun process_filename (filename, mk, ("sml"
							  | "sig"
							  | "fun"
							  | "api"
							  | "pkg") ) => read_eval_print_from_file filename;
			    process_filename (filename, mk, "cm"   ) => mk filename;
			    process_filename (filename, mk, "make7") => mk filename;
			    process_filename (filename, mk, "make6") => mk filename;
			    process_filename (filename, mk, extension)       => file::say ["!* unable to process `", filename,
										 "' (unknown extension `", extension, "')\n"];
                        end;

			fun help level
                            =
			    {    file::say
				    ["mythryld [rtsargs] [options] [files]\n\
				     \\n\
				     \  run time system args:\n\
				     \    --runtime-heap-image-to-run=<h>     (start specified heap image)\n\
				     \    --runtime-gc-gen0-bufsize=<s>    (gc generation-zero buffer size)\n\
				     \    --runtime-cmdname=<n>  (set command name)\n\
				     \    --runtime-verbosity=<n> (set level of runtime verbosity)\n\
				     \    --runtime-show-code-chunk-comments (list code heapchunks)\n\
				     \    --runtime-debug=<f>    (write debugging info to file)\n\
				     \\n\
				     \  files:\n\
				     \    <file>.make6     (make7::make)\n\
				     \    <file>.api       (run)\n\
				     \    <file>.pkg       (run)\n\
				     \\n\
				     \  options:\n\
				     \    -e 'expression'  (Evaluate and print 'expression', then quit.)\n\
				     \    -x 'expression'  (Like -e, but also prints a newline.)\n\
				     \    -E 'expression'  (Like -E, but does not quit.)\n\
				     \    -D<name>=<v>    (set make7 variable to given value)\n\
				     \    -D<name>        (set make7 variable to 1)\n\
				     \    -Uname          (unset make7 variable)\n\
				     \    -C<control>=<v> (set named control)\n\
				     \    -H               (produce complete help listing)\n\
				     \    -h               (produce minimal help listing)\n\
				     \    -h<level>        (help with obscurity limit)\n\
				     \    -S               (list all current settings)\n\
				     \    -s<level>        (limited list of settings)\n\
				     \    -P               (list all preprocessor variables)\n\
				     \    -p<level>        (limited list of preprocessor variables)\n\
				     \    --no-prompt       (Disable interactive mode prompts)\n\
				     \n\
				     \Do   bin/mythryld   to start an interactive session.\n\
                                     \n"];

				show_controls (control::name o .control,
					       fn ci =
						  cat ["(", .help (control::info ci.control),
							  ")"],
					       printf_combinator::pad printf_combinator::left)
					      level;

								# control		is from   src/lib/controls/control.pkg
								# printf_combinator	is from   src/lib/src/printf-combinator.pkg
			   };

			fun show_env_vars level
			    =
			    show_controls
                                ( fn ci =  (control::name ci.control + ":"),
				  fn ci =  null_or::the_else (ci.info.dictionary_name, "(none)"),
				  printf_combinator::pad printf_combinator::left
                                )
				level;

			fun badopt opt f ()
			    =
			    file::say ["!* bad ", opt, " option: `", f, "'\n",
				      "!* try `-h' or `-h<level>' for help\n"];

			fun quit ()
                            =
                            winix::process::exit
                                winix::process::success;


			fun quit_if TRUE  =>  quit ();
			    quit_if FALSE =>  ();
                        end;



                        # This function mainly handles Unix commandline arguments of the form -Xyyy
                        # where X is a switch char and yyy is some argument string for it.  (Ick. XXX BUGGO FIXME. Change to usual GNU conventions.)
                        #
                        # We also arrive here for anything else
                        # not previously recognized as a switch,
                        # in particular for filename arguments.
                        #
                        # First argument is the two-char "-X" argument prefix.
                        # Second argument is the full argument.
                        # Third argument is either 'automake' or 'make' function, per last -a or -m switch.
                        # Fourth argument is TRUE iff there is more stuff remaining on commandline.
                        #
                        # What 'carg' is supposed to mean, I haven't a clue.  continued_arg maybe.  ("commandline_arg"? "control_arg"? "config_arg"? "compound arg"?) XXX BUGGO FIXME pick a decent name.
			#
			fun carg (    opt as ("-C" | "-D"), f, _, _)
			    =>
			    {   bad        =   badopt opt f;
				spec       =   substring::extract (f, 2, NULL);		# substring	is from   src/lib/std/substring.pkg
				is_config  =   opt == "-C";

                                set_control' bad is_config spec;
			    };

			   carg ("-U", f, _, _)   =>    case (string::extract (f, 2, NULL))
							    #
							    ""  =>  badopt "-U" f ();
							    var =>  .set (host_properties::symbol_value var) NULL;
                                                        esac;


			   carg ("-h", f, _, last) => {   case (string::extract (f, 2, NULL))
							      #
							      ""    =>  help (THE 0);
							      level =>  help (int::from_string level);
                                                          esac;

							  quit_if last;
						      };

			   carg ("-s", f, _, last) => {   case (string::extract (f, 2, NULL))
							      #
							      ""    =>  show_control_setting  (THE 0);
							      level =>  show_control_setting  (int::from_string  level);
                                                          esac;

							  quit_if  last;
						      };

			   carg ("-p", f, _, last) => {   case (string::extract (f, 2, NULL))
							      #
							      ""    =>  show_env_vars (THE 0);
							      level =>  show_env_vars (int::from_string level);
                                                          esac;

							  quit_if  last;
						      };

			   carg (_, filename, mk, _)   =>   process_filename (
                                                                filename,
							        mk,
							        string::map char::to_lower (the_else (winix::path::ext filename, "<none>"))
						            );
									# string		is from   src/lib/std/string.pkg
									# char			is from   src/lib/std/char.pkg
									# winix			is from   src/lib/std/winix.pkg
									# compile_client	is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
                        end;

                        fun start_compile_servers ()
                            =
                            {
				root = the (ad::get_anchor(ad::dictionary, "ROOT"));
                                compile_client::start { name => "Compile Server A", preference => 0, path_translator => NULL, cmd => (root + "/bin/mythryld", ["--compile-server"]) }; 
				compile_client::cd (posix::current_directory());
#                               compile_client::start { name => "Compile Server B", preference => 0, path_translator => NULL, cmd => (root + "/bin/mythryld", ["--compile-server"]) }; 
                                ad::schedule_notification ();
                            };


                        interactive
			    =
                            mythryl_parser::interactive;


                        unparse_result
			    =
                            mythryl_parser::unparse_result;


just_return = REF FALSE;
                        # Process all commandline arguments,
                        # both switches and filenames:
                        #
			fun args ("-H"          ! rest, mk) =>  { help NULL;                      args_q (rest, mk); };
			    args ("-S"          ! rest, mk) =>  { show_control_setting NULL;      args_q (rest, mk); };
			    args ("-P"          ! rest, mk) =>  { show_env_vars NULL;             args_q (rest, mk); };
			    args ("-j"          ! rest, mk) =>  { start_compile_servers ();       args_q (rest, mk); };

			    args ("-z"          ! rest, mk) =>  { just_return := TRUE;            args   (rest, mk); };

			    args ("-q"          ! _, _)     =>  quit ();

			    args ("--build"     ! rest, _)                                 =>  build_an_executable_mythryl_heap_image  rest;
			    args ("--build-an-executable-mythryl-heap-image"    ! rest, _) =>  build_an_executable_mythryl_heap_image  rest;

			    args (["--redump",  heapfile], _)
                                =>
                                redump_heap heapfile;

			    args ("-e" ! code_string ! rest, mk)
				=>
				{   interactive    := FALSE;
                                    eval_string code_string;
                                    quit ();
				};

			    args ("-x" ! code_string ! rest, mk)
				=>
				{   interactive    := FALSE;
                                    eval_string  code_string;
				    print "\n";
                                    quit ();
				};

			    args ("-E" ! code_string ! rest, mk)
				=>
				{   interactive    := FALSE;
                                    eval_string  code_string;
                                    interactive    := TRUE;
                                    args( rest, mk );
				};

			    args (filename ! rest, mk)
                                =>
                                {   carg
                                        ( string::substring (filename, 0, 2) except (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) = "",
				        filename,
				        mk,              #  make
				        list::null rest
				    );

				    args (rest, mk);
				};

			    args ([], _) => ();
                        end 

			also
			fun args_q ([],   _) =>  quit ();
			    args_q (rest, f) =>  args (rest, f);
                        end;


											# text_primitive_io	is from   src/lib/std/src/io/text-primitive-io.pkg
											# winix			is from   src/lib/std/winix.pkg
											# text_io_g	def in    src/lib/std/src/io/text-io-g.pkg

			# This fn is duplicated between here and   src/lib/compiler/toplevel/interact/read-eval-print-loop-g.pkg   XXX BUGGO FIXME
			#
			fun input_is_tty  f
			    = 
			    {   my (rd, buf)
				    =
				    file::pure_io::get_reader
					(
					  file::get_instream  f
					);

				is_tty
				    =
				    case rd
				      
					 text_primitive_io::READER { io_descriptor => THE iod, ... }
					     =>
					     (winix::io::kind iod == winix::io::kind::tty);

					  _ => FALSE;
				    esac;

				# Since getting the reader will have terminated
				# the stream, we now need to build a new stream:
				#
				file::set_instream
				    (f, file::pure_io::make_instream (rd, buf) );

				is_tty;
			    };

			case (commandline::get_arguments ())
			  
			     ["--compile-server"]
                                 =>
                                 {   #  make7_defaults::verbose.set  FALSE;
				     file::set_name ("server A");
				     {  include file;
					set_say_policy ( SAY, STDOUT,  TRUE);
					set_say_policy (DSAY, STDOUT, FALSE);
					set_say_policy (VSAY, STDOUT, FALSE);

					set_say_policy ( SAY, LOGFILE, TRUE);
					set_say_policy (DSAY, LOGFILE, TRUE);
					set_say_policy (VSAY, LOGFILE, TRUE);
				     };
#				     pid = posix::get_process_id ();
#				     pid = posix::pid_to_word pid;
#				     include sfprintf;
#				     pid = sprintf "%d" [ INT (unt32::to_int pid) ];

                                     enter_compile_server_loop ();		# Never returns.
                                 };

			     l   =>
                                 {
				      # The next line was part of a failed attempt
				      # to get multi-core 'make-compiler' compiles
				      # working:		XXX BUGGO FIXME
				      #	
                                      file::set_name "MYTHRYLD";

                                      args (l, make);				# Process all commandline switches and arguments.


				      # Currently we use
                                      #     compiler_client_interface::interact::read_eval_print_from_script
                                      # to execute Mythryl scripts, and
                                      #     compiler_client_interface::interact::read_eval_print_from_user
                                      # to handle interactive input by a user.
                                      # We invoke the former by returning to
                                      #     src/lib/core/internal/main.pkg
                                      # We invoke the latter below, directly.
                                      #  
                                      #  
                                      # XXX BUGGO FIXME 
                                      # This could all use some cleanup.
                                      # If the compiler_client_interface::interact::read_eval_print_from_user
                                      # proves stable, we should probably
                                      # kill the interactive-prompt logic in
                                      #     src/lib/compiler/front/parse/main/mythryl-parser-guts.pkg
                                      # With a trifle more work, we can probably also kill off
                                      #     compiler_client_interface::interact::read_eval_print_from_script
                                      # entirely.

if (not *just_return )
				      if    (input_is_tty  file::stdin)
                                          
                                            read_eval_print_from_user ();
                                            quit ();
                                      fi;

			              interactive    := FALSE;
                                      unparse_result := FALSE;
fi;

				      # Issue the interactive blurb.
				      # We delay doing this until commandline
				      # switches have been processed, so as
				      # to be able to disable it with --no-prompt:
				      #	
				      if *mythryl_parser::interactive

					   print "\n";
					   print lib7_version::banner;
					   print "\nDo   help();   for help  (interact)";
				      fi;
                                 };
                        esac;
										# make7_defaults	is from   src/app/make7/util/make7-defaults.pkg
		    };

		read_eval_print_from_stream_hook
                    :=
                    read_eval_print_from_stream;

		set_up_primordial_make7file_hook (
                    root_directory,
		    linking_table,
		    process_commandline
		);
	    };                                                         		#  fun set_up_make7 

        fun help ()
            =
	    apply
		print
		[   "\n\n",
		    "              Mythryl Interactive Help\n",
		    "\n",
	            "You are interacting with an incremental compiler for\n",
                    "Mythryl, an advanced posix-flavored mostly-functional\n",
                    "programming language.\n",
                    "\n",
                    "Enter one expression per line.\n",
                    "\n",
                    "Examples:\n",
                    "    2+2;\n",
                    "    print \"Hello, world!\\n\";\n",
                    "    print `ls -l`;\n",
                    "    printf \"%d %g\\n\" (1 << 3) (sin 0.3);\n",
                    "    for (i=0; i<10; ++i) { printf \"%d\\n\" i; };\n",
                    "    fun hello () = print \"Hello, world!\\n\";\n",
                    "    hello ();\n",
                    "\n",
                    "Some useful commands:\n",
                    "\n",
                    "    # List values, functions, packages and APIs defined at top level:\n",
                    "    show_all ();\n",
                    "    show_apis();     # As above, showing only API     defs\n",
                    "    show_pkgs();     # As above, showing only package defs\n",
                    "    show_vals();     #                        value   defs\n",
                    "    show_types();    #                        type    defs\n",
                    "    show_generics(); #                        generic defs\n",
                    "\n",
                    "    show_api \"Integer\"; # Show definition of Integer API\n",
                    "    show_pkg \"control\"; # Mainly useful for packages with anonymous APIs.\n",
                    "\n",
                    "    # Display all compiler configuration variables:\n",
                    "    show_controls();\n",
                    "\n",
                    "    # Load hello lib into ram, first re/compiling as needed:\n",
                    "    make \"src/app/tut/hello/hello.make6\";\n",
                    "\n",
                    "    # Make hello.make6 library freezefile 'hello.make6.a7':\n",
                    "    freeze \"src/app/tut/hello/hello.make6\";\n",
                    "\n",
                    "Type <Ctrl>-D to exit.  (<Ctrl>-Q <Ctrl>-D in emacs.)\n"
                ];


        # The following api is defined in
        #
        #     src/lib/core/internal/make7.api
        #
	package make7 {

	    Controller( X ) = {   get:  Void -> X,
                                  set:  X -> Void
                              };

	    package control {

		keep_going              =  make7_defaults::keep_going;
		verbose                 =  make7_defaults::verbose;
		parse_caching           =  make7_defaults::parse_caching;

		warn_on_obsolete_syntax =  make7_defaults::warn_on_obsolete_syntax;
		debug                   =  make7_defaults::debug;
		conserve_memory         =  make7_defaults::conserve_memory;

		generate_index          =  make7_defaults::generate_index;
	    };

									# make7_defaults		is from   src/app/make7/util/make7-defaults.pkg
									# anchor_dictionary		is from   src/app/make7/paths/anchor-dictionary.pkg
									# make7file_g			def in    src/app/make7/parse/make7file-g.pkg
									# linking_treewalk_g		def in    src/app/make7/compile/linking-treewalk-g.pkg
									# compile_client		is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
	    package freezefile_db {

		Freezefile = ad::File;

		known     =  make7file::list_freezefiles;
		describe  =  ad::describe;

		os_string =  ad::os_string;
		dismiss   =  make7file::dismiss_freezefile;

		fun unshare library
		    =
		    {    linking_treewalk::unshare library;

			 dismiss library;
		    };
	    };

	    package make7_state {

		reset      = reset;
		dump       =       dump_api_reference;
		dump_latex = latex_dump_api_reference;
	    };

	    package compile_client {


		Compile_Server_Handle
		    =
		    compile_client::Server_Handle;

		fun start_a_compile_server x
		    =
		    compile_client::start x
		    before
			ad::schedule_notification ();

		stop_a_compile_server =  compile_client::stop;
		kill_a_compile_server =  compile_client::kill;
		compile_server_name   =  compile_client::name;
	    };

            help          =  help;
	    make          =  make;
	    compile       =  compile;
	    freeze        =  freeze' TRUE;
	    freeze1       =  freeze' FALSE;
	    freeze'       =  freeze';

	    show_all      =  show_all;
	    show_apis     =  show_apis;
	    show_pkgs     =  show_pkgs;
	    show_vals     =  show_vals;
	    show_types    =  show_types;
	    show_generics =  show_generics;
	    show_controls =  show_controls';
	    show_control  =  show_control;
	    set_control   =  set_control'';

	    show_api      =  show_api;
	    show_pkg      =  show_pkg;

	    sources       =  sources;

	    host_property =  host_properties::symbol_value;

	    load_plugin   =  cwd_load_plugin; 

	    build_executable_heap_image
                =
                build_executable_heap_image;

	    package graph =   package {
                                  graph = to_portable;
                              };

	    redump_heap =   redump_heap;

            # Random stuff we want to be defined globally at the
            # interactive prompt.  This gets 'included' by
            #     src/lib/core/internal/main.pkg
            # There's probably a cleaner way to do this:
	    #
	    package scripting_globals {

		(_!)    = integer::(_!);		# Factorial.

		# Note:  The (_[])   enables   'vec[index]'           notation;
		#        The (_[]:=) enables   'vec[index] := value'  notation;
		#
                (_[])   = vector::get;
                (_[]:=) = vector::set;

                in     = list::in;

                exit   = winix::process::exit;

                bash        = spawn::bash;
                back__ticks = spawn::bash;

		system      = winix::process::system;

		fun round f     =  float::to_int  ieee_float::TO_NEAREST  f;
		fun atoi string =  the (int::from_string   string);
		fun atod string =  the (float::from_string string);

		# Convert    src/runtime/gtk/mythryl-gtk-slave.c
		# to                         mythryl-gtk-slave.c
		# and such:
		#
		fun basename filename
		    =
		    (regex::find_first_group 1 .|/([^/]+)$| filename)
                    except
                        NOT_FOUND = filename;

		# Convert    src/runtime/gtk/mythryl-gtk-slave.c
		# to         src/runtime/gtk
		# and such:
		#
		fun dirname filename
		    =
		    (regex::find_first_group 1 .|^(.*)/[^/]+$| filename)
                    except
                        NOT_FOUND = filename;

		# Drop leading and trailing
		# whitespace from a string:
		#
		fun trim string
		    =
		    {   =~ = regex::(=~);

			if (string =~ ./^\s*$/)

			    "";

			else
			    # Drop trailing whitespace:
			    #
			    string
				=
				(regex::find_first_group 1 ./^(.*\S)\s*$/ string)
				except
				    NOT_FOUND = string;

			    # Drop leading whitespace:
			    #
			    string
				=
				(regex::find_first_group 1 ./^\s*(\S.*)$/ string)
				except
				    NOT_FOUND = string;

			    string;
			fi;
		    };

		#
		fun die message
		    =
		    {   print message;
			exit(1);
		    };


		=~          =  regex::(=~);
		chomp       =  string::chomp; 
		chdir       =  winix::file::change_directory;
		environ     =  posix::environ;
		explode     =  string::explode;
		factors     =  int::factors;
		fields      =  string::fields;
		filter      =  list::filter;
		fscanf      =  scanf::fscanf;
		getcwd      =  winix::file::current_directory;
		getenv      =  winix::process::get_env;
		getpid      =  winix::process::get_process_id;
		getppid     =  posix::get_parent_process_id;
		getuid      =  posix::get_user_id;
		geteuid     =  posix::get_effective_user_id;
		getgid      =  posix::get_group_id;
		getegid     =  posix::get_effective_group_id;
		getgroups   =  posix::get_group_ids;
		getlogin    =  posix::get_login;
		getpgrp     =  posix::get_process_group;
		setgid      =  posix::set_group_id;
		setpgid     =  posix::set_process_group_id;
		setsid      =  posix::set_session_id;
		setuid      =  posix::set_user_id;
		implode     =  string::implode;
		iseven      =  fn i = i & 1 == 0;
		isodd       =  fn i = i & 1 == 1;
		isprime     =  int::is_prime;
		join        =  string::join;
		join'       =  string::join';
		lstat       =  posix::lstat;
		now         =  time::now;
		product     =  int::product;
		shuffle     =  list_shuffle::shuffle;
		shuffle'    =  list_shuffle::shuffle';
		sleep       =  winix::process::sleep;
		sort        =  list_mergesort::sort;
		sorted      =  list_mergesort::sorted;
		scanf       =  scanf::scanf;
		sscanf      =  scanf::sscanf;
		stat        =  posix::stat;
		strcat      =  string::cat;
		strlen      =  string::length;
		strsort     =  (list_mergesort::sort string::(>));
		struniqsort =  (list_mergesort::unique_sort string::compare);
		sum         =  int::sum;
		time        =  posix::time;		# NB: 'now' has much more precision.
		tolower     =  string::to_lower;
		toupper     =  string::to_upper;
		tokens      =  string::tokens;
		uniquesort  =  list_mergesort::unique_sort;
		words       =  string::tokens char::is_space;

		dot__qquotes =  words;			# So that ."a b c d e f" == ["a", "b", "c", "d", "e", "f"]

                arg0     =  commandline::get_program_name;		# XXX BUGGO FIXME For scripts this comes out "bin/my" or "/usr/bin/my" or such, which is not helpful.
                argv     =  commandline::get_arguments;

		# NB: The following have the perl-inspired
		#     lexer-implemented synonyms
                #     -F -D -P -L -S -C -B
                #
		fun isfile     filename =  posix::stat::is_file      (posix::stat  filename)  except _ = FALSE;
		fun isdir      filename =  posix::stat::is_directory (posix::stat  filename)  except _ = FALSE;
		fun ispipe     filename =  posix::stat::is_pipe      (posix::stat  filename)  except _ = FALSE;
		fun issymlink  filename =  posix::stat::is_symlink   (posix::lstat filename)  except _ = FALSE;
		fun issocket   filename =  posix::stat::is_socket    (posix::stat  filename)  except _ = FALSE;
		fun ischardev  filename =  posix::stat::is_char_dev  (posix::stat  filename)  except _ = FALSE;
		fun isblockdev filename =  posix::stat::is_block_dev (posix::stat  filename)  except _ = FALSE;

		# I would like these to return TRUE if
                # the effective uid may do the indicated
                # operation.  I don't know if this code
                # implements exactly that, but it is a
                # quick first cut, at least.                  XXX BUGGO FIXME
                #
		# NB: The following have the perl-inspired
		#     lexer-implemented synonyms
                #     -R -W -X
                #
                fun mayread     filename =  winix::file::access (filename, [winix::file::MAY_READ])     except _ = FALSE;
                fun maywrite    filename =  winix::file::access (filename, [winix::file::MAY_WRITE])    except _ = FALSE;
                fun mayexecute  filename =  winix::file::access (filename, [winix::file::MAY_EXECUTE])  except _ = FALSE;

		# These are used in
		#     src/lib/src/eval-unit-test.pkg
		# There must be a cleaner way! *ruefulgrin*   XXX BUGGO FIXME
		# 
		eval_kludge_ref_int         =  REF 0;
		eval_kludge_ref_float       =  REF 0.0;
		eval_kludge_ref_string      =  REF "";
		#
		eval_kludge_ref_list_int    =  REF []:  Ref( List( Int    ) );
		eval_kludge_ref_list_float  =  REF []:  Ref( List( Float  ) );
		eval_kludge_ref_list_string =  REF []:  Ref( List( String ) );

                fun eval code_string
                    =
                    *eval_hook code_string;

		fun evali  user_code = {  eval("make7::scripting_globals::eval_kludge_ref_int         := (" + user_code + ")");  *eval_kludge_ref_int;          };
		fun evalf  user_code = {  eval("make7::scripting_globals::eval_kludge_ref_float       := (" + user_code + ")");  *eval_kludge_ref_float;        };
		fun evals  user_code = {  eval("make7::scripting_globals::eval_kludge_ref_string      := (" + user_code + ")");  *eval_kludge_ref_string;       };
		#
		fun evalli user_code = {  eval("make7::scripting_globals::eval_kludge_ref_list_int    := (" + user_code + ")");  *eval_kludge_ref_list_int;     };
		fun evallf user_code = {  eval("make7::scripting_globals::eval_kludge_ref_list_float  := (" + user_code + ")");  *eval_kludge_ref_list_float;   };
		fun evalls user_code = {  eval("make7::scripting_globals::eval_kludge_ref_list_string := (" + user_code + ")");  *eval_kludge_ref_list_string;  };

		include threadkit;							# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
	    };
	};                                      # package make7

	package tools
	    =
	    tools_g (
                load_plugin' = load_plugin';
		anchor_dictionary = anchor_dictionary;
	    );

	load_plugin =  load_plugin;

        (_!) = integer::(_!);
    end;                                  #  stipulate ... herein ...  
};                                        #  generic make7_g    





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright (c) 1999, 2000 by Lucent Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
