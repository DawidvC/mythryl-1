## highcode.pkg 

# Compiled by:
#     src/lib/compiler/core.make6


###                "There are only two kinds of math books.
###                 Those you cannot read beyond the first sentence,
###                 and those you cannot read beyond the first page."
###
###                         --  C.N. Yang, circa 1980 I think.
###                             [Nobel Prize in theoretical physics, 1957]


###             "I like mathematics because it is not human
###              and has nothing particular to do with this
###              planet or with the whole accidental universe
###              -- because like Spinoza's God, it won't love
###              us in return."
###
###                              -- Bertrand Russell, 1912


package highcode: (weak)  Highcode {			# Highcode			is from   src/lib/compiler/upper/highcode/highcode.api

    stipulate
							# highcode_primitive_op		is from   src/lib/compiler/upper/highcode/highcode-primitive-op.pkg
        package pt= highcode_data_representation;	# highcode_data_representation	is from   src/lib/compiler/upper/highcode/highcode-data-representation.pkg
	package di= debruijn_index;			# debruijn_index		is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg
	package lk= highcode_guts;			# highcode_guts			is from   src/lib/compiler/upper/highcode/highcode-guts.pkg
	package fl= anormal;				# anormal			is from   src/lib/compiler/upper/anormal/anormal.pkg
	package po = highcode_primitive_op;		# Really should not refer to this.

	fun bug msg = error_message::impossible("highcode: " + msg);

	say = controls::print::say;

	# Common utility functions:
        #
	type_kind_inject  = lk::type_kind_inject;
	type_kind_project = lk::type_kind_project;

	type_constructor_inject  = lk::type_constructor_inject;
	type_constructor_project = lk::type_constructor_project; 

	lambda_type_inject  = lk::lambda_type_inject;
	lambda_type_project = lk::lambda_type_project; 

	type_constructor_closure_dictionary              = lk::type_constructor_closure_dictionary;
	lambda_type_closure_dictionary                   = lk::lambda_type_closure_dictionary;
	reduce_type_constructor_to_weak_head_normal_form = lk::reduce_type_constructor_to_weak_head_normal_form;
	reduce_lambda_type_to_weak_head_normal_form      = lk::reduce_lambda_type_to_weak_head_normal_form;
	reduce_type_constructor_to_normal_form           = lk::reduce_type_constructor_to_normal_form;
	reduce_lambda_type_to_normal_form                = lk::reduce_lambda_type_to_normal_form;

    herein

	stipulate

	    package pt= highcode_data_representation;		# highcode_data_representation	is from   src/lib/compiler/upper/highcode/highcode-data-representation.pkg
	    package di= debruijn_index;				# debruijn_index		is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg
	    package lk= highcode_guts;				# highcode_guts			is from   src/lib/compiler/upper/highcode/highcode-guts.pkg

	    fun bug msg
		=
		error_message::impossible("lambdatype: " + msg);

	    say = controls::print::say;

	    # Common utility functions:
	    #
	    type_kind_inject  =  lk::type_kind_inject;
	    type_kind_project =  lk::type_kind_project;

	    type_constructor_inject  =  lk::type_constructor_inject;
	    type_constructor_project =  lk::type_constructor_project; 

	    lambda_type_inject  =  lk::lambda_type_inject;
	    lambda_type_project =  lk::lambda_type_project; 

	    type_constructor_closure_dictionary =  lk::type_constructor_closure_dictionary;
	    lambda_type_closure_dictionary      =  lk::lambda_type_closure_dictionary;

	    itos = int::to_string;

	    fun plist (p, [])
		    =>
		    "";

		plist (p, x ! xs)
		    => 
		    (p x) + (string::cat (map (fn z =  (", " + (p z))) xs));
	    end;

	    fun pfflag (lk::FNFLAG_VARIABLE b)
		    => 
		    pff b
		    where
			fun pff (TRUE,  TRUE ) => "rr";
                            pff (TRUE,  FALSE) => "rc";
			    pff (FALSE, TRUE ) => "cr";
                            pff (FALSE, FALSE) => "cc";
			end;
		    end;

		pfflag (lk::FNFLAG_FIXED)
		    =>
		    "f";
	    end;

	    fun parw (p, (ff, t1, t2))
		= 
		"<" + (p t1) + "> -" + pfflag ff + "-> <" + (p t2) + ">";
	herein

	    include highcode_type;

	    # New a type variable, currently not used:
            # 
	    my make_type_variable:  Void -> Highcode_Variable
                =
                lk::make_type_variable;

	    # Utility functions for constructing tkinds 
	    #
	    fun tkc_arg n
		= 
		h (n, [])
		where
		    fun h (n, r)
			=
			if (n < 1)   r;
			else         h (n - 1, tkc_mono ! r);
			fi;
		end;

	    tkc_fn1 = tkc_fun (tkc_arg 1, tkc_mono);
	    tkc_fn2 = tkc_fun (tkc_arg 2, tkc_mono);
	    tkc_fn3 = tkc_fun (tkc_arg 3, tkc_mono);

	    fun tkc_int 0 => tkc_mono;
		tkc_int 1 => tkc_fn1;
		tkc_int 2 => tkc_fn2;
		tkc_int 3 => tkc_fn3;
		tkc_int i => tkc_fun (tkc_arg i, tkc_mono);
	    end;

	    # Primitive fflags and rflags 
	    #
	    ffc_plambda = ffc_var (FALSE, FALSE);
	    ffc_rrhighcode = ffc_var (TRUE, TRUE);

	    fun ffc_fspec (x as lk::FNFLAG_FIXED, (TRUE, TRUE)) => x;
		ffc_fspec (x as lk::FNFLAG_VARIABLE _, nx) => ffc_var nx;
		ffc_fspec _ => bug "unexpected case in ffc_fspec";
	    end;

	    fun ffd_fspec (lk::FNFLAG_FIXED) => (TRUE, TRUE);
		ffd_fspec (lk::FNFLAG_VARIABLE x) => x;
	    end;

	    # Utility functions for constructing tycs
	    #
	    tcc_int    = tcc_prim pt::prim_type_con_int31;
	    tcc_int32  = tcc_prim pt::prim_type_con_int32;
	    tcc_real   = tcc_prim pt::prim_type_con_real;
	    tcc_string = tcc_prim pt::prim_type_con_string;
	    tcc_exn    = tcc_prim pt::prim_type_con_exn;
	    tcc_void   = tcc_prim pt::prim_type_con_void;
	    tcc_unit   = tcc_tuple [];

	    tcc_bool
		= 
		{   tbool = tcc_sum [tcc_unit, tcc_unit];
		    tsig_bool = tcc_g ([tkc_mono], tbool);
		    tcc_fix((1, tsig_bool, []), 0);
		};

	    tcc_list 	  #  not exported, used for the printing purpose 
		  =
		  {   alpha = tcc_var (di::innermost, 0);
		      tlist = tcc_var (di::innersnd, 0);
		      alist = tcc_app (tlist, [alpha]);
		      tcc_cons = tcc_tuple [alpha, alist];
		      tlist = tcc_g([tkc_mono], tcc_sum [tcc_cons, tcc_unit]);
					    # The order here should be consistent with
					    # that in basics/type-types.pkg
		      tsig_list = tcc_g([tkc_int 1], tlist);
		      tcc_fix((1, tsig_list, []), 0);
		  };

	    fun tcc_tv i     = tcc_var (di::innermost, i);
	    fun tcc_ref x    = tcc_app (tcc_prim pt::prim_type_con_ref, [x]);
	    fun tcc_array x  = tcc_app (tcc_prim pt::prim_type_con_array, [x]);
	    fun tcc_vector x = tcc_app (tcc_prim pt::prim_type_con_vector, [x]);
	    fun tcc_etag x   = tcc_app (tcc_prim pt::prim_type_con_exception_tag, [x]);

	    # Primitive lambda ltys
	    #
	    ltc_int    = ltc_tyc tcc_int;
	    ltc_int32  = ltc_tyc tcc_int32;
	    ltc_real   = ltc_tyc tcc_real;
	    ltc_string = ltc_tyc tcc_string;
	    ltc_exn    = ltc_tyc tcc_exn;
	    ltc_void   = ltc_tyc tcc_void;
	    ltc_unit   = ltc_tyc tcc_unit;
	    ltc_bool   = ltc_tyc tcc_bool;

	    ltc_tv     = ltc_tyc o tcc_tv;
	    ltc_ref    = ltc_tyc o tcc_ref o ltd_tyc;
	    ltc_array  = ltc_tyc o tcc_array o ltd_tyc;
	    ltc_vector = ltc_tyc o tcc_vector o ltd_tyc;
	    ltc_etag   = ltc_tyc o tcc_etag o ltd_tyc;

	    ltc_top = ltc_ppoly([tkc_mono], ltc_tv 0);

	    /***************************************************************************
	     *            UTILITY FUNCTIONS FOR TESTING EQUIVALENCE                    *
	     ***************************************************************************/

	    # Testing equivalence of tkinds,
	    # tycs, ltys, fflags, and rflags:
	    #
	    my type_kinds_are_equivalent:           (Highcode_Kind, Highcode_Kind) -> Bool     =  lk::type_kinds_are_equivalent;
	    my type_constructors_are_equivalent:    (Highcode_Type_Constructor, Highcode_Type_Constructor) -> Bool               =  lk::type_constructors_are_equivalent;
	    my lambda_types_are_equivalent:         (Highcode_Type, Highcode_Type) -> Bool =  lk::lambda_types_are_equivalent;
	    my function_flags_are_equivalent:       (Fn_Flag, Fn_Flag) -> Bool         =  lk::function_flags_are_equivalent;
	    my record_flags_are_equivalent:         (Record_Flag, Record_Flag) -> Bool =  lk::record_flags_are_equivalent;

	    # Testing the equivalence for tycs and
	    # ltys with relaxed constraints:
	    #
	    my type_constructors_are_approximately_equivalent:   (Highcode_Type_Constructor, Highcode_Type_Constructor) -> Bool               =  lk::type_constructors_are_approximately_equivalent;
	    my lambda_types_are_approximately_equivalent:        (Highcode_Type, Highcode_Type) -> Bool =  lk::lambda_types_are_approximately_equivalent;

	    /***************************************************************************
	     *            UTILITY FUNCTIONS FOR PRETTY PRINTING                        *
	     ***************************************************************************/

	    # Prettyprinting of tkinds, tycs, and ltys:
	    #
	    fun tk_print (x:  Highcode_Kind)
		= 
		g (type_kind_project x)
		where
		    fun g (lk::TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR) =>  "K0";
			g (lk::TYPEKIND_BOXED_TYPE_CONSTRUCTOR)       =>  "KB0";

			g (lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (ks, k))
			    =>  
			    "<" + (plist (tk_print, ks)) + "->" + (tk_print k) + ">";

			g (lk::TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE zs)
			    =>
			    "KS(" + (plist (tk_print, zs)) + ")";
		    end;
		end;

	    fun tc_print (x:  Highcode_Type_Constructor)
		=
		g (type_constructor_project x)
		where
		    fun g (lk::TC_VAR (i, j))  =>  "TV(" + (di::di_print i) + ", " + (itos j) + ")";
			g (lk::TC_NAMED_VAR v) =>  "NTV (v" + (itos v) + ")";

			g (lk::TC_PRIM pt)
			    =>
			    pt::prim_type_con_print pt;

			g (lk::TC_FN (ks, t))
			    => 
			    "(\\[" + plist (tk_print, ks) + "]." + (tc_print t) + ")";

			g (lk::TC_APPLY (t, [])) => tc_print t + "[]";
			g (lk::TC_APPLY (t, zs)) => (tc_print t) + "[" + (plist (tc_print, zs)) + "]";

			g (lk::TC_SEQ zs)      =>  "TS(" + (plist (tc_print, zs)) + ")";
			g (lk::TC_PROJ (t, i)) =>  "TP(" + (tc_print t) + ", " + (itos i) + ")";
			g (lk::TC_SUM tcs)     =>  "TSUM(" + (plist (tc_print, tcs)) + ")";

			g (lk::TC_RECURSIVE ((_, tc, ts), i))
			    => 
			    if (type_constructors_are_equivalent (x, tcc_bool))    "B"; 
			    elif (type_constructors_are_equivalent (x, tcc_list))  "LST"; 
			    else

			      #  ntc = case ts
			      #            [] => tc;
			      #            _  => tcc_app (tc, ts);
			      #        esac;

				 "DT { " + "DATA" +
							      #  "["              +
							      #  (tc_print tc)    +
							      #  "] &&"           +
							      #  (plist (tc_print, ts)) +
							      #  "&&"
				 "===="           +
				 (itos i)         +
				 "}";

			     fi;

			g (lk::TC_ABSTRACT t)   =>  "Ax(" + (tc_print t) + ")";
			g (lk::TC_BOXED t)      =>  "Bx(" + (tc_print t) + ")";
			g (lk::TC_TUPLE(_, zs)) =>  "TT<" + (plist (tc_print, zs)) + ">";

			g (lk::TC_ARROW (ff, z1, z2)) =>  parw (fn u = plist (tc_print, u), (ff, z1, z2));
			g (lk::TC_PARROW _)           =>  bug "unexpected TC_PARROW in tc_print";

			g (lk::TC_EXTENSIBLE_TOKEN (k, t))
			    => 
			    if (lk::token_is_valid k)    (lk::token_abbreviation k) + "(" + (tc_print t) + ")";
			    else                         bug "unexpected TC_EXTENSIBLE_TOKEN type_constructor in tc_print";
			    fi;

			g (lk::TC_FATE ts)
			    =>
			    "Count(" + (plist (tc_print, ts)) + ")";

			g (lk::TC_INDIRECT _) =>  bug "unexpected TC_INDIRECT in tc_print";
			g (lk::TC_CLOSURE  _) =>  bug "unexpected TC_CLOSURE in tc_print";
		    end;
		end;			# fun tc_print 

	    fun lt_print (x:  Highcode_Type)
		=
		g (lambda_type_project x)
		where
		    fun h (i, t)
			=
			"(" + (itos i) + ", " + (lt_print t) + ")";

		    fun g (lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t) => tc_print t;
			g (lk::FNTYPE_PACKAGE zs) => "S { " + (plist (lt_print, zs)) + "}";

			g (lk::FNTYPE_GENERIC (ts1, ts2))
                           => 
			   "(" + (plist (lt_print, ts1)) + ") ==> ("
			   + (plist (lt_print, ts2)) + ")";

			g (lk::FNTYPE_POLYMORPHIC (ks, ts))
                           => 
			   "(Q[" + plist (tk_print, ks) + "]."
                           + (plist (lt_print, ts)) + ")";

			g (lk::FNTYPE_INTERNAL_CLOSURE ts)
                            =>
                            "COUNT(" + (plist (lt_print, ts)) + ")";

			g (lk::FNTYPE_INDIRECT_TYPETHUNK _) => bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in lt_print";
			g (lk::FNTYPE_TYPE_CLOSURE      _) => bug "unexpected FNTYPE_TYPE_CLOSURE in lt_print";
		    end;

		end;			# fun lt_print 

	    # Finding out the depth for a type_constructor's
	    # innermost-bound free variables 
	    #
	    my type_constructor_depth_of_innermost_named_variable:   (Highcode_Type_Constructor, Depth)         -> Depth = lk::type_constructor_depth_of_innermost_named_variable;
	    my type_constructors_depth_of_innermost_named_variable:  (List( Highcode_Type_Constructor ), Depth) -> Depth = lk::type_constructors_depth_of_innermost_named_variable;

	    # Adjusting an Highcode_Type or Highcode_Type_Constructor
	    # from one depth to another 
	    #
	    fun lt_adj (lt, d, nd)
		= 
		if (d == nd)   lt; 
		else           lambda_type_closure_dictionary (lt, 0, nd - d, lk::init_type_constructor_dictionary);
		fi;

	    fun tc_adj (tc, d, nd)
		= 
		if (d == nd)   tc; 
		else           type_constructor_closure_dictionary (tc, 0, nd - d, lk::init_type_constructor_dictionary);
		fi;

	    # The following functions are smiliar to lt_adj and
	    # tc_adj; they adjust a Highcode_Type (or Highcode_Type_Constructor) from depth d+k to depth nd+k,
	    # assuming the last k levels are type abstractions. So lt_adj
	    # is really lt_adj_k with k set to 0. Both functions are currently
	    # called inside the lcontract.pkg only.
	    #
	    stipulate

		fun make_type_constructor_dictionary (i, k, dd, e)
		    = 
		    if (i >= k)   e;
		    else          make_type_constructor_dictionary (i+1, k, dd, lk::insert_type_constructor (e, (NULL, dd+i)));
		    fi;

	    herein 

		fun lt_adj_k (lt, d, nd, k)
		    = 
		    if (d == nd)  lt; 
		    else          lambda_type_closure_dictionary (lt, k, nd-d+k, make_type_constructor_dictionary (0, k, nd-d, lk::init_type_constructor_dictionary));
		    fi;

		fun tc_adj_k (tc, d, nd, k)
		    = 
		    if (d == nd)  tc; 
		    else          type_constructor_closure_dictionary (tc, k, nd-d+k, make_type_constructor_dictionary (0, k, nd-d, lk::init_type_constructor_dictionary));
		    fi;

	    end; #  lt_adj_k and tc_adj_k 

	    # Automatically flattening the argument
	    # or the result type:
	    #
	    my lt_autoflat:  Highcode_Type -> (Bool, List( Highcode_Type ), Bool)
                =
                lk::lt_autoflat;

	    # Testing if a Highcode_Type_Constructor is a unknown constructor
	    #
	    my type_constructor_is_unknown:  Highcode_Type_Constructor -> Bool
                =
                lk::type_constructor_is_unknown;

	    /***************************************************************************
	     *            UTILITY FUNCTIONS ON TKIND DICTIONARY                       *
	     ***************************************************************************/

	    Highcode_Kind_Dictionary       = lk::Highcode_Kind_Dictionary;
	    exception TYPE_KIND_UNBOUND    = lk::TYPE_KIND_UNBOUND;
	    empty_type_kind_dictionary     = lk::empty_type_kind_dictionary;
	    get_in_type_kind_dictionary    = lk::get_in_type_kind_dictionary;
	    insert_in_type_kind_dictionary = lk::insert_in_type_kind_dictionary;

	    /***************************************************************************
	     *            UTILITY FUNCTIONS ON TYC DICTIONARY                         *
	     ***************************************************************************/

	    exception TC_UNBOUND             = lk::TC_UNBOUND;
	    Type_Constructor_Dictionary      = lk::Type_Constructor_Dictionary;
	    init_type_constructor_dictionary = lk::init_type_constructor_dictionary;
	    insert_type_constructor          = lk::insert_type_constructor;

	    /***************************************************************************
	     *            UTILITY FUNCTIONS ON LTY DICTIONARY                         *
	     ***************************************************************************/

	    # Utility values and functions on lty_env 
	    #
	    Lty_Env
                =
                int_red_black_map::Map( (Highcode_Type, debruijn_index::Depth) ); 

	    exception LT_UNBOUND;

	    my init_lty_dictionary:  Lty_Env
                =
                int_red_black_map::empty;

	    fun lt_lookup (venv, lv, nd)
		= 
		case (int_red_black_map::get (venv, lv))

		    NULL
			=> 
			{   say "**** hmmm, I didn't find the variable ";
			    say (int::to_string lv); say "\n";
			    raise exception LT_UNBOUND;
			};

		    THE (lt, d)
			=> 
			if   (d == nd)   lt;
			elif (d >  nd)   bug "unexpected depth info in ltLookup";
			else             lambda_type_closure_dictionary (lt, 0, nd - d, lk::init_type_constructor_dictionary);
			fi;
		esac;

	    fun lt_insert (venv, lv, lt, d)
		=
		int_red_black_map::set (venv, lv, (lt, d));

	end;		#  top-level stipulate

	# Instantiate a polymorphic type
        # or a higher-order constructor: 
	#
	fun instantiate_polymorphic_lambda_or_higher_order_constructor_type
            ( lt:  Highcode_Type,
	      ts:  List( Highcode_Type_Constructor )
	    )
	    = 
	    {   nt = reduce_lambda_type_to_weak_head_normal_form lt;
	    
		case (/* lt_outX */ lambda_type_project nt, ts)
	
	             (lk::FNTYPE_POLYMORPHIC (ks, b),  ts)
			 => 
			 {   nenv  = lk::insert_type_constructor (lk::init_type_constructor_dictionary, (THE ts, 0));

			     map  (fn x = lambda_type_closure_dictionary (x, 1, 0, nenv))  b;
			 };

		     (_, []) =>  [nt];   #  This requires further clarifications !!! XXX FIXME BUGGO 
		     _       =>  bug "incorrect Highcode_Type instantiation in instantiate_polymorphic_lambda_or_higher_order_constructor_type";
		esac;

	   }; 

	fun protected_instantiation_of_polymorphic_lambda_or_higher_order_constructor_type
            ( lt:  Highcode_Type,
	      ts:  List( Highcode_Type_Constructor )
	    )
	    = 
	    case (instantiate_polymorphic_lambda_or_higher_order_constructor_type (lt, ts))
		[y] => y;
		 _  => bug "unexpected pmacroExpandPolymorephicLambdaTypeOrHOC";
            esac;


	/********************************************************************
	 *                      KIND-CHECKING ROUTINES                      *
	 ********************************************************************/

	exception TK_TYPE_CONSTRUCTOR_CHECK;
	exception LTY_APP_CHECK;

	# tk_subkind returns TRUE if k1 is a subkind of k2, or if they are 
	# equivalent kinds.  It is NOT commutative.  tks_subkind is the same
	# thing, component-wise on lists of kinds.
	#
	fun tks_subkind (ks1, ks2)
            =
	    paired_lists::all tk_subkind (ks1, ks2)   #  Component-wise 

	also
	fun tk_subkind (k1, k2)
            = 
	    type_kinds_are_equivalent (k1, k2)               #  reflexive 
            or
	    case (type_kind_project k1, type_kind_project k2)   

		(lk::TYPEKIND_BOXED_TYPE_CONSTRUCTOR, lk::TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR)
                    =>
                    TRUE; #  ground kinds (base case) 

		# This next case is WRONG, but necessary until the
		# infrastructure is there to give proper boxed kinds to
		# certain tycons (e.g., REF:  Omega -> Omega_b)			XXX BUGGO FIXME
		#
		(lk::TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR, lk::TYPEKIND_BOXED_TYPE_CONSTRUCTOR)
		    =>
		    TRUE;

		(lk::TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE ks1, lk::TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE ks2)
		    =>     
		    tks_subkind (ks1, ks2);

		(lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (ks1, k1'), lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (ks2, k2'))
		    => 
		    tks_subkind (ks1, ks2)   and           #  Contravariant 
		    tk_subkind  (k1', k2');

		_ => FALSE;
            esac;

	# Is kind 'k' monomorphic?
        #
	fun tk_is_mono k
            =
            tk_subkind (k, tkc_mono);

	# Assert that k1 is a subkind of k2:
	#
	fun tk_assert_subkind (k1, k2)
            =
            if (not (tk_subkind (k1, k2)))   raise exception TK_TYPE_CONSTRUCTOR_CHECK;   fi;

	# Assert that a kind is monomorphic:
        #
	fun tk_assert_is_mono k
            =
            if (not (tk_is_mono k))   raise exception TK_TYPE_CONSTRUCTOR_CHECK;   fi;

	# Select the ith element
        # from a kind sequence:
	#
	fun tk_sel (tk, i)
	    = 
	    case (type_kind_project tk)

		(lk::TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE ks)
		    =>
		    list::nth (ks, i)
		    except
			_ = raise exception TK_TYPE_CONSTRUCTOR_CHECK;

		_ => raise exception TK_TYPE_CONSTRUCTOR_CHECK;
            esac;


	fun tks_eqv (ks1, ks2)
            =
            type_kinds_are_equivalent (tkc_seq ks1, tkc_seq ks2);

	fun tk_app (tk, tks)
            = 
	    case (type_kind_project tk)

		lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (a, b)
		    =>
		    if (tks_eqv (a, tks))   b;
		    else                    raise exception TK_TYPE_CONSTRUCTOR_CHECK;
		    fi;

		_ => raise exception TK_TYPE_CONSTRUCTOR_CHECK;
            esac;

	# Check the application of tycs of kinds `tks'
	# to a type function of kind `tk':
	#
	fun tk_app (tk, tks)
            = 
	    case (type_kind_project tk)

		lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (a, b)
		    =>
		    if (tks_subkind (tks, a))   b;
		    else                        raise exception TK_TYPE_CONSTRUCTOR_CHECK;
		    fi;

		_   => raise exception TK_TYPE_CONSTRUCTOR_CHECK;
            esac;

	# Kind-checking naturally requires traversing type graphs.
	#
	# To avoid re-traversing bits of the dag, we use a dictionary
	# to memoize the kind of each Highcode_Type_Constructor we process.
	#
	# One problem is that a Highcode_Type_Constructor can have different kinds,
	# depending on the valuations of its free variables.
	#
	# So this dictionary maps a Highcode_Type_Constructor to an association list
	# that maps the kinds of the free variables in the Highcode_Type_Constructor
	# (represented as a TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE) to the Highcode_Type_Constructor's kind.
	#
	package tc_dictionary
            =
            binary_map_g (
                Key = Highcode_Type_Constructor;
		compare = lk::compare_type_constructors;
            );

	package memo:
	    api {
		Dictionary; 
		 new_dictionary:          Void -> Dictionary;
		recall_or_compute:  (Dictionary, Highcode_Kind_Dictionary, Highcode_Type_Constructor, (Void -> Highcode_Kind)) -> Highcode_Kind;
	    }
	{
	    package tc_dictionary
                =
                red_black_map_g (						# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg

		    Key     = Highcode_Type_Constructor;
		    compare = lk::compare_type_constructors;
		);

	    Dictionary
                =
                Ref( tc_dictionary::Map( List ( (Highcode_Kind, Highcode_Kind) ) ) );

	    my new_dictionary:  Void -> Dictionary
                =
                REF  o  (fn () = tc_dictionary::empty);

	    fun recall_or_compute (dictionary, kenv, type_constructor, do_it)
                =
		# What are the valuations of type_constructor's
		# free variables in kenv?

		# (Might not be available for some tycs.)
                #
		case (lk::get_in_type_kind_dictionary_free_vars (kenv, type_constructor))   

		    THE ks_fvs
                        =>
                        {
			    # Encode those as a kind sequence:
 			    #	
			    k_fvs = tkc_seq ks_fvs;

			    # Query the dictionary:
			    #
			    kci = case (tc_dictionary::get (*dictionary, type_constructor))
				      THE kci => kci;
				      NULL    => [];
				  esac;

			    # Get for an equivalent dictionary:
			    #
			    fun same_dictionary_identifier (k_fvs', _)
				=
				type_kinds_are_equivalent (k_fvs, k_fvs');

			    case (list::find same_dictionary_identifier kci)

				THE (_, k) => k;     #  HIT! 

				NULL =>
				    k
				    where
					# Not in the list.
					# Compute and cache:
					#
					k = do_it();
					kci' = (k_fvs, k) ! kci;

					dictionary := tc_dictionary::set (*dictionary, type_constructor, kci');
				    end;
			    esac;
			};

		   NULL =>
		      # freevars were not available.  we'll have to
		      # recompute and cannot cache the result.
		      #	
		      do_it();
               esac;

	};	# package memo 


	#  Return the kind of a given type_constructor
        # in the given kind dictionary 
	#
	fun tk_type_constructor_fn ()
	    =
	    tk_type_constructor
            where

	        dictionary = memo::new_dictionary ();

		fun tk_type_constructor kenv t
		    =
		    memo::recall_or_compute (dictionary, kenv, t, mk)
                    where

			g = tk_type_constructor kenv;		# Default recursive invocation.

			# How to compute the kind of a type_constructor
                        #
			fun mk ()
                            =
			    case (type_constructor_project t)

			        lk::TC_VAR (i, j)  =>   get_in_type_kind_dictionary (kenv, i, j);
			        lk::TC_NAMED_VAR _ => bug "TC_NAMED_VAR not supported yet in tk_type_constructor";

			        lk::TC_PRIM pt     => tkc_int (highcode_data_representation::prim_type_con_arity pt);
			        lk::TC_FN (ks, tc) => tkc_fun (ks, tk_type_constructor (insert_in_type_kind_dictionary (kenv, ks)) tc);

			        lk::TC_APPLY (tc, tcs) => tk_app (g tc, map g tcs);
			        lk::TC_SEQ tcs         => tkc_seq (map g tcs);
			        lk::TC_PROJ (tc, i)    => tk_sel (g tc, i);

			        lk::TC_SUM tcs
                                    =>
                                    {   list::apply (tk_assert_is_mono o g) tcs;
				        tkc_mono;
                                    };

			        lk::TC_RECURSIVE ((n, tc, ts), i)
                                    =>
				    {   k = g tc;

				        nk = case ts   
					         [] =>  k; 
					         _  =>  tk_app (k, map g ts);
                                             esac;
				 
				        case (type_kind_project nk)   

					     lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (a, b)
                                                 => 
					         {   arg =  case a    [x] => x;
						                       _  => tkc_seq a;
                                                            esac;
					 
					             if (tk_subkind (arg, b)) #  order? 

						          n == 1   ??   b
                                                                   ::   tk_sel (arg, i);
					             else
                                                          raise exception TK_TYPE_CONSTRUCTOR_CHECK;
                                                     fi;
					         };

				             _ => raise exception TK_TYPE_CONSTRUCTOR_CHECK;
                                        esac;
				    };

			        lk::TC_ABSTRACT tc
                                    =>
				    {   tk_assert_is_mono (g tc);
				        tkc_mono;
                                    };

			        lk::TC_BOXED tc
                                    =>
				    {   tk_assert_is_mono (g tc);
				        tkc_mono;
                                    };

			        lk::TC_TUPLE (_, tcs)
                                    =>
				    {   list::apply (tk_assert_is_mono o g) tcs;
				        tkc_mono;
                                    };

			        lk::TC_ARROW (_, ts1, ts2)
                                    =>
				    {   list::apply (tk_assert_is_mono o g) ts1;
				        list::apply (tk_assert_is_mono o g) ts2;
				        tkc_mono;
                                    };

			        lk::TC_EXTENSIBLE_TOKEN(_, tc)
                                    =>
				    {   tk_assert_is_mono (g tc);
				        tkc_mono;
                                    };

			        lk::TC_PARROW       _ => bug "unexpected TC_PARROW in tkTypeConstructor";
			        lk::TC_CLOSURE      _ => bug "unexpected TC_CLOSURE in tkTypeConstructor";
			        lk::TC_INDIRECT     _ => bug "unexpected TC_INDIRECT in tkTypeConstructor";
			        lk::TC_FATE _ => bug "unexpected TC_FATE in tkTypeConstructor";
                            esac;
		    end;					# fun tk_type_constructor 
	    end;						# fun tk_type_constructor_fn


	# Assert that the kind of `tc'
        # is a subkind of `k' in `kenv':
        #
	fun tk_check_generic ()
	    =
	    tk_check
            where
	        tk_type_constructor =  tk_type_constructor_fn ();

		fun tk_check kenv (k, tc)
		    =
		    tk_assert_subkind (tk_type_constructor kenv tc, k);
	    end;

	#  Highcode_Type application with kind-checking (exported) 
	#
	fun ls_inst_check_generic ()
	    =
	    lt_inst_check
            where

	        tk_check = tk_check_generic();

		fun lt_inst_check (lt:  Highcode_Type, ts:  List( Highcode_Type_Constructor ), kenv:  Highcode_Kind_Dictionary)
		    = 
		    {   nt = reduce_lambda_type_to_weak_head_normal_form lt;

			case (/* lt_outX */ lambda_type_project nt, ts)

			     (lk::FNTYPE_POLYMORPHIC (ks, b), ts)
				 => 
				 {   paired_lists::apply (tk_check kenv) (ks, ts);

				     fun h x
					 =
					 lambda_type_closure_dictionary (x, 1, 0, insert_type_constructor (init_type_constructor_dictionary, (THE ts, 0)));
				 
				     map h b;
				 };

			         (_, []) => [nt];			#  ? problematic  XXX BUGGO FIXME
			         _       => raise exception LTY_APP_CHECK;
                        esac;
		    };
	    
	    end;

	# A special Highcode_Type application used inside
        #     src/lib/compiler/upper/optimize/specialize.pkg
	#
	fun lt_sp_adj (ks, lt, ts, dist, bnl)
	    = 
	    h (dist, 1, bnl, btenv)
            where
	        btenv = insert_type_constructor (init_type_constructor_dictionary, (THE ts, 0));

	        fun h (abslevel, ol, nl, tenv)
		    =
		    if   (abslevel == 0)

			 lambda_type_closure_dictionary (lt, ol, nl, tenv);

		    elif (abslevel > 0)

			 h (abslevel - 1, ol+1, nl+1, insert_type_constructor (tenv, (NULL, nl)));
		    else
                         bug "unexpected cases in ltAdjSt";
                    fi;
	    end;

	# A special type_constructor application used
        # inside src/lib/compiler/upper/optimize/specialize.pkg
        #
	fun tc_sp_adj (ks, tc, ts, dist, bnl)
	    =
            h (dist, 1, bnl, btenv)
            where
		btenv = insert_type_constructor (init_type_constructor_dictionary, (THE ts, 0));

	        fun h (abslevel, ol, nl, tenv)
		    =
		    if   (abslevel == 0)
		         type_constructor_closure_dictionary (tc, ol, nl, tenv);
		    else if   (abslevel > 0)
			      h (abslevel - 1, ol+1, nl+1, insert_type_constructor (tenv, (NULL, nl)));
			 else bug "unexpected cases in tcAdjSt";fi;
                    fi;

	    end;

	# * Sinking the Highcode_Type one-level down -- used inside specialize.pkg 
        #
	fun lt_sp_sink (ks, lt, d, nd)
	    = 
	    {   fun h (abslevel, ol, nl, tenv)
		    =
		    if   (abslevel == 0)

		        lambda_type_closure_dictionary (lt, ol, nl, tenv);

		    elif (abslevel > 0)

			h (abslevel - 1, ol+1, nl+1, insert_type_constructor (tenv, (NULL, nl)));
		    else
                        bug "unexpected cases in ltSinkSt";
                    fi;

		nt = h (nd-d, 0, 1, init_type_constructor_dictionary);
	    
		nt; #  was reduceLambdaTypeToNormalForm nt 
	    };

	# * Sinking the type_constructor one-level down -- used inside specialize.pkg 
	#
	fun tc_sp_sink (ks, tc, d, nd)
	    = 
	    {   fun h (abslevel, ol, nl, tenv)
		    =
		    if   (abslevel == 0)

		        type_constructor_closure_dictionary (tc, ol, nl, tenv);

		    elif (abslevel > 0)

		        h (abslevel - 1, ol+1, nl+1, insert_type_constructor (tenv, (NULL, nl)));
		    else
                        bug "unexpected cases in ltSinkSt";
		    fi;

		nt = h (nd-d, 0, 1, init_type_constructor_dictionary);
	    
		nt; #  was reduceTypeConstructorToNormalForm nt 
	    };

	# Utility functions used in FPS:
        #
	fun lt_iscont lt
	    = 
	    case (lambda_type_project lt)

		  lk::FNTYPE_INTERNAL_CLOSURE _
                      =>
                      TRUE;

		  lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
                      => 
		      case (type_constructor_project tc)    lk::TC_FATE _ =>  TRUE;
                                                            _                     =>  FALSE;
                      esac;

		   _  => FALSE;
            esac;

	fun ltw_iscont (lt, f, g, h)
	    = 
	    case (lambda_type_project lt)

		  lk::FNTYPE_INTERNAL_CLOSURE t
                      =>
                      f t;

		  lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
                      => 
		      case (type_constructor_project tc)    lk::TC_FATE x =>  g x;
                                                            _                     =>  h lt;
                      esac;

		  _ => h lt;
            esac;


	fun tc_bug tc s =  bug (s + "\n\n" + (tc_print tc) + "\n\n");
	fun lt_bug lt s =  bug (s + "\n\n" + (lt_print lt) + "\n\n");

	# Other misc utility functions:
        #
	fun tc_select (tc, i)
	    = 
	    case (type_constructor_project tc)

	        lk::TC_TUPLE (_, zs)
                    =>
		 (list::nth (zs, i))
                 except
                     _ = bug "wrong TC_TUPLE in tc_select";

	         _ => tc_bug tc "wrong TCs in tc_select";
            esac;

	fun lt_select (t, i)
	    = 
	    case (lambda_type_project t)

	       lk::FNTYPE_PACKAGE ts
                   => 
		   (list::nth (ts, i))
                   except
                       _ = bug "incorrect FNTYPE_PACKAGE in lt_select";

	       lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
                   =>
                   ltc_tyc (tc_select (tc, i));

	       _ => bug "incorrect lambda types in lt_select";
            esac;

	fun tc_swap t
	    = 
	    case (type_constructor_project t)

	        lk::TC_ARROW (lk::FNFLAG_VARIABLE (r1, r2), [s1], [s2])
                    => 
		   tcc_arrow (lk::FNFLAG_VARIABLE (r2, r1), [s2], [s1]);

	        lk::TC_ARROW (lk::FNFLAG_FIXED, [s1], [s2])
                    =>
		   tcc_arrow (lk::FNFLAG_FIXED, [s2], [s1]);

	        _ => bug "unexpected tycs in tc_swap";
            esac;

	fun lt_swap t
	    = 
	    case (lambda_type_project t)

	         (lk::FNTYPE_POLYMORPHIC (ks, [x]))
                     =>
                     ltc_poly (ks, [lt_swap x]);

	         (lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR x)
                     =>
                     ltc_tyc (tc_swap x);

	         _ => bug "unexpected type in lt_swap";
            esac;

	# Functions that manipulate the highcode
        # function and record types
        #
	fun ltc_fkfun ( { calling_convention=>fl::CALLING_CONVENTION_GENERIC,       ... }: fl::Function_Kind, atys, rtys) 
                =>
                ltc_fct  (       atys, rtys);

	    ltc_fkfun ( { calling_convention=>fl::CALLING_CONVENTION_FUNCTION fixed, ... },           atys, rtys)
                =>
                ltc_arrow (fixed, atys, rtys);
        end;

	fun ltd_fkfun lambda_type
	    = 
	    if   (ltp_fct lambda_type)
	         ltd_fct lambda_type;
	    else
                 my (_, atys, rtys) = ltd_arrow lambda_type;
		 (atys, rtys);
	    fi;

	fun ltc_rkind (fl::RK_TUPLE _, lts) =>  ltc_tuple lts;
	    ltc_rkind (fl::RK_STRUCT,  lts) =>  ltc_str   lts;
	    ltc_rkind (fl::RK_VECTOR t, _)  =>  ltc_vector (ltc_tyc t);
        end;

	fun ltd_rkind (lt, i)
            =
            lt_select (lt, i);

	/****************************************************************************
	 *             UTILITY FUNCTIONS USED BY POST-REPRESENTATION ANALYSIS       *
	 ****************************************************************************/
	# Figure the appropriate primitive_operation given a type_constructor:
	#
	fun tc_upd_prim tc
	    = 
	    h (type_constructor_project tc)
            where
	        fun h (lk::TC_PRIM pt)
			=> 
			if   (pt::ubxupd pt)
			     po::UNBOXED_SET;
			else if   (pt::bxupd pt)
				  po::BOXED_SET; 
			     else po::UPDATE;fi;
			fi;

		    h (lk::TC_TUPLE _ | lk::TC_ARROW _)
                        =>
                        po::BOXED_SET;

		    h (lk::TC_RECURSIVE ((1, tc, ts), 0))
		        => 
		        {   ntc = case ts    [] => tc;
					      _ => tcc_app (tc, ts);
                                  esac;

		            case (type_constructor_project ntc)
			        lk::TC_FN([k], b) => h (type_constructor_project b);
			        _                 => po::UPDATE;
                            esac;
		      };

		    h (lk::TC_SUM tcs)
                        => 
		        {   fun g (a ! r) =>   type_constructors_are_equivalent (a, tcc_unit)
                                                   ??  g r
                                                   ::  FALSE;
			        g []      => TRUE;
                            end;

		            if (g tcs)  po::UNBOXED_SET;
                            else        po::UPDATE;
                            fi;
		      };

		    h _ => po::UPDATE;
                end;
	    
	    end;

	# tk_lty:  Highcode_Kind -> Highcode_Type -- finds out the corresponding type for a Highcode_Kind
	# 
	fun tk_lty tk
	    = 
	    case (type_kind_project tk)
	      
		 lk::TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR => ltc_int;
		 lk::TYPEKIND_BOXED_TYPE_CONSTRUCTOR => ltc_int;
		 lk::TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE ks => ltc_tuple (map tk_lty ks);
		 lk::TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (ks, k) => 
		    ltc_arrow (ffc_fixed, [ltc_tuple (map tk_lty ks)], [tk_lty k]);
            esac;


	# tnarrow_fn:  Void -> ((Highcode_Type_Constructor -> Highcode_Type_Constructor) * (Highcode_Type -> Highcode_Type) * (Void->Void))
	#
	fun tnarrow_fn ()
	    = 
	    ( tc_map  o  reduce_type_constructor_to_normal_form,
              lt_map  o  reduce_lambda_type_to_normal_form,
              fn () = ()
            )
            where
		fun tc_narrow tcf t
		    = 
		    case (type_constructor_project t)

			lk::TC_PRIM pt
			    => 
			    if (pt::isvoid pt ) tcc_void; else t;fi;

			lk::TC_TUPLE (_, tcs)
			    =>
			    tcc_tuple (map tcf tcs);

			lk::TC_ARROW (r, ts1, ts2)
			    => 
			    tcc_arrow (ffc_fixed, map tcf ts1, map tcf ts2);

		       _ => tcc_void;
		    esac;

		fun lt_narrow (tcf, ltf) t
		    = 
		    case (lambda_type_project t)
			lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc => ltc_tyc (tcf tc);
			lk::FNTYPE_PACKAGE ts => ltc_str (map ltf ts);
			lk::FNTYPE_GENERIC (ts1, ts2) => ltc_fct (map ltf ts1, map ltf ts2);
			lk::FNTYPE_POLYMORPHIC (ks, xs)
                            => 
			    ltc_fct([ltc_str (map tk_lty ks)], map ltf xs);
			lk::FNTYPE_INTERNAL_CLOSURE _ => bug "unexpected CNTs in ltNarrow";
			lk::FNTYPE_INDIRECT_TYPETHUNK _ => bug "unexpected INDs in ltNarrow";
			lk::FNTYPE_TYPE_CLOSURE _ => bug "unexpected ENVs in ltNarrow";
		    esac;

		my { tc_map, lt_map }
                    =
                    highcode_dictionary::tmemo_fn
                      {
                        tcf => tc_narrow,
                        ltf => lt_narrow
                      };

	    end;		# fun tnarrow_fn 

	/* twrap_fn:    Bool -> ((Highcode_Type_Constructor -> Highcode_Type_Constructor) * (Highcode_Type -> Highcode_Type) *
	 *                        (Highcode_Type_Constructor -> Highcode_Type_Constructor) * (Highcode_Type -> Highcode_Type) * (Void -> Void)) 
	 */
	fun twrap_fn bbb
	    = 
	    {   fun tc_wmap (w, u) t
		    =
		    case (type_constructor_project t)
		        (lk::TC_VAR _ | lk::TC_NAMED_VAR _) => t;
		        lk::TC_PRIM pt => if (pt::unboxed pt ) tcc_wrap t; else t;fi;
		        lk::TC_FN (ks, tc) => tcc_g (ks, w tc); #  impossible case 
		        lk::TC_APPLY (tc, tcs) => tcc_app (w tc, map w tcs);
		        lk::TC_SEQ tcs => tcc_seq (map w tcs);
		        lk::TC_PROJ (tc, i) => tcc_proj (w tc, i);
		        lk::TC_SUM tcs => tcc_sum (map w tcs);

		        lk::TC_RECURSIVE ((n, tc, ts), i)
                            => 
			    tcc_fix((n, reduce_type_constructor_to_normal_form (u tc), map w ts), i); 

		        lk::TC_TUPLE (_, ts) => tcc_wrap (tcc_tuple (map w ts)); #  ? 
		        lk::TC_ARROW (lk::FNFLAG_VARIABLE (b1, b2), ts1, ts2)
                            =>  
 			    {   nts1 = case ts1    # Too specific !
					   [t11, t12] => [w t11, w t12]; 
					   _          => [w (lk::type_constructor_list_to_type_constructor_tuple ts1)];
				       esac;
			        nts2 = [w (lk::type_constructor_list_to_type_constructor_tuple ts2)];

			        nt = tcc_arrow (ffc_fixed, nts1, nts2);

			        if b1  nt; else tcc_wrap nt;fi;
			    };

		        lk::TC_ARROW (lk::FNFLAG_FIXED, _, _)
                            =>  
			    bug "unexpected TC_FIXED_ARROW in tc_umap";

		        lk::TC_EXTENSIBLE_TOKEN (k, t) => bug "unexpected token Highcode_Type_Constructor in tc_wmap";
		        lk::TC_BOXED _ => bug "unexpected TC_BOXED in tc_wmap";
		        lk::TC_ABSTRACT _ => bug "unexpected TC_ABSTRACT in tc_wmap";
		        _ => bug "unexpected other tycs in tc_wmap";
                    esac;

		fun tc_umap (u, w) t
		    =
		    case (type_constructor_project t)
			(lk::TC_VAR _ | lk::TC_NAMED_VAR _ | lk::TC_PRIM _) => t;
			lk::TC_FN (ks, tc) => tcc_g (ks, u tc); /* impossible case */ 
			lk::TC_APPLY (tc, tcs) => tcc_app (u tc, map w tcs);
			lk::TC_SEQ tcs => tcc_seq (map u tcs);
			lk::TC_PROJ (tc, i) => tcc_proj (u tc, i);
			lk::TC_SUM tcs => tcc_sum (map u tcs);

			lk::TC_RECURSIVE ((n, tc, ts), i)
                            => 
			    tcc_fix((n, reduce_type_constructor_to_normal_form (u tc), map w ts), i); 

			lk::TC_TUPLE (rk, tcs) => tcc_tuple (map u tcs);

			lk::TC_ARROW (lk::FNFLAG_VARIABLE (b1, b2), ts1, ts2)
                            =>  
			    tcc_arrow (ffc_fixed, map u ts1, map u ts2);

			lk::TC_ARROW (lk::FNFLAG_FIXED, _, _)
                            =>  
			    bug "unexpected TC_FIXED_ARROW in tc_umap";

			lk::TC_PARROW   _ => bug "unexpected TC_PARROW in tc_umap";
			lk::TC_BOXED    _ => bug "unexpected TC_BOXED in tc_umap";
			lk::TC_ABSTRACT _ => bug "unexpected TC_ABSTRACT in tc_umap";

			lk::TC_EXTENSIBLE_TOKEN (k, t)
                            => 
			    if (lk::tokens_are_equal (k, lk::wrap_token)) 
			        bug "unexpected TC_WRAP in tc_umap";
			    else
                                type_constructor_inject (lk::TC_EXTENSIBLE_TOKEN (k, u t));
                            fi;

			_ => bug "unexpected other tycs in tc_umap";
                    esac;

		fun lt_umap (tcf, ltf) t
		    = 
		    case (lambda_type_project t)
			lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc => ltc_tyc (tcf tc);
			lk::FNTYPE_PACKAGE ts           => ltc_str (map ltf ts);
			lk::FNTYPE_GENERIC (ts1, ts2)   => ltc_fct (map ltf ts1, map ltf ts2);
			lk::FNTYPE_POLYMORPHIC (ks, xs) => ltc_poly (ks, map ltf xs);
			lk::FNTYPE_INTERNAL_CLOSURE   _ => bug "unexpected CNTs in lt_umap";
			lk::FNTYPE_INDIRECT_TYPETHUNK _ => bug "unexpected INDs in lt_umap";
			lk::FNTYPE_TYPE_CLOSURE       _ => bug "unexpected ENVs in lt_umap";
                    esac;

		my { tc_wmap=>tc_wrap, tc_umap=>tc_map, lt_umap=>lt_map, cleanup }
		    =
		    highcode_dictionary::wmemo_fn { tc_wmap, tc_umap, lt_umap };

		fun lt_wrap x
                    = 
		    ltw_tyc (x, (fn tc => ltc_tyc (tc_wrap tc); end ),
			       fn _ => bug "unexpected case in ltWrap"; end );

	    
		( tc_wrap o reduce_type_constructor_to_normal_form,
		  lt_wrap o reduce_lambda_type_to_normal_form, 
		  tc_map  o reduce_type_constructor_to_normal_form,
		  lt_map  o reduce_lambda_type_to_normal_form,
		  cleanup
		);
	    };


	/************************************************************************
	 *            SUBSTITION OF NAMED VARS IN A TYC/LTY                     *
	 ************************************************************************/
	package lt_dictionary
            =
            binary_map_g (
		Key = Highcode_Type;
		compare = highcode_guts::compare_lambda_types;
	    );

	fun tc_nvar_elim_fn ()
	    =
	    tc_nvar_elim
            where

	        dictionary = REF (tc_dictionary::empty);

		fun tc_nvar_elim s d type_constructor
                    = 
		    case (lk::free_named_variables_in_type_constructor  type_constructor)   

			[] => type_constructor;                   #  nothing to elim 

			_  =>
			   {   # Encode the type_constructor and
			       # the depth for memoization
			       # using tcc_proj:
			       #
			       tycdepth = tcc_proj (type_constructor, d);

			       case (tc_dictionary::get (*dictionary, tycdepth))

				   THE t => t;                 #  hit! 

				   NULL =>                  #  must recompute
				       { 
					   r = tc_nvar_elim s d;	# Default recursive invoc. 
					   rs = map r;		# Recursive invocation on list.

					   t = case (type_constructor_project type_constructor)   

						   lk::TC_VAR  _ => type_constructor;
						   lk::TC_PRIM _ => type_constructor;

						   lk::TC_FN   (tks, t) =>  tcc_g (tks, tc_nvar_elim s (di::next d) t);
						   lk::TC_APPLY (t, ts) =>  tcc_app (r t, rs ts);
						   lk::TC_SEQ ts        =>  tcc_seq (rs ts);

						   lk::TC_PROJ (t, i)   =>  tcc_proj (r t, i);
						   lk::TC_SUM ts        =>  tcc_sum (rs ts);

						   lk::TC_TUPLE (rf, ts)      =>  tcc_tuple (rs ts);
						   lk::TC_ARROW (ff, ts, ts') =>  tcc_arrow (ff, rs ts, rs ts');
						   lk::TC_PARROW (t, t')      =>  tcc_parrow (r t, r t');

						   lk::TC_BOXED t             =>  tcc_box (r t);
						   lk::TC_ABSTRACT t          =>  tcc_abs (r t);
						   lk::TC_FATE ts     =>  tcc_cont (rs ts);

						   lk::TC_RECURSIVE ((i, t, ts), j)
						       =>
						       tcc_fix ((i, r t, rs ts), j);

						   lk::TC_NAMED_VAR tvar
						       =>   
						       case (s (tvar, d))   
							   THE t => t;
							   NULL => type_constructor;
						       esac;

						   lk::TC_EXTENSIBLE_TOKEN (tok, t)
						       =>
						       type_constructor_inject (lk::TC_EXTENSIBLE_TOKEN (tok, r t));


						   lk::TC_INDIRECT     _  =>  bug "unexpected TC_INDIRECT in tc_nvar_elim";
						   lk::TC_CLOSURE      _  =>  bug "unexpected TC_CLOSURE in tc_nvar_elim";
					       esac;

					   dictionary := tc_dictionary::set (*dictionary, tycdepth, t);

					   t;
				   };
			       esac;
			   };
                    esac; #  tc_nvar_elim 
	    
	    end;

	fun lt_nvar_elim_fn ()
            =
	    lt_nvar_elim
            where

		dictionary =  REF (lt_dictionary::empty);

		tc_nvar_elim =  tc_nvar_elim_fn();

		fun lt_nvar_elim s d lambda_type
                    = 
		    case (lk::free_named_variables_in_lambda_type  lambda_type)   

			[] => lambda_type;                   #  nothing to elim 

		        _  => 
		            {
				# Encode the Highcode_Type and depth info
                                # using FNTYPE_TYPE_CLOSURE
				# (only first 2 args are useful)
                                #
				ltydepth
                                    =
                                    lambda_type_inject
                                      (
                                        lk::FNTYPE_TYPE_CLOSURE (lambda_type, d, 0, lk::init_type_constructor_dictionary)
                                      );

				case (lt_dictionary::get (*dictionary, ltydepth))

				    THE t => t;                 #  hit! 

				    NULL =>                 #  must recompute 
					t
                                        where
					    r = lt_nvar_elim s d; #  Default recursive invoc. 
					    rs = map r;          #  recursive invocation on list 

					    t = case (lambda_type_project lambda_type)   

						    lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t  =>  ltc_tyc (tc_nvar_elim s d t);
						    lk::FNTYPE_PACKAGE                      ts =>  ltc_str (rs ts);

						    lk::FNTYPE_GENERIC          (ts, ts') =>  ltc_fct (rs ts, rs ts');
						    lk::FNTYPE_POLYMORPHIC      (tks, ts) =>  ltc_poly (tks, map (lt_nvar_elim s (di::next d)) ts);
						    lk::FNTYPE_INTERNAL_CLOSURE  ts       =>  ltc_cont (rs ts);

						    lk::FNTYPE_INDIRECT_TYPETHUNK _ => bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in lt_nvar_elim";
						    lk::FNTYPE_TYPE_CLOSURE       _ => bug "unexpected FNTYPE_TYPE_CLOSURE in lt_nvar_elim";
                                                esac;

					    dictionary :=  lt_dictionary::set (*dictionary, ltydepth, t);
					end;
                                esac;
		            };
                    esac;			 # fun lt_nvar_elim 

	    end;				 # fun lt_nvar_elim_fn 

	# **********************************************************

	Smap = List ((Highcode_Variable, Highcode_Type_Constructor));

	# Is the intersection of two
        # sorted lists non-NIL?
        # 
	fun intersection_non_empty (NIL, _: List( Highcode_Variable ))
                =>
                FALSE;

	    intersection_non_empty(_, NIL)
                =>
                FALSE;

	    intersection_non_empty (s1 as (h1: Highcode_Variable, _) ! t1, s2 as h2 ! t2)
                =>
		case (int::compare (h1, h2))   
		    LESS    => intersection_non_empty (t1, s2);
		    GREATER => intersection_non_empty (s1, t2);
		    EQUAL   => TRUE;
                esac;
        end;

	fun search_subst (tv: Highcode_Variable, s)
            = 
	    h s
            where
	        fun h []
                        =>
                        NULL;

		    h ((tv': Highcode_Variable, type_constructor) ! s)
                        => 
			case (int::compare (tv, tv'))   
			    LESS => NULL;
			    GREATER => h s;
			    EQUAL => THE type_constructor;
                        esac;
                end;
	    end;

	fun tc_nvar_subst_fn ()
            =
	    tc_nvar_subst
            where
		dictionary = REF (tc_dictionary::empty);

		fun tc_nvar_subst subst
                    =
		    loop
                    where
			fun loop type_constructor
			    =
			    # Check if substitution overlaps
                            # with free vars list:
                            #
			    case (intersection_non_empty (subst, lk::free_named_variables_in_type_constructor type_constructor))   

				FALSE => type_constructor;               #  nothing to subst 

				TRUE => 
				    # Next check the memoization table:
				    #
				    case (tc_dictionary::get (*dictionary, type_constructor))

					THE t => t;			# Hit! 

					NULL =>                       # Must recompute.
					    t
					    where
						t = case (type_constructor_project type_constructor)   

							lk::TC_NAMED_VAR tv
							    => 
							    case (search_subst (tv, subst))    
								THE t => t; 
								NULL  => type_constructor;
							    esac;

							lk::TC_VAR  _ => type_constructor;
							lk::TC_PRIM _ => type_constructor;

							lk::TC_FN   (tks, t) =>  tcc_g (tks, loop t);
							lk::TC_APPLY (t, ts) =>  tcc_app (loop t, map loop ts);

							lk::TC_SEQ ts      =>  tcc_seq (map loop ts);
							lk::TC_PROJ (t, i) =>  tcc_proj (loop t, i);
							lk::TC_SUM ts      =>  tcc_sum (map loop ts);

							lk::TC_RECURSIVE ((i, t, ts), j)
							    =>
							    tcc_fix ((i, loop t, map loop ts), j);

							lk::TC_TUPLE (rf, ts)      =>  tcc_tuple (map loop ts);
							lk::TC_ARROW (ff, ts, ts') =>  tcc_arrow (ff, map loop ts, map loop ts');
							lk::TC_PARROW (t, t')      =>  tcc_parrow (loop t, loop t');

							lk::TC_BOXED        t  =>  tcc_box (loop t);
							lk::TC_ABSTRACT     t  =>  tcc_abs (loop t);
							lk::TC_FATE ts =>  tcc_cont (map loop ts);

							lk::TC_EXTENSIBLE_TOKEN (tok, t)
							     =>
							     type_constructor_inject (lk::TC_EXTENSIBLE_TOKEN (tok, loop t));

							lk::TC_INDIRECT _ => bug "unexpected TC_INDIRECT in substTypeConstructor";
							lk::TC_CLOSURE  _ => bug "unexpected TC_CLOSURE in substTypeConstructor";
						    esac;

						# Update memoization table:
						# 
						dictionary :=  tc_dictionary::set (*dictionary, type_constructor, t);
					    end;
				     esac;

			    esac;
		end;			# fun tc_nvar_subst 
	    end;			# fun tc_nvar_subst_fn 

	fun lt_nvar_subst_fn ()
            =
	    lt_nvar_subst
            where
		dictionary = REF (lt_dictionary::empty);

		tc_nvar_subst' = tc_nvar_subst_fn();

		fun lt_nvar_subst subst
                    =
		    loop
                    where

			tc_nvar_subst = tc_nvar_subst' subst;

			fun loop lambda_type
			    =
			    # First check if there are
			    # any free type variables:
			    #
			    case (intersection_non_empty (subst, lk::free_named_variables_in_lambda_type lambda_type))   

				FALSE => lambda_type;                  #  nothing to subst 

				TRUE => 
				    # Next, check the memoization table:
				    # 
				    case (lt_dictionary::get (*dictionary, lambda_type))

					THE t => t;		# A hit! 

					NULL =>		# Must recompute>
					    t
					    where
						t =
						  case (lambda_type_project lambda_type)   

						      lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t => ltc_tyc (tc_nvar_subst t);

						      lk::FNTYPE_PACKAGE ts            =>  ltc_str (map loop ts);
						      lk::FNTYPE_GENERIC (ts, ts')     =>  ltc_fct (map loop ts, map loop ts');

						      lk::FNTYPE_POLYMORPHIC (tks, ts) =>  ltc_poly (tks, map loop ts);
						      lk::FNTYPE_INTERNAL_CLOSURE ts   =>  ltc_cont (map loop ts);

						      lk::FNTYPE_INDIRECT_TYPETHUNK _  =>  bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in lt_nvar_elim";
						      lk::FNTYPE_TYPE_CLOSURE       _  =>  bug "unexpected FNTYPE_TYPE_CLOSURE in lt_nvar_elim";
						  esac;

						# Update memoization table:
						#
						dictionary :=  lt_dictionary::set (*dictionary, lambda_type, t);
					    end;
				     esac;

			    esac;
		    end;				# fun lt_nvar_subst 
	    end;					# fun lt_nvar_subst_fn 

	# **********************************************************

	# Building up a polymorphic type by abstracting over a 
	# list of named vars 

	Tvoffs = List ((Highcode_Variable, Int));

	fun intersect (NIL, _: List( Highcode_Variable ))
                =>
                NIL;

	    intersect(_, NIL)
                =>
                NIL;

	    intersect (s1 as (h1: Highcode_Variable, n) ! t1, s2 as h2 ! t2)
                =>
		case (int::compare (h1, h2))   
		    LESS    => intersect (t1, s2);
		    GREATER => intersect (s1, t2);
		    EQUAL   => (h1, n) ! intersect (t1, t2);
                esac;
        end;

	#  s_iter = compile_statistics::makeStat "Cvt Iterations"      
	#  s_hits = compile_statistics::makeStat "Cvt Hits in dictionary"    
	#  s_cuts = compile_statistics::makeStat "Cvt Freevar cutoffs" 

	#  s_tvoffs = compile_statistics::makeStat "Cvt tvoffs length" 
	#  s_nvars = compile_statistics::makeStat "Cvt free nvars length" 

	fun tc_nvar_cvt_fn ()
            =
	    tc_nvar_cvt
            where

                dictionary = REF (tc_dictionary::empty);

		fun tc_nvar_cvt (tvoffs: Tvoffs) d type_constructor
                    = 
		    #  Compile_statistics::addStat s_iter 1; 
		    #  Compile_statistics::addStat s_tvoffs (length tvoffs); 
		    #  Compile_statistics::addStat s_nvars (length (lk::freeNamedVariablesInTypeConstructor type_constructor)); 
		    #  Check if substitution overlaps with free vars list 
		    #	
		    case (intersect (tvoffs, lk::free_named_variables_in_type_constructor type_constructor))   

			[] => (#  Compile_statistics::addStat s_cuts 1; 
			       type_constructor           #  nothing to convert 
			       );

		        tvoffs
                            =>
                            {
			        # Encode the type_constructor
				# and the depth for memoization
				# using tcc_proj:
				#
				tycdepth = tcc_proj (type_constructor, d);

				case (tc_dictionary::get (*dictionary, tycdepth))

				    THE t => (#  Compile_statistics::addStat s_hits 1; 
					      t                 #  hit! 
					      );

				    NULL =>                  #  must recompute 
				       t
				       where	
					   r = tc_nvar_cvt tvoffs d; #  Default recursive invoc. 

					   rs = map r;          #  recursive invocation on list 

					   t = 
					       case (type_constructor_project type_constructor)

						   lk::TC_NAMED_VAR tvar
						       =>
						       case (search_subst (tvar, tvoffs))
							   THE i => tcc_var (d, i);
							   NULL  => type_constructor;
						       esac;

						   lk::TC_VAR _        => type_constructor;
						   lk::TC_PRIM _       => type_constructor;
						   lk::TC_FN (tks, t)  => tcc_g (tks, tc_nvar_cvt tvoffs (di::next d) t);

						   lk::TC_APPLY (t, ts) => tcc_app (r t, rs ts);
						   lk::TC_SEQ ts        => tcc_seq (rs ts);
						   lk::TC_PROJ (t, i)   => tcc_proj (r t, i);

						   lk::TC_SUM ts                    => tcc_sum (rs ts);
						   lk::TC_RECURSIVE ((i, t, ts), j) => tcc_fix ((i, r t, rs ts), j);
						   lk::TC_TUPLE (rf, ts)            => tcc_tuple (rs ts);

						   lk::TC_ARROW (ff, ts, ts')  => tcc_arrow (ff, rs ts, rs ts');
						   lk::TC_PARROW (t, t')       => tcc_parrow (r t, r t');
						   lk::TC_BOXED t              => tcc_box (r t);

						   lk::TC_ABSTRACT t                => tcc_abs (r t);
						   lk::TC_EXTENSIBLE_TOKEN (tok, t) => type_constructor_inject (lk::TC_EXTENSIBLE_TOKEN (tok, r t));
						   lk::TC_FATE ts           => tcc_cont (rs ts);

						   lk::TC_INDIRECT _ => bug "unexpected TC_INDIRECT in tc_nvar_cvt";
						   lk::TC_CLOSURE _  => bug "unexpected TC_CLOSURE in tc_nvar_cvt";
					       esac;

					   dictionary := tc_dictionary::set (*dictionary, tycdepth, t);
				       end;
				esac;
			    };
                    esac;			# fun tc_nvar_cvt 
	    end;				# fun tc_nvar_cvt_fn 


	fun lt_nvar_cvt_fn ()
            =
	    lt_nvar_cvt
            where

                dictionary = REF (lt_dictionary::empty);

		tc_nvar_cvt = tc_nvar_cvt_fn();

		fun lt_nvar_cvt tvoffs d lambda_type
                    = 
		    # Check if substitution overlaps
                    # with free vars list:
                    #
		    case (intersect (tvoffs, lk::free_named_variables_in_lambda_type lambda_type))   

			 [] => lambda_type;                #  nothing to convert 

		         tvoffs
                             => 
		             {
		                 # encode the lambdaType and depth info using FNTYPE_TYPE_CLOSURE
				 # (only first 2 args are useful)
				 ltydepth = lambda_type_inject (lk::FNTYPE_TYPE_CLOSURE (lambda_type, d, 0, lk::init_type_constructor_dictionary));

				 case (lt_dictionary::get (*dictionary, ltydepth))

				    THE t => t;                 #  hit! 

				    NULL =>                 #  must recompute 
					t
					where

					    r = lt_nvar_cvt tvoffs d;		# Default recursive invoc. 
					    rs = map r;			# Recursive invocation on list.

					    t =
						case (lambda_type_project lambda_type)   

						    lk::FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t
							=> 
							ltc_tyc (tc_nvar_cvt tvoffs d t);

						    lk::FNTYPE_PACKAGE ts        =>  ltc_str (rs ts);
						    lk::FNTYPE_GENERIC (ts, ts') =>  ltc_fct (rs ts, rs ts');

						    lk::FNTYPE_POLYMORPHIC (tks, ts)
							=> 
							ltc_poly (tks, 
								   map (lt_nvar_cvt tvoffs (di::next d)) ts);

						    lk::FNTYPE_INTERNAL_CLOSURE ts
							=> 
							ltc_cont (rs ts);

						    lk::FNTYPE_INDIRECT_TYPETHUNK _ => bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in lt_nvar_cvt";
						    lk::FNTYPE_TYPE_CLOSURE       _ => bug "unexpected FNTYPE_TYPE_CLOSURE in lt_nvar_cvt";
						esac;

					    dictionary := lt_dictionary::set (*dictionary, ltydepth, t);
					end;
                                 esac;
		             };
		    esac;		# fun lt_nvar_cvt 
	    end;			# fun lt_nvar_cvt_fn 

	# Make a type abstraction
        # from nvar to lambda type: 
	#
	fun lt_nvpoly (tvks, lt)
	    = 
	    {   fun frob ((tv, k) ! tvks, n, ks, tvoffs)
		        =>
                        frob (tvks, n+1, k ! ks, (tv, n) ! tvoffs);

		    frob ([], _, ks, tvoffs)
                        =>
                        (reverse ks, reverse tvoffs);
                end;

		my (ks, tvoffs) = frob (tvks, 0, [], []);

		fun cmp ((tvar1, _), (tvar2, _))
                    =
                    tvar1 > tvar2;

		tvoffs = list_mergesort::sort cmp tvoffs;

		#  temporarily gen() 
		lt_subst = lt_nvar_cvt_fn() tvoffs (di::next di::top);
	    
                ltc_poly (ks, map lt_subst lt);
	    };

    end;	#  top-level local 
};		#  package highcode 


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright (c) 1997 YALE FLINT PROJECT 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
