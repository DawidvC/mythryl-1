## mythryl-token-table-g.pkg

# Compiled by:
#     src/lib/compiler/front/parse/parser.make6



###                 "The range of our projectiles---even ... the artillery -- however great,
###                  will never exceed four of those miles of which as many thousand separate
###                  us from the center of the earth."
### 
###                                                   --- Galileo,
###                                                       Dialogues Concerning Two New Sciences



/***************************************************************************

  hash table for token recognition

 ***************************************************************************/


# Used in ROOT/src/lib/compiler/front/parse/lex/mythryl.lex

generic package mythryl_token_table_g (tokens: Mythryl_Tokens)		# Mythryl_Tokens	is from   src/lib/compiler/front/parse/yacc/mythryl.grammar.sig
: (weak)
api {
     check_id:                       ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int ); 
     check_passive_id:               ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int ); 
     check_symbol_id:                ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int );
     check_passive_symbol_id:        ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int );
     check_type_var:                 ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int );
     new_check_type_var:             ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int );
     check_implicit_thunk_parameter: ((String, Int)) -> tokens::Token( tokens::Semantic_Value, Int );
}

{
    exception NO_TOKEN;

    package table=   word_string_hash_table;	# word_string_hash_table	is from   src/lib/compiler/front/basics/miscutil/wordstr-hashtable.pkg

    hash_string =   hash_string::hash_string;

    fun make_table (size, l)
        =
        {   t =   table::make_table (size, NO_TOKEN);

	    fun ins (str, tokfn)
                =
		table::set t ((hash_string str, str), tokfn);

	    list::apply ins l;
	    t;
	};

    symbol_id_table
        =
        make_table (16, [
#	    ("-",	 fn yypos =  tokens::dash        (yypos, yypos+1)),
#	    ("/",	 fn yypos =  tokens::slash       (yypos, yypos+1)),
#	    ("*",	 fn yypos =  tokens::star        (yypos, yypos+1)),
#	    ("~",	 fn yypos =  tokens::tilda       (yypos, yypos+1)),
#	    ("|",	 fn yypos =  tokens::bar         (yypos, yypos+1)),
	    (":",	 fn yypos =  tokens::colon       (yypos, yypos+1)),
	    ("=",	 fn yypos =  tokens::equal_op    (yypos, yypos+1)),
	    ("#",	 fn yypos =  tokens::hash        (yypos, yypos+1)),
	    ("==",	 fn yypos =  tokens::eqeq_op     (yypos, yypos+2)),
	    ("&=",	 fn yypos =  tokens::amper_eq    (yypos, yypos+2)),
	    ("@=",	 fn yypos =  tokens::atsign_eq   (yypos, yypos+2)),
	    ("\\=",	 fn yypos =  tokens::back_eq     (yypos, yypos+2)),
#	    ("!=",	 fn yypos =  tokens::bang_eq     (yypos, yypos+2)),	# Don't do this!
	    ("$=",	 fn yypos =  tokens::buck_eq     (yypos, yypos+2)),
	    ("^=",	 fn yypos =  tokens::caret_eq    (yypos, yypos+2)),
	    ("-=",	 fn yypos =  tokens::dash_eq     (yypos, yypos+2)),
	    (".=",	 fn yypos =  tokens::dot_eq      (yypos, yypos+2)),
	    ("%=",	 fn yypos =  tokens::percnt_eq   (yypos, yypos+2)),
	    ("+=",	 fn yypos =  tokens::plus_eq     (yypos, yypos+2)),
	    ("?=",	 fn yypos =  tokens::qmark_eq    (yypos, yypos+2)),
	    ("/=",	 fn yypos =  tokens::slash_eq    (yypos, yypos+2)),
	    ("*=",	 fn yypos =  tokens::star_eq     (yypos, yypos+2)),
	    ("~=",	 fn yypos =  tokens::tilda_eq    (yypos, yypos+2)),
	    ("++=",	 fn yypos =  tokens::plusplus_eq (yypos, yypos+3)),
	    ("--=",	 fn yypos =  tokens::dashdash_eq (yypos, yypos+3)),
	    ("->",	 fn yypos =  tokens::arrow       (yypos, yypos+2)),
	    ("=>",	 fn yypos =  tokens::darrow      (yypos, yypos+2)),
	    ("~~",	 fn yypos =  tokens::tilda_tilda (yypos, yypos+2)),
	    ("::",	 fn yypos =  tokens::colon_colon (yypos, yypos+2)),
	    ("??",	 fn yypos =  tokens::what_what   (yypos, yypos+2)),
	    ("?:",	 fn yypos =  tokens::what_colon  (yypos, yypos+2)),	# XXX BUGGO FIXME should kill this
	    (":?",	 fn yypos =  tokens::colon_what  (yypos, yypos+2)),	# XXX BUGGO FIXME should kill this
	    ("++",	 fn yypos =  tokens::plus_plus   (yypos, yypos+2)),
	    ("--",	 fn yypos =  tokens::dash_dash   (yypos, yypos+2)),
	    ("||",	 fn yypos =  tokens::or_t        (yypos, yypos+2)),	# XXX BUGGO FIXME should kill this
	    ("&&",	 fn yypos =  tokens::and_t       (yypos, yypos+2))	# XXX BUGGO FIXME should kill this

	  ]);

    id_table
        =
        make_table (64, [
	    ("abstype",	    fn yypos =  tokens::abstype_t   (yypos, yypos+7)),
	    ("also",	    fn yypos =  tokens::also_t      (yypos, yypos+4)),
	    ("and",	    fn yypos =  tokens::and_t       (yypos, yypos+3)),
	    ("api",         fn yypos =  tokens::api_t       (yypos, yypos+3)),
	    ("as",	    fn yypos =  tokens::as_t        (yypos, yypos+2)),
	    ("case",	    fn yypos =  tokens::case_t      (yypos, yypos+4)),
	    ("class",	    fn yypos =  tokens::class_t     (yypos, yypos+5)),
	    ("class2",	    fn yypos =  tokens::class2_t    (yypos, yypos+6)),
	    ("elif",	    fn yypos =  tokens::elif_t      (yypos, yypos+4)),
	    ("else",	    fn yypos =  tokens::else_t      (yypos, yypos+4)),
	    ("end",	    fn yypos =  tokens::end_t       (yypos, yypos+3)),
	    ("eqtype",	    fn yypos =  tokens::eqtype_t    (yypos, yypos+6)),
	    ("esac",	    fn yypos =  tokens::esac_t      (yypos, yypos+4)),
	    ("except",	    fn yypos =  tokens::except_t    (yypos, yypos+6)),
	    ("exception",   fn yypos =  tokens::exception_t (yypos, yypos+9)),
	    ("fi",	    fn yypos =  tokens::fi_t        (yypos, yypos+2)),
	    ("field",       fn yypos =  tokens::field_t     (yypos, yypos+5)),	# Not a reserved word!
	    ("fn",	    fn yypos =  tokens::fn_t        (yypos, yypos+2)),
	    ("for",	    fn yypos =  tokens::for_t       (yypos, yypos+3)),
	    ("fprintf",     fn yypos =  tokens::fprintf_t   (yypos, yypos+7)),
	    ("fun",	    fn yypos =  tokens::fun_t       (yypos, yypos+3)),
	    ("generic",	    fn yypos =  tokens::generic_t   (yypos, yypos+7)),	# Not a reserved word!
	    ("herein",	    fn yypos =  tokens::herein_t    (yypos, yypos+6)),
	    ("if",	    fn yypos =  tokens::if_t        (yypos, yypos+2)),
	    ("in",	    fn yypos =  tokens::in_t        (yypos, yypos+2)),	# Not a reserved word!
	    ("include",	    fn yypos =  tokens::include_t   (yypos, yypos+7)),
	    ("infix",	    fn yypos =  tokens::infix_t     (yypos, yypos+5)),	# Not a reserved word!
	    ("infixr",	    fn yypos =  tokens::infixr_t    (yypos, yypos+6)),	# Not a reserved word!
	    ("lazy",	    fn yypos = *mythryl_parser::lazy_is_a_keyword ??  tokens::lazy_t (yypos, yypos+4) ::  (raise exception NO_TOKEN)),
	    ("message",     fn yypos =  tokens::message_t   (yypos, yypos+6)),	# Not a reserved word!
	    ("method",      fn yypos =  tokens::method_t    (yypos, yypos+6)),	# Not a reserved word!
	    ("my",	    fn yypos =  tokens::my_t        (yypos, yypos+2)),
	    ("nonfix",	    fn yypos =  tokens::nonfix_t    (yypos, yypos+6)),	# Not a reserved word!
	    ("or",	    fn yypos =  tokens::or_t        (yypos, yypos+2)),
	    ("overloaded",  fn yypos =  tokens::overloaded_t(yypos, yypos+10)),	# Not a reserved word!
	    ("package",     fn yypos =  tokens::package_t   (yypos, yypos+7)),
	    ("printf",      fn yypos =  tokens::printf_t    (yypos, yypos+6)),
	    ("raise",	    fn yypos =  tokens::raise_t     (yypos, yypos+5)),	# Not a reserved word!
	    ("recursive",   fn yypos =  tokens::recursive_t (yypos, yypos+9)),	# Not a reserved word!
	    ("sharing",	    fn yypos =  tokens::sharing_t   (yypos, yypos+7)),
	    ("sprintf",     fn yypos =  tokens::sprintf_t   (yypos, yypos+7)),
	    ("stipulate",   fn yypos =  tokens::stipulate_t (yypos, yypos+9)),
	    ("val",	    fn yypos =  tokens::my_t        (yypos, yypos+3)),
	    ("where",	    fn yypos =  tokens::where_t     (yypos, yypos+5)),
	    ("with",	    fn yypos =  tokens::with_t      (yypos, yypos+4)),
	    ("withtype",    fn yypos =  tokens::withtype_t  (yypos, yypos+8))
	  ]);

#    overload_hash   =   hash_string "overload";
#    lazy_hash       =   hash_string "lazy";

    # Look up an identifier.
    # If the symbol is found
    # the corresponding token is
    # generated, otherwise it is
    # a regular lowercase id:
    #
    fun check_id (str, yypos)
        =
        {   hash =   hash_string str;

            fun make_id ()
                =
                tokens::lowercase_id (fast_symbol::raw_symbol (hash, str), yypos, yypos+size (str));

	    table::get  id_table  (hash, str)  yypos
	    except
                NO_TOKEN
                =
                make_id ();
	};

    fun check_passive_id (string, yypos)
        =
        {
            len  = string::length string;
            string = string::extract( string, 1, THE (len - 2) );		# Drop leading and trailing parentheses from string.
            hash = hash_string string;

            fun make_id ()
                =
                tokens::passiveop_id (fast_symbol::raw_symbol (hash, string), yypos, yypos+(size string));

	    table::get  id_table  (hash, string)  yypos
	    except
                NO_TOKEN
                =
                make_id ();
	};

    # Look up an identifier with a leading '#' on its name.
    # We use these for implicit thunk parameters, so that we
    # can write
    #
    #     .{ #a < #b; }
    #
    # as an abbreviation for
    #
    #     fn (a, b) =  a < b;
    #
    fun check_implicit_thunk_parameter (str, yypos)
        =
        {   hash =   hash_string str;

            fun make_id ()
                =
                tokens::implicit_thunk_parameter (fast_symbol::raw_symbol (hash, str), yypos, yypos+size str);

#	    table::lookup_implicit_thunk_parameter_table (hash, str) yypos	# Eventually we'll want this for #if #else #elif #end 
#	    except
#                NO_TOKEN
#                =
                make_id ();
	};

    fun check_symbol_id (str, yypos)
        =
        {   hash =   hash_string str;

	    table::get  symbol_id_table  (hash, str)  yypos
	    except
                NO_TOKEN
		    =
		    tokens::operators_id (fast_symbol::raw_symbol (hash, str), yypos, yypos+size str);
	};

    fun check_passive_symbol_id (string, yypos)
        =
        {   len = string::length string;
            string = string::extract( string, 1, THE (len - 2) );		# Drop leading and trailing parentheses from string.
            hash =   hash_string string;
	    tokens::passiveop_id (fast_symbol::raw_symbol (hash, string), yypos+1, yypos+1+(size string));
	};

    fun check_type_var (str, yypos)
        =
        {   hash =   hash_string str;

	    tokens::tyvar (fast_symbol::raw_symbol (hash, str), yypos, yypos+size (str));
	};

    fun new_check_type_var (str, yypos)
        =
        {   string = /* "$" + */ str;
            hash   =   hash_string string;

	    tokens::tyvar (fast_symbol::raw_symbol (hash, string), yypos, yypos+size str);
	};

};


## COPYRIGHT (c) 1996 Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
