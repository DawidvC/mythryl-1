## triangle.pkg

# Compiled by:
#     src/lib/x-kit/tut/triangle/tri.make6

stipulate
    include threadkit;				# threadkit	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package xc  =  xcore;			# xdraw		is from   src/lib/x-kit/xclient/xcore.pkg
    package xd  =  xdraw;			# xdraw		is from   src/lib/x-kit/xclient/xdraw.pkg
    package xf  =  xfont;			# xfont		is from   src/lib/x-kit/xclient/xfont.pkg
    package xg  =  xgeometry;			# xgeometry	is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;			# xinput	is from   src/lib/x-kit/xclient/xinput.pkg
    package xs  =  xselection;			# xselection	is from   src/lib/x-kit/xclient/xselection.pkg
    package xw  =  xwindow;			# xwindow	is from   src/lib/x-kit/xclient/xwindow.pkg
    #
    package che =  cartouche;			# cartouche	is from   src/lib/x-kit/draw/cartouche.pkg
    #
    package ib  =  icon_bitmap;			# icon_bitmap	is from   src/lib/x-kit/tut/triangle/icon-bitmap.pkg
herein

    package triangle: Triangle {		# Triangle	is from   src/lib/x-kit/tut/triangle/triangle.api

	min_wide =  300;
	min_high =  300;

	min_sz   =  xg::SIZE { wide => min_wide, high => min_high };

	button_wide = 100;
	button_high =  30;

	button_corner_radius = 8;

	# Put button window at bottom of topwindow:
	# 
	fun button_window_site  (topwindow_size as { wide: Int, high: Int })
	    =
	    xg::WINDOW_SITE
	      {
		upperleft    =>  xg::POINT { col => (wide -  button_wide)/2,
				             row => (high - (button_high+10))
				           },
		size         =>  xg::SIZE  { wide => button_wide,
                                             high => button_high
                                           },
		border_width =>  0
	      };

	# Let drawing window fill the rest of topwindow:
	# 
	fun drawing_window_site (topwindow_size as { wide: Int, high: Int })
	    =
	    xg::WINDOW_SITE
	      {
		border_width =>  1,
		upperleft    =>  xg::POINT { col => 5, row => 5 },
		#
		size         =>  xg::SIZE { wide => wide - 10,
				            high => high - (button_high+25)
				          }
	      };

	fun make_topwindow  display_name
	    =
	    (screen, window, kidplug)
	    where
# XXX BUGGO FIXME need xauthentication here:
		xsession =  xc::open_xsession (display_name, NULL);

		screen   =  xc::default_screen_of  xsession;

		window_size   =  xg::SIZE { wide => 450, high => 400 };

		my (window, kidplug, mailslot)			# 2009-12-10 CrT: Had to add 'mailslot' so it would compile.
		    =
		    xw::make_simple_top_window  screen
		      {
			site =>  xg::WINDOW_SITE { upperleft => xg::POINT { col=>0, row=>0 }, size=>window_size, border_width=>1 },
			#
			border_color     =>  xc::black,
			background_color =>  xc::rgb8_white
		      };

		icon_ro_pixmap
		    =
		    xc::make_readonly_pixmap_from_clientside_pixmap
			screen
			icon_bitmap::icon_bitmap;


											# commandline		is from   src/lib/std/commandline.pkg
		xw::set_window_manager_properties  window
		  {
		    window_name => THE "Triangle",
		    icon_name   => THE "triangle",
		    #
		    size_hints =>
		      [
			xs::HINT_PPOSITION,
			xs::HINT_PSIZE,
			xs::HINT_PMIN_SIZE min_sz
		      ],
		    #
		    nonsize_hints  =>  [ xs::HINT_ICON_RO_PIXMAP icon_ro_pixmap ],
		    class_hints    =>  THE { resource_name=>"triangle", resource_class=>"Triangle" },
		    #
		    commandline_arguments =>  commandline::get_arguments ()
		  };

		xw::show_window  window;
	    end;

	fun make_drawing_and_button_windows  display_name
	    =
	    {   (make_topwindow  display_name)
		    ->
		    (screen, top_window, top_kidplug);
		    

		(xc::size_of_window  top_window)
		    ->
		    xg::SIZE topwindow_size;

		drawing_window
		    =
		    xw::make_simple_subwindow  top_window
		      {
			site => drawing_window_site  topwindow_size,
			#
			border_color     => THE  xc::black,
			background_color => THE  xc::rgb8_color0
		      };

		button_window
		    =
		    xw::make_simple_subwindow  top_window
		      {
			site =>  button_window_site  topwindow_size,
			#
			border_color     =>  NULL,
			background_color =>  THE  xc::rgb8_white
		      };

		xw::show_window  drawing_window;
		xw::show_window  button_window;

		{ top_window,
		  top_kidplug,
		  drawing_window,
		  button_window
		};
	    };


	fun make_button_threads (window, kidplug)
	    =
	    {   make_thread "tri" loop;
		take' reset_slot;
	    }
	    where

		my xi::KIDPLUG { from_mouse', from_other', ... }
		    =
		    xi::ignore_keyboard  kidplug;

		mouse_mailop
		    =
		    from_mouse' ==> xi::envelope_contents;

		cmd_mailop
		    =
		    from_other' ==> xi::envelope_contents;

		drawable =  xd::drawable_of_window  window;

		pen = xd::make_pen
			[
			  xd::FUNCTION xd::OP_COPY,
			  xd::FOREGROUND  xc::rgb8_black
			];

		draw_cartouche
		    =
		    che::draw_cartouche  drawable  pen;

		text = "RESET";

		font =  xf::open_font
			    #
			    (xw::xsession_of_window  window)
			    #
			    "9x15";

		text_pt
		    =
		    {   text_width = xf::text_width font text;

			my { ascent, descent }
			    =
			    xf::font_high  font;

			xg::POINT {
			    col => ( button_wide - text_width) / 2,
			    row => ((button_high - (ascent + descent)) / 2) + ascent
			  };
		    };

		draw_string
		    =
		    xd::draw_transparent_string drawable pen font;

		fun redraw ()
		    =
		    {   draw_cartouche
			  {
			    corner_radius =>  button_corner_radius,
			    #
			    box  =>  xg::BOX { col  => 0,
					       row  => 0,
					       #	
					       high => button_high - 1,
					       wide => button_wide - 1
					     }
			  };

			draw_string (text_pt, text);
		    };

		reset_slot = make_mailslot ();

		fun loop ()
		    =
		    {   fun mouse_fn (xi::MOUSE_FIRST_DOWN _)
				=>
				give (reset_slot, ());

			    mouse_fn _
				=>
				();
			end;


			fun cmd_fn (xi::ETC_REDRAW _) =>  redraw ();
			    cmd_fn xi::ETC_OWN_DEATH  =>  ();
			    cmd_fn _	        =>  ();
			end;


			for (;;) {
			    #
			    select [
				mouse_mailop ==> mouse_fn,
				cmd_mailop   ==> cmd_fn
			    ];
			};
		    };

	    end;				# fun make_button_threads 

	fun make_draw_threads (window, reset_mailop, kidplug)
	    =
	    {   make_thread "tri draw mouse"  mouse_thread;
		make_thread "tri draw"       .{ loop []; };
		();
	    }
	    where
		my xi::KIDPLUG { from_mouse', from_other', ... }
		    =
		    xi::ignore_keyboard  kidplug;

		mouse_mailop =    from_mouse' ==> xi::envelope_contents;
		cmd_mailop   =    from_other' ==> xi::envelope_contents;

		draw_slot = make_mailslot ();

		fun mouse_thread ()
		    =
		    for (;;) {
			#
			case (do_mailop  mouse_mailop)
			    #
			    xi::MOUSE_FIRST_DOWN { window_point, ... }
				=>
				give (draw_slot, window_point);

			    _   => ();
			esac;
		    };

		draw_mailop = take' draw_slot;

		drawable = xd::drawable_of_window  window;

		pen = xd::make_pen
			[
			  xd::FUNCTION    xd::OP_COPY,
			  xd::FOREGROUND  xc::rgb8_black
			];

		draw = xd::fill_polygon drawable pen;


		fun draw_triangle (xg::POINT { col, row } )
		    =
		    draw
		      {
			shape => xd::CONVEX_SHAPE,

			verts => [ xg::POINT { col => col,       row => row - 10 },
				   xg::POINT { col => col - 8,   row => row +  6 },
				   xg::POINT { col => col + 8,   row => row +  6 }
				 ]
		      };


		fun loop state
		    =
		    {   fun reset ()
			    =
			    {   xd::clear_drawable  drawable;
				loop [];
			    };


			fun handle_cmd (xi::ETC_REDRAW _)
				=>
				{   xd::clear_drawable  drawable;

				    apply draw_triangle state;

				    loop state;
				};

			    handle_cmd xi::ETC_OWN_DEATH
				=>
				();

			    handle_cmd _
				=>
				loop state;
			end;


			fun draw pt
			    =
			    {   draw_triangle pt;
				loop (pt ! state);
			    };

			select [
			    #
			    reset_mailop ==>  reset,
			    cmd_mailop   ==>  handle_cmd,
			    draw_mailop  ==>  draw
			];
		    };

	    end;					# fun make_draw_threads 

	fun make_toplevel_threads
            {
              top_window,
              top_kidplug  => xi::KIDPLUG { from_keyboard', from_mouse', from_other', ... },
              button_window,
              drawing_window
            }
	    =
	    {   make_thread "triangle router" router;

		{ button_kidplug,
		  draw_kidplug
		};
	    }
	    where
		(xi::make_widget_cable ()) ->   { kidplug => button_kidplug, momplug => button_momplug };
		(xi::make_widget_cable ()) ->   { kidplug =>   draw_kidplug, momplug =>   draw_momplug };
		(xi::make_widget_cable ()) ->   { kidplug,                   momplug                   };

		kidplug =  xi::ignore_all  kidplug;

		fun find_cable  envelope
		    =
		    case (xi::route_envelope  envelope)
			#
			xi::TO_SELF _				# Envelope has reached its destination window/widget.
			    =>
			    momplug;

			xi::TO_CHILD msg'			# Envelope needs to be passed on down the widget hierarchy.
			    =>
			    if   (xi::to_window (msg',   drawing_window))   draw_momplug;
			    elif (xi::to_window (msg', button_window))   button_momplug;
			    else                                         raise exception FAIL "find_cable";
			    fi;
		    esac;

		fun do_keyboard envelope
		    =
		    {   my xi::MOMPLUG { keyboard_sink, ... }
			    =
			    find_cable  envelope;

			do_mailop (keyboard_sink envelope);
		    };

		fun do_mouse envelope
		    =
		    {   my xi::MOMPLUG { mouse_sink, ... }
			    =
			    find_cable  envelope;

			do_mailop (mouse_sink  envelope);
		    };

		fun do_other envelope
		    =
		    {   my xi::MOMPLUG { other_sink, ... }
			    =
			    find_cable  envelope;

			do_mailop (other_sink  envelope);
		    };

		fun router ()
		    =
		    for (;;) {
			#
			select [ from_keyboard' ==> do_keyboard,
				 from_mouse'    ==> do_mouse,
				 from_other'    ==> do_other
			       ];
		    };

	    end;			# fun make_toplevel_threads

	fun run_triangle_app display
	    =
	    {   (make_drawing_and_button_windows  display)
		    ->
		    (x as { button_window, drawing_window, ... } );

		(make_toplevel_threads  x)
		    ->
		    { button_kidplug, draw_kidplug };
		    

		make_draw_threads
		  ( drawing_window,
		    make_button_threads (button_window, button_kidplug),
		    draw_kidplug
		  );
	    };

	fun do_it' (flgs, display_name)
	    =
	    {   xtracing::init flgs;

		start_up_thread_scheduler'
		    #
		    (time::from_milliseconds 20)
		    #
		   .{   xtracing::xspawn("triangle",  .{ run_triangle_app display_name; } );
			();
		    };
	    };

	fun do_it s
	    =
	    do_it' ([], s);

	fun main (program, server ! _) =>  do_it  server;
	    main _                     =>  do_it  "";
	end;
    };								# package  main 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1992 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
