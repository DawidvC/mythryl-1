## sim.pkg

# Compiled by:
#     src/lib/x-kit/tut/nbody/nbody-app.make6

stipulate
    include threadkit;					# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
herein

    package sim:  Sim {					# Sim			is from   src/lib/x-kit/tut/nbody/sim.api

	package v {

	    Vect = (Float, Float);

	    zero = (0.0, 0.0);

	    fun add ((x1, y1): Vect, (x2, y2)) =  (x1 + x2, y1 + y2);
	    fun sub ((x1, y1): Vect, (x2, y2)) =  (x1 - x2, y1 - y2);

	    fun neg ((x, y): Vect) = (-x, -y);

	    fun scmul (c, (x, y): Vect) =  (c * x, c * y);

	    fun sqnorm ((x, y): Vect) =  x * x + y * y;
	    fun proj2d ((x, y): Vect) = { x, y };
	};

	Vect = v::Vect;

	Body(X) = { p: Vect,
		    v: Vect,
		    m: Float,
		    data: X
		  };

	Plea_Mail(X)
	  = NEW_SIMSECS_PER_SIMSTEP Float
	  | NEW_N    Int
	  | NEW_BODY Body(X)
	  | QUERY    Mailslot( List( Body(X) ))
	  | STOP
	  ;

	fun run { g, bodies, simsecs_per_simstep, plea_slot, n }
	    =
	    {   fun accels []
			=>
			[];

		    accels [_]
			=>
			[v::zero];

		    accels ( { p => ph,		# position
                               v => vh,		# vector
                               m => mh,		# mass
                               data
                             } ! tl
                           )
			=>
			{
			      fun addh (b, ab, (ah, atl))
				  =
				  {
				      b ->  { p => pb, v => vb, m => mb, data };

				      distv = v::sub (pb, ph);
				      dist2 = v::sqnorm distv;

				      dist = math::sqrt dist2;

				      geometry = g // (dist2 * dist);

				      ah = v::add (ah, v::scmul (geometry * mb, distv));
				      ab = v::sub (ab, v::scmul (geometry * mh, distv));

				      (ah, ab ! atl);
				  };

			      my (ah, atl)
				  =
				  paired_lists::fold_right
				      addh
				      (v::zero, [])
				      (tl, accels tl);

			      ah ! atl;
			};
		end;


		fun step (bodies, simsecs_per_simstep)		# "bl" == "body_list", "dt" == "delta_time" (time step in seconds)
		    =
		    paired_lists::map
			one_body
			(bodies, accels bodies)
		    where 
			fun one_body ( { p, v, m, data }, a)
			    =
			    { p =>  v::add (p, v::scmul (simsecs_per_simstep, v)),
			      v =>  v::add (v, v::scmul (simsecs_per_simstep, a)),
			      m,
			      data
			    };
		    end;


		fun steps n (bodies, simsecs_per_simstep)
		    =
		    loop (n, bodies)
		    where
			fun loop (0, bodies) =>  bodies;
			    loop (n, bodies) =>  loop (n - 1, step (bodies, simsecs_per_simstep));
			end;
		    end;


		always' =  always_mailop ();
#		timeout' =  timeout_in' (time::from_milliseconds 25);
#         time::(-) (time::of_day(), t);

		fun loop (bodies, simsecs_per_simstep, n)
		    =
		    select [  take' plea_slot ==>  do_plea (bodies, simsecs_per_simstep, n),
			      always'         ==>  .{  loop (steps n (bodies, simsecs_per_simstep), simsecs_per_simstep, n);  }
		           ]

		also
		fun do_plea (bodies, simsecs_per_simstep, n) m
		    =
		    case m
			#
			NEW_SIMSECS_PER_SIMSTEP simsecs_per_simstep  => loop (bodies, simsecs_per_simstep, n);
			NEW_N n    => loop (bodies, simsecs_per_simstep, n);
			NEW_BODY b => loop (b ! bodies, simsecs_per_simstep, n);
			QUERY c    => {   give (c, bodies);   loop (bodies, simsecs_per_simstep, n);  };
			STOP       => ();
		    esac;


		make_thread  "sim"  .{
		    #
		    loop (bodies, simsecs_per_simstep, n);
		};
	    };
    };
end;