## highcode-guts.pkg 
#
# Here we implement a high-level lambda-based intermediate
# code format which is hash-consed to merge common sub-expressions.
#
# For comments and external interface see:
#
#     src/lib/compiler/upper/highcode/highcode.api
#     src/lib/compiler/upper/highcode/highcode-type.api

# Compiled by:
#     src/lib/compiler/core.make6

###             "It's OK to figure out murder mysteries,
###              but you shouldn't need to figure out code.
###              You should be able to read it."
###
###                             -- Steve McConnell


package highcode_guts: Highcode_Guts {		# Highcode_Guts	is from   src/lib/compiler/upper/highcode/highcode-guts.api

    fun bug s = error_message::impossible ("highcode_guts:" + s);

    # *************************************************************************
    #                UTILITY FUNCTIONS FOR HASHCONSING BASICS                 *
    # *************************************************************************

    #  Hashconsing implementation basics 
    #
    stipulate #  use sorted_list 

	mval = 10000;
	bval = mval * 2;	#  All index i start from 0 

    herein 

	Enc_Tvar = Int;

	fun tv_encode (d, i) =  d * mval + i;
	fun tv_decode x      =  ((x / mval), (x % mval));

	fun exit_level xs
            = 
            h (xs, [])
            where
	        fun h ([],    x) =>  reverse x;
		    h (a ! r, x) =>  if (a < bval)   h (r, x);
                                     else            h (r, (a-mval) ! x);
                                     fi;
                end;
	    end;

	# Definitions of named type_constructor variables.
	# For now these share the highcode_var space:
	#
	Highcode_Variable        = highcode_var::Highcode_Variable;
	make_type_variable = highcode_var::make_highcode_variable;

	# For lists of free type variables, debruijn indices are collapsed
	# into a single integer using tv_encode/tv_decode, named variables use
	# the tvar as an integer.  The debruijn-indexed list is kept sorted,
	# the named variables are in arbitrary order (for now) --league, 2 July 1998

	Aux_Info
	    = AUX_INFO_REG  (Bool,			# Normalization flag.
		     List( Enc_Tvar ),			# Free debruijn-indexed type vars.
		     List( Highcode_Variable ))		# Free named type vars.
	    | AUX_INFO_UNAVAILABLE			# No aux_info available.
	    ;

	# These two are originally from sorted_list -- which I wanted to get
	# rid of.  -- Matthias  11/2000
	#
	fun merge_tvs (l:  List( Highcode_Variable ), [])
                =>
                l;

	    merge_tvs ([], l)
                =>
                l;

	    merge_tvs (l as (h ! t), l' as (h' ! t'))
		=>
		if   (h <  h')   h  ! merge_tvs (t, l');
		elif (h == h')   h  ! merge_tvs (t, t');
		else             h' ! merge_tvs (l, t');
                fi;
        end;

	fun fmerge_tvs []
                =>
                [];

	    fmerge_tvs (h ! t)
		=>
	        loop (t, h)
		where
		    fun loop ([],    a) =>  a;
		        loop (h ! t, a) =>  loop (t, merge_tvs (h, a));
                    end;
		end;
        end;


#	merge_tvs = sorted_list::merge
#	fmerge_tvs = sorted_list::foldmerge


	Hash_Cell( X )  =  Ref ((Int, X, Aux_Info)); 

    end;                #  local: hashconsing implementation basics 

    # **************************************************************************
    #                 DATATYPE DEFINITIONS                                     *
    # **************************************************************************

    # Definition of kinds for all the lambda tycs:
    #
    Highcode_Kind_I
      = TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR						#  Ground mono  type_constructor 
      | TYPEKIND_BOXED_TYPE_CONSTRUCTOR							#  Boxed/tagged type_constructor 
      | TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE  List( Highcode_Kind )			#  Sequence of tycons 
      | TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION  (List( Highcode_Kind ), Highcode_Kind)	#  Tycon function     

    withtype
    Highcode_Kind = Hash_Cell( Highcode_Kind_I );             #  hash-consing-impl of Highcode_Kind 

    # A special extensible token key:
    #
    Token = Int;      

    Fn_Flag									# Calling conventions 
      = FNFLAG_VARIABLE  (Bool, Bool)						# is it fixed ? 
      | FNFLAG_FIXED;								# used after rep. analysis 

    Record_Flag = RECORDFLAG_TMP;						# tuple kind: a template 

    #  Definitions of type constructors:
    #
    Highcode_Type_I
      = TC_VAR  (debruijn_index::Index, Int)					# type_constructor variables 
      | TC_NAMED_VAR  Highcode_Variable						# named type_constructor variables 
      | TC_PRIM  highcode_data_representation::Primitive_Type_Constructor		# primitive type_constructor 

      | TC_FN  (List( Highcode_Kind ), Highcode_Type_Constructor)				# Type abstraction 
      | TC_APPLY  (Highcode_Type_Constructor, List( Highcode_Type_Constructor ))			# Type application 
      | TC_SEQ  List( Highcode_Type_Constructor )						# Type sequence 
      | TC_PROJ  (Highcode_Type_Constructor, Int)						# Type projection 

      | TC_SUM  List( Highcode_Type_Constructor )						# sum Type 
      | TC_RECURSIVE  (((Int, Highcode_Type_Constructor, List( Highcode_Type_Constructor )) ), Int)	# recursive Type 

      | TC_TUPLE  (Record_Flag, List( Highcode_Type_Constructor ))				# std record Type 
      | TC_ARROW  (Fn_Flag, List( Highcode_Type_Constructor ), List( Highcode_Type_Constructor ))	# std function Type 
      | TC_PARROW  (Highcode_Type_Constructor, Highcode_Type_Constructor)				# special fun Type, not used 

      | TC_BOXED  Highcode_Type_Constructor							# Boxed Type 
      | TC_ABSTRACT  Highcode_Type_Constructor						# Abstract Type, not used 
      | TC_EXTENSIBLE_TOKEN  (Token, Highcode_Type_Constructor)				# extensible token Type 
      | TC_FATE  List( Highcode_Type_Constructor )					# intern fate Type 
      | TC_INDIRECT  (Highcode_Type_Constructor, Highcode_Type_I)				# indirect Type thunk 
      | TC_CLOSURE  (Highcode_Type_Constructor, Int, Int, Type_Constructor_Dictionary)	# Type closure 

    withtype
    Highcode_Type_Constructor = Hash_Cell( Highcode_Type_I )

    also
    Type_Constructor_Dictionary = Highcode_Type_Constructor; 				# This is really List( (Null_Or(List(Highcode_Type_Constructor)), Int) ),
			      							# it is encoded using SEQ[(PROJ (SEQ tcs), i)]
			      							# and SEQ[(PROJ (VOID, i))]. (ZHONG)


    # Definitions of types:
    #
    Highcode_Fn_I          
      = FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR  Highcode_Type_Constructor			# monomorphic type 
      | FNTYPE_PACKAGE       List( Highcode_Type )				# package record type 
      | FNTYPE_GENERIC      (List( Highcode_Type ), List( Highcode_Type ))		# generic arrow type 
      | FNTYPE_POLYMORPHIC  (List( Highcode_Kind   ), List( Highcode_Type ))	# polymorphic type 

      | FNTYPE_INTERNAL_CLOSURE    List( Highcode_Type )				# Internal fate type 
      | FNTYPE_INDIRECT_TYPETHUNK  (Highcode_Type, Highcode_Fn_I)			# A Highcode_Type thunk and its sig 
      | FNTYPE_TYPE_CLOSURE
            (Highcode_Type, Int, Int, Type_Constructor_Dictionary)             	# Highcode_Type closure 

    withtype
    Highcode_Type = Hash_Cell( Highcode_Fn_I );					# Hash-consed Highcode_Type cell 



    # *************************************************************************
    #                   TOKEN TYC UTILITY FUNCTIONS                           *
    # *************************************************************************

    Token_Info
        =
        { name:                      String, 
	  abbrev:                    String,
	  reduce_one:               (Token, Highcode_Type_Constructor) -> Highcode_Type_Constructor,
	  is_weak_head_normal_form:  Highcode_Type_Constructor -> Bool,
	  is_known:                 (Token, Highcode_Type_Constructor) -> Bool
	};


    stipulate

          token_key = REF 0;		# XXX BUGGO FIXME more icky global variables

	  token_table_size = 10;

	  default_token_info
              =
              { name                     => "TC_GARBAGE", 
		abbrev                   => "GB",
		reduce_one               => (fn _ = bug "token not implemented"),
		is_weak_head_normal_form => (fn _ = bug "token not implemented"),
		is_known                 => (fn _ = bug "token not implemented")
              };

	  my token_array:   rw_vector::Rw_Vector( Token_Info )
              =
	      rw_vector::make_rw_vector (token_table_size, default_token_info);

	  token_validity_table
              =
              rw_vector::make_rw_vector (token_table_size, FALSE);


	  fun get_next_token ()
              = 
	      {   n = *token_key;
	      
                  if  (n > token_table_size)
                       bug "running out of tokens";
		  else
                       token_key := n+1;
                       n;
                  fi;
	      };


	  fun store_token_info (x, k)
              =
              rw_vector::set (token_array, k, x);


	  fun get_is_whnm k
              =
              .is_weak_head_normal_form (rw_vector::get (token_array, k));


	  fun get_reduce_one (z as (k, t))
              = 
	     (.reduce_one (rw_vector::get (token_array, k))) z;


	  fun get_name k
              =
              .name (rw_vector::get (token_array, k));


	  fun get_abbrev k
              =
              .abbrev (rw_vector::get (token_array, k));


	  fun get_is_known (z as (k, t))
              = 
	      (.is_known (rw_vector::get (token_array, k))) z;


	  fun is_valid k
              =
              rw_vector::get (token_validity_table, k);


	  fun set_valid k
              =
              rw_vector::set (token_validity_table, k, TRUE);
    herein 

	my register_token: Token_Info -> Token
	    = 
	    fn x = {   k = get_next_token ();
		       store_token_info (x, k);
		       set_valid k;
		       k;
		   };

	my token_name:           Token -> String				= get_name; 
	my token_abbreviation:   Token -> String				= get_abbrev;
	#
	my token_whnm:           Token -> Highcode_Type_Constructor -> Bool 		=  get_is_whnm; 
	my token_reduce:        (Token, Highcode_Type_Constructor) -> Highcode_Type_Constructor		=  get_reduce_one;
	my token_is_known:      (Token, Highcode_Type_Constructor) -> Bool			=  get_is_known;
	#
	my token_is_valid:       Token -> Bool					=  is_valid;
	my tokens_are_equal:    (Token, Token) -> Bool				=  fn (x, y) = (x==y);
	#
	my token_int:            Token -> Int					=  fn x = x;
	my token_key:            Int -> Token					=  fn x = x;

    end;				#  end of all token-related hacks 

    # **************************************************************************
    #                    HASHCONSING IMPLEMENTATIONS                           *
    # **************************************************************************

    # Hash-consing implementations of Highcode_Type_Constructor, Highcode_Kind, Highcode_Type 

    stipulate

        package weak_reference = weak_reference;	# weak_reference		is from   src/lib/std/src/nj/weak-reference.pkg
	package pt= highcode_data_representation;		# highcode_data_representation	is from   src/lib/compiler/upper/highcode/highcode-data-representation.pkg
	package di= debruijn_index;			# debruijn_index		is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg

	fun bug msg
            =
            error_message::impossible("highcode_guts: " + msg);

	itow = unt::from_int;
	wtoi = unt::to_int_x;
	bitwise_and = unt::bitwise_and;

	nnn = 2048; #  1024 
	nnnnnn = itow (nnn*nnn);
	ppp = 0u509; #  was 0u1019, a prime < 1024 so that nnn*nnn*ppp < maxint 

	my tk_table:  rw_vector::Rw_Vector( List( weak_reference::Weak( Highcode_Kind   	 ) ) ) =  rw_vector::make_rw_vector (nnn, NIL);
	my tc_table:  rw_vector::Rw_Vector( List( weak_reference::Weak( Highcode_Type_Constructor) ) ) =  rw_vector::make_rw_vector (nnn, NIL);
	my lt_table:  rw_vector::Rw_Vector( List( weak_reference::Weak( Highcode_Type            ) ) ) =  rw_vector::make_rw_vector (nnn, NIL);

	fun vector2list v
            =
            vector::fold_right (!) [] v;

	fun revcat (a ! rest, b) =>  revcat (rest, a ! b);
	    revcat (NIL,      b) =>  b;
        end;


	fun combine [x]
                =>
                itow x;

	    combine (a ! rest)
                => 
	        bitwise_and (itow a + (combine rest)*ppp, nnnnnn - 0u1);

	    combine _
                =>
                bug "unexpected case in combine";
        end;


	# Given a value of type Highcode_Kind_I,
        # Highcode_Type_I or Highcode_Fn_I
        # and the matching hashtable &tc for that
        # type, find or create the corresponding
        # hash-consed value.
        #
	# NB: Because of the "cmp" function below,
        # it is necessary to keep each bucket-list
        # in a consistent order, and not reverse
	# or move-to-front or whatever. 
	#
	fun get
            ( table,		# The appropriate hashtable -- one of tk_table/tc_table/lt_table.
              h,		# The hash of the value in question.
              t,		# The value in question.
              eq,		# Equality comparison for the type in question -- one of tk_i_eq/tc_i_eq/lt_i_eq.
              mk		# Function to create a hashconsed value of type in question -- one of tk_mk/tc_mk/lt_mk.
            )
            =
	    g ([], rw_vector::get (table, i))
            where
		# Mask value hash down to size
                # of our hashtable:
		#
	        i = wtoi (bitwise_and (itow h, itow (nnn - 1)));

								# weak_reference	is from   src/lib/std/src/nj/weak-reference.pkg
		# Search our hash table bucket-chain
                # for the given value:
		#
		fun g (l, z as (w ! rest))
			=> 
			case (weak_reference::strong w)
			  
			     THE (r as REF (h', t', _))
				 =>
				 if   (h==h'  and  eq { new=>t, old=>t'})
				     
				      rw_vector::set (table, i, revcat (l, z));
				      r;
				 else
				      g (w ! l, rest);
				 fi;

			     NULL => g (l, rest);
			 esac;

		    g (l, [])
                        => 
		        {   r = mk (h, t);
			    rw_vector::set (table, i, (weak_reference::weak r) ! reverse l);
                            r;
		        };
                end;
	    end;

	fun cmp (table, a as REF (ai, _, _), b as REF (bi, _, _))
	    =
	    if   (ai < bi) LESS; 
	    elif (ai > bi) GREATER;
	    elif (a == b ) EQUAL;
	    else
		 index = wtoi (bitwise_and (itow ai, itow (nnn - 1)));

		 fun g []
			 =>
			 bug "unexpected case in cmp";

		     g (w ! rest)
			 =>
			 case (weak_reference::strong w)

			      THE r
				  => 
				  if        (a == r   ) LESS; 
				  else if   (b == r   ) GREATER;
				       else g rest;  fi;
				  fi;

			     NULL => g rest;
			 esac;
		 end;

		 g (rw_vector::get (table, index));
            fi;


	fun getnum (REF (i, _, _))
            =
            i;


	fun tagnums NIL
                =>
                NIL;

	    tagnums ((i, t) ! rest)
                =>
                i ! getnum t ! tagnums rest;
        end;


	fun tk_hash tk
            =
	    g tk
            where
	        fun g (TYPEKIND_MONOMORPHIC_TYPE_CONSTRUCTOR)      =>  0u1;
		    g (TYPEKIND_BOXED_TYPE_CONSTRUCTOR)            =>  0u2;
		    g (TYPEKIND_TYPE_CONSTRUCTOR_SEQUENCE  ks    ) =>  combine (3 ! map getnum ks);
		    g (TYPEKIND_TYPE_CONSTRUCTOR_FUNCTION (ks, k)) =>  combine (4 ! getnum k ! (map getnum ks));
                end;
	    end;

	fun tc_hash tc
	    = 
	    g tc
            where
	        fun g (TC_VAR (d, i))    => combine [1, (di::di_key d)*10, i];
		    g (TC_NAMED_VAR v)   => combine [15, v];
		    g (TC_PRIM pt)       => combine [2, pt::prim_type_con_to_int pt];

		    g (TC_FN (ks, t))    => combine (3 ! (getnum t) ! (map getnum ks));
		    g (TC_APPLY (t, ts)) => combine (4 ! (getnum t) ! (map getnum ts));
		    g (TC_SEQ ts)        => combine (5 ! (map getnum ts));

		    g (TC_PROJ (t, i))   => combine [6, (getnum t), i];
		    g (TC_SUM ts)        => combine (7 ! (map getnum ts));

		    g (TC_ABSTRACT t)    => combine [9, getnum t];
		    g (TC_BOXED t)       => combine [10, getnum t];
		    g (TC_TUPLE (_, ts)) => combine (11 ! (map getnum ts));

		    g (TC_PARROW (t1, t2))          => combine [13, getnum t1, getnum t2];
		    g (TC_EXTENSIBLE_TOKEN (i, tc)) => combine [14, i, getnum tc];
		    g (TC_FATE ts)          => combine (15 ! (map getnum ts));

		    g (TC_RECURSIVE((n, t, ts), i))
                        => 
			combine (8 ! n ! i ! (getnum t) ! (map getnum ts));

		    g (TC_ARROW (rw, ts1, ts2))
                        => 
			combine (12 ! (h rw) ! (map getnum (ts1@ts2)))
                        where
			    fun h (FNFLAG_FIXED) => 10;
				h (FNFLAG_VARIABLE (TRUE, b2)) => if b2  20; else 30;fi;
				h (FNFLAG_VARIABLE (FALSE, b2)) => if b2  40; else 50;fi;
                            end;
			end;

		    g (TC_CLOSURE (t, i, j, dictionary))
                        => 
			combine [16, getnum t, i, j, getnum dictionary];

		    g (TC_INDIRECT _)
                        =>
                        bug "unexpected TC_INDIRECT in tc_hash";
                end;
	    end; 


	fun lt_hash lt
            = 
	    g lt
            where
	        fun g (FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t    ) => combine [1, getnum t];
		    g (FNTYPE_PACKAGE ts                        ) => combine (2 ! (map getnum ts));
		    g (FNTYPE_GENERIC (ts1, ts2)                ) => combine (3 ! (map getnum (ts1@ts2)));
		    g (FNTYPE_POLYMORPHIC (ks, ts)              ) => combine (4 ! ((map getnum ts)@(map getnum ks)));
		    g (FNTYPE_INTERNAL_CLOSURE ts               ) => combine (5 ! (map getnum ts));
		    g (FNTYPE_TYPE_CLOSURE (t, i, j, dictionary)) => combine [6, getnum t, i, j, getnum dictionary];
		    g (FNTYPE_INDIRECT_TYPETHUNK _) => bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in tc_hash";
                end;
	    end;


	fun tk_i_eq { new: Highcode_Kind_I, old }
            =
            new == old;

	# The 1st is one being mapped;
        # the 2nd is in the hash table 
	#
	fun tc_i_eq { new:  Highcode_Type_I, old=>TC_INDIRECT(_, s) }
		=>
		tc_i_eq { new, old=>s };

	    tc_i_eq { new, old }
		=>
		new == old;
        end;


	fun lt_i_eq { new:  Highcode_Fn_I, old=>FNTYPE_INDIRECT_TYPETHUNK(_, s) }
                =>
                lt_i_eq { new, old=>s };

	    lt_i_eq { new, old }
		=>
		new == old;
        end;


	base_aux =  AUX_INFO_REG (TRUE, [], []);


	fun get_aux (REF (i:  Int, _, x))
            =
            x;


	fun merge_aux (AUX_INFO_UNAVAILABLE, _) =>  AUX_INFO_UNAVAILABLE;
	    merge_aux (_, AUX_INFO_UNAVAILABLE) =>  AUX_INFO_UNAVAILABLE;

	    merge_aux (AUX_INFO_REG (b1, vs1, nvs1), AUX_INFO_REG (b2, vs2, nvs2))
                =>
	        AUX_INFO_REG (b2 and b1, merge_tvs (vs1, vs2),
		     merge_tvs (nvs1, nvs2));
        end;


	fun fsmerge [] => base_aux;
	    fsmerge [x] => get_aux x;

	    fsmerge xs
                => 
		loop (xs, base_aux)
                where
		    fun loop ([], z) => z;
		        loop(_, AUX_INFO_UNAVAILABLE) => AUX_INFO_UNAVAILABLE;
		        loop (a ! r, z) => loop (r, merge_aux (get_aux a, z));
                    end;
		end;
        end;


	fun exit_aux (AUX_INFO_REG (b, vs, nvs))
                =>
                AUX_INFO_REG (b, exit_level vs, nvs);

	    exit_aux x
                => x;
        end;


	fun tc_aux tc
	    = 
	    g tc
            where
	        fun g (TC_VAR (d, i)) => AUX_INFO_REG (TRUE, [tv_encode (d, i)], []);
		    g (TC_NAMED_VAR v) => AUX_INFO_REG (TRUE, [], [v]);
		    g (TC_PRIM pt) => base_aux;
		    g (TC_APPLY (REF(_, TC_FN _, AUX_INFO_UNAVAILABLE), _)) => AUX_INFO_UNAVAILABLE;
		    g (TC_PROJ (REF(_, TC_SEQ _, AUX_INFO_UNAVAILABLE), _)) => AUX_INFO_UNAVAILABLE;

		    g (TC_APPLY (REF(_, TC_FN _, AUX_INFO_REG(_, vs, nvs)), ts))
                        => 
			merge_aux (AUX_INFO_REG (FALSE, vs, nvs), fsmerge ts); #  ? 

		    g (TC_PROJ (REF(_, TC_SEQ _, AUX_INFO_REG(_, vs, nvs)), _))
                        => 
			AUX_INFO_REG (FALSE, vs, nvs); #  ? 

		    g (TC_FN (ks, t)) => exit_aux (get_aux t);
		    g (TC_APPLY (t, ts)) => fsmerge (t ! ts);
		    g (TC_SEQ ts) => fsmerge ts;
		    g (TC_PROJ (t, _)) => get_aux t;
		    g (TC_SUM ts) => fsmerge ts;

		    g (TC_RECURSIVE((_, t, ts), _))
                        => 
			{   ax = get_aux t;

			    case ax
			        AUX_INFO_REG(_,[],[]) => merge_aux (ax, fsmerge ts);
				AUX_INFO_REG _ => bug "unexpected TC_RECURSIVE freevars in tc_aux";
				AUX_INFO_UNAVAILABLE => AUX_INFO_UNAVAILABLE;
                            esac;
			};

		    g (TC_ABSTRACT t) => get_aux t;
		    g (TC_BOXED t) => get_aux t;
		    g (TC_TUPLE (_, ts)) => fsmerge ts;
		    g (TC_ARROW(_, ts1, ts2)) => fsmerge (ts1@ts2);
		    g (TC_PARROW (t1, t2)) => fsmerge [t1, t2];
		    g (TC_EXTENSIBLE_TOKEN (k, (REF(_, t, AUX_INFO_UNAVAILABLE)))) => AUX_INFO_UNAVAILABLE;

		    g (TC_EXTENSIBLE_TOKEN (k, (x as REF(_, t, AUX_INFO_REG (b, vs, nvs)))))
                        => 
			AUX_INFO_REG((token_whnm k x) and b, vs, nvs);

		    g (TC_FATE ts) => fsmerge ts;
		    g (TC_INDIRECT _) => bug "unexpected TC_INDIRECT in tc_aux";
		    g (TC_CLOSURE _) => AUX_INFO_UNAVAILABLE;
                end;
	    end; 


	fun lt_aux lt
	    = 
	    g lt
            where
	        fun g (FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR t) => get_aux t;
		    g (FNTYPE_PACKAGE ts) => fsmerge ts;
		    g (FNTYPE_GENERIC (ts1, ts2)) => fsmerge (ts1@ts2);
		    g (FNTYPE_POLYMORPHIC (ks, ts)) => exit_aux (fsmerge ts);
		    g (FNTYPE_INTERNAL_CLOSURE ts) => fsmerge ts;
		    g (FNTYPE_INDIRECT_TYPETHUNK _) => bug "unexpected FNTYPE_INDIRECT_TYPETHUNK in lt_aux";
		    g (FNTYPE_TYPE_CLOSURE _) => AUX_INFO_UNAVAILABLE;
                end;
	    end;

	fun tk_mk (i:  Int, k:   Highcode_Kind_I) =  REF (i, k, AUX_INFO_UNAVAILABLE);
	fun tc_mk (i:  Int, tc:  Highcode_Type_I) =  REF (i, tc, tc_aux tc);
	fun lt_mk (i:  Int, lt:  Highcode_Fn_I  ) =  REF (i, lt, lt_aux lt);

    herein 

	# A temporary hack on getting the list of free type_variables 
	# ignores named vars for now.  --CALeague, 1 Jul 1998 
	#
	fun tc_vs (r as REF(_ : Int, _ : Highcode_Type_I, AUX_INFO_UNAVAILABLE)) => NULL;
	    tc_vs (r as REF(_ : Int, _ : Highcode_Type_I, AUX_INFO_REG (_, x, _))) => THE x;
	end;

	fun lt_vs (r as REF(_ : Int, _ : Highcode_Fn_I, AUX_INFO_UNAVAILABLE)) => NULL;
	    lt_vs (r as REF(_ : Int, _ : Highcode_Fn_I, AUX_INFO_REG (_, x, _))) => THE x;
	end;

	# Converting from the hash-consing reps to the standard reps:
	#
	fun tk_out_x (r as REF(_ : Int, t:  Highcode_Kind_I,   _ : Aux_Info)) = t;
	fun tc_out_x (r as REF(_ : Int, t:  Highcode_Type_I,   _ : Aux_Info)) = t;
	fun lt_out_x (r as REF(_ : Int, t:  Highcode_Fn_I,     _ : Aux_Info)) = t;


	# Converting from the standard reps to the hash-consing reps:
	#
	fun tk_inj_x t = get (tk_table, wtoi (tk_hash t), t, tk_i_eq, tk_mk);
	fun tc_inj_x t = get (tc_table, wtoi (tc_hash t), t, tc_i_eq, tc_mk);
	fun lt_inj_x t = get (lt_table, wtoi (lt_hash t), t, lt_i_eq, lt_mk);


	# Key-comparison on Highcode_Kind, Highcode_Type_Constructor, Highcode_Type:
	#
	fun compare_type_kinds        (k1, k2) =  cmp (tk_table, k1, k2);
	fun compare_type_constructors (t1, t2) =  cmp (tc_table, t1, t2);
	fun compare_lambda_types      (t1, t2) =  cmp (lt_table, t1, t2);


	# Get the hash key of each Highcode_Type.
	# Only used by reps/coerce.pkg; a hack:
	# 
	fun hash_lambda_type (REF (h:  Int, _ : Highcode_Fn_I, _ : Aux_Info))
	    =
	    h;

	# **************************************************************************
	#            UTILITY FUNCTIONS ON TKIND DICTIONARY                         *
	# **************************************************************************

	# Highcode_Kind dictionary: maps each Highcode_Variable,
	# i.e., its debindex, to its kind
	#
	Highcode_Kind_Dictionary
            =
            List( List( Highcode_Kind ) );

	# Utility functions for manipulating the type_kind_dictionary
	#
	exception TYPE_KIND_UNBOUND;

	my empty_type_kind_dictionary:  Highcode_Kind_Dictionary
            =
            [];

	fun get_in_type_kind_dictionary (kenv, i, j)
	    = 
	    {   ks = list::nth (kenv, i - 1)
                     except
                         _ = raise exception TYPE_KIND_UNBOUND;

		list::nth (ks, j)
                except
                    _ = raise exception TYPE_KIND_UNBOUND;
	    };

	fun insert_in_type_kind_dictionary (kenv, ks)
	    =
	    ks ! kenv;

	# Strip any unused type variables out of a kenv,
        # given a list of [encoded] free type variables.
        # The result is a "parallel list" of the kinds
        # of those free type variables in the dictionary.
	# This is meant to use the same representation
        # of a kind dictionary as in ltybasic.
	#
	#                          --CALeague

	fun get_in_type_kind_dictionary_free_vars (kenv, type_constructor)
	    =
	    {   fun h ftvs =  g (kenv, 1, ftvs);

		null_or::map h (tc_vs type_constructor);
	    }
	    where

		fun g (kenv, d, [])
			=>
			[];

		    g (kenv, d, ftv ! ftvs)
			=>
			{   my (d', i') = tv_decode ftv;

			    kenv' = list::drop (kenv, d'-d)
				    except
					 _ = raise exception TYPE_KIND_UNBOUND;

			    k = list::nth (head kenv', i')
				except
				    _ = raise exception TYPE_KIND_UNBOUND;

			    rest = g (kenv', d', ftvs);

			    k ! rest;
			};
		end;
	    end;

	# *************************************************************************
	#             UTILITY FUNCTIONS ON TYC DICTIONARY                         *
	# *************************************************************************

	# Utility functions for manipulating the type_constructor_dictionary 
	#
	stipulate

	      tc_void
                  =
                  tc_inj_x (TC_PRIM (pt::prim_type_con_void));


	      fun tc_cons (t, b)
		  =
		  tc_inj_x (TC_ARROW (FNFLAG_FIXED, [t],[b]));


	      fun tc_interp x
		  = 
		  case (tc_out_x x)

		      TC_PROJ (y, i)
			   =>
			  case (tc_out_x  y)
			      TC_SEQ ts =>  (THE ts, i);
			      TC_PRIM _ =>  (NULL,   i);
			      _         =>  bug "unexpected tycDict1 in tc_interp";
			  esac;

		     _ => bug "unexpected tycDict2 in tc_interp";
		  esac;

	      fun tc_encode (NULL, i)
		      =>
		      tc_inj_x (TC_PROJ (tc_void, i));

		  tc_encode (THE ts, i)
		      => 
		      tc_inj_x (TC_PROJ (tc_inj_x (TC_SEQ (ts)), i));
	      end;

	herein

	    exception TC_UNBOUND;

	    my  init_type_constructor_dictionary:  Type_Constructor_Dictionary
                =
                tc_void;

	    fun tc_lookup (i, tenv:  Type_Constructor_Dictionary)
		= 
		if   (i > 1)

		    case (tc_out_x tenv)

			 TC_ARROW(_, _,[x]) =>  tc_lookup (i - 1, x);
			 _                  =>  bug "unexpected type_constructor_dictionary in tcLookup";
		    esac;
		else
		    if (i == 1)
			case (tc_out_x tenv)
			    TC_ARROW(_,[x], _) =>  tc_interp x; 
			    _                  =>  raise exception TC_UNBOUND;
			esac;
		    else
			bug "unexpected argument in tcLookup";
		    fi;
		fi;


	    fun insert_type_constructor (tenv:  Type_Constructor_Dictionary, et)
		=
		tc_cons (tc_encode et, tenv);


	    fun tc_split (tenv:  Type_Constructor_Dictionary)
		=
		case (tc_out_x tenv)
		    TC_ARROW(_,[x],[y]) =>  THE (tc_interp x, y);
		    _                   =>  NULL;
		esac;


	end; #  utililty function for type_constructor_dictionary 


	# Checking if a Highcode_Type_Constructor or
        # a Highcode_Type is in the normal form:
	#
	fun type_constructor_is_normalized ((t as REF (i, _, AUX_INFO_REG (b, _, _))) : Highcode_Type_Constructor) =>  b;
	    type_constructor_is_normalized _ => FALSE;
	end;

	fun lambda_type_is_normalized ((t as REF (i, _, AUX_INFO_REG (b, _, _))) : Highcode_Type) =>  b;
	    lambda_type_is_normalized _ => FALSE;
	end;


	# Utility functions for tc_env and lt_env.
	#
	stipulate

	    fun tcc_env_int (x, 0, 0, te) => x;
		tcc_env_int (x, i, j, te) => tc_inj_x (TC_CLOSURE (x, i, j, te));
	    end;

	    fun ltc_env_int (x, 0, 0, te) => x;
		ltc_env_int (x, i, j, te) => lt_inj_x (FNTYPE_TYPE_CLOSURE (x, i, j, te));
	    end;

	    fun with_eff ([], ol, nl, tenv)
		    =>
		    FALSE;

		with_eff (a ! r, ol, nl, tenv)
		    => 
		    {   my (i, j) = tv_decode a;

			neweff
			    = 
			    if (i > ol)
                                (ol != nl);
			    else
                                # case (tcLookup (i, tenv))
				#     (NULL, n) => (nl - n) != i
				#     (THE ts, n) =>
				#	   (let y = list::nth (ts, j)
				#	     in (case tc_outX y
				#		  of TC_VAR (ni, nj) =>
				#		      ((nj != j) or ((ni+nl-n) != i))
				#		   | _ => TRUE)
				#	    end) */

                                TRUE;
                            fi;

			neweff   or   (with_eff (r, ol, nl, tenv));
		    };
	    end;

	herein 

	    fun type_constructor_closure_dictionary (x, ol, nl, tenv)
		=
		{   tvs = tc_vs x;

		    case tvs
			NULL => tcc_env_int (x, ol, nl, tenv);
			THE [] => x;
			THE nvs => if (with_eff (nvs, ol, nl, tenv)) 
					tcc_env_int (x, ol, nl, tenv);
				   else x;
                                   fi;
		    esac; 
		};

	    fun lambda_type_closure_dictionary (x, ol, nl, tenv)
		= 
		{   tvs = lt_vs x;

		    case tvs
			NULL    => ltc_env_int (x, ol, nl, tenv);
			THE []  => x;
			THE nvs => if (with_eff (nvs, ol, nl, tenv)) 
				        ltc_env_int (x, ol, nl, tenv);
				   else x;
                                   fi;
		    esac; 
		};

	end;			# Utility functions for lt_env and tc_env.


	# Utility functions t update tycs and ltys:
	#
	fun tyc_upd (tgt as REF (i:  Int, old:  Highcode_Type_I, AUX_INFO_UNAVAILABLE), nt)
		=> 
		tgt := (i, TC_INDIRECT (nt, old), AUX_INFO_UNAVAILABLE);

	    tyc_upd (tgt as REF (i:  Int, old:  Highcode_Type_I, x as (AUX_INFO_REG (FALSE, _, _))), nt)
		=> 
		tgt := (i, TC_INDIRECT (nt, old), x);

	    tyc_upd _ => bug "unexpected tyc_upd on already normalized Highcode_Type_Constructor";
	end;


	fun lty_upd (tgt as REF (i:  Int, old:  Highcode_Fn_I, AUX_INFO_UNAVAILABLE), nt)
		=> 
		tgt := (i, FNTYPE_INDIRECT_TYPETHUNK (nt, old), AUX_INFO_UNAVAILABLE);

	    lty_upd (tgt as REF (i:  Int, old:  Highcode_Fn_I, x as (AUX_INFO_REG (FALSE, _, _))), nt)
		=> 
		tgt := (i, FNTYPE_INDIRECT_TYPETHUNK (nt, old), x);

	    lty_upd _ => bug "unexpected lty_upd on already normalized Highcode_Type";
	end;



	# *************************************************************************
	#            UTILITY FUNCTIONS ON REASONING ABOUT REDUCTIONS              *
	# *************************************************************************

	# A list of constructor functions:
	#
	tcc_var = tc_inj_x o TC_VAR;
	tcc_g = tc_inj_x o TC_FN;
	tcc_app = tc_inj_x o TC_APPLY;
	tcc_seq = tc_inj_x o TC_SEQ;
	tcc_proj = tc_inj_x o TC_PROJ;
	tcc_fix = tc_inj_x o TC_RECURSIVE;
	tcc_abs = tc_inj_x o TC_ABSTRACT;
	tcc_tup  = tc_inj_x o TC_TUPLE;
	tcc_parw = tc_inj_x o TC_PARROW;
	tcc_box = tc_inj_x o TC_BOXED;
	tcc_real = tc_inj_x (TC_PRIM pt::prim_type_con_real);
	ltc_tyc = lt_inj_x o FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR;
	ltc_str = lt_inj_x o FNTYPE_PACKAGE;
	ltc_fct = lt_inj_x o FNTYPE_GENERIC;
	ltc_poly = lt_inj_x o FNTYPE_POLYMORPHIC;
	tcc_sum = tc_inj_x o TC_SUM;
	tcc_token = tc_inj_x o TC_EXTENSIBLE_TOKEN;

						# fps_preoptimization_transform	def in     src/lib/compiler/upper/fps/fps-preoptimization-transform-g.pkg

	# The following functions decide on how to
        # flatten the arguments and results of an
        # arbitrary highcode function.
        #
        # The current threshold	is maintained by
        # the "flatten_limit" parameter.
	#
        # This parameter is intended to be
        # architecture independent, however
        # some implicit constraints are:
	#
	#     (1) flatten_limit <= numgpregs - numcalleesaves - 3
	#     (2) flatten_limit <= numfpregs - 2
	#
	# Right now (2) is in general not true for x86;
        # we inserted a special hack in
        # fps_preoptimization_transform phase
        # to deal with this case.
        #
        # In the long term, if the spilling phase
        # in the backend can offer more support
        # on large numbers of arguments, then we
        # can make this flattening more aggressive.
        #
        #                      -- Zhong

	flatten_limit = 9;  

	fun is_known tc
	    = 
	    case (tc_out_x (reduce_type_constructor_to_weak_head_normal_form tc))

		 (TC_PRIM _ | TC_ARROW _ | TC_BOXED _ | TC_ABSTRACT _ | TC_PARROW _) =>  TRUE; 
		 (TC_FATE _ | TC_RECURSIVE _ | TC_SUM _ | TC_TUPLE _)        =>  TRUE;

		 TC_APPLY (tc, _) =>  is_known tc;
		 TC_PROJ  (tc, _) =>  is_known tc;

		 TC_EXTENSIBLE_TOKEN (k, x)
		     =>
		     token_is_known  (k, x);

		 _ => FALSE;
	    esac

	also
	fun tc_autoflat tc
	    = 
	    {   ntc = reduce_type_constructor_to_weak_head_normal_form tc; 

		case (tc_out_x ntc)

		     TC_TUPLE (_, [_])		# singleton record is not flattened to ensure
			 =>		  	# isomorphism btw plambdatype and highcodetype
			 (TRUE, [ntc], FALSE);

		    TC_TUPLE (_, [])		# unit is not flattened to avoid coercions 
			=>
			(TRUE, [ntc], FALSE);

		    TC_TUPLE (_, ts)
			=> 
			if (length ts <= flatten_limit)   (TRUE, ts,    TRUE );
			else			          (TRUE, [ntc], FALSE);				#  ZHONG added the magic number 10 
			fi;	

		    _ => if (is_known ntc) (TRUE,  [ntc], FALSE);
			 else              (FALSE, [ntc], FALSE);
			 fi;
		esac;
	    }

	also
	fun type_constructor_list_to_type_constructor_tuple [x]
		=>
		x; 

	    type_constructor_list_to_type_constructor_tuple xs
		=> 
		if (length xs <= flatten_limit)

                    tcc_tup (RECORDFLAG_TMP, xs);
		else
                    bug "fatal error with typeConstructorListToTypeConstructorTuple";
		fi;
	end 

	also
	fun tcs_autoflat (flag, ts)
	    = 
	    if flag
		(flag, ts); 
	    else
		case ts 
		    [tc] => {   ntc =  reduce_type_constructor_to_weak_head_normal_form
                                           tc;

				my (nraw, ntcs, _)
                                    =
                                    tc_autoflat ntc;

				(nraw, ntcs);
			     };

		     _   => bug "unexpected cooked multiples in tcs_autoflat";
		esac;
	    fi

	also
	fun lt_autoflat lt
	    = 
	    case (lt_out_x (reduce_lambda_type_to_weak_head_normal_form lt))

		 FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
		     => 
		     {   my (raw, ts, flag)
                             =
                             tc_autoflat tc;

			 (raw, map ltc_tyc ts, flag);
		     };

		_    =>
		     (TRUE, [lt], FALSE);
	    esac

	# A special version of tcc_arrow
	# that does automatic flattening:
	#
	also
	fun tcc_arrow (x as (FNFLAG_FIXED, _, _))
		=>
		tc_inj_x (TC_ARROW x);

	    tcc_arrow (x as (FNFLAG_VARIABLE (TRUE, TRUE), _, _))
		=>
		tc_inj_x (TC_ARROW x);

	    tcc_arrow (b as (FNFLAG_VARIABLE (b1, b2)), ts1, ts2)
		=>
		{   my (nb1, nts1) = tcs_autoflat (b1, ts1);
		    my (nb2, nts2) = tcs_autoflat (b2, ts2);

		    tc_inj_x (TC_ARROW (FNFLAG_VARIABLE (nb1, nb2),  nts1, nts2));
		};
	end 

	# Utility function to read the top-level
        # of a Highcode_Type_Constructor:
	#
	also
	fun tc_lzrd t
	    = 
	    {   fun g x
		  = 
		  case (tc_out_x x)

		      TC_INDIRECT (tc, _)
                          =>
                          g tc;

		      TC_CLOSURE (tc, i, j, te)
                          => 
			  {   ntc = g (h(tc, i, j, te));

			      tyc_upd (x, ntc); ntc;
			  };

		      _ => x;
		  esac

		also
		fun h (x, 0, 0, _)
			=>
			g x;

		    h (x, ol, nl, tenv)
			=> 
			{   fun prop z
				=
				type_constructor_closure_dictionary (z, ol, nl, tenv);

			    case (tc_out_x x)

				TC_VAR (i, j)
				    => 
				    if (i <= ol) 

					et = tc_lookup (i, tenv);

					case et 

					    (NULL,   n)
                                                =>
                                                tcc_var (nl - n, j);

					    (THE ts, n)
                                                =>
                                                {   y = list::nth (ts, j) 
							except
							    _ = raise exception TC_UNBOUND;

						    h (y, 0, nl - n, init_type_constructor_dictionary);
						};
					esac;

				    else
					tcc_var (i-ol+nl, j);
				    fi;

				TC_NAMED_VAR _ => x;
				TC_PRIM      _ => x;
				TC_FN (ks, tc) => {   tenv' = insert_type_constructor (tenv, (NULL, nl));
						      tcc_g (ks, type_constructor_closure_dictionary (tc, ol+1, nl+1, tenv'));
						  };

				TC_APPLY (tc, tcs) =>  tcc_app (prop tc, map prop tcs);
				TC_SEQ tcs         =>  tcc_seq (map prop tcs);
				TC_PROJ (tc, i)    =>  tcc_proj (prop tc, i);
				TC_SUM tcs         => tcc_sum (map prop tcs);

				TC_RECURSIVE ((n, tc, ts), i)
				    => 
				    tcc_fix((n, prop tc, map prop ts), i);

				TC_ABSTRACT tc =>  tcc_abs (prop tc);
				TC_BOXED    tc =>  tcc_box (prop tc);

				TC_TUPLE (rk, tcs)     =>  tcc_tup (rk, map prop tcs);
				TC_ARROW (r, ts1, ts2) =>  tcc_arrow (r, map prop ts1, map prop ts2);
				TC_PARROW (t1, t2)     =>  tcc_parw (prop t1, prop t2);

				TC_EXTENSIBLE_TOKEN (k, t) =>  tcc_token (k, prop t);
				TC_INDIRECT (tc, _)        =>  h (tc, ol, nl, tenv);

				TC_CLOSURE (tc, ol', nl', tenv')
				    => 
				    if (ol == 0)   h (tc,  ol', nl+nl', tenv');
				    else           h (g x, ol,  nl,     tenv );
				    fi;

				TC_FATE _
				    =>
				    bug "unexpected TC_FATE in tc_lzrd";
			    esac;
			};
		end;				# fun h 

		if (type_constructor_is_normalized t)      t;
		else                                     g t;
		fi;
	  }								# fun tc_lzrd 

	# Utility function to read the
        # top-level of an Highcode_Type:
	#
	also
	fun lt_lzrd t		#  Maybe "lzrd" == "level zero read" ? 
	    = 
	    {   fun g x
		    = 
		    case (lt_out_x x)

			FNTYPE_INDIRECT_TYPETHUNK (lt, _)
                            =>
                            g lt;

			FNTYPE_TYPE_CLOSURE (lt, i, j, te)
                            => 
			    {   nlt = g (h(lt, i, j, te));
			        lty_upd (x, nlt); nlt;
			    };

			 _ => x;
		    esac

		also
		fun h (x, 0, 0, _)
			=>
			g x;

		    h (x, ol, nl, tenv)
			=> 
			{   fun prop z
				=
				lambda_type_closure_dictionary (z, ol, nl, tenv);

			    case (lt_out_x x)

				FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
                                    =>
                                    ltc_tyc (type_constructor_closure_dictionary (tc, ol, nl, tenv));

				FNTYPE_PACKAGE ts
                                    =>
                                    ltc_str (map prop ts);

				FNTYPE_GENERIC (ts1, ts2)
                                    =>
                                    ltc_fct (map prop ts1, map prop ts2);

				FNTYPE_POLYMORPHIC (ks, ts)
                                    => 
				    {   tenv' = insert_type_constructor (tenv, (NULL, nl));

				        ltc_poly
                                          ( ks, 
					    map (fn t = lambda_type_closure_dictionary (t, ol+1, nl+1, tenv'))
                                                ts
                                          );
				   };

				FNTYPE_INTERNAL_CLOSURE _
                                    =>
                                    bug "unexpected FNTYPE_INTERNAL_CLOSURE in lt_lzrd";

				FNTYPE_INDIRECT_TYPETHUNK (t, _)
                                    =>
                                    h (t, ol, nl, tenv);

				FNTYPE_TYPE_CLOSURE (lt, ol', nl', tenv')
				    => 
				    if (ol == 0)  h (lt,  ol', nl+nl', tenv');
				    else          h (g x, ol,  nl,     tenv );
				    fi;

			    esac;
		      };
		end;			#  function h 

		if (lambda_type_is_normalized  t)     t;
		else                                g t;
		fi;
	    }                                     #  function lt_lzrd 

	# Taking out the TC_INDIRECT indirection:
	#
	also
	fun strip_ind t
	    =
	    case (tc_out_x t)
                TC_INDIRECT (x, _) =>  strip_ind x;
		_                  =>  t;
	    esac

	# Normalizing an arbitrary Highcode_Type_Constructor
	# into a simple weak-head-normal-form
	#
	also
	fun reduce_type_constructor_to_weak_head_normal_form t
	    =
	    if (type_constructor_is_normalized t)
		t;
	    else
		nt = tc_lzrd t;

		case (tc_out_x nt)

		    TC_APPLY (tc, tcs)
			=>
			{   tc' = reduce_type_constructor_to_weak_head_normal_form tc;

			    case (tc_out_x tc')

				TC_FN (ks, b)
				    =>  
				    {   fun base ()
					    = 
					    (b, 1, 0, insert_type_constructor (init_type_constructor_dictionary, (THE tcs, 0)));

					sp = case (tc_out_x b)

						  TC_CLOSURE (b', ol', nl', te')
						      => 
						      case (tc_split te')

							   THE((NULL, n), te)
							       =>
							       if ((n == nl' - 1) and (ol' > 0))

								    (b', ol', n, 
								     insert_type_constructor (te, (THE tcs, n)));
							       else
								    base();
							       fi;

							_ => base();

						      esac;

						 _ => base();
					     esac;

				      result = reduce_type_constructor_to_weak_head_normal_form (type_constructor_closure_dictionary sp);

				      tyc_upd (nt, result); result;
				    };

				((TC_SEQ _) | (TC_TUPLE _) | (TC_ARROW _) | (TC_INDIRECT _))
				    =>
				    bug "unexpected tycs in-reduceTypeConstructorToWeakHeadNormalForm-TC_APPLY";

			       _ => {   xx = tcc_app (tc', tcs); 
					strip_ind xx;
				    };
			   esac;
			};

		    TC_PROJ (tc, i)
		       =>
		       {   tc' = reduce_type_constructor_to_weak_head_normal_form tc;

			   case (tc_out_x tc')

				 TC_SEQ tcs
				     => 
				     {   result = list::nth (tcs, i)
						  except
						      _ = bug "TC_SEQ in reduceTypeConstructorToWeakHeadNormalForm";

					 nres = reduce_type_constructor_to_weak_head_normal_form result;
					 tyc_upd (nt, nres); nres;
				     };

				((TC_PRIM _) | (TC_NAMED_VAR _) | (TC_RECURSIVE _) | (TC_FN _) |
				  (TC_SUM _) | (TC_ARROW _) | (TC_ABSTRACT _) | (TC_BOXED _) | 
				  (TC_INDIRECT _) | (TC_TUPLE _))
				    =>
				    bug "unexpected tycs in-reduceTypeConstructorToWeakHeadNormalForm-TC_PROJ";

				_ => { xx = tcc_proj (tc', i);
					strip_ind xx;
				      };
			   esac;
		       };

		    TC_EXTENSIBLE_TOKEN (k, tc)
		        =>
		        {   tc' = reduce_type_constructor_to_weak_head_normal_form tc;

			    if (token_whnm k tc') 
				xx = tcc_token (k, tc');  strip_ind xx;
			    else
                               result = token_reduce (k, tc');
			       nres = reduce_type_constructor_to_weak_head_normal_form result;
			       tyc_upd (nt, nres); nres;
			    fi;
			};

		    TC_INDIRECT (tc, _)
                        =>
                        reduce_type_constructor_to_weak_head_normal_form tc;

		    TC_CLOSURE _
                        =>
                        bug "unexpected TC_CLOSURE in reduce_type_constructor_to_weak_head_normal_form";

		    _ => nt;
		esac;
	    fi			# fun reduce_type_constructor_to_weak_head_normal_form


	# Normalizing an arbitrary Highcode_Type
	# into the simple weak-head-normal-form 
	#
	also
	fun reduce_lambda_type_to_weak_head_normal_form t
	    =
	    if (lambda_type_is_normalized (t) )
		 t;
	    else 
		 nt = lt_lzrd t;

		 case (lt_out_x nt)

		     FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc
                         =>
                         ltc_tyc (reduce_type_constructor_to_weak_head_normal_form  tc);

		      _ => nt;
		 esac;
	    fi;			# fun reduceLambdaTypeToWeakHeadNormalForm 

	# Normalizing an arbitrary Highcode_Type_Constructor
	# into the standard normal form:
	#
	fun reduce_type_constructor_to_normal_form t
	    =
	    if (type_constructor_is_normalized t)
                t;
	    else
		nt = reduce_type_constructor_to_weak_head_normal_form t;

		if (type_constructor_is_normalized nt)

		     nt;
		else
		     result
			 = 
			 case (tc_out_x nt)
			     TC_FN (ks, tc) => tcc_g (ks, reduce_type_constructor_to_normal_form tc);

			     TC_APPLY (tc, tcs)
                                 => 
				 tcc_app
                                   (     reduce_type_constructor_to_normal_form tc,
                                     map reduce_type_constructor_to_normal_form tcs
                                   );

			     TC_SEQ tcs => tcc_seq (map reduce_type_constructor_to_normal_form tcs);
			     TC_PROJ (tc, i) => tcc_proj (reduce_type_constructor_to_normal_form tc, i);
			     TC_SUM tcs => tcc_sum (map reduce_type_constructor_to_normal_form tcs);

			     TC_RECURSIVE ((n, tc, ts), i)
                                 => 
				 tcc_fix
                                   ( ( n,
                                       reduce_type_constructor_to_normal_form      tc,
                                       map reduce_type_constructor_to_normal_form  ts
                                     ),

                                     i
                                   );

			     TC_ABSTRACT tc => tcc_abs (reduce_type_constructor_to_normal_form tc);
			     TC_BOXED tc => tcc_box (reduce_type_constructor_to_normal_form tc);
			     TC_TUPLE (rk, tcs) => tcc_tup (rk, map reduce_type_constructor_to_normal_form tcs);

			     TC_ARROW (r, ts1, ts2)
                                 => 
				 tcc_arrow
                                   ( r,
                                     map  reduce_type_constructor_to_normal_form  ts1,
                                     map  reduce_type_constructor_to_normal_form  ts2
                                   );

			     TC_PARROW (t1, t2)
                                 =>
                                 tcc_parw
                                   ( reduce_type_constructor_to_normal_form  t1,
                                     reduce_type_constructor_to_normal_form  t2
                                   );

			     TC_EXTENSIBLE_TOKEN (k, t) => tcc_token (k, reduce_type_constructor_to_normal_form t);
			     TC_INDIRECT (tc, _) => reduce_type_constructor_to_normal_form tc;

			     TC_CLOSURE _ => bug "unexpected tycs in reduceTypeConstructorToNormalForm";

			     _ => nt;
			 esac;

		     tyc_upd (nt, result);

		     result;
		fi;
	    fi;			# fun reduceTypeConstructorToNormalForm 

	# Normalizing an arbitrary Highcode_Type
	# into the standard normal form
	#
	fun reduce_lambda_type_to_normal_form t
	    =
	    if (lambda_type_is_normalized t)  t;
	    else 
		nt = lt_lzrd t;

		if (lambda_type_is_normalized nt)
                    nt;
		else 
		    result
			= 
			case (lt_out_x nt)
			    FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR tc => ltc_tyc (reduce_type_constructor_to_normal_form tc);
			    FNTYPE_PACKAGE ts => ltc_str (map reduce_lambda_type_to_normal_form ts);

			    FNTYPE_GENERIC (ts1, ts2)
                                => 
			        ltc_fct
                                  ( map reduce_lambda_type_to_normal_form  ts1,
                                    map reduce_lambda_type_to_normal_form  ts2
                                  );

			    FNTYPE_POLYMORPHIC (ks, ts) => ltc_poly (ks, map reduce_lambda_type_to_normal_form ts);
			    FNTYPE_INDIRECT_TYPETHUNK (lt, _) => reduce_lambda_type_to_normal_form lt;

			    _ => bug "unexpected ltys in reduceLambdaTypeToNormalForm";
			esac;

		    lty_upd (nt, result);

		    result;
		fi;
	    fi;			# fun reduceLambdaTypeToNormalForm 


	# **************************************************************************
	#          REGISTER A NEW TOKEN TYC --- TC_WRAP                            *
	# **************************************************************************

	# We add a new constructor named
	# TC_RBOX through the token facility:
	#
	stipulate

	    name = "TC_WRAP";

	    abbrev = "WR";

	    is_known =  fn _ = TRUE;      # Why is this ? 	XXX BUGGO FIXME

	    fun tcc_tok k t
                =
                tcc_token (k, t);

	    fun unknown tc
		= 
		case (tc_out_x tc)

		   (TC_VAR _ | TC_NAMED_VAR _) => TRUE;

		   (TC_APPLY (tc, _)) =>  unknown tc;
		   (TC_PROJ  (tc, _)) =>  unknown tc;

		  _ => FALSE;
		esac;

	    fun flex_tuple ts
		= 
		hhh (ts, FALSE, TRUE)
		where
		    fun hhh (x ! r, ukn, wfree)
			    => 
			    {   fun iswp tc
				    =
				    case (tc_out_x tc)

					TC_EXTENSIBLE_TOKEN (k', t)		 #  WARNING: need check k' 
					    =>
					    case (tc_out_x t)
						 TC_PRIM pt =>  FALSE;
						 _          =>  TRUE;
					    esac;

					_ => TRUE;
				    esac;

				hhh (r, (unknown x) or ukn, (iswp x) and wfree);
			    };

			hhh([], ukn, wfree)
			    =>
			    ukn and wfree;
		    end;
		end;

	    fun is_weak_head_normal_form tc
		= 
		case (tc_out_x tc)
		    (TC_ARROW (FNFLAG_FIXED, [t], _)) => (unknown t); 
		    (TC_TUPLE (rf, ts)) => flex_tuple ts;
		    (TC_PRIM pt) => pt::unboxed pt;
		    _ => FALSE;
		esac;

	    # Invariants: tc itself is in whnm
	    # but isWeakHeadNormalForm tc = FALSE 
	    #
	    fun reduce_one (k, tc)
		=  
		case (tc_out_x tc)

		    TC_TUPLE (rk, ts)
			=> 
			hhh (ts, [], FALSE)
			where
			    fun hhh (x ! r, nts, ukn)
				    => 
				    hhh (r, nnx ! nts, b1 or ukn)
				    where
					nx = reduce_type_constructor_to_weak_head_normal_form x;
					b1 = unknown nx;

					nnx = case (tc_out_x nx)

						  TC_EXTENSIBLE_TOKEN (k', t)
						      =>
						      if (tokens_are_equal (k, k') )

							  case (tc_out_x t)    TC_PRIM _ => t;
									       _         => nx;
							  esac;

						      else
							  nx;
						      fi;

						  _ => nx;
					      esac;
				    end;

				hhh ([], nts, ukn)
				    => 
				    {   nt = tcc_tup (rk, reverse nts);

					if ukn    tcc_token (k, nt);
					else      nt;
					fi;
				    };
			    end;
			end;

		    TC_ARROW (FNFLAG_FIXED, [_, _], [_])
			=>
			tc;

		    TC_ARROW (FNFLAG_FIXED, [t1], ts2 as [_])
			=> 
			{   nt1 = reduce_type_constructor_to_weak_head_normal_form t1;

			    fun ggg z
				= 
				{   nz = reduce_type_constructor_to_weak_head_normal_form z;

				    case (tc_out_x nz)

					TC_PRIM pt
					    => 
					    if (pt::unboxed pt)   tcc_token (k, nz);
					    else                  nz;
					    fi;

					_   => nz;

				    esac;
			     };

			    my (wp, nts1)
				=
				case (tc_out_x nt1)

				   TC_TUPLE(_, [x, y])
                                       =>
                                       (FALSE, [ggg x, ggg y]);

				   TC_EXTENSIBLE_TOKEN (k', x)
                                       => 
				       if (tokens_are_equal (k, k'))

					   case (tc_out_x x)

					       TC_TUPLE(_, [y, z])
                                                   => 
						   (FALSE, [ggg y, ggg z]);

					       _   =>
                                                   (FALSE, [nt1]);
					   esac;
				       else
                                           (FALSE, [nt1]);
                                       fi;

				  _ => (unknown nt1, [nt1]);
				esac;

			    nt = tcc_arrow (FNFLAG_FIXED, nts1, ts2);

			    if wp  tcc_token (k, nt);
                            else   nt;
                            fi;
		       };

		    TC_ARROW (FNFLAG_FIXED, _, _)
			=> 
			bug "unexpected reduceOne on ill-formed FF_FIX arrow types";

		    TC_ARROW (FNFLAG_VARIABLE (b1, b2), ts1, ts2)
			=> 
			bug "calling reduceOne on FNFLAG_VARIABLE arrow types";

		    TC_PRIM pt
			=> 
			if (pt::unboxed pt)   bug "calling reduceOne on an already-reduced whnm";
			else                  tc;
			fi;

		    TC_EXTENSIBLE_TOKEN (k', t)
			=>
			if (tokens_are_equal (k, k'))   tc;
			else                            bug "unexpected token in reduceOne";
			fi;

		    (TC_BOXED _ | TC_ABSTRACT _ | TC_PARROW _)
			=> 
			bug "unexpected tc_box/abs/parrow in reduceOne";

		    TC_CLOSURE  _ => bug "unexpected TC_CLOSURE in reduceOne";
		    TC_INDIRECT _ => bug "unexpected TC_INDIRECT in reduceOne";

		    _ => tc;
	        esac;

	herein

	    wrap_token
                =
                register_token
		  { name,
		    abbrev,
		    reduce_one,
		    is_weak_head_normal_form,
		    is_known
		  };

	end;							# End of creating the box token for "tcc_rbox".



	# Testing if a Highcode_Type_Constructor is a unknown constructor:
	#
	fun type_constructor_is_unknown tc
	    =
	    not (is_known tc);

	# *************************************************************************
	#          RENAMING THE INJECTION AND PROJECTION FUNCTIONS                *
	# *************************************************************************

	# Converting from the standard reps
	# to the hash-consing reps:
	#
	type_kind_inject        = tk_inj_x;
	type_constructor_inject = tc_inj_x;
	lambda_type_inject      = lt_inj_x;

	# Converting from the hash-consing
	# reps to the standard reps:
	#
	type_kind_project        = tk_out_x; 
	type_constructor_project = tc_out_x  o  reduce_type_constructor_to_weak_head_normal_form;
	lambda_type_project      = lt_out_x  o  reduce_lambda_type_to_weak_head_normal_form;

	# **************************************************************************
	#          UTILITY FUNCTIONS ON TESTING EQUIVALENCE                        *
	# **************************************************************************

	# Testing the equality of values
	# of Highcode_Kind, Highcode_Type_Constructor, Highcode_Type
	#
	fun eqlist p (x ! xs, y ! ys) => (p (x, y)) and (eqlist p (xs, ys));
	    eqlist p ([], []) => TRUE;
	    eqlist _ _ => FALSE;
        end;

	# Testing the "pointer" equality on normalized
	# Highcode_Kind, Highcode_Type_Constructor, and Highcode_Type:
	#
	fun tk_eq (x: Highcode_Kind, y)              =   (x == y);
	fun tc_eq (x: Highcode_Type_Constructor, y)  =   (x == y);
	fun lt_eq (x: Highcode_Type, y)              =   (x == y);

	# Testing the equivalence for
	# arbitrary tkinds, tycs and ltys:
	#
	type_kinds_are_equivalent = tk_eq;       #  All tkinds are normalized 

	stipulate

	    # The efficiency of checking FIX equivalence
            # could probably be improved somewhat,
            # but it doesn't seem so bad for my purposes
	    # right now.  Anyway, somebody might eventually
            # want to do some profiling and improve this.
            #                --league, 24 March 1998


	    #  Profiling code, temporary?? 
	    #
	    package click {

		stipulate
		    s_unroll = compile_statistics::make_stat "FIX unrolls";
		herein
		    fun unroll () = compile_statistics::add_stat s_unroll 1;
		end;
	    };		#  Click 

	    # Unrolling a fix, Highcode_Type_Constructor -> Highcode_Type_Constructor 
	    #
	    fun tc_unroll_fix type_constructor
		=
		case (tc_out_x type_constructor)

		    TC_RECURSIVE((n, tc, ts), i)
			=>
			{   fun genfix i
				=
				tcc_fix ((n, tc, ts), i);

			    fixes = list::tabulate (n, genfix);
			    mu = tc;

			    mu = if (null ts)  mu;
				 else          tcc_app (mu, ts);
                                 fi;

			    mu = tcc_app (mu, fixes);

			    mu = if (n==1)  mu;
				 else       tcc_proj (mu, i);
                                 fi;

			    click::unroll();
			    mu;
			};

		     _   => bug "unexpected non-FIX in tc_unroll_fix";
		esac;


	    # In order to check equality of two FIXes, we need to be able to
	    # unroll them once, and check equality on the unrolled version, with
	    # an inductive assumption that they ARE equal.  The following code
	    # supports making and checking these inductive assumptions.
	    # Furthermore, we need to avoid unrolling any FIX more than once.
	    #
	    package tc_dictionary
		=
		red_black_map_g (						# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg

		    Key = Highcode_Type_Constructor;
		    compare = compare_type_constructors;
		);


	    # For each type in this dictionary
	    # we store a dictionary containing
	    # tycs that are assumed equivalent to it.
	    #
	    Eqilk = tc_dictionary::Map( Void );
	    Hyp   = tc_dictionary::Map( Eqilk );


	    # The null hypothesis, no assumptions about equality:
	    # 
	    my empty_eqilk:  Eqilk   =  tc_dictionary::empty;
	    my null_hyp:     Hyp     =  tc_dictionary::empty;


	    # Add assumption t1=t2 to current hypothesis.
	    # Return composite hypothesis:
	    #
	    fun assume_eq' (hyp, t1, t1eq_opt, t2)
		=
		hyp'
		where
		    t1eq  = case t1eq_opt
				THE e =>  e;
				NULL  =>  empty_eqilk;
			    esac;

		    t1eq' = tc_dictionary::set (t1eq, t2, ());
		    hyp'  = tc_dictionary::set (hyp, t1, t1eq');
		end;


	    fun assume_eq (hyp, t1, t1eq_opt, t2, t2eq_opt)
		=
		assume_eq' (assume_eq' (hyp, t1, t1eq_opt, t2),
			    t2, t2eq_opt, t1);


	    # Check whether t1=t2 according to the hypothesis 
	    #
	    my eq_by_hyp:  (Null_Or( Eqilk ), Highcode_Type_Constructor) -> Bool
		=
		fn (NULL,      t2) =>  FALSE;
		   (THE eqilk, t2) =>  not_null (tc_dictionary::get (eqilk, t2));
		end;


	    # Have we made any assumptions about `t' already?
	    # 
	    my visited:  Null_Or( Eqilk ) -> Bool 
	      = not_null;


	    # Test if two recursive datatypes are equivalent 
	    #
	    fun eq_fix (eqop1, hyp) (t1, t2)
		= 
		case ( tc_out_x  t1,
		       tc_out_x  t2
		     ) 

		    ( TC_RECURSIVE ((n1, tc1, ts1), i1),
		      TC_RECURSIVE ((n2, tc2, ts2), i2)
		    )
			=> 
			if (not *controls::highcode::check_datatypes)
			    TRUE; 
			else
			    t1eq_opt = tc_dictionary::get (hyp, t1);

			    # First check the induction hypothesis.
			    #	
			    # We only ever make hypotheses about FIX nodes,
			    # so this test is okay here.
			    #	
			    # If assume_eq appears in other cases, this 
			    # test should be lifted outside the switch.
			    #	
			    if (eq_by_hyp (t1eq_opt, t2))

				TRUE;

			    else
				# Next try structural eq on the components.
				# I'm not sure why this part is necessary,
				# but it does seem to be...
				#                --league, 23 March 1998
				#
				(    n1 == n2 and i1 == i2
				and  eqop1 hyp (tc1, tc2)
				and  eqlist (eqop1 hyp) (ts1, ts2)
				)
				or

				# Not equal by inspection; we have to unroll it.
				# We prevent unrolling the same FIX twice by asking
				# the `visited' function.
				#
				if (visited t1eq_opt)

				    FALSE; 
				else
				    t2eq_opt =  tc_dictionary::get (hyp, t2);

				    if (visited t2eq_opt)

					FALSE; 
				    else
					eqop1 (assume_eq (hyp, t1, t1eq_opt, t2, t2eq_opt))
					      (tc_unroll_fix t1, tc_unroll_fix t2);
				    fi;
				fi;
			    fi;
			fi;

		     _ => bug "unexpected types in eq_fix";
		esac;


	    # tc_eqv_generator, invariant: t1 and t2 are in the wh-normal form 
	    #     eqop1 is the default equality to be used for tycs
	    #     eqop2 is used for body of FN, arguments in APPLY,
	    #     eqop3 is used for ABS and BOX.
	    #     eqop4 is used for arrow arguments and results
	    # Each of these first takes the set of hypotheses.
	    #
	    fun tc_eqv_fn (eqop1, eqop2, hyp) (t1, t2)
		= 
		case (tc_out_x t1, tc_out_x t2)

		    (TC_RECURSIVE _, TC_RECURSIVE _)
			=>
			eqop2 (eqop1, hyp) (t1, t2);


		    (TC_FN (ks1, b1), TC_FN (ks2, b2))
			=>
			eqlist type_kinds_are_equivalent (ks1, ks2) and eqop1 hyp (b1, b2);


		    (TC_APPLY (a1, b1), TC_APPLY (a2, b2))
			=>
			eqop1 hyp (a1, a2) and eqlist (eqop1 hyp) (b1, b2);


		    (TC_SEQ ts1, TC_SEQ ts2)
			=>
			eqlist (eqop1 hyp) (ts1, ts2);


		    (TC_SUM ts1, TC_SUM ts2)
			=>
			eqlist (eqop1 hyp) (ts1, ts2);


		    (TC_TUPLE (_, ts1), TC_TUPLE (_, ts2))
			=>
			eqlist (eqop1 hyp) (ts1, ts2);


		    (TC_ABSTRACT a, TC_ABSTRACT b)
			=>
			eqop1 hyp (a, b);


		    (TC_BOXED a, TC_BOXED b)
			=>
			eqop1 hyp (a, b);


		    (TC_EXTENSIBLE_TOKEN (k1, t1), TC_EXTENSIBLE_TOKEN (k2, t2))
			=> 
			tokens_are_equal (k1, k2) and eqop1 hyp (t1, t2);


		    (TC_PROJ (a1, i1), TC_PROJ (a2, i2))
			=>
			i1 == i2 and eqop1 hyp (a1, a2);

		    (TC_ARROW (r1, a1, b1), TC_ARROW (r2, a2, b2))
			=> 
			r1 == r2 and eqlist (eqop1 hyp) (a1, a2) 
				 and eqlist (eqop1 hyp) (b1, b2);


		    (TC_PARROW (a1, b1), TC_PARROW (a2, b2))
			=> 
			eqop1 hyp (a1, a2) and eqop1 hyp (b1, b2);

		    (TC_FATE ts1, TC_FATE ts2)
			=>
			eqlist (eqop1 hyp) (ts1, ts2);

		    _ => FALSE;
		esac;


	    # General equality for tycs:
	    #
	    fun type_constructors_are_equivalent' hyp (x as REF (_, _, AUX_INFO_REG (TRUE, _, _)),
			     y as REF (_, _, AUX_INFO_REG (TRUE, _, _)))
		    =>
		    tc_eq (x, y);

		type_constructors_are_equivalent' hyp (x, y)
		    =>
		    {
			t1 = reduce_type_constructor_to_weak_head_normal_form x;
			t2 = reduce_type_constructor_to_weak_head_normal_form y;

			if (type_constructor_is_normalized t1
			and type_constructor_is_normalized t2)

			    tc_eq (t1, t2);
			else    
			    tc_eqv_fn (type_constructors_are_equivalent', fn _ = tc_eq, hyp) (t1, t2);
			fi;
		    };				# fun type_constructors_are_equivalent'
	    end; 


	    # Slightly relaxed constraints (???)
	    #
	    fun type_constructors_are_approximately_equivalent' hyp (x, y)
		=
		{   t1 = reduce_type_constructor_to_weak_head_normal_form x;
		    t2 = reduce_type_constructor_to_weak_head_normal_form y;

		    if ( type_constructor_is_normalized t1  and
			 type_constructor_is_normalized t2
		    )
			tc_eq (t1, t2);
		    else
			FALSE;
		    fi
		    or
		    (tc_eqv_fn (type_constructors_are_approximately_equivalent', eq_fix, hyp) (t1, t2));
		};

	herein

	    type_constructors_are_equivalent
		=
		type_constructors_are_equivalent' null_hyp;


	    type_constructors_are_approximately_equivalent
		=
		type_constructors_are_approximately_equivalent' null_hyp;
	end;


	# lt_eqv_generator, invariant: x and y are in the weak head-normal form
	#
	fun lt_eqv_generator (eqop1, eqop2) (x:  Highcode_Type, y)
	    = 
	    seq (x, y)
	    where
		#  seq should be called if t1 and t2 are weak-head normal form 
		fun seq (t1, t2)
		    = 
		    case ( lt_out_x  t1,
			   lt_out_x  t2
			 )

			( FNTYPE_POLYMORPHIC (ks1, b1),
			  FNTYPE_POLYMORPHIC (ks2, b2)
			)
			    =>
			    (eqlist type_kinds_are_equivalent (ks1, ks2)) and (eqlist eqop1 (b1, b2));

			( FNTYPE_GENERIC (as1, bs1),
			  FNTYPE_GENERIC (as2, bs2)
			)
			    => 
			    (eqlist eqop1 (as1, as2)) and (eqlist eqop1 (bs1, bs2));

			( FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR a,
			  FNTYPE_MONOMORPHIC_TYPE_CONSTRUCTOR b
			)
			    =>
			    eqop2 (a, b);

			( FNTYPE_PACKAGE s1,
			  FNTYPE_PACKAGE s2
			)
			    =>
			    eqlist eqop1 (s1, s2);

			( FNTYPE_INTERNAL_CLOSURE s1,
			  FNTYPE_INTERNAL_CLOSURE s2
			)
			    =>
			    eqlist eqop1 (s1, s2);

			_ => FALSE;
		    esac;
	    end;

	fun lambda_types_are_equivalent (x:  Highcode_Type, y)
	    = 
	    {   seq = lt_eqv_generator (lambda_types_are_equivalent, type_constructors_are_equivalent); 

		if  (lambda_type_is_normalized  x
		and  lambda_type_is_normalized  y)

		    lt_eq (x, y);
		else
		    t1 = reduce_lambda_type_to_weak_head_normal_form x;
		    t2 = reduce_lambda_type_to_weak_head_normal_form y;

		    if (lambda_type_is_normalized t1
		    and lambda_type_is_normalized t2)
			lt_eq (x, y);
		    else
			seq (t1, t2);
		    fi;
		fi;
	    };

	fun lambda_types_are_approximately_equivalent (x:  Highcode_Type, y)
	    = 
	    {   seq = lt_eqv_generator (lambda_types_are_approximately_equivalent, type_constructors_are_approximately_equivalent); 

		if (lambda_type_is_normalized x
		and lambda_type_is_normalized y)

		    (lt_eq (x, y)) or (seq (x, y));

		else

		    t1 = reduce_lambda_type_to_weak_head_normal_form x;
		    t2 = reduce_lambda_type_to_weak_head_normal_form y;

		    if  (lambda_type_is_normalized t1
		    and  lambda_type_is_normalized t2
			)  
			(lt_eq (t1, t2)) or (seq (t1, t2));
		    else
			seq (t1, t2);
		    fi;
		fi;
	    };


	# Test equivalence of fflags and rflags:
	#
	fun function_flags_are_equivalent (FNFLAG_VARIABLE (b1, b2), FNFLAG_VARIABLE (b1', b2'))                  =>   b1 == b1' and b2 == b2';
	    function_flags_are_equivalent (FNFLAG_FIXED, FNFLAG_FIXED)                                            =>  TRUE;
	    function_flags_are_equivalent ((FNFLAG_FIXED, FNFLAG_VARIABLE _) | (FNFLAG_VARIABLE _, FNFLAG_FIXED)) =>  FALSE;
	end;


	fun record_flags_are_equivalent (RECORDFLAG_TMP, RECORDFLAG_TMP)
	    =
	    TRUE;


	# *************************************************************************
	#  UTILITY FUNCTIONS ON FINDING OUT THE DEPTH OF THE FREE TYC VARIABLES   *
	# *************************************************************************
	# * finding out the innermost naming depth for a Highcode_Type_Constructor's free variables 
	#
	fun type_constructor_depth_of_innermost_named_variable (x, d)
	    =
	    {   tvs = tc_vs (reduce_type_constructor_to_normal_form x); 

		#  Unfortunately we have to reduce everything to the normal form
		#	 before we can talk about its list of free type variables.
		#
		case tvs
		    THE [] => di::top;
		    THE (a ! _) => d + 1 - (#1 (tv_decode a));
		    NULL => bug "unexpected case in typeConstructorDepthOfInnermostBoundVariable";
		esac;
	    };


	fun type_constructors_depth_of_innermost_named_variable ([],    d) => di::top;
	    type_constructors_depth_of_innermost_named_variable (x ! r, d) => int::max (type_constructor_depth_of_innermost_named_variable (x, d), type_constructors_depth_of_innermost_named_variable (r, d));
	end;


	# These return the list of free NAMED type_variables 
	#
	fun free_named_variables_in_type_constructor (type_constructor: Highcode_Type_Constructor)
	    =
	    case (get_aux (reduce_type_constructor_to_normal_form type_constructor))   
		AUX_INFO_REG (_, _, tvs) => tvs;
		AUX_INFO_UNAVAILABLE => bug "unexpected case in freeNamedVariablesInTypeConstructor";
	    esac;


	fun free_named_variables_in_lambda_type (lambda_type: Highcode_Type)
	    = 
	    case (get_aux (reduce_lambda_type_to_normal_form lambda_type))
		AUX_INFO_REG (_, _, tvs) => tvs;
		AUX_INFO_UNAVAILABLE => bug "unexpected case in freeNamedVariablesInLambdaType";
	    esac;


    end;	# toplevel stipulate 
};		# package highcode_guts 








##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## COPYRIGHT (c) 1997 YALE FLINT PROJECT 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
