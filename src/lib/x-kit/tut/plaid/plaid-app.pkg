## plaid-app.pkg
#
# This app draws screensaver-like rectangular patterns in a window.
#
# It has two modes, "idle" and "active".
#
# In "idle" mode it uses normal buffered xd::fill_boxes XOR-draw
# commands to fill the window with a rectangular pattern and stops.
#
# In "active" mode is uses unbuffered xd::fill_boxes XOR-draw
# commands to draw a continuously changing (another draw every
# 100ms) pattern.
#
# Clicking any mouse button anywhere in the window toggles
# the app between these two modes.
#
# This app uses the "unbuffered" window mode designed to support
# rubber-banding and also the XOR drawing mode used by rubber-banding;
# this makes it a useful unit test for rubber-banding functionality.
#
# One way to run this app from the base-directory commandline is:
#
#     linux% my
#     eval: make "src/lib/x-kit/tut/plaid/plaid-app.make6";
#     eval: plaid_app::do_it ();

# Compiled by:
#     src/lib/x-kit/tut/plaid/plaid-app.make6

stipulate
    include threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package rx  =  run_xkit;				# run_xkit			is from   src/lib/x-kit/widget/lib/run-xkit.pkg
    package xc  =  xcore;				# xcore				is from   src/lib/x-kit/xclient/xcore.pkg
    package xd  =  xdraw;				# xdraw				is from   src/lib/x-kit/xclient/xdraw.pkg
    package xg  =  xgeometry;				# xgeometry			is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;				# xinput			is from   src/lib/x-kit/xclient/xinput.pkg
    package xtr =  xtracing;				# xtracing			is from   src/lib/x-kit/xclient/src/stuff/xtracing.pkg
    #
    package top =  topwindow;				# topwindow			is from   src/lib/x-kit/widget/basic/topwindow.pkg
    package wg  =  widget;				# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wa  =  widget_attribute;			# widget_attribute		is from   src/lib/x-kit/widget/lib/widget-attribute.pkg
    package wy  =  widget_style;			# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    #
    package sz  =  size_preference_wrapper;		# size_preference_wrapper	is from   src/lib/x-kit/widget/wrapper/size-preference-wrapper.pkg
    #
    tracefile   =  "plaid-app.trace.log";
    trace	=  xtr::print_if  xtr::io_tracing;	# Conditionally write strings to tracing.log or whatever.
herein

    package plaid_app: Plaid_App {			# Plaid_App			is from   src/lib/x-kit/tut/plaid/plaid-app.api

	empty_box
	    =
	    xg::BOX
	      { col  => 0,
		row  => 0,
		wide => 0,
		high => 0
	      };


	# Center given box on given point:
	#
	fun center_box
            ( xg::BOX   { wide, high, ... },
              xg::POINT { col, row }
            )
	    = 
	    xg::BOX
	      { wide,
		high,
		col => col - (wide / 2),
		row => row - (high / 2)
	      };


	fun make_plaid_widgettree  root_window
	    =
	    {   bounds = wg::make_tight_size_preference (300, 200);

		sz::make_loose_size_preference_wrapper
		    (wg::make_widget
		      {
			root_window,
			size_preference_thunk_of =>  .{ bounds; },
			args                     =>  .{ { background => NULL }; },
			realize                  => realize_plaid
		      }
		    );
	    }
	    where
		screen = wg::screen_of root_window;
trace .{ "make_plaid_widgettree/AAA..."; };

		pen = xd::make_pen [
                                     xd::FOREGROUND (xc::rgb8_from_int 0xFF0000),	# Was xc::rgb8_color1
				     xd::FUNCTION   xd::OP_XOR
				   ];
trace .{ "make_plaid_widgettree/BBB..."; };
		idle_pen = pen;

trace .{ "make_plaid_widgettree/CCC..."; };
		timeout' =  timeout_in' (time::from_milliseconds 100);

		fun realize_plaid { window, size, kidplug }
		    =
		    {   make_thread "plaid" .{ do_idle size;  };
			();
		    }
		    where
trace .{ "realize_plaid/AAA..."; };
			drawwin     = xd::drawable_of_window  window;

trace .{ "realize_plaid/BBB..."; };
			autodrawwin = xd::make_unbuffered_drawable  drawwin;

trace .{ "realize_plaid/CCC..."; };
			idle_fill = xd::fill_boxes drawwin     idle_pen;
trace .{ "realize_plaid/DDD..."; };
			fill      = xd::fill_boxes autodrawwin idle_pen;

trace .{ "realize_plaid/EEE..."; };
			my xi::KIDPLUG { from_mouse', from_other', ... }
			    =
			    xi::ignore_keyboard  kidplug;

trace .{ "realize_plaid/FFF..."; };
			fun do_active (size as xg::SIZE { wide, high } )
			    =
			    start_over ()
			    where
trace .{ "do_active/AAA..."; };
				my middle as (xg::POINT { col=>midx, row=>midy } )
				    = 
				    xg::box::middle (xg::box::make (xg::point::zero, size));


trace .{ "do_active/BBB..."; };
				# Given a point (x,y) with a velocity (dx,dy),
				# make it bounce off walls to stay within
				#    0 < x < wide
				#    0 < y < high
				# by appropriately adjusting point and velocity
				# whenever it strays outside that area:	
				#
				fun bounce_if_outside_box
                                    (arg as ( xg::POINT { col=>x,  row=>y },		# Position.
					      xg::POINT { col=>dx, row=>dy }		# Velocity.
				    )       )
				    =
				    if   (x < 0)     bounce_if_outside_box (xg::POINT { col=> -x,             row=>  y             }, xg::POINT { col=> -dx, row=>  dy } );
				    elif (x >= wide) bounce_if_outside_box (xg::POINT { col=> 2*wide - x - 2, row=>  y             }, xg::POINT { col=> -dx, row=>  dy } );
				    elif (y < 0)     bounce_if_outside_box (xg::POINT { col=> x,              row=> -y             }, xg::POINT { col=>  dx, row=> -dy } );
				    elif (y >= high) bounce_if_outside_box (xg::POINT { col=> x,              row=> 2*high - y - 2 }, xg::POINT { col=>  dx, row=> -dy } );
				    else arg;
				    fi;


				# Step point by one velocity increment,
				# bouncing off any wall(s) encountered:
				#
				fun step_point (point, velocity)
				    =
				    {   point = xg::point::add (point, velocity);		# Move point one increment.
					#
					my (point, velocity)
					    =
					    bounce_if_outside_box (point, velocity);

					(point, velocity);
				    };
		
				# Step point, bouncing off walls,
				# and on odd cycles draw to display:
				#
				fun step_state { point, velocity, last_box, odd_cycle }
				    =
				    {   # Move the point per velocity,
					# bouncing off walls appropriately:
					#	
trace .{ "step_state/AAA..."; };
					(step_point (point, velocity))
					    ->
					    ( point  as  xg::POINT { col, row },
                                              velocity
                                            );
					    

trace .{ "step_state/BBB..."; };
					# Map 'point' into the fourth quadrant, then
					# define a box with that as one corner and
					# (0,0) as the other:
					#
					box = xg::BOX
						 { col  => 0,
						   row  => 0,
						   #
						   wide => 2 * abs(col - midx),
						   high => 2 * abs(row - midy)
						 };

trace .{ "step_state/CCC..."; };

					# Center above box on middle of drawing_window:
					#
					box = center_box (box, middle);

trace .{ "step_state/DDD..."; };
					if odd_cycle
					    #
					    fill (xg::box::xor (box, last_box));
					fi;

trace .{ "step_state/EEE..."; };
					{ point,
                                          velocity,
                                          last_box  =>  box,
                                          odd_cycle =>  not odd_cycle
                                        };
				    };


				fun do_mom (xi::ETC_REDRAW _)                              =>  start_over ();
				    do_mom (xi::ETC_RESIZE (xg::BOX { wide, high, ... } )) =>  do_active (xg::SIZE { wide, high } );
do_mom xi::ETC_OWN_DEATH => { print "do_active: do_mom: ETC_OWN_DEATH ignored\n"; (); };
				    do_mom _					           =>  ();
				end

				also
				fun active_loop state
				    = 
				    select [    timeout'     ==>  .{  active_loop (step_state state);  },
						from_other'  ==>  do_mom o xi::envelope_contents,
						from_mouse'  ==>  (fn mail =  case (xi::envelope_contents  mail)
										  #
										  xi::MOUSE_FIRST_DOWN _ =>  do_idle      size;
										  _                      =>  active_loop  state;
									      esac
								  )
				    ]

				also
				fun start_over ()
				    =
				    {
trace .{ "start_over/AAA..."; };
					xd::clear_drawable  drawwin;

trace .{ "start_over/BBB..."; };
					active_loop
					  {
					    point     =>  middle,
					    last_box  =>  empty_box,
					    odd_cycle =>  FALSE,
					    velocity  =>  xg::POINT { col=>1, row=>1 }
					  };
				    };
			    end			# fun do_active

			also
			fun do_idle (size as xg::SIZE { wide, high } )
			    =
			    idle_loop ()
			    where

				fun redraw ()
				    =
				    {
trace .{ "do_idle: redraw/AAA..."; };
					xd::clear_drawable  drawwin;
					redraw_loop 1;
				    }
				    where	
trace .{ "do_idle: redraw/BBB..."; };
					bound = int::min (wide, high) / 2;
trace .{ "do_idle: redraw/CCC..."; };

					fun redraw_loop i
					    = 
					    if (i <= bound)
						#
trace .{ "do_idle: redraw_loop/AAA..."; };
						idle_fill
						  [
						    xg::BOX { col=>i,            row=>i,            wide=>1,          high=>high-(2*i) },
						    xg::BOX { col=>wide - i - 1, row=>i,            wide=>1,          high=>high-(2*i) },
						    xg::BOX { col=>i,            row=>i,            wide=>wide-(2*i), high=>1 },
						    xg::BOX { col=>i,            row=>high - i - 1, wide=>wide-(2*i), high=>1 }
						  ];

trace .{ "do_idle: redraw_loop/BBB..."; };
						redraw_loop (i+2);
					    fi;

				    end;


				fun do_mom (xi::ETC_REDRAW _)                              =>  redraw ();
				    do_mom (xi::ETC_RESIZE (xg::BOX { wide, high, ... } )) =>  do_idle (xg::SIZE { wide, high } );
do_mom xi::ETC_OWN_DEATH => { print "do_idle: do_mom: ETC_OWN_DEATH ignored\n"; (); };
				    do_mom _						   =>  ();
				end;


				fun idle_loop ()
				    = 
				    select [ from_other' ==>  idle_loop  o  do_mom  o  xi::envelope_contents,
					     #
					     from_mouse' ==>  (fn envelope = case (xi::envelope_contents  envelope)
										  #
										  xi::MOUSE_FIRST_DOWN _ =>  do_active size;
										  _                      =>  idle_loop ();
									      esac

							      )

				    ];
			    end;					# fun do_idle
		    end;						# fun realize_plaid
	    end;							# fun make_plaid_widgettree


	fun plaid_app root_window
	    =
	    {   name = wy::make_view
			 { name    =>   wy::style_name [],
			   aliases => [ wy::style_name [] ]
			 };

		style = wg::style_from_strings (root_window, []);

		view = (name, style);

		plaid_widgettree =  make_plaid_widgettree  root_window;

		args = [ (wa::title,     wa::STRING_VAL "Plaid"),
			 (wa::icon_name, wa::STRING_VAL "Plaid")
		       ];

		topwindow
		    =
		    top::topwindow  (root_window, view, args)  plaid_widgettree;

		top::start  topwindow;

		close_window' =  top::get_''close_window''_mailop  topwindow;

		make_thread "window closer" .{
		    #
		    select [
			close_window'
			    ==>
			   .{
print "ATTEMPTING TO CLOSE WINDOW.\n";
				topwindow::destroy  topwindow;
				shut_down_thread_scheduler  winix::process::success;
			    }
		    ];	
		};

		();
	    };

	fun set_up_tracing ()
	    =
	    {   # Open tracelog file and
		# select tracing level:
		#
		include tracing;				# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg
		#
printf "plaid-app: do_it': Creating new %s file...\n" tracefile;
		log_trace_messages  (TO_FILE tracefile);
		enable all_tracing;				# Gross overkill.
	    };

	fun do_it' (debug_flags, server)
	    =
	    {   set_up_tracing ();

		xtracing::init debug_flags;

		rx::run_xkit'
		    #
		    plaid_app
		    #
		    { display => THE server,
		      time_quantum_in_milliseconds => NULL
		    };
	    };


	fun do_it ()
	    =
	    {   set_up_tracing ();
		#
		rx::run_xkit  plaid_app;
	    };


	fun main (program ! server ! _, _)
		=>
		do_it' ([], server);

	    main _
		=>
		do_it ();
	end;
    };				# package plaid
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1991, 1995 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
