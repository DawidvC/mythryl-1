C-GLUE-LIB library and C-GLUE-MAKER glue code generator
====================================================

A very incomplete introduction
(by Matthias Blume (blume@research.bell-labs.com))

   WARNING:  This currently works on x86/Linux only.

The Mythyrl FFI ("foreign function interface") is based on the
idea of data-level interoperability:  Mythryl code (a mixture of
pre-defined code imported from $ROOT/src/lib/c-glue-lib/c.make7,
code generated by c-glue-maker, and code the user writes) operates
directly on C datastructures without any marshalling/unmarshalling.

There are no C stub routines (no C glue code at all), and very
little code on the Mythryl side, just enough to deal with "new"
types (struct/union), with generating code for C function calls,
and with dynamic linking.

There are three libraries that are part of c-glue-lib, accessible
from Make7 as:
    $ROOT/src/lib/c-glue-lib/c.make7
    $ROOT/src/lib/c-glue-lib/internals/c-internals.make7
    $ROOT/src/lib/c-glue-lib/memory/memory.make7
but a user of this interface only needs the first.

Library $ROOT/src/lib/c-glue-lib/c.make7 implements an encoding of
the C type system in Mythryl types.  This is exported as package 'c'.
For details on package 'c', see $ROOT/src/lib/c-glue-lib/c.api.

Moreover, there is a package dynamic_linkage that handles dynamic linking:
    $ROOT/src/lib/c-glue-lib/memory/linkage.api
    $ROOT/src/lib/c-glue-lib/memory/linkage-dlopen.pkg

Thanks to Mythryl's type inference, the FFI user will usually not need
to spell out many (if any) of the (rather complicated!) types exported
by package 'c'.

Conversely, at least in theory, if you are a competent Mythryl programmer
but don't know C, then you could simply run the C code through
c-glue-maker and read the apis it produces...

--------------------------------------------------------------------

An example:

Suppose you have a shared library nodelist.so that exports a global
function to generate lists of nodes.  A C header file node.h explains
the interface:

   struct node {
     int i;
     struct node *next;
   };

   /* Produce n-element node list where first node's i is 'first',
    * and where (x->next->i - x->i == incr) for all nodes except the
    * last: */
   struct node *gen (int n, int first, int incr);

We run this header file through our FFI generator:

   $ c-glue-maker node.h

The result is a new Make7 library described by node.h.make7 (which, in turn,
is implemented by node.h.api and node.h.pkg).  The library exports a
package 'node' which contains a package macro node_fn.  We need to write some
Mythryl glue code to instantiate this package macro.  In simple cases like ours,
the only argument the package macro needs is a handle on the dynamic library
(nodelist.so).  So we make a file node-glue.pkg and write:

  package node
      =
      node::node_fn (
          my library
              =
              dynamic_linkage::open_lib
                  { name   =>  "./nodelist.so",
	  	    global =>  TRUE,
		    lazy   =>  TRUE
                  }
      )

[Package dynamic_linkage is an interface to dlopen/dlsym.  To get access
to symbols that are already linked into the main program (e.g., the
runtime system), use dynamic_linkage::main_lib.]

With this preparation we can now write a "client" module
(node-client.pkg) that contains code to inspect results from calling
function gen.  As an example, let us write two functions "len" and
"sum" which calculate the length of a list and the sum of a list's
elements, respectively, as well as a procedure "increment_all" which
traverses a list and increments every "i":

package node_client
    =
    pkg
	fun len l
            =
	    if   c::ptr::is_null l
            then
                 0;
	    else
                 1 + len (c::get::ptr (node::s_node::f_next (c::ptr::deref l)));
            fi;

	fun sum l
            =
	    if   c::ptr::is_null l
            then
                 0;
	    else
                 n = c::ptr::deref l;
		 i = c::cvt::ml_sint (c::get::sint (node::s_node::f_i n));
		 next = c::get::ptr (node::s_node::f_next n);
		 i + sum next;
	    fi;

	fun increment_all l
            =
	    if   not (c::ptr::is_null l)
            then 
                 n      =  c::ptr::deref l;
		 ichunk =  node::s_node::f_i n;
		 i      =  c::cvt::ml_sint (c::get.sint ichunk);
		 next   =  c::get::ptr (node::s_node::f_next n);

		 c::set::sint (ichunk, c::cvt.c_sint (i + 1));

		 increment_all next;
	    fi;
    end

Notice how a combination of operators from the predefined package 'c'
(exported from $ROOT/src/lib/c-glue-lib/c.make7 and operations from
package 'node' (resulting from our instantiation of the
C-GLUE-MAKER-generated package macro node::node_fn) was sufficient
to traverse and inspect a C data structure, and to even modify it.

Here is the key to this code:

   Mythryl                            C

   c::ptr::is_null <ptr>              <ptr> == NULL
   c::ptr::deref <ptr>                *<ptr>
   node::s_node::f_next <struct>      <struct>.next
   c::get::<foo> <chunk>              (lvalue in an rvalue context;
                                      this is a fetch from memory which in C
                                      happens implicitly when an lvalue turns
                                      into an rvalue)
   c::set::<foo> (<chunk>, <value>)   <lvalue> = <rvalue>;
   c::cvt::ml_<foo> <value>           abstract C value -> concrete Mythryl value
   c::cvt::c_<foo> <value>            concrete Mythryl value -> abstract C value

We can wrap all this up and make it into a Make7 library (node.make7):

  LIBRARY_EXPORTS

	package node
	package node_client


  LIBRARY_COMPONENTS

	$ROOT/src/lib/std/stdlib.make7
	$ROOT/src/lib/c-glue-lib/c.make7

	node.h.make7
	node-glue.pkg
	node-client.pkg

Another way of doing this -- automating the task of invoking
c-glue-maker -- would be:

  LIBRARY_EXPORTS

	package node
	package node_client


  LIBRARY_COMPONENTS

	$ROOT/src/lib/std/stdlib.make7
	$ROOT/src/lib/c-glue-lib/c.make7

	node.h : shell (target:node.h.make7
                        c-glue-maker %s)
	node-glue.pkg
	node-client.pkg

-------------------------------------------------------------------------
Despite the fact that one usually does not need to deal with types
very much (thanks to Hindley-Milner type inference), I will now briefly describe
the main ideas behind the types of the 'c' module.  I will generally
omit the "c::" prefix, assuming a global "include c;" to be in effect.

   1. Chunks:

   Chunks describe locations in memory that hold values of some C
   type.  (This roughly corresponds to C's notion of lvalues, although
   not every chunk can appear on the left-hand side of an assignment
   operator.  For example, array chunks cannot.)

   1.1 Chunk types:

   The type of a chunk is

        Chunk (T, C)

   Here, T is a "phantom type" that describes the type of the value
   stored in the chunk and C is the "constness" of the chunk (i.e.,
   "Ro" or "Rw" --- depending on whether there was a "const" qualifier
   in the C declaration or not).

   1.2. Fetching and storing:

   For certain types T, there are fetch and store operations for the
   corresponding chunks.  See subpackages "get" and "set".

   If a type T has fetch/store operations for Chunk(T, ?), then we
   call values of type T "first-class C values".  For first-class
   values, the phantom type coincides with the type of the value.  (For
   other (second-class) values, the phantom type is a true phantom
   type because there are no constructable values.  Second-class C
   values do not exist outside of their corresponding chunks.)

   2. Base types:

   Base types to be substituted for T and their corresponding C types
   are given below:

      Mythyrl    C

      Schar      signed char
      Uchar      unsigned char
      Sint	 signed int
      Uint	 unsigned int
      Sshort	 signed short
      Ushort	 unsigned short
      Slong	 signed long
      Ulong	 unsigned long
      Float	 float
      Double	 double
      Voidptr	 void *

   Notice that there is no equivalent for "void" since it is not a
   "true" type in C but has many different meanings depending
   on the context in which it is used.

   All types given above are abstract.  To convert to or from concrete
   Mythryl types, use cvt::ml_<foo> and cvt::c_<foo>.  These routines exist
   for all of the above types except Voidptr.  They convert to and
   from certain INTEGER, WORD, and REAL types which are collectively
   defined in package mlrep.  For example, the x86 version of
   package mlrep::Sint is the same as Int32 and mlrep::Float as well
   as mlrep::Double are the same as Real64.  (Notice that the Mythryl
   representation type for different C types can be the same, but the
   C types themselves are kept distinct to enforce a typing discipline
   that is equivalent to what a C compiler would do.)

   3. Pointers:

   Pointers are first-class C types.  Their Mythryl type is

      Ptr (T, C)

   A pointer of type Ptr(T, C) points to a chunk of type
   Chunk (T, C).  One can obtain the chunk by applying the ptr::deref
   operator.  ptr::enref goes the other direction.

   Pointers permit pointer arithmetic just as in C using ptr::plus
   (for adding an integer to a pointer) and ptr::diff (for subtracting
   two pointers).  A pointer can be injected into the Voidptr domain
   using ptr::inject.  (It can also be recovered from the Voidptr domain
   using ptr::cast, but this requires run-time type information. See below.)

   Since they are first-class, pointers can be fetched from and stored
   into pointer chunks of type Chunk(Ptr(T, P_c), C),
   where P_c is the constness of the chunk pointed to by the pointer
   and C is the constness of the chunk containing the pointer.

   The ptr::sub operation is a shorthand for a combination of ptr::plus
   and ptr::deref.  (Or, alternatively, ptr::deref is the same as
   fn p = ptr::sub (p, 0).)

   4. Arrays:

   Arrays are second-class values.  Their (phantom) type is

     Arr (T, N) 

   Here, T is the type of the values stored in the array's individual
   elements and N is a type describing the size of the array.

   4.1.  Array dimensions:

   The 'dim' subpackage defines an infinite family of types in such a
   way that there is a 1-1 correspondence between natural numbers and
   this family.  In particular, if a positive natural number is
   written in decimal and without leading zeros as <dn>...<d1><d0>,
   where <di> are decimal digits, then the corresponding 'dim' type is

      Dec Dg<dn> ... Dg<d1> Dg<d0> Dim

   which happens to be an abbreviation for
      
      Dim0 (Dec Dg<dn> ... Dg<d1> Dg<d0>, Nonzero)

   (If you are wondering: The type corresponding to 0 is Dim0 (Dec, Zero).)

   The connection to array types is this:  An array of size N has type

      Arr (T, [N]) 

   iff "Dim [N]" is the type assigned to N by our Dim construction.

   Example (assume "include dim;"):

   The C type (int[312]) is encoded as

       Arr (Sint, Dec Dg3 Dg1 Dg2)

   In other words, if you "squint away" the "Dec", the "Dg"s, and the
   spaces, then the array dimension gets spelled out in decimal.

   4.2. Operations over arrays:

   Since array types are second-class, there are no operations that
   produce or consume values of type Arr (?, ?).  Instead, we use
   array chunks of type Chunk ( Arr(?, ?), ?).

   Most operations related to array chunks are in subpackage 'arr'.

   Array subscript takes an array chunk and an integer i and produces
   the chunk describing the i-th element of the array.  It is
   implemented in such a way that it performs bounds-checking: if i<0
   or i>=N where N is the array's size, then general::SUBSCRIPT will be
   raised.

   To get C's behavior (no bounds checks), one can use pointer
   subscript instead.  This requires one to first let the array "decay"
   into a pointer to its first element.  In C this happens implicitly
   in many situtations, but in Mythryl one must ask for it explicitly by
   invoking arr::decay.

   Given a value of type dim::Dim(N) one can reconstruct the array from
   the pointer to its first element.

   5. Function pointers:

   Function pointers have type Fptr(F) where F is always instantiated
   to (A -> B) for some A and B.

   A function pointer of type Fptr(A -> B) can be invoked with an
   argument of type A and yields a result of type B by invoking the
   "call" operator:

       call:  (Fptr(A -> B), A) -> B

   Function pointers are first-class C values and can be stored in
   function-pointer-chunks as usual.

   The C-GLUE-MAKER program generator tool will arrange for every C
   function prototype that occurs in a given piece of C code to define
   a corresponding Fptr (A -> B)  type.  Here, A is derived from the
   argument list of the C function and B describes the result type.
   In particular, here is what happens:

       0. Vararg functions are not handled.

       1. If the argument list is (void) and the result type is not a
       struct or union type, then A is Void.

       2. For the case of non-empty argument lists where the types of
          the arguments are C types t1 ... tk, we form a "preliminary
	  Mythryl argument list" [t1] ... [tk] as follows:
          - If ti is a first-class C type, then [ti] is the
	    (light-weight version (see below) of the) corresponding
            Mythryl type describing it.
          - Otherwise, ti must be a struct or union type.  For each
            struct or union type, the C-GLUE-MAKER tool will generate a new
            fresh phantom type X (as described later).  A function
            argument of such a type will be  Chunk'(X, Ro).  That
            is, on the Mythryl side the function will expect a read-only
            struct or union chunk.
            (Notice the primed type "Chunk'"! We pass structs in
             light-weight form.  For an explanation of "light-weight",
             see the discussion below.)

       3. If the result is of struct or union type Y, then an additional
          argument of type Chunk'(Y, Rw) is prepended to the
          preliminary argument list.  This means that on the Mythryl side
          functions "returning" a struct or union must be passed a
	  corresponding writable struct or union chunk. 

       4. Let the final argument type list (formed in step 2. or 3.) be
          x1 ... xn.  Type A will be the tuple (x1, ... xn).  In
          particular, if there is only one type x1, then A = x1.

   The result type B is formed as follows:

       1. If the C return type is "void", then B is "Void".
       2. If the C return type is a struct or union, then B
          coincides with the type of the first argument, i.e.,
          it is the same as the first element of the tuple that is A.
          (On the Mythryl side, the function, when called, will return its
           first argument after having stored the struct or union
           that was returned by the C function into it.)
       3. Otherwise the return type must be a first-class C type and
          B will be that type's (light-weight) Mythryl-side representation.

   6. Run-time type information:

   For every chunk of type Chunk(T, C)  there is corresponding
   RTTI (Run-Time Type Information) that describes values of type T.
   RTTI is used mainly to keep track of size information (needed
   for pointer arithmetic), but it also facilitates array bounds checking.

   Most of the time this information is kept completely behind the
   scenes, but in some situations the programmer might want to use it
   directly.

   In the part of the interface described to this point,
   there is really only one place that requires run-time type
   information: ptr::cast.  A Voidptr together with type information
   describing a non-void pointer's target type can be used to "cast" the
   Voidptr to that pointer type.

   RTTI is used extensively in the other "light-weight" part of the
   interface.  (See below.)  It can be extracted from existing chunks
   using t::typeof or can be constructed directly using the value
   constructors of subpackage(s) 't' (and 'dim').

   Example, RTTI for a 12-element array of pointers to constant ints:

              {
                  include c;
                  include dim;
                  t::arr (t::ro (t::ptr t::sint), dec dg1 dg2 dim)
              }

   (Note: The "dec dg1 dg2 dim" in the example above is an
    _expression_ that returns a dim::Dim _value_.  And, by construction,
    the type of that expression also happens to be "Dec Dg1 Dg2 Dim".)

   7. Light-weight interface:

   The concrete representation for values of chunk-, ptr-, and fptr-type
   carries run-time type information.  This makes the interface
   convenient to use, because RTTI is hidden behind the scenes.  It is
   also somewhat inefficient because RTTI must be tracked (and operated
   upon) by most operations.

   Light-weight versions of these types (constructors carry a prime in
   their names: "Chunk'", "Ptr'", "Fptr'") do not use RTTI in their
   concrete representations.  This is more efficient for all
   operations that don't need access to RTTI.  On the downside, it
   means that RTTI must be passed in explicitly by the programmer for
   operations that do.

   To make passing of type information statically safe (i.e., to
   disallow mixing a C value of one type with type information
   corresponding to a different type), RTTI itself has a static Mythryl
   type.  In particular, the RTTI for a value stored in a
   "Chunk(T, C)" chunk will have type "t::Typ T".

   Array subscript, to name one example, on light-weight array chunks
   enforces correct usage of RTTI using Mythryl's static typing:

	arr.sub' : t::Typ Arr (T, N)  ->
		   (Chunk' (Arr(T, N), C), Int) ->  Chunk' (T, C)

   7.1 Light vs. heavy:

   One can convert between light and heavy versions by using the
   functions in subpackages 'light' and 'heavy'.

   7.2 Slimmed-down RTTI: Run-time size information

   Our RTTI contains a lot of information that is not needed in many
   situations.  For example, we can extract RTTI for a pointer's
   element type from the RTTI for the pointer type.  In many cases all
   we need is _size_ information (which, internally, is just number).
   Definitions pertaining to run-time size information are collected
   in subpackage 's'.  Like RTTI itself, we give static types to sizes:
    
         type Size(T)

   Size information can be obtained from RTTI (but not vice versa):

         t::sizeof : t::Typ(T) -> s::Size(T)

   Light-weight pointer arithmetic uses size information for the
   element type:

         ptr::plus' : s::Size(T) ->  (Ptr'(T, C), Int) -> Ptr'(T, C)

   (Rationale: C types are monomorphic. In Mmythryl programs we can precompute
    size info for any monomorphic type, so with a bit of help from a
    cross-module inliner and the compiler's value-propagation- and
    constant-folding phases we should see machine code very similar to
    what a C compiler would produce.)

   8. Struct- and union-types:

   A struct- or union-declaration in C declares a brand-new type.  In
   C, struct- and union-types are of class "one-and-a-half", so to
   speak.  They are not truly first-class because the only operations
   on values of these types end up being what amounts to "copy"
   operations from chunks to other chunks.  Struct/union- assignment
   is clearly in this category and passing structs/unions as function
   arguments is essentially the same. (Passing the argument amounts to
   copying the struct/union into the chunk that gets allocated for
   the corresponding formal parameter.)  The only exception seems to
   come from struct/union return values, but C compilers tend to
   implement this by allocating a new (unnamed) struct chunk for
   holding the return value, so that struct/union return also amounts
   to copying into struct/union chunks.

   For these reasons (and to avoid having to implement a struct/union
   value type), we treat struct/union types as second-class
   types and provides copy operations separately.  The treatment of
   function calls involving struct/union types has already been
   described above.

   On the Mythryl side, each struct/union type is implemented as an
   abstract data type.  The type definition as well as operations over
   chunks involving this type are generated by the C-GLUE-MAKER tool.

   Consider once again our introductory example:

             struct node {
                int i;
                struct node*  next;
             };

   The Mythryl-side equivalent to this is an abstract type "Su S_Node"
   (which will be the phantom type for struct node) and a
   corresponding package "s_node" that contains operations for this
   type.  (For a union, replace "s_" with "u_" and "S_" with "U_".)

   The api for s_node generated by C-GLUE-MAKER will be the
   following (note that it makes use of several type abbreviations
   that are provided by C-GLUE-LIB):

   package s_node : sig /* struct node */
        Tag = S_Node;
        
        # Size for this struct:
        size:  s::Size Su S_Node; 
        
        # RTTI for this struct:
        typ : t::Typ Su S_Node
        
        # Witness types for fields:
        T_F_I = Sint;
        T_F_Next = Ptr (Su S_Node, Rw);
        
        # RTTI for fields:
        typ_f_i : t::Typ Sint;
        typ_f_next:  t::Typ Ptr (Su S_node, Rw);
        
        # Field accessors:
        f_i :  Su_Chunk (S_Node, C) -> Sint_Chunk Ro;
        f_next :  Su_Chunk (S_Node, C) ->  Chunk (Ptr(Su S_Node, Rw), C);
        
        # Field accessors (lightweight variety):
        f_i' :  Su_Chunk'( S_Node, C) -> Sint_Chunk' Ro;
        f_next' :  Su_Chunk'(S_Node, C) ->  Chunk'( Ptr(Su S_Node, Rw), C);
    end # package s_node

   We find RTTI and size info for the new type, RTTI for all the
   field's types, and access methods that map struct chunks to
   corresponding field chunks.  Access methods are provided both in
   normal and in light-weight form.

   The access method for a field declared "const" maps struct chunks
   of arbitrary constness to field chunks where C is instantiated
   with "Ro".  The access method for other fields maps the constness
   for the whole struct chunk to the constness of the field chunk.
   The name of an access method is the name of the field prepended
   with "f_" (and followed by "'" in case of the light-weight version).
   The reader can probably infer the other naming conventions from the
   example.

   Bitfields (not shown here) are special because they are not
   first-class values and there are no ordinary chunks that hold
   bitfields. C-GLUE-LIB provides separate abstract types for signed and
   unsigned bitfields, and access methods for C bitfields map the
   struct chunk to such (Mythryl) bitfields.

   8.1 Equivalence of struct/union types:

   It is not literally true that C-GLUE-MAKER will generate a brand-new
   type for every struct or union it sees.  Instead, it draws from
   another infinite family of abstract "tag types" which has been
   predefined.  (This works in a way similar to dim::Dim.)

   As a result, two separate mentions of struct foo in different C
   source files that belong to the same program will produce Mythryl
   code which still identifies these two struct foos.

   9. Global exports and their types:

   9.1 Global variables:

   Global variables will be represented by a corresponding thunkified
   chunk.  The thunk's name is the same as the variable's name
   prepended with "g_".
   Examples:

      C                   Mythryl

      int i;              g_i : Void -> Chunk (Sint, Rw);
      const unsigned j;   g_j : Void -> Chunk (Uint, Ro);
      int (**f)(void);    g_f : Void -> Chunk (Ptr(Fptr(Void -> Sint), Rw), Rw);

   (Fortunately, the types will all be generated by C-GLUE-MAKER, so
   the programmer will not have to write down ugly things like the
   type for f.)

   9.2 Global functions:

   Exported C functions will be represented by three distinct Mythryl
   values:

      1. A thunkified fptr value of corresponding type.  The name of
         the thunk is "fptr_fn_" concatenated with the name of the
         function.

      2. A Mythryl function that takes an argument list similar to the
         fptr in 1., but where those arguments/results that have a
	 corresponding concrete Mythryl representation (in mlrep, via
	 subpackage cvt) have already been translated and
	 light-weight struct/union chunks (for passing/returning
	 structs and unions) have been translated to their heavy
	 versions.  The name of the Mythryl function is the name
         of the C function prepended with "fn_".

      3. A Mythryl function as in 2., but with all arguments/results
         that have a light-weight version having been translated to
	 that.  The name of the Mythryl function is the same as that in
         2. but with a trailing apostrophe ("'") added.

   To see the difference between 1. and 2./3., consider a C function
   from int to int.  The Mythryl fptr type would be

         Fptr (Sint -> Sint)

   and calling it via "call" requires an abstract "Sint" argument.
   Type "Sint" is not equal to its Mythryl representation type
   (mlrep::sint::Int = int32::Int), so in order to pass a Mythryl int32::Int
   value one must apply cvt::c_sint "by hand".
   (The reason for "Sint" not being equal to int32::Int is that the
   representation types for other abstract C types might also be
   int32::Int.  For example, the current implementation uses
   mlrep::sshort::Int == int32::Int which would force Sint == Sshort
   had the C types not been abstract.  But we definitely want to have types
   Sint and Sshort be distinct!)

   9.4: Persistence of C values:

   C values are transient in that they do not stay valid across
   lib7::{spawn|fork}_to_disk and a restart using the resulting heap
   image.  The only things that stay valid are the thunks for global
   variables and global function pointers.  (Since global Mythryl functions
   generated to represent global C functions re-invoke the function-pointer
   thunk every time they are called, they also stay valid.)

   10. Package macro-ization:

   The C-GLUE-MAKER tool produces a package containing a package macro for
   every C source file it is presented with.  The package macro will at least
   take the library argument shown in the example.  However, there are
   cases when it requires additional arguments.

   Extra package macro arguments are required every time the C source file
   refers to "incomplete pointer types" -- pointers to structs that
   are not declared.

   For example, if the source file mentions "struct foo*" without
   spelling out what "struct foo" is, then the resulting package macro will
   take an argument of the form:

      package i_s_foo: Pointer_To_Incomplete_Type;

   That is, the package macro argument must be a package satisfying
   api Pointer_To_Incomplete_Type.

   There are two ways of obtaining a matching package for the
   purpose of passing it to the package macro:

     1. If the type is to be treated as "abstract", then a fresh
        incomplete pointer type can be obtained by invoking package macro
        pointer_to_incomplete_type (without arguments).
        If the same incomplete type is mentioned in more than one place,
        make sure you generate only one fresh instantiation for it,
        i.e., invoke pointer_to_incomplete_type only once and pass the
        result to all generics that require it.

     2. If the type is incomplete in one file but gets spelled out in
        another, then one can produce the matching package from
        the latter by applying package macro pointer_to_complete_type to the
        package s_foo that describes "struct foo".

        Suppose module 'bar' defines struct 'foo'.  Then we have a
        package 'bar' and a package macro 'bar::bar_fn' which, when applied,
        would define package 's_foo'.  pointer_to_complete_type could be
        applied to this package. However, there is a partial version
        of the same package (only containing a type definition and
        some RTTI) known as 'bar::s_foo'.  The partial version is
        sufficient for invoking pointer_to_complete_type -- which is
        important to break dependency cycles and avoid the
        chicken-and-egg problem in the case of mutually recursive
        types involving incomplete pointers.

        The main point of using pointer_to_complete_type is to let
        client code "see" that i_s_foo::Iptr(C) is the same as
        Ptr(Su S_Foo, C).

        Client code that must be written without the benefit of having
        access to the real definition of struct 'foo' but which must
        leave open the possibility of interacting with other code that
        does must itself be in the form of a package macro, leaving the
        instantiation of i_s_foo to _its_ clients.

----------------------------------------------------------------

Invoking c-glue-maker:

The C-GLUE-MAKER tool is a stand-alone program c-glue-maker which can be
invoked from the shell command line. It takes one mandatory argument
<cfile> which is the file name of the C language .h file that describes
the interface to be implemented.

The mandatory argument can be preceded by any combination of the
following options:

  -sigfile <file>                 name of the api file to be generated
                                  (default: <cfile>.sig)

  -strfile <file>                 name of the package file to be generated
                                  (default: <cfile>.sml)

  -cmfile  <file>                 name of the make7 file to be generated
                                  (default: <cfile>.make7;
                                   This is the file that needs to be mentioned
                                   in the client make7 file.  See node.h.make7
                                   vs. node.make7 in our example.)

  -signame <name>                 name of the api to be generated
                                  (The default is obtained by taking <cfile>,
                                   stripping the extension, capitalizing
                                   all letters, and turning embedded dots
                                   and dashes into underscores.
                                   Example: f.oo-bar.h --> F_OO_BAR)

  -strname <name>                 name of the package to be generated
                                  If the package's name is <foo>, then
                                  the name of the generic contained therein
                                  will be <foo>Fn.
                                  (The default is obtained by taking <cfile>,
                                   stripping the extension, dividing the
                                   remainder into sections at dot- and 
                                   dash-boundaries, capitalizing the first
                                   letter of each section, and then joining
                                   them.
                                   Example: foo-bar.h --> FooBar)

  -allSU                          Normally the tool will treat all
                                  struct or union definitions that are
                                  not spelled out in <cfile> as
                                  incomplete (even if <cfile> includes
                                  a header file that spells them out).
                                  This flag will force c-glue-maker to
                                  treat included header files the same
                                  as <cfile>.
                                  (Structs and unions whose tags start with
                                  an underscore are _always_ treated as
                                  incomplete.)

  -width                          Maximum text width for pretty-printing
                                  generated Mythryl code.  The pretty-printer
                                  occasionally overruns this limit, however.

  -lambdasplit <arg>              places "(lambdasplit:<arg>)" after
                                  the names of source files in the
                                  generated .make7 file. (This controls
                                  the cross-module inlining machinery
                                  of the compiler.)
