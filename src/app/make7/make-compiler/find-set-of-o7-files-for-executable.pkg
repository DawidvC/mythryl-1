## find-set-of-o7-files-for-executable.pkg
## (C) 1999 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)

# Compiled by:
#     src/app/make7/Make7.make6



# A Lib7 "executable" is really the heap image from a running
# process, saved on disk:  the only way to run it is to have
# bin/runtime7 load it into memory and continue execution.
#
# (These "executable" files have "#!/usr/bin/runtime7" lines at
# the top to make this process transparent to the casual user.)
#
# Building such an "executable" file involves four basic steps:
#
# 1) Compile all the source files for the application
#    into .o7 files.  (We may optionally combine some
#    or all of these .o7 files into libraries.)
#
# 2) Make up a list of all the .o7 files needed
#    by the application.
#
# 3) Topologically sort this list by dependencies,
#    so that no .o7 file depends upon one later in
#    in the sequence.  (Later, by loading the .o7
#    files in this order, we will guarantee that
#    when each one executes, all the resources it
#    needs will be available.
#
# 4) Invoke the bare Lib7 runtime bin/runtime7
#    with --runtime-o7-files-to-load=OH7_FILES_TO_LOAD
#    where the latter file contains the above topologically
#    sorted list.  The last .o7 file in the list will
#    contain code to dump the heap image via lib7::spawn_to_disk
#    or a similar call.
#
# In this file we handle step (2) in the above sequence.
#
# Our main entrypoint is find_set_of_o7_files_for_executable.
#
# We are given as input the root node of the file
# dependency graph for the application.
#
# We traverse this graph to find all reachable nodes --
# which is to say, all .o7 files needed by the application --
# and return this list.


package find_set_of_o7_files_for_executable {

							# scan_dependency_graph		is from   src/app/make7/depend/scan-dependency-graph.pkg
    scan_dependency_graph
	=
    	scan_dependency_graph::scan_dependency_graph;


    Info = ICED_O7  iced_o7::Iced_O7
	 | BARE_O7  bare_o7::Bare_O7
         ;

    # Used (only) once, in make7-g.pkg,
    # to search library() return value:
    #
    fun same_info (ICED_O7 i )
                 (ICED_O7 i')
	    =>
	    iced_o7::compare (i, i') == EQUAL;

        same_info (BARE_O7  i )
                 (BARE_O7  i')
	    =>
	    bare_o7::compare  (i, i') == EQUAL;

        same_info           _            _ 
            =>
            FALSE;
    end;

    #
    fun find_set_of_o7_files_for_executable
            filepath_to_string
            dependency_graph_root
	=
	{   nil = { l  =>  [],
		    ss =>  iced_o7_set::empty
		  };
	    #
	    fun cons ( { x, s => NULL  }, { l, ss } ) =>   { l => x ! l, ss };
	        cons ( { x, s => THE i }, { l, ss } ) =>   { l => x ! l, ss => iced_o7_set::add (ss, i) };
            end;
	    #
	    fun a7file_info i
		=
		# Now we implement part of the kludge which lets
		# Lib7 code call functions in the C-coded runtime.
		# For details, see the comments in
		#     src/lib/core/init/runtime-system-placeholder.pkg
		# Here, when we hit the runtime-system-placeholder.pkg.o7
		# file, instead of writing out a normal line, we write out
		# a RUNTIME_SYSTEM_PICKLEHASH line.  Later,
		#     src/runtime/main/load-o7-files.c/load_o7_files()
		# will key on this to substitute the special C-coded runtime
		# exports list for that generated by runtime-system-placeholder.pkg.o7:
		#
		case (iced_o7::runtime_system_pid i)
		  
		    THE p
			=>
			{   x => ( ICED_O7 i,
				   "RUNTIME_SYSTEM_PICKLEHASH=" + picklehash::to_hex p
				 ),

			    s => NULL
			};

		    NULL
			=>
			{   x = cat [   filepath_to_string (iced_o7::freezefile_name i),
					"@",
					int::to_string (iced_o7::offset i),
					":",
					iced_o7::describe i
				    ];

			    s = case (iced_o7::sharing_mode i)
				    sharing_mode::DO_NOT_SHARE => NULL;
				    _                          => THE i;
                                esac;

			    { x => (ICED_O7 i, x),
			      s
			    };
			};
		esac;

	    #
	    fun bare_o7 i
		=
		{ x => (BARE_O7 i,  filepath_to_string (bare_o7::oh7_file_name i)),
		  s => NULL
		};

	    per_graph_node
                =
                { a7file_info,     #  What to extract from a built-library node.  
		  bare_o7,	   #  What to extract from other nodes.           
	          cons,            #  How to add one of above two to return my.  
		  nil              #  Initial return value.                       
	        };
	
	    # Process every node reachable
	    # from inter_library_dependency_graph node 'dependency_graph_root'
	    # and return resulting Cons-ed up result:
	    #
	    scan_dependency_graph::scan_dependency_graph
                per_graph_node
                dependency_graph_root;
	};
};


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
