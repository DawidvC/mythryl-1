## triangle-app.pkg
#
# This app displays a drawing window and a RESET button.
# It puts a triangle wherever the user clicks in the drawing window;
# It clears the drawing window when the RESET button is clicked.
#
# One way to run this app from the base-directory commandline is:
#
#     linux% my
#     eval: make "src/lib/x-kit/tut/triangle/triangle-app.make6";
#     eval: triangle_app::do_it "";

# Compiled by:
#     src/lib/x-kit/tut/triangle/triangle-app.make6

stipulate
    include make7::scripting_globals;
    include threadkit;					# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package xc  =  xcore;				# xdraw			is from   src/lib/x-kit/xclient/xcore.pkg
    package xd  =  xdraw;				# xdraw			is from   src/lib/x-kit/xclient/xdraw.pkg
    package xf  =  xfont;				# xfont			is from   src/lib/x-kit/xclient/xfont.pkg
    package xg  =  xgeometry;				# xgeometry		is from   src/lib/x-kit/xclient/xgeometry.pkg
    package xi  =  xinput;				# xinput		is from   src/lib/x-kit/xclient/xinput.pkg
    package xs  =  xselection;				# xselection		is from   src/lib/x-kit/xclient/xselection.pkg
    package xw  =  xwindow;				# xwindow		is from   src/lib/x-kit/xclient/xwindow.pkg
    package xau =  xauthentication;			# xauthentication	is from   src/lib/x-kit/xclient/src/stuff/xauthentication.pkg
    package xtr =  xtracing;				# xtracing		is from   src/lib/x-kit/xclient/src/stuff/xtracing.pkg
    #
    package che =  cartouche;				# cartouche		is from   src/lib/x-kit/draw/cartouche.pkg
    #
    package ib  =  icon_bitmap;				# icon_bitmap		is from   src/lib/x-kit/tut/triangle/icon-bitmap.pkg
    #
    tracefile   =  "triangle-app.trace.log";
    trace	=  xtr::print_if  xtr::io_tracing;	# Conditionally write strings to tracing.log or whatever.
herein

    package triangle_app: Triangle_App {		# Triangle_App		is from   src/lib/x-kit/tut/triangle/triangle-app.api


	min_wide =  300;
	min_high =  300;

	min_sz   =  xg::SIZE { wide => min_wide, high => min_high };

	button_wide = 100;
	button_high =  30;

	button_corner_radius = 8;


	run_selfcheck =  REF FALSE;

	# This is a hack to support selfcheck;
	# if it is set non-NULL, drawing_window_imp
	# will 'give' the displayed triangle list
	# to this slot each time it changes:
	#
	my  add_triangle_watcher_slot:		Ref (Null_Or( Mailslot( List( xg::Point ))))
	    =
	    REF NULL;	

	stipulate
	    selfcheck_tests_passed =  REF 0;
	    selfcheck_tests_failed =  REF 0;
	herein
	    fun test_passed () =  selfcheck_tests_passed :=  *selfcheck_tests_passed + 1;
	    fun test_failed () =  selfcheck_tests_failed :=  *selfcheck_tests_failed + 1;
	    #
	    fun test_stats  ()
		=
                { passed => *selfcheck_tests_passed,
                  failed => *selfcheck_tests_failed
                };
	end;


	# Put button window at bottom of topwindow:
	# 
	fun button_window_site  (topwindow_size as { wide: Int, high: Int })
	    =
	    xg::WINDOW_SITE
	      {
		upperleft    =>  xg::POINT { col => (wide -  button_wide)/2,
				             row => (high - (button_high+10))
				           },
		size         =>  xg::SIZE  { wide => button_wide,
                                             high => button_high
                                           },
		border_thickness =>  0
	      };

	# Let drawing window fill the rest of topwindow:
	# 
	fun drawing_window_site (topwindow_size as { wide: Int, high: Int })
	    =
	    xg::WINDOW_SITE
	      {
		border_thickness =>  1,
		upperleft    =>  xg::POINT { col => 5, row => 5 },
		#
		size         =>  xg::SIZE { wide => wide - 10,
				            high => high - (button_high+25)
				          }
	      };

#	# Temporary hack to test out call to
#	# read mouse position:
#	#
#	fun make_mouse_watcher  xsession  window
#	    =
#	    {   fun mouse_watcher ()
#		    =
#		    loop (10, 10, 1)
#		    where
#			fun loop (row, col, delta)
#			    =
#			    {
#				(xc::get_mouse_location  xsession)
#				    ->
#				    xg::POINT { row => r, col => c };
#
#	printf "triangle_app: mouse_watcher: row,col d=(%d, %d)\n" r c;
#
#	#			sleep_for (time::from_milliseconds 333);
#
#				delta =   row <   10 ??  1 :: delta;
#				delta =   row > 1000 ?? -1 :: delta;
#
#				row   = row + delta;
#				col   = col + delta;
#
#				if (row == 20)   thread_done ();   fi;
#
#				xc::set_mouse_location  xsession  (xg::POINT { row, col });
#
#				loop (row, col, delta);
#			    };		
#		    end;
#
#		xtr::make_thread "mouse watcher" mouse_watcher;
#	    };

	# Temporary hack to test out
	# periodic operation:
	#
	fun make_periodic_prints  ()
	    =
	    {   fun periodic_prints ()
		    =
		    loop ()
		    where
			fun loop ()
			    =
			    {

print "triangle_app: periodic_prints/AAA\n";

trace .{ "periodic_print sleeping for 1/3 second..."; };
				sleep_for (time::from_milliseconds 333);
trace .{ "periodic_print back from 1/3 second sleep."; };

				loop ();
			    };		
		    end;

		xtr::make_thread "periodic prints" periodic_prints;
	    };

	# Thread to exercise the app by simulating user
	# mouseclicks and verifying their effects:
	#
	fun make_selfcheck_thread
            { xsession:         xc::Xsession,
	      topwindow:        xw::Window,
              drawing_window:   xw::Window,
              button_window:    xw::Window
            }
	    =
	    {   fun get_''seen_first_expose''_oneshot
			window
		    =
		    case (xw::get_''seen_first_expose''_oneshot_of  window)
			#
			THE oneshot =>  oneshot;
			NULL        =>  get_''seen_first_expose''_oneshot window;		# Cannot actually happen.
		    esac;

		# Wait for drawing window to
		# get its first EXPOSE x event:
		#
		fun wait_for_first_drawing_window_expose ()
		    =
		    {
			# Normally we would use the
			#
			#     seen_first_redraw_oneshot_of
			#
			# from 
			#
			#     src/lib/x-kit/widget/basic/widget.api
			#
			# but the logic here doesn't use the widget
			# support (I'm guessing this app predates
			# the widget layer) so we have to use the
			# following call instead:
			#
			# 
			seen_first_drawing_window_expose_oneshot
			    =
			    get_''seen_first_expose''_oneshot
				#
				drawing_window;

			get  seen_first_drawing_window_expose_oneshot;
		    };

		fun clear_drawing_window ()
		    =
		    {   drawable = xd::drawable_of_window  drawing_window;
trace .{ sprintf "clear_drawing_window: drawing_window.id x=%x   drawimp_thread_id_of drawing_window d=%d" (xc::id_of_window drawing_window) (xd::drawimp_thread_id_of (xd::drawable_of_window  drawing_window)); };
                        xd::clear_drawable  drawable;
		    };

		fun get_window_depth  window
		    =
		    {   drawable =  xd::drawable_of_window  window;
			#
			
			#
			xd::depth_of_drawable  drawable;
# Unfinished code; The above is a quick test hack mid-development.
		    };	

		fun selfcheck ()
		    =
		    {   # First order of business is to wait
			# until things are up and running:
			#
trace .{ sprintf "drawing_window.id d=%d x=%x" (xc::id_of_window drawing_window) (xc::id_of_window drawing_window); };
trace .{ sprintf "drawimp_thread_id_of drawing_window d=%d" (xd::drawimp_thread_id_of (xd::drawable_of_window  drawing_window)); };
trace .{ "Waiting for first drawing window EXPOSE..."; };
			wait_for_first_drawing_window_expose ();
trace .{ "Seen first drawing window EXPOSE."; };

window_depth = get_window_depth  drawing_window;
			# Get size of drawing window:
			#
			(xw::get_window_site  drawing_window)
			    ->
			    xg::BOX { row, col, high, wide };
trace .{ sprintf "drawing window box = { row %d, col %d, high %d, wide %d }; depth = %d." row col high wide window_depth; };

			# Define midpoint of drawing window,
			# and a 9x9 box enclosing it:
			#
			stipulate
			    row =  high / 2;
			    col =  wide / 2;
my _ = trace  .{  sprintf  "drawing window midpoint = { row %d, col %d }."  row  col ;  };
			herein
			    midpoint      =  xg::POINT { row, col };

			    midwindow_box =  xg::BOX { row => row - 4, col => col - 4, high => 9, wide => 9 };
			end;
# Sleep for one second in the hope that all pending
# initialization stuff will have time to run, making
# the tracelog of the following stuff easier to interpret.
# trace .{ "sleeping for one second"; };
#		        sleep_for (time::from_milliseconds 1000);
# trace .{ "slept    for one second"; };

			# Clear drawing window.  The drawing window
			# thread does this anyhow, but doing it here
			# saves us worrying about race conditions between
			# us and the drawing window threads:
			#
			clear_drawing_window ();

			# Fetch from X server the mid-window pixels
			# over which we are about to draw a triangle.
			# These should be all all background color (black)
			# at the moment, due to above clear_drawing_window():
			#
			antedraw_midwindow_image  =  xc::make_clientside_pixmap_from_window (midwindow_box, drawing_window);

			# Do it again, verify that they compare equal:			
			#
			{   antedraw_midwindow_image2 =  xc::make_clientside_pixmap_from_window (midwindow_box, drawing_window);
			    #
			    if (xc::same_cs_pixmap (antedraw_midwindow_image, antedraw_midwindow_image2))   test_passed ();
			    else									    test_failed ();	
			    fi;
			};

			# Set up a hook to detect when
			#
			#     add_triangle ()
			#
			# runs.  To avoid race conditions, we must
			# do this BEFORE sending the below simulated
			# mouseclicks.  (I forgot this at first, and
			# in fact got bitten.)
			# 
			triangle_list_slot =  make_mailslot ();
			# 
trace .{ sprintf "Setting add_triangle_watcher_slot."; };
			add_triangle_watcher_slot :=  THE triangle_list_slot;

			# Simulate a mouseclick in center of drawing window:
			#
trace .{ sprintf "XYZZY Sending midwindow downclick to X server."; };
			xw::send_mousebutton_press_xevent
                          { window => drawing_window,
                            button => xi::MOUSEBUTTON 1,
			    point  => midpoint
			  };
			#
trace .{ sprintf "XYZZY Sending midwindow upclick to X server."; };
			xw::send_mousebutton_release_xevent
                          { window => drawing_window,
                            button => xi::MOUSEBUTTON 1,
			    point  => midpoint
			  };

			# 
			select [
			    take' triangle_list_slot ==>  check_triangle_list1,
			    timeout'                 ==>  do_timeout1
			]
			where
			    timeout' =   timeout_in' (time::from_milliseconds 5000);

			    fun check_triangle_list1  [ point ]
				    =>
				    {
					if (xg::point::eq (point, midpoint))  test_passed ();
					else                                  test_failed ();
trace .{ sprintf "test_failed/AAA. (Clearing add_triangle_watcher_slot.)"; };
					fi;

					add_triangle_watcher_slot :=  NULL;
				    };

				check_triangle_list1  []
				    =>
				    {   test_failed ();
trace .{ sprintf "test_failed/BBB. (Clearing add_triangle_watcher_slot.)"; };

					add_triangle_watcher_slot :=  NULL;
				    };

				check_triangle_list1  triangles
				    =>
				    {   test_failed ();
trace .{ sprintf "test_failed/CCC len(triangles) d=%d. (Clearing add_triangle_watcher_slot.)" (list::length triangles); };

					add_triangle_watcher_slot :=  NULL;
				    };
			    end;

			    fun do_timeout1 ()
				=
				{   test_failed ();
trace .{ sprintf "test_failed/DDD. (Clearing add_triangle_watcher_slot.)"; };

				    add_triangle_watcher_slot :=  NULL;
				};	
			end;

			# Make sure the triangle-draw command
			# has flushed from the draw_imp before
			# fetching the pixels which we expect
			# to have changed -- if we do not do
			# this flush, we have a race condition
			# between the two:
			#
# This flush shouldn't be needed now -- cs_pixmap does it -- but
# empirically it IS needed. ?!?
# trace .{ "tri-app calling xd::flush drawing_window_drawable."; };
#			xd::flush  drawing_window_drawable
#			where
#			    drawing_window_drawable = xd::drawable_of_window  drawing_window;
#			end;
# trace .{ "tri-app done    xd::flush drawing_window_drawable."; };

			# Fetch from X server the mid-window pixels
			# over which we should have drawn a triangle.
			#
			# Verify that they differ from our original
			# all-black image of the same area:
			#
			{
trace .{ "XYZZY tri-app calling postdraw_midwindow_image = xc::make_clientside_pixmap_from_window."; };
			    postdraw_midwindow_image =  xc::make_clientside_pixmap_from_window (midwindow_box, drawing_window);
trace .{ "XYZZY tri-app done    postdraw_midwindow_image = xc::make_clientside_pixmap_from_window."; };
			    #	
#			    if (xc::same_cs_pixmap (antedraw_midwindow_image, postdraw_midwindow_image))   test_failed ();
#			    else									   test_passed ();	
#			    fi;				
			    if (xc::same_cs_pixmap (antedraw_midwindow_image, postdraw_midwindow_image))
print "postdraw midwindow image did NOT differ from antedraw midwindow image :-(";
                                test_failed ();
			    else
print "postdraw midwindow image DID differ from antedraw midwindow image :-)";
		                test_passed ();	
			    fi;				
			};

			(test_stats ()) ->  { passed, failed };
trace .{ sprintf "test_stats: passed %d  failed %d" passed failed; };

			xc::close_xsession  xsession;

			shut_down_thread_scheduler  winix::process::success;
		    };

		xtr::make_thread "tri-app selfcheck" selfcheck;
	    };

	fun make_topwindow  xdisplay  xauthentication
	    =
	    ( xsession,
              screen,
              window,
              kidplug
            )
	    where
		xsession =  xc::open_xsession (xdisplay, xauthentication);

		screen   =  xc::default_screen_of  xsession;

		window_size   =  xg::SIZE { wide => 450, high => 400 };

		my (window, kidplug, delete_slot)					# 2009-12-10 CrT: Had to add 'delete_slot' so it would compile.
		    =
		    xw::make_simple_top_window  screen
		      {
			site =>  xg::WINDOW_SITE { upperleft => xg::POINT { col=>0, row=>0 }, size=>window_size, border_thickness=>1 },
			#
			border_color     =>  xc::black,
			background_color =>  xc::rgb8_white
		      };

		icon_ro_pixmap								# serverside
		    =
		    xc::make_readonly_pixmap_from_clientside_pixmap
			screen
			ib::icon_bitmap;						# clientside


											# commandline		is from   src/lib/std/commandline.pkg
		xw::set_window_manager_properties  window
		  {
		    window_name => THE "Triangle",
		    icon_name   => THE "triangle",
		    #
		    size_hints =>
		      [
			xs::HINT_PPOSITION,
			xs::HINT_PSIZE,
			xs::HINT_PMIN_SIZE min_sz
		      ],
		    #
		    nonsize_hints  =>  [ xs::HINT_ICON_RO_PIXMAP icon_ro_pixmap ],
		    class_hints    =>  THE { resource_name=>"triangle", resource_class=>"Triangle" },
		    #
		    commandline_arguments =>  commandline::get_arguments ()
		  };

make_periodic_prints  ();
# make_mouse_watcher  xsession  window;

		xw::show_window  window;
	    end;

	# Divide the topwindow into a
	# drawing window over a button window:
	#
	fun make_drawing_and_button_windows  (screen, topwindow, top_kidplug)
	    =
	    {   (xc::size_of_window  topwindow)
		    ->
		    xg::SIZE topwindow_size;

		drawing_window
		    =
		    xw::make_simple_subwindow  topwindow
		      {
			site => drawing_window_site  topwindow_size,
			#
			border_color     => THE  xc::black,
			background_color => THE  xc::rgb8_color0
		      };

trace .{ "make_drawing_and_button_windows noting drawing window oneshot..."; };
		xw::note_''seen_first_expose''_oneshot
		    drawing_window
		    (make_oneshot_maildrop ());

		button_window
		    =
		    xw::make_simple_subwindow  topwindow
		      {
			site =>  button_window_site  topwindow_size,
			#
			border_color     =>  NULL,
			background_color =>  THE  xc::rgb8_white
		      };

trace .{ "make_drawing_and_button_windows noting button window oneshot..."; };
		xw::note_''seen_first_expose''_oneshot
		    button_window
		    (make_oneshot_maildrop ());

		xw::show_window  drawing_window;
		xw::show_window  button_window;

		{ topwindow,
		  top_kidplug,
		  drawing_window,
		  button_window
		};
	    };


	fun make_button_threads (button_window, button_kidplug)
	    =
	    {   xtr::make_thread "triangle button" loop;
		take' reset_slot;
	    }
	    where

		# Define a function to re/draw the
		# button as "RESET" inside a cartouche:
		#
		fun redraw ()
		    =
		    {
trace .{ "button redraw()/TOP -- drawing cartouche"; };
                        draw_cartouche
			  {
			    corner_radius =>  button_corner_radius,
			    #
			    box  =>  xg::BOX { col  => 0,
					       row  => 0,
					       #	
					       high => button_high - 1,
					       wide => button_wide - 1
					     }
			  };

trace .{ "button redraw()/MID -- drawing text"; };
			draw_string (text_point, text);
trace .{ "button redraw()/BOT"; };
		    }
		    where
			drawable =  xd::drawable_of_window  button_window;

			pen = xd::make_pen
				[
				  xd::FUNCTION    xd::OP_COPY,
				  xd::FOREGROUND  xc::rgb8_black
				];

			draw_cartouche
			    =
			    che::draw_cartouche  drawable  pen;

			text = "RESET";

			font =  xf::open_font
				    #
				    (xw::xsession_of_window  button_window)
				    #
				    "9x15";

			text_point
			    =
			    {   text_width =  xf::text_width  font  text;

				my { ascent, descent }
				    =
				    xf::font_high  font;

				xg::POINT
				  {
				    col => ( button_wide - text_width) / 2,
				    row => ((button_high - (ascent + descent)) / 2) + ascent
				  };
			    };

			draw_string
			    =
			    xd::draw_transparent_string  drawable  pen  font;
		    end;

		# Define the main thread loop animating the button.
		# We respond to ETC_REDRAW by redrawing our button;
		# we respond to a click by resetting the draw thread:
		#
		(xi::ignore_keyboard  button_kidplug)
		    ->
		    xi::KIDPLUG { from_mouse', from_other', ... };

		from_mouse'' =   from_mouse' ==> xi::envelope_contents;
		from_other'' =   from_other' ==> xi::envelope_contents;

		reset_slot = make_mailslot ();

		fun loop ()
		    =
		    {   fun do_mouse' (xi::MOUSE_FIRST_DOWN _)
				=>
				give (reset_slot, ());

			    do_mouse' _
				=>
				();
			end;


fun do_mouse x
    =
    {
trace .{ "button loop do_mouse/TOP"; };
        do_mouse' x;
trace .{ "button loop do_mouse/BOT"; };
    };

			fun do_other' (xi::ETC_REDRAW _)  =>  redraw ();
			    do_other'  xi::ETC_OWN_DEATH  =>  ();
			    do_other' _	  	          =>  ();
			end;

fun do_other x
    =
    {
trace .{ "button loop do_other/TOP"; };
        do_other' x;
trace .{ "button loop do_other/BOT"; };
    };


			for (;;) {
			    #
trace .{ "button loop TOP"; };
			    select [
				from_mouse'' ==>  do_mouse,
				from_other'' ==>  do_other
			    ];
			};
		    };

	    end;				# fun make_button_threads 

	# Define drawing_window logic to put
	# a triangle at each spot the user
	# clicks on:
	#
	fun make_drawing_window_threads (drawing_window, reset', draw_kidplug)
	    =
	    {   xtr::make_thread "drawing window mouse"  mouse_thread;
		xtr::make_thread "drawing window"       .{ drawing_window_imp []; };
		();
	    }
	    where
		my xi::KIDPLUG { from_mouse', from_other', ... }
		    =
		    xi::ignore_keyboard  draw_kidplug;

		mouse' =   from_mouse' ==> xi::envelope_contents;
		other' =   from_other' ==> xi::envelope_contents;

		add_triangle_slot = make_mailslot ();

		fun mouse_thread ()
		    =
		    for (;;) {
			#
trace .{ "mouse thread/TOP"; };
			case (do_mailop  mouse')
			    #
			    xi::MOUSE_FIRST_DOWN { window_point, ... }
				=>
				give (add_triangle_slot, window_point);
			    #
			    _   => ();
			esac;
		    };

		add_triangle' = take' add_triangle_slot;

		drawable = xd::drawable_of_window  drawing_window;

		pen = xd::make_pen
			[
			  xd::FUNCTION    xd::OP_COPY,
			  xd::FOREGROUND  xc::rgb8_green
			];

		draw = xd::fill_polygon drawable pen;


		fun draw_triangle' (xg::POINT { col, row } )
		    =
		    draw
		      {
			shape => xd::CONVEX_SHAPE,
			#
			verts => [ xg::POINT { col => col,       row => row - 10 },
				   xg::POINT { col => col - 8,   row => row +  6 },
				   xg::POINT { col => col + 8,   row => row +  6 }
				 ]
		      };

fun draw_triangle x
    =
    {
trace .{ sprintf "XYZZY drawing_window draw_triangle/TOP: drawing_window.id x=%x   drawimp_thread_id_of drawing_window d=%d" (xc::id_of_window drawing_window) (xd::drawimp_thread_id_of (xd::drawable_of_window  drawing_window)); };
        draw_triangle' x;
trace .{ sprintf "XYZZY drawing_window draw_triangle/TOP: drawing_window.id x=%x   drawimp_thread_id_of drawing_window d=%d" (xc::id_of_window drawing_window) (xd::drawimp_thread_id_of (xd::drawable_of_window  drawing_window)); };
    };


		# "triangles" is the list of points at which we
		# show triangles in the drawing window:
		#
		fun drawing_window_imp  triangles
		    =
		    {   fun do_reset ()
			    =
			    {
trace .{ "drawing_window loop do_reset()/TOP -- clearing drawable"; };
                                xd::clear_drawable  drawable;
trace .{ "drawing_window loop do_reset()/BOT"; };
				drawing_window_imp [];
			    };


			fun do_other (xi::ETC_REDRAW _)
				=>
				{
trace .{ "drawing_window loop do_other/ETC_REDRAW/TOP -- clearing drawable"; };
                                    xd::clear_drawable  drawable;

trace .{ "drawing_window loop do_other/ETC_REDRAW/MID -- drawing triangles"; };
				    apply  draw_triangle  triangles;

trace .{ "drawing_window loop do_other/ETC_REDRAW/BOT"; };
				    drawing_window_imp  triangles;
				};

			    do_other xi::ETC_OWN_DEATH
				=>
				{
trace .{ "drawing_window loop do_other/ETC_OWN_DEATH"; };
                                    ();
				};

			    do_other _
				=>
				{
trace .{ "drawing_window loop do_other/whoknows (ignored)"; };
				    drawing_window_imp  triangles;
				};
			end;


			# In response to a mouse downclick at a point,
			# add a triangle to our list and draw it:
			#
			fun add_triangle  point
			    =
			    {
{ point -> xg::POINT { row, col };
  trace .{ sprintf "add_triangle (POINT { row %d, col %d })/TOP" row col; };
};
			        draw_triangle  point;

case *add_triangle_watcher_slot  THE slot => trace .{ sprintf "add_triangle: add_triangle_watcher_slot is SET."; };
                                  NULL     => trace .{ sprintf "add_triangle: add_triangle_watcher_slot is CLEAR."; };
esac;
				case *add_triangle_watcher_slot
				    #
				    THE slot =>	 give (slot, (point ! triangles));
				    NULL     =>  ();
				esac;

trace .{ "drawing_window loop do_draw/BOT -- adding point to list and continuing"; };
				drawing_window_imp (point ! triangles);
			    };

trace .{ "drawing_window loop -- doing select []"; };
			select [
			    #
			    reset'         ==>  do_reset,
			    other'         ==>  do_other,
			    add_triangle'  ==>  add_triangle
			];

		    };					# fun drawing_window_imp
	    end;					# fun make_drawing_window_threads 

	fun make_toplevel_threads
            {
              topwindow,
              top_kidplug  => xi::KIDPLUG { from_keyboard', from_mouse', from_other', ... },
              button_window,
              drawing_window
            }
	    =
	    {   xtr::make_thread "triangle router" router;

		{ button_kidplug,
		  draw_kidplug
		};
	    }
	    where
		(xi::make_widget_cable ()) ->   { kidplug => button_kidplug, momplug => button_momplug };
		(xi::make_widget_cable ()) ->   { kidplug =>   draw_kidplug, momplug =>   draw_momplug };
		(xi::make_widget_cable ()) ->   { kidplug,                   momplug                   };

		kidplug =  xi::ignore_all  kidplug;

		fun find_cable  envelope
		    =
		    case (xi::route_envelope  envelope)
			#
			xi::TO_SELF _				# Envelope has reached its destination window/widget.
			    =>
			    momplug;

			xi::TO_CHILD msg'			# Envelope needs to be passed on down the widget hierarchy.
			    =>
			    if   (xi::to_window (msg',   drawing_window))   draw_momplug;
			    elif (xi::to_window (msg', button_window))   button_momplug;
			    else                                         raise exception FAIL "find_cable";
			    fi;
		    esac;

		fun do_keyboard envelope
		    =
		    {
trace .{ "main do_keyboard/TOP -- find_cable being called"; };
                        my xi::MOMPLUG { keyboard_sink, ... }
			    =
			    find_cable  envelope;

trace .{ "main do_keyboard/MID -- do_mailop (keyboard_sink envelope) being called"; };
			do_mailop (keyboard_sink envelope);
		    };

		fun do_mouse envelope
		    =
		    {
trace .{ "main do_mouse/TOP -- find_cable being called"; };
		        my xi::MOMPLUG { mouse_sink, ... }
			    =
			    find_cable  envelope;

trace .{ "main do_keyboard/MID -- do_mailop (mouse_sink envelope) being called"; };
			do_mailop (mouse_sink  envelope);
		    };

		fun do_other envelope
		    =
		    {
trace .{ "main do_other/TOP -- find_cable being called"; };
		        my xi::MOMPLUG { other_sink, ... }
			    =
			    find_cable  envelope;

trace .{ "main do_other/MID -- do_mailop (mouse_sink envelope) being called"; };
			do_mailop (other_sink  envelope);
		    };

		fun router ()
		    =
		    for (;;) {
			#
trace .{ "main router for (;;) -- above select []"; };
			select [ from_keyboard' ==> do_keyboard,
				 from_mouse'    ==> do_mouse,
				 from_other'    ==> do_other
			       ];
		    };

	    end;			# fun make_toplevel_threads

	fun run_triangle_app  xdisplay  xauthentication
	    =
	    {
trace .{ "run_triangle_app -- above make_topwindow ()"; };
		(make_topwindow  xdisplay  xauthentication)
		    ->
		    ( xsession,
		      screen,
		      topwindow,
		      kidplug
		    );

trace .{ "run_triangle_app -- above make_drawing_and_button_windows ()"; };
	        (make_drawing_and_button_windows (screen, topwindow, kidplug))
		    ->
		    (x as { button_window, drawing_window, ... } );

trace .{ "run_triangle_app -- above make_toplevel_threads ()"; };
		(make_toplevel_threads  x)
		    ->
		    { button_kidplug, draw_kidplug };
		    

trace .{ "run_triangle_app -- above make_drawing_window_threads ()"; };
		make_drawing_window_threads
		  ( drawing_window,
		    make_button_threads (button_window, button_kidplug),
		    draw_kidplug
		  );

		if *run_selfcheck
		    #
		    make_selfcheck_thread  { xsession, topwindow, drawing_window, button_window };
		    ();
		fi;
trace .{ "run_triangle_app -- DONE"; };
	    };

	fun do_it' (flgs, display_name)
	    =
	    {   xtr::init flgs;

# Commented the following out because the
#     src/lib/std/src/unix/posix-text-primitive-io.pkg
# logic will already truncate a file when opening it for
# write:
# printf "triangle-app: do_it': Checking for existing %s file...\n" tracefile;
# 		# Remove any old version of the tracefile:
# 		#
# 		if (isfile tracefile)
# 		    #
# printf "triangle-app: do_it': Removing pre-existing %s file...\n" tracefile;
# 		    unlink tracefile;
# 		fi;

		# Open tracelog file and
                # select tracing level:
		#
		{   include tracing;				# tracing			is from   src/lib/src/lib/thread-kit/src/lib/tracing.pkg
		    #
printf "triangle-app: do_it': Creating new %s file...\n" tracefile;
		    log_trace_messages  (TO_FILE tracefile);
		    enable all_tracing;				# Gross overkill.
		};

	        my  ( xdisplay,								# Typically from $DISPLAY environment variable.
                      xauthentication:  Null_Or(xc::Xauthentication)			# Typically from ~/.Xauthority
                    )
		    =
		    xau::get_xdisplay_string_and_xauthentication
			#
			case display_name
			    #
			    "" =>  NULL;
			    _  =>  THE display_name;
			esac;

trace .{ sprintf "triangle-app: DISPLAY variable is set to '%s'" xdisplay; };

		start_up_thread_scheduler'
		    #
		    (time::from_milliseconds 20)
		    #
		   .{
trace .{ "triangle-app: Thread scheduler now running -- above run_triangle_app call."; };
                        xtr::make_thread  "triangle"  .{ run_triangle_app  xdisplay  xauthentication; };
trace .{ "triangle-app: Back from run_triangle_app call."; };
			();
		    };
	    };

	fun do_it s
	    =
	    do_it' ([], s);

	fun selfcheck ()
	    =
	    {   run_selfcheck :=  TRUE;
		do_it' ([], "");
		test_stats ();
	    };	

	fun main (program, server ! _) =>  do_it  server;
	    main _                     =>  do_it  "";
	end;
    };								# package  main 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1992 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
