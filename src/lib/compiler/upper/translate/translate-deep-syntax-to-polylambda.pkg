## translate-deep-syntax-to-polylambda.pkg 
#
# This package is the doorway between the front end,
# which is concerned with syntax and typechecking,
# and the back end, which is concerned with optimization
# and code generation.
# 
# Deep syntax is the most abstract of the front-end
# code representations:
#
#     src/lib/compiler/front/typecheck-stuff/deep-syntax/deep-syntax.api
#
# A-Normal form is the highest level code representation
# used in the back end.  In particular, A-Normal form
# still explicitly represents the call hierarchy, and
# is thus an apppropriate setting for code optimizations
# based on call hierarchy:
#
#     src/lib/compiler/upper/anormal/anormal.api
#
# We use a polymorphically typed lambda calculus representation
# as a stepping stone to get from deep syntax to A-Normal form:
#
#     src/lib/compiler/upper/polylambda/polylambda.api
#
# A-Normal is a relatively minor code representation in
# this compiler;  it serves primarily as a stepping stone
# to our FPS ("fate passing style") code
# representation, which is the workhorse of the back
# end top half:
#
#     src/lib/compiler/upper/fps/fate-passing-style.api
#
# For higher-level context, read 
#
#     src/lib/compiler/README
#
#
# We get invoked (only) from
#
#     src/lib/compiler/toplevel/main/compile-g.pkg

# Compiled by:
#     src/lib/compiler/core.make6

api Translate_Deep_Syntax_To_Polylambda {

   # Invariant: translate_deep_syntax_declaration_to_polylambda is always applied
   # to a top-level deep_syntax::Declaration

   translate_deep_syntax_declaration_to_polylambda
       :
       { declaration:                  deep_syntax::Declaration,
	 exported_highcode_variables:  List( var_home::Highcode_Variable ),
         symbol_table:                 symbol_table::Symbol_Table,
	 ansi_c_prototype_convention:  String,							#  "unix_convention" or "windows_convention" 
	 compile_info:                 compile_info::Compile_Info( deep_syntax::Declaration )
       }
       ->
       { polylambda_expression:	       polylambda::Polylambda_Expression,

         imports:                      List( ( picklehash::Picklehash,
                                               import_tree::Import_Tree
                                           ) )
       };
};



###          "It is not the strongest of the species
###           that survive, not the most intelligent,
###           but the one most responsive to change."
###
###                          -- Charles Darwin



package translate_deep_syntax_to_polylambda

: (weak)  Translate_Deep_Syntax_To_Polylambda	# Translate_Deep_Syntax_To_Polylambda	is from   src/lib/compiler/upper/translate/translate-deep-syntax-to-polylambda.pkg

{
    stipulate

        package st = symbol_table_entry;	# symbol_table_entry		is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package bt = type_types;		# type_types			is from   src/lib/compiler/front/typechecker/types/type-types.pkg
	package da = var_home;			# var_home			is from   src/lib/compiler/front/typecheck-stuff/basics/var-home.pkg
	package di = debruijn_index;		# debruijn_index		is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg
	package em = error_message;		# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
	package ii = inlining_info;		# inlining_info			is from   src/lib/compiler/front/semantic/basics/inlining-info.pkg
	package lt = polylambda_type;		# polylambda_type		is from   src/lib/compiler/upper/polylambda/polylambda-type.pkg
	package m  = module;			# module			is from   src/lib/compiler/front/typecheck-stuff/modules/module.pkg
	package mc = compile_pattern;		# compile_pattern		is from   src/lib/compiler/upper/translate/compile-pattern.pkg
	package po = highcode_primitive_op;	# highcode_primitive_op		is from   src/lib/compiler/upper/highcode/highcode-primitive-op.pkg
	package pp = prettyprint;		# prettyprint			is from   src/lib/prettyprint/src/prettyprint.pkg
	package s  = symbol;			# symbol			is from   src/lib/compiler/front/basics/mlcomp/symbol.pkg
	package sp = symbol_path;		# symbol_path			is from   src/lib/compiler/front/typecheck-stuff/basics/symbol-path.pkg
	package ln = literal_to_num;		# literal_to_num		is from   src/lib/compiler/src/util/literal-to-num.pkg
	package tt = translate_types;		# translate_types		is from   src/lib/compiler/upper/translate/translate-types.pkg
	package tp = types;			# types				is from   src/lib/compiler/front/typecheck-stuff/types/types.pkg
	package tu = type_stuff;		# type_stuff			is from   src/lib/compiler/front/typecheck-stuff/types/type-stuff.pkg
	package vc = variables_and_constructors;# variables_and_constructors	is from   src/lib/compiler/front/typecheck-stuff/deep-syntax/variables-and-constructors.pkg
	package eu = typecheck_stuff;		# typecheck_stuff		is from   src/lib/compiler/front/typechecker/typecheck/typecheck-stuff.pkg

	package intinf_map
            =
            red_black_map_g (			# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg

                Key = integer::Int;
		compare = integer::compare;
            );

	include  deep_syntax;
	include  polylambda; 

    herein 

	/****************************************************************************
	 *                   CONSTANTS AND UTILITY FUNCTIONS                        *
	 ****************************************************************************/

        debugging = typecheck_data_control::translate_to_anormal_debugging;		#  REF FALSE 

	fun bug msg
            =
            em::impossible("translate_deep_syntax_to_polylambda: " + msg);

	say = controls::print::say;
	prettyprint_depth = controls::print::print_depth;

	fun prettyprint_type  type
            =
	    typechecking_debugging::with_internals
	      (fn ()
                  =
                  typechecking_debugging::debug_print
                      debugging
		      ( "type: ",
                        unparse_type::unparse_type symbol_table::empty,
                        type
                      )
              );


	prettyprint_declaration = prettyprint_deep_syntax::prettyprint_declaration (symbol_table::empty, NULL);
	prettyprint_expression  = prettyprint_deep_syntax::prettyprint_expression  (symbol_table::empty, NULL);
	prettyprint_pattern     = prettyprint_deep_syntax::prettyprint_pattern      symbol_table::empty;

	unparse_declaration = unparse_deep_syntax::unparse_declaration (symbol_table::empty, NULL);
	unparse_expression  = unparse_deep_syntax::unparse_expression  (symbol_table::empty, NULL);
	unparse_pattern     = unparse_deep_syntax::unparse_pattern      symbol_table::empty;

	unparse_typevar_ref = unparse_type::unparse_typevar_ref         symbol_table::empty;

	fun if_debugging_unparse_expression (msg, expression)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_expression, expression));
	    fi;

	fun if_debugging_unparse_pattern (msg, pattern)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_pattern, pattern));
	    fi;

	fun if_debugging_unparse_declaration (msg, declaration)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_declaration, declaration));
	    fi;

	fun if_debugging_unparse_typevar_ref  (msg, typevar_ref)
	    = 
	    if *debugging		# Without this 'if' (and the matching one in unify_types), compiling the compiler takes 5X as long! :-)
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_typevar_ref, typevar_ref));
	    fi;



	fun if_debugging_prettyprint_expression (msg, expression)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_expression, expression));
	    fi;

	fun if_debugging_prettyprint_pattern (msg, pattern)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_pattern, pattern));
	    fi;

	fun if_debugging_prettyprint_declaration (msg, declaration)
            =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_declaration, declaration));
	    fi;



	fun print_callstack
            (msg:        String)
            (callstack:  List(String))
	    =
            {   printf "%s:  callstack(%d) == " msg (list::length callstack);
		apply  .{ printf " -> %s" #string; }  (reverse callstack);
                printf "\n";
            };

	fun ident x   =   x;

	unit_lexp = RECORD [];

	fun get_name_or_null p
            =
            if (sp::null p)   NULL;
            else              THE (sp::last p);
            fi;

# apparently not actually used:
#	Picklehash = picklehash::Picklehash;

						# fold_right	def in    src/lib/core/init/pervasive.pkg

	# Old-style fold for cases where
        # it is partially applied:
	#
	fun fold f l init
            =
            fold_right f init l;


	# Sorting the record fields for
        # record types and record expressions:
	#
	stipulate

	    fun elem_gtr ((NUMBERED_LABEL { number=>x, ... }, _), (NUMBERED_LABEL { number=>y, ... }, _))
		=
		x > y;

	herein

	    fun sorted  x   =   list_mergesort::sorted  elem_gtr  x;
	    fun sortrec x   =   list_mergesort::sort    elem_gtr  x;

	end;

	# Is given var_home external?
        #
	fun extern (da::EXTERN _)    =>   TRUE;
	    extern (da::PATH (a, _)) =>   extern a;
	    extern _                 =>   FALSE;
        end;

	# An exception to raise exception if
        # coreDict is not available: 
	#
	exception NO_CORE;



													# deep_syntax		is from   src/lib/compiler/front/typecheck-stuff/deep-syntax/deep-syntax.pkg
													# var_home		is from   src/lib/compiler/front/typecheck-stuff/basics/var-home.pkg
													# symbol_table		is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
													# compile_info		is from   src/lib/compiler/front/typecheck-stuff/main/compile-info.pkg
													# anormal		is from   src/lib/compiler/upper/anormal/anormal.pkg
													# import_tree		is from   src/lib/compiler/execution/main/importtree.pkg
													# picklehash		is from   src/lib/compiler/front/basics/mlcomp/picklehash.pkg
	# This is the external entrypoint
        # into this file.  We are invoked
        # (only) from
        #
        #     src/lib/compiler/toplevel/main/compile-g.pkg
	#
        # All the remaining code in this file
        # is nested within this function:
	#
	fun translate_deep_syntax_declaration_to_polylambda
            {
	      declaration => given_declaration:  deep_syntax::Declaration,
	      exported_highcode_variables:       List( var_home::Highcode_Variable ),
	      symbol_table:                      symbol_table::Symbol_Table,
	      ansi_c_prototype_convention:       String,               #  "unix_convention" or "windows_convention"  XXX BUGGO FIXME This should be a datatype.
	      compile_info
              as
                { error_match,
                  error_fn,
                  ...
                }:                               compile_info::Compile_Info( deep_syntax::Declaration )
            }
	    :
            { polylambda_expression:		 Polylambda_Expression,
	      imports:                           List( (picklehash::Picklehash, import_tree::Import_Tree) )	
            }	
            =
	    {
		if *debugging
		    printf "\n============= translate_deep_syntax_declaration_to_polylambda/TOP =============  in translate-deep-syntax-to-polylambda.pkg\n";
                    printf   "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\n";
	            if_debugging_unparse_declaration     ("given_declaration unparsed      at translate_deep_syntax_declaration_to_polylambda/TOP", (given_declaration, 100) );
	            if_debugging_prettyprint_declaration ("given_declaration prettyprinted at translate_deep_syntax_declaration_to_polylambda/TOP", (given_declaration, 100) );
		fi;

                make_highcode_variable
                    =
                    compile_info.make_highcode_variable;

		fun make_var ()
                    =
                    make_highcode_variable  NULL;

		# Generate the set of deep syntax 
                # to polylambda type translation
                # functions:
                #
                (tt::generate_type_translation_functions ())
                    ->
		    { tps_knd,
		      tps_type_constructor,
		      to_type_constructor,
		      to_lambda_type,
		      package_to_lambda_type,
		      generic_lty,
		      mark_lbound
                    };

		fun to_tc_lt  debruijn_depth
                    =
                    ( to_type_constructor debruijn_depth,
                      to_lambda_type      debruijn_depth
                    );



		# Translate the type field in
                # ENUM_CONSTRUCTOR into Highcode_Type.
                #
                # Constant datacons will take
                # ltc_unit as the argument.

		fun to_dcon_lty debruijn_depth  type
                    =
		    case type 
		      
		         tp::TYPE_SCHEME_TYPE
                             {
                               type_scheme_arg_eq_properties => an_api,
                               type_scheme => tp::TYPE_SCHEME { arity, body }
                             }
				 =>
				 if   (bt::is_arrow_type body)
				      to_lambda_type  debruijn_depth  type;
				 else to_lambda_type  debruijn_depth
                                        ( tp::TYPE_SCHEME_TYPE
                                            { type_scheme_arg_eq_properties => an_api, 
					      type_scheme => tp::TYPE_SCHEME
                                                               { arity,
								 body  => bt::(-->) (bt::void_type, body)
							       }
					    }
					);
				 fi;

			 _ => if   (bt::is_arrow_type type)
                                  
                                   to_lambda_type  debruijn_depth  type;
			      else to_lambda_type  debruijn_depth  (bt::(-->) (bt::void_type, type));
                              fi;
                    esac;

		# The special look-up functions for the Core dictionary:
                # 
		fun core_lookup (id, dictionary)
                    = 
		    {   sp  =   symbol_path::SYMBOL_PATH [   core_symbol::core_symbol,   s::make_value_symbol id   ];
			err =   fn _ =  fn _ =  fn _ =  raise exception NO_CORE;

                        find_in_symbol_table::find_value_via_symbol_path (dictionary, sp, err);
		    };

		fun con' ((_, da::REF_REP, lt), ts, e)
                        =>
                        APPLY (PRIMITIVE_OP (po::MAKEREF, lt, ts), e);

		    con' ((_, da::SUSP (THE (da::HIGHCODE_VARIABLE d, _)), lt), ts, e)
			=>
			{   v  =   make_var ();

			    fe =   FN (v, lt::ltc_tuple [], e);

			    APPLY (TYPE_APPLY (VAR d, ts), fe);
			};

		    con' x => CONSTRUCTOR x;
                end;

		# The following code implements the exception tracking and 
		# errormsg reporting. 


		stipulate

                     source_code_region
                         =
                         REF (0, 0);

		     markexn
                         =
                         PRIMITIVE_OP ( po::MARKEXN,
				lt::ltc_parrow ( lt::ltc_tuple [ lt::ltc_exn, lt::ltc_string ],
						lt::ltc_exn
					      ),
				[]
			      );
		herein 

		    fun with_region loc f x
                        =
			{   r =   *source_code_region;

                            {   source_code_region := loc;

                                f x
                                before
                                    source_code_region := r;
                            }
			    except
                                e = {   source_code_region := r;
                                        raise exception e;
                                    };
			};

		    fun make_raise (x, lt)
                        = 
			{   e =    if *controls::track_exn
				        APPLY (markexn, RECORD [ x, STRING (error_match *source_code_region) ] );
				   else
                                        x;
                                   fi;

                            RAISE (e, lt);
			};

		    fun complain s =   error_fn   *source_code_region   s;
		    fun rep_err x  =   complain  em::ERROR  x  em::null_error_body;

		    fun rep_poly_eq ()
                        = 
			if *controls::poly_eq_warn
                             complain em::WARNING "calling poly_equal"  em::null_error_body;
			fi;

		end;			#  markexn-local 

		############################################################################
		#          SHARING AND LIFTING OF PACKAGE IMPORTS AND VAR_HOMEES
		############################################################################


		exception HASHTABLE;

		Key = Int;

		# * hashkey of var_homepath + var_homepath + res_var 

		Info = ((Key,  List( Int ), Highcode_Variable)); 

		my hashtable:  int_hash_table::Hash_Table( List( Info ) )
                              =
		              int_hash_table::make_table (32, HASHTABLE);    

		fun hashkey l
                    =
                    fold_right
                        (fn (x, y) =  ((x * 10 + y) % 1019))
                        0
                        l;

		fun build_header v
                    = 
		    {
                        fold_right h ident info
                        where

			    info =   int_hash_table::get  hashtable  v;

			    fun h ((_, l, w), header)
				= 
				{   le   =   fold_left  (fn (k, e) = SELECT (k, e))
							(VAR v)
							l;

				    fn e =  header (LET (w, le, e));
				};
			end;
		    }
                    except
                        _ = ident;


		fun bindvar (v, [], _)
                        =>
                        v;

		    bindvar (v, l, name_or_null)
			=> 
			h info
                        where
			    info   =   (int_hash_table::get  hashtable  v)  except _ = [];
			    key    =   hashkey l;

			    fun h []
				    =>  
				    {   u   =   make_highcode_variable  name_or_null;

					int_hash_table::set hashtable (v, (key, l, u) ! info);

					u;
				    };

			        h ((k', l', w) ! r)
				    => 
				    if   (k' == key)
				        
                                         if  (l' == l)  w;
					 else           h r;
                                         fi;
				    else
                                         h r;
                                    fi;
                            end;
			end;
                end;

		Picklehash_Info = ANON    List ((Int, Picklehash_Info))
		                | NAMED  (Highcode_Variable, Highcode_Type,  List ((Int, Picklehash_Info)));

		fun make_picklehash_info
                    ( t,
                      l,
                      name_or_null
                    )
                    = 
		    {   v =  make_highcode_variable
                                 name_or_null;

			fun h []      =>  NAMED (v, t, []);
			    h (a ! r) =>  ANON [(a, h r)];
                        end;

                        ( h l,
                          v
                        );
		    };

		fun merge_picklehash_info (pi, t, l, name_or_null)
                    = 
                    h (pi, l)
                    where
		        fun h (z as NAMED (v, _, _), [])
				=>
				(z, v);

			    h (ANON xl, [])
				=> 
				{   v = make_highcode_variable  name_or_null;

				    ( NAMED (v, t, xl),
				      v
				    );
				};

			    h (z, a ! r)
				=> 
				{   my (xl, make_node)
					= 
					case z

                                            ANON c
                                                =>
                                                (c, ANON);

				 	    NAMED (v, tt, c)
                                                =>
                                                ( c,
                                                  fn x = NAMED (v, tt, x)
                                                );
                                        esac;

				    fun dump ((np, v), z, y)
					= 
					{   nz =  (a, np) ! z;

					    ( make_node ((reverse y) @ nz),
					      v
					    );
					};

				    fun get ([], y)
					    =>
					    dump (   make_picklehash_info (t, r, name_or_null),
						     [],
						     y
						 );

				        get (u as ((x as (i, pi)) ! z), y)
					    => 
					    if   (i <  a)   get (z, x ! y);
					    elif (i == a)   dump (h (pi, r), z, y);
				  	    else            dump (make_picklehash_info (t, r, name_or_null), u, y);
                                            fi;
                                    end;


				    get (xl, []);
				};
                        end;
		    end;               # where (fun merge_picklehash_info)


		# A map that stores information
                # about external references:
                # 
		picklehash_map
                    =
                    REF (picklehash_map::empty:  picklehash_map::Map( Picklehash_Info ));


		fun make_picklehash (picklehash, t, l, name_or_null)
                    =
		    case (picklehash_map::get (*picklehash_map, picklehash))
		      
		         NULL
			     => 
			     {   my (picklehash_info, var)
				     =
				     make_picklehash_info (t, l, name_or_null);

				 picklehash_map
                                     :=
                                     picklehash_map::set
                                       ( *picklehash_map,
                                          picklehash,
                                          picklehash_info
                                       );

				 var;
			     };

		         THE picklehash_info
			     =>
			     {   my (new_picklehash_info, var)
				     =
				     merge_picklehash_info (picklehash_info, t, l, name_or_null);

				 fun remove (key, map)
				     = 
				     {   my (new_map, _) = picklehash_map::drop (map, key); 
					 new_map;
				     }
				     except
					 e =  map;

				 picklehash_map
                                     :=
                                     picklehash_map::set
                                       ( remove (picklehash, *picklehash_map),
                                         picklehash,
                                         new_picklehash_info
                                       );
				 var;
			     };
                    esac;

		intinf_map   =   REF (intinf_map::empty:  intinf_map::Map( Highcode_Variable ));

		fun get_interface_info n
                    =
		    case (intinf_map::get (*intinf_map, n))
		      
		         THE v => v;
		         NULL  => {   v = make_var ();
				      intinf_map := intinf_map::set (*intinf_map, n, v);
				      v;
				  };
                    esac;

		# Convert an var_home w. type into a lambda expression 
		#
		fun translate_var_home_with_type (p, t, name_or_null)
                    = 
                    VAR (h (p, []))
                    where
		        fun h (da::HIGHCODE_VARIABLE v, l) =>   bindvar (v, l, name_or_null);
			    h (da::EXTERN picklehash,   l) =>   make_picklehash (picklehash, t, l, name_or_null);
			    h (da::PATH (a, i),         l) =>   h (a, i ! l);
			    h _                            =>   bug "unexpected var_home in mkAccT";
                        end;
		    end;

		# Convert a var_home into a lambda expression 
		#
		fun translate_var_home (p, name_or_null)
                    = 
                    VAR (h (p, []))
		    where
		        fun h (da::HIGHCODE_VARIABLE v, l) =>   bindvar (v, l, name_or_null);
			    h (da::PATH (a, i), l)         =>   h (a, i ! l);
			    h _                            =>   bug "unexpected var_home in mkAcc";
                        end;
		    end;


		# These two functions are major gross hacks.
                # The NO_CORE exceptions would raised when compiling the files
                #     src/lib/core/init/runtime-system-placeholder.pkg,
                #     src/lib/core/init/runtime-system.api,
		#     boot/core.pkg
                # The assumption is that the result of core_exn and core_get
		# would never be used when compiling these three files.
                #
                # A good way to clean this up would be to put all the core constructors
		# and primitives into the primitive dictionary. XXX BUGGO FIXME (ZHONG)

		exception NO_CORE;

		fun core_exn id
                    =
		    case (core_access::get_constructor'  (fn () =  raise exception NO_CORE)  (symbol_table, id))
		      
			 tp::ENUM_CONSTRUCTOR { symbol, representation as da::EXCEPTION _, constructor_type, ... }
			     =>
			     {   constructor_type = to_dcon_lty  di::top  constructor_type;

				 constructor_rep = make_representation (representation, constructor_type, symbol);

				 con'((symbol, constructor_rep, constructor_type), [], unit_lexp);
			     };

			 _ => bug "core_exn in translate";
		    esac
		    except
                        NO_CORE
                            =
                            {   say "WARNING: no Core access\n";
                                INT 0;
                            }

		also
                fun core_get id
                    =
		    case (core_access::get_variable'  (fn () =  raise exception NO_CORE)  (symbol_table, id))
		      
		         vc::ORDINARY_VARIABLE { var_home, var_type, path, ... }
			     =>
			     translate_var_home_with_type (   var_home,
					to_lambda_type di::top  *var_type,
					get_name_or_null  path
				    );

			 _   =>
                             bug "core_get in translate";
		    esac
		    except
                        NO_CORE
			    =
			    {   say "WARNING: no Core access!\n";
				INT 0;
			    }

		# Expand the flex record pattern and convert the EXCEPTION var_home pattern 
		# internalize the Constructor_Form's var_home, always exceptions 
		#
		also
                fun make_representation (representation, lt, name)
                    = 
		    {   fun g (da::HIGHCODE_VARIABLE v, l, t)  => bindvar (v, l, THE name);
			    g (da::PATH (a, i), l, t) => g (a, i ! l, t);
			    g (da::EXTERN p, l, t) => make_picklehash (p, t, l, THE name);
			    g _ => bug "unexpected var_home in make_representation";
                        end;

		    
                        case representation
			  
			     (da::EXCEPTION x)
				 => 
				 { my (argt, _) = lt::ltd_parrow lt;

				     da::EXCEPTION ( da::HIGHCODE_VARIABLE ( g (x,   [],   lt::ltc_etag argt)));
				 };

			     (da::SUSP NULL)
				 =>  						#  A hack to support "delay-force" primitives 
				 case (core_get "delay", core_get "force")
				   
				      (VAR x, VAR y)
					  =>
					  da::SUSP ( THE ( da::HIGHCODE_VARIABLE x,
							   da::HIGHCODE_VARIABLE y
							 )

						  );
				      _   =>
                                          bug "unexpected case on Constructor_Form SUSP 1";
				  esac;


			     (da::SUSP (THE _))
                                 =>
                                 bug "unexpected case on Constructor_Form SUSP 2";

			     _ => representation;
                        esac; 
		    };

		# Convert a value of var_home+info into the lambda expression 
		#
		fun translate_var_home_info (var_home, info, get_lty, name_or_null)
                    = 
		    extern var_home   ??   translate_var_home_with_type (var_home, get_lty(), name_or_null)
                                      ::   translate_var_home           (var_home,            name_or_null);


		fun fill_pattern (pattern, d)
                    = 
                    fill pattern
                    where
		        fun fill (TYPE_CONSTRAINT_PATTERN (p, t))
                                =>
                                fill p;

			    fill (AS_PATTERN (p, q))
                                =>
                                AS_PATTERN (fill p, fill q);

			    fill (RECORD_PATTERN { fields, is_incomplete => FALSE, type_ref } )
				=>
				RECORD_PATTERN {
                                    fields =>   map   (fn (lab, p) =  (lab, fill p))   fields,
				    is_incomplete  => FALSE,
				    type_ref
				};

			    fill (pattern as RECORD_PATTERN { fields, is_incomplete => TRUE, type_ref } )
				=>
				{   exception DONT_BOTHER;

				    fields' =   map   (fn (l, p) =  (l, fill p))   fields;

				    fun find (t as tp::CONSTRUCTOR_TYPE (tp::RECORD_TYPE_CONSTRUCTOR labels, _))
                                            => 
					    {   type_ref := t;
                                                labels;
                                            };

				        find _ => {   complain em::ERROR "unresolved flexible record"
							  (fn stream
								=
								{ pp::newline stream;
								 pp::string stream "pattern: ";
								 unparse_deep_syntax::unparse_pattern symbol_table stream
								    (pattern,*controls::print::print_depth);
								}
							   );

						       raise exception DONT_BOTHER;
                                                   };
                                    end;

				    fun merge (a as ((id, p) ! r), lab ! s)
                                            =>
					    if (s::eq (id, lab) ) (id,  p               ) ! merge (r, s);
					    else                  (lab, WILDCARD_PATTERN) ! merge (a, s);
                                            fi;

				        merge ([], lab ! s) => (lab, WILDCARD_PATTERN) ! merge([], s);
				        merge ([], []) => [];
				        merge _ => bug "merge in translate";
                                    end;


				    RECORD_PATTERN { fields => merge ( fields', 
								       find (tu::head_reduce_type  *type_ref)
							             ),
						     is_incomplete => FALSE,
						     type_ref
					           }
				    except
                                        DONT_BOTHER
					    =
					    WILDCARD_PATTERN;
				};

			    fill (VECTOR_PATTERN (pats, type)) =>   VECTOR_PATTERN (map fill pats, type);
			    fill (OR_PATTERN (p1, p2))           =>   OR_PATTERN (fill p1, fill p2);

			    fill (CONSTRUCTOR_PATTERN (tp::ENUM_CONSTRUCTOR { symbol, const, constructor_type, representation, signature, is_lazy }, ts))
				=> 
				CONSTRUCTOR_PATTERN (

				    tp::ENUM_CONSTRUCTOR {

					symbol,
					const,
					constructor_type,
					is_lazy,
					signature,

					representation
                                            =>
                                            make_representation
                                              (
                                                representation,
                                                to_dcon_lty  d  constructor_type,
                                                symbol
                                              )
				    },
				    ts
				);

			    fill (APPLY_PATTERN (    tp::ENUM_CONSTRUCTOR { symbol, const, constructor_type, representation, signature, is_lazy },
                                              ts,
                                              pattern
                                         )
                                 )
				=> 
				APPLY_PATTERN (

				    tp::ENUM_CONSTRUCTOR {

					symbol,
					const,
					constructor_type,
					signature,
					is_lazy,

					representation
                                            =>
                                            make_representation 
                                              (
                                                representation,
                                                to_dcon_lty  d  constructor_type,
                                                symbol
                                              )
				    },
				    ts,
				    fill pattern
				);

			    fill xp
                                =>
                                xp;
                        end;
		    end;                  		# fun fill_pattern 

		# The runtime polymorphic equality
                # and string equality dictionary:
                #
		polymorphic_equality_dictionary
                    =
		    {   my str_eq_ref:      Ref( Null_Or( Polylambda_Expression ) ) =   REF NULL;
			my poly_eq_ref:     Ref( Null_Or( Polylambda_Expression ) ) =   REF NULL;
			my integer_eq_ref:  Ref( Null_Or( Polylambda_Expression ) ) =   REF NULL;

			fun get_string_eq ()
                            = 
			    case *str_eq_ref
                              
			         THE e => e;
			         NULL  => {   e = core_get "stringequal";
					      str_eq_ref := THE e;
                                              e;
					  };
                            esac;

			fun get_integer_eq ()		#  same as polyeq, but silent 
                            =
			    case *integer_eq_ref
                              
				 THE e => e;
			         NULL  => {   e = TYPE_APPLY (core_get "polyequal",
						      [to_type_constructor di::top bt::big_int_type]);
					      integer_eq_ref := THE e;
                                              e;
					  };
                            esac;

			fun get_poly_eq ()
                            = 
			    {   rep_poly_eq();

			        case *poly_eq_ref
                                  
                                     THE e => e;
			             NULL  => {   e = core_get "polyequal";
					         poly_eq_ref := (THE e);
                                                 e;
					     };
                                esac;
                            };
		    
                        { get_string_eq,
                          get_integer_eq,
                          get_poly_eq
                        };
		    };

		eq_g = polyequal::equal (polymorphic_equality_dictionary, symbol_table); 

		/***************************************************************************
		 *                                                                         *
		 * Translating the primops; this should be moved into a separate file      *
		 * in the future. (ZHONG)        XXX BUGGO FIXME                           *
		 *                                                                         *
		 ***************************************************************************/

		lt_tyc   = lt::ltc_tyc;
		lt_arw   = lt::ltc_parrow;
		lt_tup   = lt::ltc_tuple;
		lt_int   = lt::ltc_int;
		lt_int32 = lt::ltc_int32;
		lt_bool  = lt::ltc_bool;
		lt_unit  = lt::ltc_unit;

		lt_ipair   = lt_tup [lt_int, lt_int];
		lt_i32pair = lt_tup [lt_int32, lt_int32];
		lt_icmp    = lt_arw (lt_ipair, lt_bool);
		lt_ineg    = lt_arw (lt_int, lt_int);
		lt_intop   = lt_arw (lt_ipair, lt_int);
		lt_u_u     = lt_arw (lt_unit, lt_unit);

		my (true_dcon', false_dcon')
                    = 
		    {   lt = lt::ltc_parrow (lt::ltc_unit, lt::ltc_bool);	# highcode "Void -> Bool"

			fun h (tp::ENUM_CONSTRUCTOR { symbol, representation, constructor_type, ... } )
                            =
                            (symbol, representation, lt);
		    
                        (h bt::true_dcon, h bt::false_dcon);
		    };

		true_lexp  = CONSTRUCTOR (true_dcon',  [], unit_lexp); 
		false_lexp = CONSTRUCTOR (false_dcon', [], unit_lexp);

		fun cond (a, b, c)
		    =
		    SWITCH ( a,
                             bt::bool_signature,
                             [ (DATACON (true_dcon',  [], make_var()), b),
			       (DATACON (false_dcon', [], make_var()), c)
                             ],
                             NULL
                           );

		fun compose_not (eq, t)
		    =  
		    {   v = make_var();
			argt = lt_tup [t, t];
		        FN (v, argt, cond (APPLY (eq, VAR v), false_lexp, true_lexp));
		    };

		fun cmp_op  p =  PRIMITIVE_OP (p, lt_icmp, []);
		fun ineg_op p =  PRIMITIVE_OP (p, lt_ineg, []);

		lessu = po::CMP { oper=>po::LTU, kind=>po::UINT 31 };

		lt_len = lt::ltc_poly([lt::tkc_mono], [lt_arw (lt::ltc_tv 0, lt_int)]);

		lt_upd
                    = 
		    {   x = lt::ltc_ref (lt::ltc_tv 0);
		        lt::ltc_poly([lt::tkc_mono], 
				  [lt_arw (lt_tup [x, lt_int, lt::ltc_tv 0], lt::ltc_unit)]);
		    };

		fun len_op (tc) = PRIMITIVE_OP (po::LENGTH, lt_len, [tc]);

		fun rshift_op  k =  po::ARITH { oper=>po::RSHIFT, overflow=>FALSE,  kind=>k };
		fun rshiftl_op k =  po::ARITH { oper=>po::RSHIFTL, overflow=>FALSE, kind=>k };
		fun lshift_op  k =  po::ARITH { oper=>po::LSHIFT,  overflow=>FALSE, kind=>k };

		fun lword0 (po::UINT 31) => WORD 0u0;  
		    lword0 (po::UINT 32) => WORD32 0u0;
		    lword0 _  => bug "unexpected case in lword0";
                end;

		fun baselt (po::UINT 31) => lt_int;
		    baselt (po::UINT 32) => lt_int32;
		    baselt _  => bug "unexpected case in baselt";
                end;

		fun shift_type k
                    = 
		    {   element = baselt k;
		        tupt = lt_tup [element, lt_int]; 
		        lt_arw (tupt, element);
		    }; 

		fun inline_shift (shift_op, kind, clear)
                    = 
		    {   fun shift_limit (po::UINT lim | po::INT lim) => WORD (unt::from_int lim);
			    shift_limit _ => bug "unexpected case in shiftLimit";
                        end;

			p   = make_var();   vp   = VAR p;
			w   = make_var();   vw   = VAR w;
			count = make_var();   vcnt = VAR count;

			argt = lt_tup [baselt (kind), lt_int];

			cmp_shift_amt
                            = 
			    PRIMITIVE_OP (po::CMP { oper=>po::LEU, kind=>po::UINT 31 }, lt_icmp, []);

			FN (p, argt,
			     LET (w, SELECT (0, vp),
				 LET (count, SELECT (1, vp),
				     cond (APPLY (cmp_shift_amt, RECORD [shift_limit (kind), vcnt]),
					  clear vw, 
					  APPLY (PRIMITIVE_OP (shift_op (kind), shift_type (kind), []),
					      RECORD [vw, vcnt])))));
		    };

		fun inlops nk
		    =
		    {
			my (lt_arg, zero, overflow)
			    =
			    case nk
			      
				 po::INT 31 => (lt::ltc_int, INT 0, TRUE);
				 po::UINT 31 => (lt::ltc_int, WORD 0u0, FALSE);
				 po::INT 32 => (lt::ltc_int32, INT32 0, TRUE);
				 po::UINT 32 => (lt::ltc_int32, WORD32 0u0, FALSE);
				 po::FLOAT 64 => (lt::ltc_real, REAL "0.0", FALSE);
				 _ => bug "inlops: bad numkind";
			    esac;

			lt_argpair = lt_tup [lt_arg, lt_arg];
			compare_lambda_types = lt_arw (lt_argpair, lt_bool);

			lt_neg = lt_arw (lt_arg, lt_arg);
			less = PRIMITIVE_OP (po::CMP { oper => po::LT, kind => nk }, compare_lambda_types, []);

			greater = PRIMITIVE_OP (po::CMP { oper => po::GT, kind => nk }, compare_lambda_types, []);

			negate =
			    PRIMITIVE_OP (po::ARITH { oper => po::NEGATE, overflow, kind => nk },
				  lt_neg, []);

			{ lt_arg, lt_argpair, compare_lambda_types, less, greater, zero, negate };
		    };

		fun inlminmax (nk, ismax)
                    =
                    {   my { lt_argpair, less, greater, compare_lambda_types, ... }
                            =
                            inlops nk;

			x = make_var ();
                        y = make_var ();
                        z = make_var ();

			cmpop = if ismax  greater; else less;fi;

			elsebranch
                            =
			    case nk
                              
				po::FLOAT _ => {
				    #  testing for NaN 
				    fequal =
					PRIMITIVE_OP (po::CMP { oper => po::EQL, kind => nk }, compare_lambda_types, []);

				    cond (APPLY (fequal, RECORD [VAR y, VAR y]), VAR y, VAR x);
				};

			        _ => VAR y;
                            esac;

			FN (z, lt_argpair,
			    LET (x, SELECT (0, VAR z),
				 LET (y, SELECT (1, VAR z),
				      cond (APPLY (cmpop, RECORD [VAR x, VAR y]),
					    VAR x, elsebranch))));
		    };

		fun inlabs nk
		    =
		    {   my { lt_arg, greater, zero, negate, ... }
                            =
                            inlops nk;

			x = make_var ();

			FN (x, lt_arg,
			    cond (APPLY (greater, RECORD [VAR x, zero]),
				  VAR x, APPLY (negate, VAR x)));
		    };

		fun inl_inf_prec (what, corename, p, lt, is_from_inf)
		    =
		    {   my (orig_arg_lt, res_lt)
                            =
			    case (lt::ltd_arrow lt)
                              
				 (_, [a], [r]) =>  (a, r);
			         _             =>  bug ("unexpected type of " + what);
                            esac;

			extra_arg_lt
                            =
			    lt::ltc_parrow (if is_from_inf  (orig_arg_lt, lt::ltc_int32);
					   else (lt::ltc_int32, orig_arg_lt);fi);

			new_arg_lt =  lt::ltc_tuple [orig_arg_lt, extra_arg_lt];
			new_lt     =  lt::ltc_parrow (new_arg_lt, res_lt);

			x = make_var ();

			FN (x, orig_arg_lt,
			    APPLY (PRIMITIVE_OP (p, new_lt, []),
				 RECORD [VAR x, core_get corename]));
		    };

		fun translate_primitive_operation (primitive_op, lt, ts)		
                    = 
		    g primitive_op
                    where
		        fun g (po::INLLSHIFT  k) =>  inline_shift (lshift_op,  k, fn _ =  lword0 (k));
			    g (po::INLRSHIFTL k) =>  inline_shift (rshiftl_op, k, fn _ =  lword0 (k));

			    g (po::INLRSHIFT k)  #  preserve an_api bit with arithmetic rshift 
                                =>
				inline_shift (rshift_op, k, clear)
                                where
				    fun clear w
                                        =
                                        APPLY (PRIMITIVE_OP (rshift_op k, shift_type k, []), 
						      RECORD [w, WORD 0u31]); 
				end;

			    g (po::INLMIN nk) => inlminmax (nk, FALSE);
			    g (po::INLMAX nk) => inlminmax (nk, TRUE);
			    g (po::INLABS nk) => inlabs nk;

			    g (po::INLNOT)
				=>
				{   x = make_var();

				    FN (x, lt_bool, cond (VAR x, false_lexp, true_lexp));
				}; 

			    g (po::INLCOMPOSE)
				=>
				{   my (t1, t2, t3)
					= 
					case ts
					  
					     [a, b, c] =>  ( lt_tyc  a,
							     lt_tyc  b,
							     lt_tyc  c
							   );

					     _         =>  bug "unexpected type for INLCOMPOSE";
					esac;

				    argt = lt_tup [ lt_arw  (t2, t3),
						    lt_arw  (t1, t2)
						  ];

				    x = make_var();
				    z = make_var(); 
				    f = make_var();
				    g = make_var();

				    FN (z, argt, 
					LET (f, SELECT (0, VAR z),
					  LET (g, SELECT (1, VAR z),
					    FN (x, t1, APPLY (VAR f, APPLY (VAR g, VAR x))))));
				};                  

			    g (po::INLBEFORE)
				=>
				{   my (t1, t2)
					= 
					case ts
					  
					     [a, b] =>  (lt_tyc a, lt_tyc b);
					     _      =>  bug "unexpected type for INLBEFORE";
					esac;

				    argt = lt_tup [t1, t2];
				    x = make_var();

				    FN (x, argt, SELECT (0, VAR x));
				};

			    g (po::INLIGNORE)
				=>
				{   argt =
					case ts
					  
					     [a] =>  lt_tyc a;
					     _   =>  bug "unexpected type for INLIGNORE";
					esac;

				    FN (make_var (), argt, unit_lexp);
				};

			    g (po::INLIDENTITY)
				=>
				{   argt =
					case ts
					  
					     [a] =>  lt_tyc  a;
					     _   =>  bug "unexpected type for INLIDENTITY";
					esac;

				    v = make_var ();

				    FN (v, argt, VAR v);
				};

			    g (po::CVT64)
				=>
				{   v = make_var ();
				    FN (v, lt_i32pair, VAR v);
				};

			    g (po::INLSUBSCRIPTV)
				=>
				{   my (tc1, t1)
					=
					case ts
					  
					     [z] =>  (z, lt_tyc z);
					     _   =>  bug "unexpected type for INLSUBV";
					esac;

				    seqtc =  lt::tcc_vector tc1;
				    argt  =  lt_tup [lt_tyc seqtc, lt_int];

				    oper = PRIMITIVE_OP (po::SUBSCRIPT, lt, ts);

				    p = make_var();
				    a = make_var();
				    i = make_var();

				    vp = VAR p;
				    va = VAR a;
				    vi = VAR i;

				  FN (p, argt,
				      LET (a, SELECT (0, vp),
					LET (i, SELECT (1, vp),
					  cond (APPLY (cmp_op (lessu), 
						   RECORD [vi, APPLY (len_op seqtc, va)]),
					       APPLY (oper, RECORD [va, vi]),
					       make_raise (core_exn "SUBSCRIPT", t1)))));
				};


			    g (po::INLSUBSCRIPT)
				=> 
				{   my (tc1, t1)
					=
					case ts
					  
					    [z] => (z, lt_tyc z);
					    _   => bug "unexpected type for INLSUB";
					esac;

				    seqtc = lt::tcc_array tc1;
				    argt = lt_tup [lt_tyc seqtc, lt_int];

				    oper = PRIMITIVE_OP (po::SUBSCRIPT, lt, ts);

				    p = make_var();
				    a = make_var();
				    i = make_var();

				    vp = VAR p;
				    va = VAR a;
				    vi = VAR i;

				    FN (p, argt,
					LET (a, SELECT (0, vp),
					  LET (i, SELECT (1, vp),
					    cond (APPLY (cmp_op (lessu), 
						     RECORD [vi, APPLY (len_op seqtc, va)]),
						 APPLY (oper, RECORD [va, vi]),
						 make_raise (core_exn "SUBSCRIPT", t1)))));
				};

			    g (po::NUMSUBSCRIPT { kind, checked=>TRUE, immutable } )
				=>
				{   my (tc1, t1, t2)
					= 
					case ts
					  
					     [a, b] =>  (a, lt_tyc a, lt_tyc b);
					     _      =>  bug "unexpected type for NUMSUB";
					esac;

				    argt = lt_tup [t1, lt_int];

				    p = make_var();
				    a = make_var();
				    i = make_var();

				    vp = VAR p;
				    va = VAR a;
				    vi = VAR i;

				    oper = po::NUMSUBSCRIPT { kind, checked=>FALSE,
							       immutable };
				    oper' = PRIMITIVE_OP (oper, lt, ts);

				    FN (p, argt,
					LET (a, SELECT (0, vp),
					  LET (i, SELECT (1, vp),
					    cond (APPLY (cmp_op (lessu), RECORD [vi, 
								     APPLY (len_op tc1, va)]),
						 APPLY (oper', RECORD [va, vi]),
						 make_raise (core_exn "SUBSCRIPT", t2)))));
				};

			    g (po::INLUPDATE)
				=> 
				{   my (tc1, t1)
					=
					case ts
					  
					     [z] =>  (z, lt_tyc z);
					     _   =>  bug "unexpected type for INLSUB";
					esac;

				    seqtc = lt::tcc_array tc1;
				    argt = lt_tup [lt_tyc seqtc, lt_int, t1];

				    oper = PRIMITIVE_OP (po::UPDATE, lt, ts);

				    x = make_var();

				    a = make_var();
				    i = make_var();
				    v = make_var();

				    vx = VAR x;
				    va = VAR a;
				    vi = VAR i;
				    vv = VAR v;

				    FN (x, argt,
					LET (a, SELECT (0, vx),
					  LET (i, SELECT (1, vx),
					    LET (v, SELECT (2, vx),
					      cond (APPLY (cmp_op (lessu),
						       RECORD [vi, APPLY (len_op seqtc, va)]),
						   APPLY (oper, RECORD [va, vi, vv]),
						   make_raise (core_exn "SUBSCRIPT", lt::ltc_unit))))));
				};

			    g (po::NUMUPDATE { kind, checked=>TRUE } )
				=>
				{   my (tc1, t1, t2)
					= 
					case ts
					  
					     [a, b] =>  (a, lt_tyc a, lt_tyc b);
					     _      =>  bug "unexpected type for NUMUPDATE";
					esac;

				    argt = lt_tup [t1, lt_int, t2];

				    p = make_var();
				    a = make_var();
				    i = make_var();
				    v = make_var();

				    vp = VAR p;
				    va = VAR a;
				    vi = VAR i;
				    vv = VAR v;

				    oper = po::NUMUPDATE { kind, checked=>FALSE };
				    oper' = PRIMITIVE_OP (oper, lt, ts);

				    FN (p, argt,
					LET (a, SELECT (0, vp),
					  LET (i, SELECT (1, vp),
					    LET (v, SELECT (2, vp),
					      cond (APPLY (cmp_op (lessu),
						       RECORD [vi, APPLY (len_op tc1, va)]),
						   APPLY (oper', RECORD [va, vi, vv]),
						   make_raise (core_exn "SUBSCRIPT", lt::ltc_unit))))));
				};

		  /**** ASSIGN (r, x) != UPDATE (r, 0, x) under new rw_vector reps (John H Reppy;1998-10-30)
			  | g (po::ASSIGN) = 
				let my (tc1, t1) = case ts of [z] => (z, lt_tyc z)
						      | _ => bug "unexpected type for ASSIGN"

				    seqtc = lt::tcc_ref tc1
				    argt = lt_tup [lt_tyc seqtc, t1]

				    oper = PRIMITIVE_OP (po::UPDATE, lt_upd, [tc1])

				    x = make_var()
				    varX = VAR x

				 in FN (x, argt, 
				     APPLY (oper, RECORD [SELECT (0, varX), INT 0, SELECT (1, varX)]))
				end
		  ****/

			    # Precision-conversion operations involving integer.
			    # These need to be translated specially by providing
			    # a second argument -- the routine from _Core that
			    # does the actual conversion to or from integer.

			    g (p as po::TEST_INF prec)
				=>
				inl_inf_prec ("TEST_INF", "test_inf", p, lt, TRUE);


			    g (p as po::TRUNC_INF prec)
				=>
				inl_inf_prec ("TRUNC_INF", "trunc_inf", p, lt, TRUE);


			    g (p as po::EXTEND_INF prec)
				=>
				inl_inf_prec ("EXTEND_INF", "fin_to_inf", p, lt, FALSE);


			    g (p as po::COPY_INF prec)
				=>
				inl_inf_prec ("COPY", "fin_to_inf", p, lt, FALSE);

			    # Default handling for all other
			    # primitive operations:
			    #
			    g primitive_op
                                =>
                                PRIMITIVE_OP (primitive_op, lt, ts);
			end; 
		    end;			#  where (fun translate_primitive_operation)


		fun make_intinf_switch (sv, cases, default)
                    =
                    {   v = make_var ();

			# Build a chain of equality tests
                        # for checking large pattern values 
			#
			fun build []
                                =>
                                default;

			    build ((n, e) ! r)
				=>
				cond ( APPLY ( polymorphic_equality_dictionary.get_integer_eq (),
                                             RECORD [VAR v, VAR (get_interface_info n)]
                                           ),
				       e,
                                       build r
                                     );
			end;

			# Split pattern values into small values also large values;
			# small values can be handled directly using SWITCH:
			#
			fun split ([], s, l)
                                =>
                                (reverse s, reverse l);

			    split ((n, e) ! r, sm, lg)
				=>
				case (ln::low_val n)
                                  
				    THE l =>   split (r, (INTCON l, e) ! sm, lg);
				    NULL  =>   split (r, sm, (n, e) ! lg);
                                esac;
			end;

			fun gen ()
			    =
			    case (split (cases, [], []))
			      
				([], largeints)
                                    =>
                                    build largeints;

				(smallints, largeints)
				    =>
				    {   iv = make_var ();

					LET ( iv,
                                              APPLY (core_get "inf_low_value", VAR v),
					      SWITCH ( VAR iv,
						       da::NULLARY_CONSTRUCTOR,
						       smallints,
						       THE (build largeints)
                                            )        );
				    };
			    esac;

			LET (v, sv, gen ());
		    };


		##########################################################################################
		# 
		# Translation of various namings into lambda expressions:
		# 
		#  my translate_variable:  vc::var * di::depth -> l::Polylambda_Expression
		#  my mkVE:  vc::var * List( t::Type ) -> l::Polylambda_Expression
		#  my mkCE:  t::Constructor
		#          * List( t::Type )
		#          * Null_Or( l::Polylambda_Expression )
		#          * di::depth -> l::Polylambda_Expression
		#  my translate_package:  m::Package * di::depth -> l::Polylambda_Expression
		#  my translate_generic:  m::Generic * di::depth -> l::Polylambda_Expression
		#  my translate_symbol_table_entry:   di::depth -> st::naming -> l::Polylambda_Expression
		#
		##########################################################################################
		fun translate_variable
                        ( (v as vc::ORDINARY_VARIABLE { var_home, inlining_info, var_type, path }):   vc::Variable,
                          debruijn_depth:  debruijn_index::Depth
                        )
                        : polylambda::Polylambda_Expression
			=> 
			translate_var_home_info
                          (
                            var_home,
			    inlining_info,
			    fn () =  to_lambda_type  debruijn_depth  *var_type,
			    get_name_or_null  path
			  );

		    translate_variable _
                        =>
                        bug "unexpected vars in makeVariable";
                end;

		fun translate_variable_in_expression (v, ts, d)
		    =
		    {   fun otherwise ()
			    =
			    case ts
			      
			         [] =>  translate_variable (v, d);
			         _  =>  TYPE_APPLY (translate_variable (v, d), map (to_type_constructor d) ts);
                            esac;
		    
			case v
			  
			     vc::ORDINARY_VARIABLE { inlining_info, ... }
				 =>
				 ii::match inlining_info
				     {
				       do_inline_package =>  fn _  =  otherwise (),
				       do_inline_nothing =>  fn () =  otherwise (),

                                       do_inline_primitive
                                           =>
                                           fn (p, type)
                                               =
				               case (p, ts)
                                                 
						    (po::POLYEQL, [t])
                                                        =>
                                                        eq_g (type, t, to_tc_lt d);

						    (po::POLYNEQ, [t])
                                                        =>
						        compose_not (eq_g (type, t, to_tc_lt d), to_lambda_type d t);

						    (po::INLMKARRAY, [t])
                                                        => 
						        {   dictionary = 
							        { default =>  core_get "mk_norm_array",
							          table   =>  [([lt::tcc_real], core_get "mk_real_array")]
                                                                };

						            GENOP (
                                                                dictionary,
                                                                p,
                                                                to_lambda_type  d  type,
                                                                map  (to_type_constructor d)  ts
                                                            );
						        };

						    (po::RAW_CCALL NULL, [a, b, c])
                                                        =>
						        {   i = THE (cprototype::decode ansi_c_prototype_convention
										      { function_type => a, encoding => b }
								    )
								    except
								        cprototype::BAD_ENCODING =  NULL;

							    PRIMITIVE_OP (
                                                                po::RAW_CCALL  i,
                                                                to_lambda_type  d  type,
                                                                map  (to_type_constructor d)  ts
                                                            );
						        };

						    _   =>
                                                        translate_primitive_operation
                                                          (
                                                            p,
                                                            (to_lambda_type d type),
                                                            map (to_type_constructor d) ts
                                                          );
                                               esac
                                   };

			     _   =>
                                 otherwise ();
                        esac;
		    };

		fun translate_constructor_expression (tp::ENUM_CONSTRUCTOR { const, representation, symbol, constructor_type, ... }, ts, ap_op, d)
                    = 
		    {   lt = to_dcon_lty  d  constructor_type;
			representation' = make_representation (representation, lt, symbol);
			dc = (symbol, representation', lt);
			ts' = map (to_type_constructor d) ts;

                        if   (const)
                             con'(dc, ts', unit_lexp);
			else
                             case ap_op
			       
				  THE le => con'(dc, ts', le);

				  NULL => 
				    {   my (arg_t, _) = lt::ltd_parrow (lt::protected_instantiation_of_polymorphic_lambda_or_higher_order_constructor_type (lt, ts'));
					v = make_var ();
				        FN (v, arg_t, con'(dc, ts', VAR v));
				    };
                             esac;
                        fi;
		    };

		fun translate_package (s as m::A_PACKAGE { var_home, inlining_info=>info, ... }, d)
			=>
			translate_var_home_info
                            (
                              var_home,
                              info,
                              fn () = package_to_lambda_type (s, d, compile_info),
                              NULL
                            );

		    translate_package _
			=>
			bug "unexpected packages in translate_package";
                end;


		fun translate_generic (f as m::GENERIC { var_home, inlining_info=>info, ... }, d)
			=>
			translate_var_home_info
                            (
                              var_home,
                              info,
                              fn () = generic_lty (f, d, compile_info),
                              NULL
                            );

		    translate_generic _
			=>
			bug "unexpected generics in translate_generic";
                end;


		fun translate_symbol_table_entry
                    (debruijn_depth:  debruijn_index::Depth)
		    : (st::Symbol_Table_Entry -> polylambda::Polylambda_Expression)
                    =
                    g
                    where
		        fun g (st::NAMED_VARIABLE v) =>  translate_variable (v, debruijn_depth);
			    g (st::NAMED_PACKAGE  s) =>  translate_package  (s, debruijn_depth);
			    g (st::NAMED_GENERIC  f) =>  translate_generic  (f, debruijn_depth);

			    g (st::NAMED_CONSTRUCTOR (tp::ENUM_CONSTRUCTOR { representation=>(da::EXCEPTION acc), symbol, constructor_type, ... } ))
				=>
				{   nt = to_dcon_lty  debruijn_depth  constructor_type;

				    my (argt, _) = lt::ltd_parrow nt;

				    translate_var_home_with_type (acc, lt::ltc_etag argt, THE symbol);
				};

			    g _ => bug "unexpected namings in translate_symbol_table_entry";
                        end;
		    end;


		#################################################################################
		# 
		# Translate core deep_syntax_tree declarations into lambda expressions:
		# 
		#    my translate_named_values:  List( deep_syntax::Named_Value )
		#                          * depth
		#                         -> Lambda::Polylambda_Expression
		#                         -> Lambda::Polylambda_Expression
		# 
		#    my translate_named_recursive_values
		#        :
		#        List( deep_syntax::Named_Recursive_Values )
		#      * depth
		#     -> Lambda::Polylambda_Expression
		#     -> Lambda::Polylambda_Expression
		# 
		#    my translate_exception_declarations:   List( deep_syntax::eb )
		#               * depth
		#              -> Lambda::Polylambda_Expression
		#              -> Lambda::Polylambda_Expression
		#
		#################################################################################

													# polylambda		is from   src/lib/compiler/upper/polylambda/polylambda.pkg
													# deep_syntax		is from   src/lib/compiler/front/typecheck-stuff/deep-syntax/deep-syntax.pkg
													# debruijn_index	is from   src/lib/compiler/front/typechecker/basics/de-bruijn-index.pkg

/*x*/		fun translate_pattern_expression (expression, d, [], callstack)
                        =>
                        {
				    if *debugging
                                        print_callstack "\n============= translate_pattern_expression/TOP ============= " callstack;
					if_debugging_unparse_expression ("translate_pattern_expression input expression argument:", (expression,100));
					printf "translate_pattern_expression bound_typevar_refs argument has 0 entries so calling translate_expression instead of translate_pattern-expression.\n";
				    fi;

                            result = translate_deep_syntax_expression_to_polylambda (expression, d, "translate_pattern_expression" ! callstack );

				    if *debugging
					printf "translate_pattern_expression/BOTTOM in translate-deep-syntax-to-polylambda.pkg\n";
				    fi;

                            result;
                        };

/*x*/		    translate_pattern_expression
/*x*/                   ( expression:          deep_syntax::Deep_Expression,
/*x*/                     debruijn_depth:      debruijn_index::Depth,
/*x*/                     bound_typevar_refs:  List( types::Typevar_Ref ),	# From a deep syntax NAMED_VALUE or NAMED_RECURSIVE_VALUES record.
/*x*/                     callstack:           List( String ) 
/*x*/                   )
/*x*/                   : polylambda::Polylambda_Expression
/*x*/			=> 
/*x*/			{
                            if *debugging
                                print_callstack "\n============= translate_pattern_expression/TOP ============= " callstack;
                                if_debugging_unparse_expression ("translate_pattern_expression input expression argument:", (expression,100));
                                printf "translate_pattern_expression bound_typevar_refs argument has %d entries:\n"  (length  bound_typevar_refs);
				apply unparse bound_typevar_refs
                                where
	                            fun unparse  typevar_ref
                                        =
                                        if_debugging_unparse_typevar_ref  ("", typevar_ref);
                                end;
                                printf "\n";
                            fi;



/*x*/                       bound_typevar_refs'
/*x*/                           =
/*x*/                           map f bound_typevar_refs
/*x*/                           where
/*x*/				    fun f { id, ref_typevar }
/*x*/                                   =
/*x*/                                   ref_typevar;
/*x*/                           end;

/*x*/                       old_bound_typevar_refs_values
/*x*/                           =
/*x*/                           map  (*_)  bound_typevar_refs';

											# translate_types	is from   src/lib/compiler/upper/translate/translate-types.pkg
                            # Assign TYPE_VARIABLE_MARK type_variables.
			    # We will erase these before we return.
			    #
			    # These TYPE_VARIABLE_MARK values are only
			    # used in translate_types::to_type_constructor():	
			    #
/*x*/			    g (0, bound_typevar_refs)
                            where
				fun g (i, [])
					=>
					();

/*x*/				    g (i, { id, ref_typevar as REF (tp::META_TYPE_VARIABLE _ | tp::INCOMPLETE_RECORD_TYPE_VARIABLE _) } ! rest)
/*x*/					=>
/*x*/					{   m =   mark_lbound (debruijn_depth, i);		# This is the only call to mark_lbound in the compiler.

					    if *debugging
                                                printf "Setting [id%d]typevar_ref to (TYPE_VARIABLE_MARK (mark_lbound (d==%d, i==%d))):  g()  in  translate_pattern_expression()  in translate_deep_syntax_to_polylambda\n" id (di::dp_toint debruijn_depth)  i;
                                            fi;

/*x*/					    ref_typevar :=   tp::TYPE_VARIABLE_MARK m;		# This is the only place TYPE_VARIABLE_MARK are created.

/*x*/					    g (i+1, rest);
					};

                                    # 2009-06-01 CrT: In the parent SML/NJ compiler this case cannot happen.
                                    # When I added OOP support, in particular generalizing mutually recursive
                                    # functions, it became possible, but so far as I can see it is harmless,
                                    # so now we just ignore this case:
				    #
/*x*/				    g (i, ( typevar_ref as { id, ref_typevar as REF (tp::TYPE_VARIABLE_MARK _) } ) ! result)
/*x*/					=>
					{   if *debugging
                                                printf "Ignoring the fact that [id%d]typevar_ref is already set to (TYPE_VARIABLE_MARK (i d==%d) translate_deep_syntax_to_polylambda\n" id i;
                                            fi;
/*x*/				           # bug (sprintf "unexpected [id%d]type_variable TYPE_VARIABLE_MARK in translate_pattern_expression i d=%d" id i);
/*x*/					   ();
                                        };

				    g _ => bug "unexpected type_variable MACRO_EXPANDED in translate_pattern_expression";
				end;
			    end;


/*x*/			    expression' = translate_deep_syntax_expression_to_polylambda (expression, di::next debruijn_depth, "translate_pattern_expression" ! callstack);

                            if *debugging
                                printf "translate_pattern_expression/BBB in translate-deep-syntax-to-polylambda.pkg\n";
			    fi;	

			    # Set all bound_typevar_refs
                            # back to their original value:
			    #
			    restore (bound_typevar_refs', old_bound_typevar_refs_values)
                            where
				fun restore ([], [])
                                        =>
                                        ();

				    restore
                                        ( ref_typevar ! ref_typevars,
                                          old_value   ! old_values
                                        )
                                        =>
                                        {   ref_typevar := old_value;
                                            restore (ref_typevars, old_values);
                                        };

				    restore _
                                        =>
                                        bug "unexpected cases in translate_pattern_expression";
				end;
			    end;

			    len = length  bound_typevar_refs';

                            if *debugging
                                printf "translate_pattern_expression/BOTTOM in translate-deep-syntax-to-polylambda.pkg\n";
                                printf "translate_pattern_expression bound_typevar_refs argument %d entries restored:\n"  (length  bound_typevar_refs);
				apply unparse bound_typevar_refs
                                where
	                            fun unparse  typevar_ref
                                        =
                                        if_debugging_unparse_typevar_ref  ("", typevar_ref);
                                end;
			    fi;	

			    TYPE_FN (lt::tkc_arg  len,  expression');
			};
                end 

		also
/*x*/           fun translate_named_values
/*x*/               ( named_values:    List( deep_syntax::Named_Value ),		# Obtained from a deep_syntax::VALUE_DECLARATIONS
/*x*/                 debruijn_depth:  debruijn_index::Depth,
/*x*/                 callstack:       List( String ) 
/*x*/               )
/*x*/		    : (polylambda::Polylambda_Expression -> polylambda::Polylambda_Expression)
/*x*/               =
/*x*/		    {
                                                             if *debugging    print_callstack "\n============= translate_named_values/TOP    ============= " callstack; fi;
/*x*/                   result =  fold  g  named_values;
                                                             if *debugging    print_callstack "\n============= translate_named_values/BOTTOM ============= " callstack; fi;
/*x*/                   result;
/*x*/               }
                    where
		        fun eq_tvs ([], [])					# "tvs" == "type variables"
                                =>
                                TRUE;

			    eq_tvs (a ! r, (tp::TYPE_VARIABLE_REF b) ! s)
                                =>
                                if (a==b)  eq_tvs (r, s);
                                else       FALSE;
                                fi;

			    eq_tvs _
                                =>
                                FALSE;
                        end;

/*x*/			fun g named_value
/*x*/                       =
/*x*/                       {
                                                             if *debugging printf "\ntranslate_named_values/LOOP TOP\n"; fi;
/*x*/				result =  g'  named_value;
                                                             if *debugging printf "\ntranslate_named_values/LOOP BOTTOM\n"; fi;
/*x*/				result;
/*x*/                       }
                        also
			fun g'  ( NAMED_VALUE
                                    {
                                      pattern    => VARIABLE_IN_PATTERN (vc::ORDINARY_VARIABLE { var_home=>da::HIGHCODE_VARIABLE v, ... } ),
				      expression as VARIABLE_IN_EXPRESSION (REF (w as (vc::ORDINARY_VARIABLE _)), instys),
				      bound_typevar_refs,
                                      ...
                                    },
                                  fold_result_so_far
                                )
				=> 
				if   (eq_tvs (bound_typevar_refs, instys))
if *debugging printf "\nCALLING translate_variable:  g()/NAMED_VALUE I in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
				     result = LET (v, translate_variable (w, debruijn_depth), fold_result_so_far);
if *debugging printf "\nCALLED  translate_variable:  g()/NAMED_VALUE I in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
                                     result;
				else
if *debugging printf "\nCALLING translate_pattern_expression:  g()/NAMED_VALUE I in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;

                                     result = LET (v, translate_pattern_expression (expression, debruijn_depth, bound_typevar_refs, "translate_named_values/g/NAMED_VALUE" ! callstack), fold_result_so_far);

if *debugging printf   "CALLED  translate_pattern_expression:  g()/NAMED_VALUE I in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;

				     result;
                                fi;

/*x*/			    g'  ( NAMED_VALUE { pattern as VARIABLE_IN_PATTERN (vc::ORDINARY_VARIABLE { var_home=>da::HIGHCODE_VARIABLE v, ... } ),
/*x*/				                expression,
/*x*/                                           bound_typevar_refs,
/*x*/                                           ...
/*x*/                                         },
/*x*/                             fold_result_so_far
/*x*/                           )
/*x*/				=>
/*x*/			        {
                                                               if *debugging    print_callstack "\n============= translate_named_values/g()/NAMED_VALUE II/TOP    ============= " callstack; fi;
	                                                       if_debugging_unparse_expression ("\nexpression:", (expression,100));
	                                                       if_debugging_unparse_pattern    ("\npattern:",    (pattern,   100));
							       if *debugging
								   printf "\nbound_typevar_refs (%d entries):\n"  (length  bound_typevar_refs);
								   apply unparse bound_typevar_refs
								   where
								       fun unparse  typevar_ref
									   =
									   if_debugging_unparse_typevar_ref  ("", typevar_ref);
								   end;
								   printf "\n";
							       fi;
	                                                       if_debugging_prettyprint_expression ("\nexpression:", (expression,100));
	                                                       if_debugging_prettyprint_pattern    ("\npattern:",    (pattern,   100));

                                                               if *debugging printf "\nCALLING translate_pattern_expression:  g()/NAMED_VALUE II in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;

/*x*/				    result = LET (v, translate_pattern_expression (expression, debruijn_depth, bound_typevar_refs, "translate_named_values.g/NAMED_VALUE II" ! callstack), fold_result_so_far);

                                                               if *debugging printf "CALLED  translate_pattern_expression:  g()/NAMED_VALUE II in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
                                                               if *debugging    print_callstack "\n============= translate_named_values/g()/NAMED_VALUE II/BOTTOM ============= " callstack; fi;

/*x*/                               result;
				}; 

			    g'  ( NAMED_VALUE { pattern => TYPE_CONSTRAINT_PATTERN (VARIABLE_IN_PATTERN (vc::ORDINARY_VARIABLE { var_home=>da::HIGHCODE_VARIABLE v, ... } ), _),
				                expression,
                                                bound_typevar_refs,
                                                ...
                                              },
                                  fold_result_so_far
                                )
				=>
				{
if *debugging printf "\nCALLING translate_pattern_expression:  g()/NAMED_VALUE III (type-constrained variable) in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
                                    result = LET (v, translate_pattern_expression (expression, debruijn_depth, bound_typevar_refs, "translate_named_values.g/NAMED_VALUE III" ! callstack), fold_result_so_far);
if *debugging printf "CALLED  translate_pattern_expression:  g()/NAMED_VALUE III (type-constrained variable) in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
                                    result;
				};

			    g'  ( NAMED_VALUE { pattern, expression, bound_typevar_refs, ... },
                                  fold_result_so_far
                                )
				=>
				{
if *debugging printf "\nCALLING translate_pattern_expression:  g()/NAMED_VALUE IV (type-constrained variable) in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
				    ee    = translate_pattern_expression (expression, debruijn_depth, bound_typevar_refs, "translate_pattern_expression.g/NAMED_VALUE IV" ! callstack);
if *debugging printf "CALLED  translate_pattern_expression:  g()/NAMED_VALUE IV (type-constrained variable) in  translate_named_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;

				    rules = [ (fill_pattern (pattern, debruijn_depth), fold_result_so_far),
                                              (WILDCARD_PATTERN, unit_lexp)
                                            ];

				    root_var = make_var();

				    fun finish x
					=
					LET (root_var, ee, x);

				    mc::compile_naming_pattern (
                                        symbol_table,
                                        rules,
                                        finish,
                                        root_var,
                                        to_tc_lt  debruijn_depth,
                                        complain,
                                        make_intinf_switch
                                    );
				};
                        end;
		    end				# where (fun translate_named_values) 

		also
                fun translate_named_recursive_values (rvbs, debruijn_depth, callstack)
                    =
                    {
if *debugging    print_callstack "\n============= translate_named_recursive_values/TOP    ============= " callstack; fi;
                        result =    fn b =  MUTUALLY_RECURSIVE_FNS (vlist, tlist, elist, b);
if *debugging    print_callstack "\n============= translate_named_recursive_values/BOTTOM ============= " callstack; fi;
			result;
                    }
		    where
			my (vlist, tlist, elist)
                            =
                            fold_right g ([], [], []) rvbs
                            where
				fun g   ( NAMED_RECURSIVE_VALUES
					    { variable => vc::ORDINARY_VARIABLE { var_home=>da::HIGHCODE_VARIABLE v, var_type => REF type, ... },
					      expression,
					      bound_typevar_refs,
					      ...
					     },

					  (vlist, tlist, elist)
					)
					=> 
#					{   ee = translate_expression (expression, debruijn_depth); #  was translate_pattern_expression (expression, debruijn_depth, tvs) 
#						                                  #  we no longer track type namings at NAMED_RECURSIVE_VALUES anymore ! 
					{
if *debugging printf "\nCALLING translate_pattern_expression:  g() in translate_named_recursive_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
					    ee = translate_pattern_expression (expression, debruijn_depth, bound_typevar_refs, "translate_named_recursive_values" ! callstack);		# Restored old code 2009-04-25 CrT
if *debugging printf "CALLED  translate_pattern_expression:  g() in translate_named_recursive_values in translate-deep-syntax-to-polylambda.pkg\n"; fi;
					    vt = to_lambda_type  debruijn_depth   type;

					    ( v  ! vlist,
					      vt ! tlist,
					      ee ! elist
					    );
					};

				    g _ => bug "unexpected valrec namings in makeRecursiveValueNamings";
				end;
			    end;
		    end

		also
                fun translate_exception_declarations (ebs, debruijn_depth, callstack)
                    = 
                    fold g ebs
                    where
		        fun g (   NAMED_EXCEPTION {
				      exception_constructor => tp::ENUM_CONSTRUCTOR {
								 representation => da::EXCEPTION (da::HIGHCODE_VARIABLE v),
								 constructor_type,
								 ...
							     }, 
				      name_string => ident,
				      ...
				  },
				  b
			      )
				=>
				{   nt = to_dcon_lty  debruijn_depth  constructor_type;

				    my (argt, _) = lt::ltd_parrow  nt;

				    LET ( v,
                                          EXCEPTION_TAG
                                            ( translate_deep_syntax_expression_to_polylambda
                                                ( ident,
                                                  debruijn_depth,
                                                  "translate_exception_declarations" ! callstack
                                                ),
                                              argt
                                            ),
                                          b
                                        );
				};

			    g (    DUPLICATE_NAMED_EXCEPTION {
				       exception_constructor => tp::ENUM_CONSTRUCTOR {
								  representation => da::EXCEPTION (da::HIGHCODE_VARIABLE v),
								  constructor_type,
								  symbol,
								  ...
							      },
				       equal_to => tp::ENUM_CONSTRUCTOR { representation=>da::EXCEPTION (acc), ... }
				   },
				   b
			      )
				=>
				{   nt = to_dcon_lty  debruijn_depth  constructor_type;
				    my (argt, _) = lt::ltd_parrow nt;

				    LET (v, translate_var_home_with_type (acc, lt::ltc_etag argt, THE symbol), b);
				};

			    g _ => bug "unexpected exn namings in makeExceptionNamings";
                        end;
		    end


		###########################################################################
		# 
		# Translating module exprs and decls into lambda expressions:
		# 
		#    my translate_package_expression
		#        :
		#        deep_syntax::Package_Expression
		#      * depth
		#     -> Lambda::Polylambda_Expression
		# 
		#    my translate_generic_expression
		#        : 
		#        deep_syntax::Generic_Expression
		#      * depth
		#     -> Lambda::Polylambda_Expression
		# 
		#    my translate_package_declarations
		#        :
		#        List( deep_syntax::Named_Package )
		#      * depth
		#     -> Lambda::Polylambda_Expression
		#     -> Lambda::Polylambda_Expression
		# 
		#    my translate_generic_namings
		#        :
		#        List( deep_syntax::Named_Generic )
		#      * depth
		#     -> Lambda::Polylambda_Expression
		#     -> Lambda::Polylambda_Expression
		# 
		###########################################################################

/*x*/		also
/*x*/           fun translate_package_expression (package_expression, debruijn_depth, callstack)
                    = 
                    g package_expression
                    where
		        fun g (PACKAGE_BY_NAME  a_package)
                                =>
                                translate_package (a_package, debruijn_depth);

			    g (PACKAGE_DEFINITION bs)
                                =>
                                PACKAGE_RECORD
                                    (map  (translate_symbol_table_entry debruijn_depth)
                                          bs
                                    );

			    g (COMPUTED_PACKAGE { a_generic=>oper, generic_argument=>arg, parameter_types } )
                                => 
				{   e1 = translate_generic (oper, debruijn_depth);
				    tycs = map (tps_type_constructor debruijn_depth) parameter_types;
				    e2 = translate_package (arg, debruijn_depth);
				    APPLY (TYPE_APPLY (e1, tycs), e2);
				};

/*x*/			    g (PACKAGE_LET { declaration, expression })
/*x*/                           =>
/*x*/                           translate_deep_syntax_declaration_to_polylambda'
/*x*/                               (declaration, debruijn_depth, "translate_package_expression" ! callstack)
/*x*/                               (g expression);

			    g (SOURCE_CODE_REGION_FOR_PACKAGE (b, reg))
                                =>
                                with_region reg g b;
                        end;
		    end

		also
                fun translate_generic_expression (fe, debruijn_depth, callstack)
                    = 
                    g fe
                    where
		        fun g (GENERIC_BY_NAME f)
                                =>
                                translate_generic (f, debruijn_depth);

			    g (GENERIC_DEFINITION { parameter as m::A_PACKAGE { var_home, ... }, parameter_types, definition=>def } )
				=>
				case var_home
				  
				     da::HIGHCODE_VARIABLE v
					 =>
					 {   knds = map tps_knd parameter_types;
					     new_depth = di::next debruijn_depth;
					     body = translate_package_expression (def, new_depth, "translate_generic_expression" ! callstack);
					     header = build_header v;
					 #  Naming of all v's components 

					     TYPE_FN (knds, FN (v, package_to_lambda_type (parameter, new_depth, compile_info), header body));
					 };

				    _ => bug "translate_generic_expression: unexpected var_home";
				esac;

			    g (GENERIC_LET (declaration, b))
                                =>
                                translate_deep_syntax_declaration_to_polylambda'
                                  ( declaration,
                                    debruijn_depth,
                                    "translate_generic_expression" ! callstack
                                  )
                                  (g b);

			    g (SOURCE_CODE_REGION_FOR_GENERIC (b, reg))
                                =>
                                with_region reg g b;

			    g _ => bug "unexpected generic package expressions in translate_generic_expression";
                        end;
		    end

		also
/*x*/           fun translate_package_declarations (sbs, debruijn_depth, callstack)
                    =
/*x*/               fold g sbs
                    where
/*x*/		        fun g (NAMED_PACKAGE { a_package=>m::A_PACKAGE { var_home, ... }, definition=>def, ... }, b)
                                =>
			        case var_home
			          
/*x*/			             da::HIGHCODE_VARIABLE  v
/*x*/                                    =>
/*x*/				         {   header = build_header v;     #  Naming of all v's components 
/*x*/				      
/*x*/					     LET (v, translate_package_expression (def, debruijn_depth, "translate_package_declarations" ! callstack), header b);
/*x*/				         };

			             _   =>
                                         bug "translate_package_declarations: unexpected var_home";
                                esac;

			    g _ => bug "unexpected package namings in translate_package_declarations";
                        end;
		    end

		also
                fun translate_generic_namings (fbs, debruijn_depth, callstack)
                    = 
                    fold g fbs
                    where
		        fun g (NAMED_GENERIC { a_generic=>m::GENERIC { var_home, ... }, definition=>def, ... }, b)
			        =>
			        case var_home
				  
				     da::HIGHCODE_VARIABLE v
					 =>
					 { header = build_header v;

					     LET (v, translate_generic_expression (def, debruijn_depth, "translate_generic_namings" ! callstack), header b);
					 };

				     _   =>
                                         bug "translate_generic_namings: unexpected var_home";
                                esac;

			    g _ => bug "unexpected generic package namings in translate_package_declarations";
                        end;
		    end


		also
/*x*/           fun translate_deep_syntax_declaration_to_polylambda'
/*x*/               ( declaration:	deep_syntax::Declaration,
/*x*/                 debruijn_depth:   debruijn_index::Depth,
/*x*/                 callstack:        List( String )
/*x*/               )
/*x*/		    : (polylambda::Polylambda_Expression -> polylambda::Polylambda_Expression)
/*x*/               = 
/*x*/               g declaration
                    where
		        fun g (VALUE_DECLARATIONS vbs)                 => translate_named_values (vbs, debruijn_depth, "translate_deep_syntax_declaration_to_polylambda'/g" ! callstack);
			    g (RECURSIVE_VALUE_DECLARATIONS rvbs)      => translate_named_recursive_values (rvbs, debruijn_depth, "translate_deep_syntax_declaration_to_polylambda'/g" ! callstack);
			    g (ABSTRACT_TYPE_DECLARATION { body, ... } ) => g body;

			    g (EXCEPTION_DECLARATIONS        ebs)      => translate_exception_declarations (ebs, debruijn_depth, "translate_deep_syntax_declaration_to_polylambda'/g" ! callstack);
/*x*/			    g (PACKAGE_DECLARATIONS          sbs)      => translate_package_declarations   (sbs, debruijn_depth, "translate_deep_syntax_declaration_to_polylambda'/g" ! callstack);

			    g (GENERIC_DECLARATIONS fbs)               => translate_generic_namings (fbs, debruijn_depth, "translate_deep_syntax_declaration_to_polylambda'/g" ! callstack);
			    g (LOCAL_DECLARATIONS (ld, vd))            => (g ld) o (g vd);
			    g (SEQUENTIAL_DECLARATIONS ds)             =>  fold_right (o) ident (map g ds);

			    g (SOURCE_CODE_REGION_FOR_DECLARATION (x, reg))
				=> 
				{   f = with_region reg g x;

				    fn y =  with_region reg f y;
				};

			    g (INCLUDE_DECLARATIONS xs)
				=> 
				{   #  Special hack to make the include tree simpler: 
				    fun mkos (_, s as m::A_PACKAGE { var_home => acc, ... } )
					    =>
					    if   (extern acc)
					         
						 translate_var_home_with_type (acc, package_to_lambda_type (s, debruijn_depth, compile_info), NULL);
						 ();
					    fi;
					mkos _ => ();
				    end;

				    apply mkos xs;
				    ident;
				};

			    g _ => ident;
                        end;
		    end

		also
/*x*/           fun translate_deep_syntax_expression_to_polylambda
/*x*/               ( expression:	deep_syntax::Deep_Expression,
/*x*/                 debruijn_depth:   debruijn_index::Depth,
/*x*/                 callstack:        List( String )
/*x*/               )
/*x*/		    : polylambda::Polylambda_Expression
/*x*/               = 
/*x*/		    {
/*x*/			result =   translate_deep_syntax_expression_to_polylambda' expression;
 
			if *debugging
                            print_callstack "\n============= translate_deep_syntax_expression_to_polylambda/BOTTOM ============= " callstack;
			fi;

			result;
		    }
                    where
			if *debugging
                            print_callstack "\n============= translate_deep_syntax_expression_to_polylambda/TOP    ============= " callstack;
			    if_debugging_unparse_expression ("translate_deep_syntax_expression_to_polylambda input expression argument:", (expression,100));
			fi;

		        t_type_constructor = to_type_constructor  debruijn_depth;
			t_lty              = to_lambda_type       debruijn_depth;

			fun make_rules xs
                            =
                            map (fn (CASE_RULE (p, e)) =  (fill_pattern (p, debruijn_depth), translate_deep_syntax_expression_to_polylambda' e))
                                xs

			also
/*x*/			fun translate_deep_syntax_expression_to_polylambda'  expression
                            =
                            {
					if *debugging
                                            print_callstack "\n============= translate_deep_syntax_expression_to_polylambda'/TOP    ============= " callstack;
					    if_debugging_unparse_expression ("translate_deep_syntax_expression_to_polylambda' input expression argument:", (expression,100));
					fi;

/*x*/                           result =  translate_deep_syntax_expression_to_polylambda'' expression;

					if *debugging
                                            print_callstack "\n============= translate_deep_syntax_expression_to_polylambda'/BOTTOM ============= " callstack;
					fi;

                                result;
                            }
                        where
			    fun translate_deep_syntax_expression_to_polylambda'' (VARIABLE_IN_EXPRESSION (REF v, ts))
				    =>
				    translate_variable_in_expression (v, ts, debruijn_depth);

				translate_deep_syntax_expression_to_polylambda'' (CONSTRUCTOR_EXPRESSION (dc, ts))
				    =>
				    translate_constructor_expression (dc, ts, NULL, debruijn_depth);

				translate_deep_syntax_expression_to_polylambda'' (APPLY_EXPRESSION (CONSTRUCTOR_EXPRESSION (dc, ts), e2))
				    =>
				    translate_constructor_expression (dc, ts, THE (translate_deep_syntax_expression_to_polylambda' e2), debruijn_depth);

				translate_deep_syntax_expression_to_polylambda'' (INT_CONSTANT_IN_EXPRESSION (s, t))
				   =>
				    if   (tu::types_are_equal (t, bt::int_type)     ) INT   (ln::int   s);
				    elif (tu::types_are_equal (t, bt::int32type)    ) INT32 (ln::int32 s);
				    elif (tu::types_are_equal (t, bt::big_int_type) ) VAR (get_interface_info s);
				    elif (tu::types_are_equal (t, bt::int64type)    )

					  my (hi, lo) = ln::int64 s;
					  RECORD [WORD32 hi, WORD32 lo];

				    else
					 bug "translate INT_CONSTANT_IN_EXPRESSION";
				    fi
				    except
					OVERFLOW = { rep_err "int constant too large";
						     INT 0;
						   };

				translate_deep_syntax_expression_to_polylambda'' (UNT_CONSTANT_IN_EXPRESSION (s, t))
				    =>
				    if   (tu::types_are_equal (t, bt::word_type) )   WORD   (ln::word s);
				    elif (tu::types_are_equal (t, bt::word8type) )   WORD   (ln::word8 s);
				    elif (tu::types_are_equal (t, bt::word32type))   WORD32 (ln::word32 s);
				    elif (tu::types_are_equal (t, bt::word64type)) 

					 my (hi, lo) = ln::word64 s;
					 RECORD [WORD32 hi, WORD32 lo];

				    else
					 prettyprint_type t;
					 bug "translate UNT_CONSTANT_IN_EXPRESSION";
				    fi
				    except
					OVERFLOW = { rep_err "word constant too large";   INT 0;};

				translate_deep_syntax_expression_to_polylambda'' (FLOAT_CONSTANT_IN_EXPRESSION s)
				    =>
				    REAL s;

				translate_deep_syntax_expression_to_polylambda'' (STRING_CONSTANT_IN_EXPRESSION s)
				    =>
				    STRING s;

				translate_deep_syntax_expression_to_polylambda'' (CHAR_CONSTANT_IN_EXPRESSION s)
				    =>
				    INT (char::to_int (string::get (s, 0)));

				     # NOTE: the above won't work for cross compiling to 
				     #  multi-byte characters        XXX BUGGO FIXME

				translate_deep_syntax_expression_to_polylambda'' (RECORD_EXPRESSION [])
				    =>
				    unit_lexp;

				translate_deep_syntax_expression_to_polylambda'' (RECORD_EXPRESSION xs)
				     =>
				     if   (sorted xs)

					  RECORD  (map  (fn (_, e) = translate_deep_syntax_expression_to_polylambda' e)  xs);

				     else

					  vars =   map  (fn (l, e) =  (l, (translate_deep_syntax_expression_to_polylambda' e, make_var())))
						        xs;

					  fun bind ((_, (e, v)), x)
					      =
					      LET (v, e, x);

					  bexp =   map  (fn (_, (_, v)) =  VAR v)
						        (sortrec vars);

					  fold_right
					      bind
					      (RECORD bexp)
					      vars;
				     fi;

				translate_deep_syntax_expression_to_polylambda'' (RECORD_SELECTOR_EXPRESSION (NUMBERED_LABEL { number=>i, ... }, e))
				     =>
				     SELECT (i, translate_deep_syntax_expression_to_polylambda' e);

				translate_deep_syntax_expression_to_polylambda'' (VECTOR_EXPRESSION ([], type))
				     => 
				     TYPE_APPLY (core_get "vector0", [t_type_constructor type]);

				translate_deep_syntax_expression_to_polylambda'' (VECTOR_EXPRESSION (xs, type))
				     => 
				     {   tc   =   t_type_constructor type;

					 vars =   map (fn e =  (translate_deep_syntax_expression_to_polylambda' e, make_var()))
						      xs;

					 fun bind ((e, v), x)
					     =
					     LET (v, e, x);

					 bexp =   map (fn (_, v) = VAR v)
						      vars;

					 fold_right  bind  (VECTOR (bexp, tc))  vars;
				     };

				translate_deep_syntax_expression_to_polylambda'' (PACK_EXPRESSION (e, type, tycs))
				     =>
				     translate_deep_syntax_expression_to_polylambda' e;

    #				{   my  (nty, ks, tps)
    #					=
    #					tu::reformatTypeAbstraction (type, tycs, debruijn_depth);
    #
    #				    ts = map (tpsTypeConstructor debruijn_depth) tps;
    #				    # * use of LtyDict::tcAbs is a temporary hack (ZHONG) *
    #
    #				    nts =   paired_lists::map LtyDict::tcAbs (ts, ks);
    #
    #				    nd =   di::next debruijn_depth;
    #
    #				   case (ks, tps)
    #				     of ([], []) => translate_deep_syntax_expression_to_polylambda' e
    #				      | _ => PACK (lt::ltc_poly (ks, [to_lambda_type nd nty]), 
    #						  ts, nts, translate_deep_syntax_expression_to_polylambda' e);
    #				}

				translate_deep_syntax_expression_to_polylambda'' (SEQUENTIAL_EXPRESSIONS [e])
				    =>
				    translate_deep_syntax_expression_to_polylambda' e;

				translate_deep_syntax_expression_to_polylambda'' (SEQUENTIAL_EXPRESSIONS (e ! r))
				    =>
				    LET (make_var(), translate_deep_syntax_expression_to_polylambda' e, translate_deep_syntax_expression_to_polylambda' (SEQUENTIAL_EXPRESSIONS r)); 

				translate_deep_syntax_expression_to_polylambda'' (APPLY_EXPRESSION (e1, e2))
				    =>
				    APPLY (translate_deep_syntax_expression_to_polylambda' e1, translate_deep_syntax_expression_to_polylambda' e2);

				translate_deep_syntax_expression_to_polylambda'' (SOURCE_CODE_REGION_FOR_EXPRESSION (expression, region))
				    =>
				    with_region  region  translate_deep_syntax_expression_to_polylambda''  expression;

				translate_deep_syntax_expression_to_polylambda'' (TYPE_CONSTRAINT_EXPRESSION (e, _))
				    =>
				    translate_deep_syntax_expression_to_polylambda' e;

				translate_deep_syntax_expression_to_polylambda'' (RAISE_EXPRESSION (e, type))
				     =>
				     make_raise (translate_deep_syntax_expression_to_polylambda' e, t_lty type);

				translate_deep_syntax_expression_to_polylambda'' (EXCEPT_EXPRESSION (e, (l, type)))
				     =>
				     {   root_var =   make_var();

					 fun f x
					     =
					     FN (root_var, t_lty type, x);

					 l' =   make_rules l;

					 EXCEPT
					   ( translate_deep_syntax_expression_to_polylambda' e,
					     mc::compile_exception_pattern
					       ( symbol_table,
						 l',
						 f, 
						 root_var,
						 to_tc_lt  debruijn_depth,
						 complain,
						 make_intinf_switch
					   )   );
				     };

				translate_deep_syntax_expression_to_polylambda'' (FN_EXPRESSION (l, type))
				     => 
				     {   root_var =   make_var();

					 fun f x
					     =
					     FN (root_var, t_lty type, x);

					 mc::compile_case_pattern
					   (
					     symbol_table,
					     make_rules l,
					     f,
					     root_var,
					     to_tc_lt  debruijn_depth,
					     complain,
					     make_intinf_switch
					   );
				     };

				translate_deep_syntax_expression_to_polylambda'' (CASE_EXPRESSION (ee, l, is_match))
				     => 
				     {   root_var = make_var();

					 ee' = translate_deep_syntax_expression_to_polylambda' ee;

					 fun f x
					     =
					     LET (root_var, ee', x);

					 l' =   make_rules l;

					 (is_match ?? mc::compile_case_pattern
						   :: mc::compile_naming_pattern
					 ) (
					     symbol_table,
					     l',
					     f,
					     root_var,
					     to_tc_lt  debruijn_depth,
					     complain,
					     make_intinf_switch
					   );
				     };

				translate_deep_syntax_expression_to_polylambda'' (IF_EXPRESSION { test_case, then_case, else_case } )
				     =>
				     cond (translate_deep_syntax_expression_to_polylambda' test_case, translate_deep_syntax_expression_to_polylambda' then_case, translate_deep_syntax_expression_to_polylambda' else_case);

				translate_deep_syntax_expression_to_polylambda'' (AND_EXPRESSION (e1, e2))
				     =>
				     cond (translate_deep_syntax_expression_to_polylambda' e1, translate_deep_syntax_expression_to_polylambda' e2, false_lexp);

				translate_deep_syntax_expression_to_polylambda'' (OR_EXPRESSION (e1, e2))
				     =>
				     cond (translate_deep_syntax_expression_to_polylambda' e1, true_lexp, translate_deep_syntax_expression_to_polylambda' e2);

				translate_deep_syntax_expression_to_polylambda'' (WHILE_EXPRESSION { test, expression } )
				     =>
				     {   fv = make_var ();

					 body = FN (make_var (), lt_unit,
						 cond (translate_deep_syntax_expression_to_polylambda' test,
						       LET (make_var (), translate_deep_syntax_expression_to_polylambda' expression, APPLY (VAR fv, unit_lexp)),
						       unit_lexp));

					 MUTUALLY_RECURSIVE_FNS ([fv], [lt_u_u], [body], APPLY (VAR fv, unit_lexp));
				     };

/*x*/				translate_deep_syntax_expression_to_polylambda'' (LET_EXPRESSION (dc, e))
/*x*/				     =>
/*x*/				     translate_deep_syntax_declaration_to_polylambda' (dc, debruijn_depth, "translate_deep_syntax_expression_to_polylambda''" ! callstack) (translate_deep_syntax_expression_to_polylambda' e);

				translate_deep_syntax_expression_to_polylambda'' e
				     => 
				     em::impossible_with_body "untranslateable expression"
					 (fn stream
					     =
					     {   pp::string stream " expression: ";
						 unparse_deep_syntax::unparse_expression
						     (symbol_table, NULL)
						     stream
						     (e, *prettyprint_depth);
					     }
					 );
			    end;			# fun translate_deep_syntax_expression_to_polylambda''
			end;				# where
		    end					# fun translate_deep_syntax_expression_to_polylambda

		also
                fun translate_integer (debruijn_depth, callstack) s
                    =
		    # This is a temporary solution.  Since integer literals
		    # are created using a core function call, there is
		    # no indication within the program that we are really
		    # dealing with a constant value that -- in principle --
		    # could be subject to such things as constant folding. XXX BUGGO FIXME

		    {   consexp =   CONSTRUCTOR_EXPRESSION (bt::cons_dcon, [bt::word_type]);

			fun build []
				=>
				CONSTRUCTOR_EXPRESSION (bt::nil_dcon, [bt::word_type]);

			    build (d ! ds)
				=>
				{   i = unt::to_int_x d;

				    APPLY_EXPRESSION (consexp,
					    eu::tupleexp [UNT_CONSTANT_IN_EXPRESSION (integer::from_int i, bt::word_type),
							 build ds]);
				};
                        end;

			fun small w
                            =
			    APPLY ( core_get (ln::is_negative s   ??   "make_small_neg_inf"
					                          ::   "make_small_pos_inf"
                                  ),

				  translate_deep_syntax_expression_to_polylambda
				    (
				      UNT_CONSTANT_IN_EXPRESSION (integer::from_int (unt::to_int_x w), bt::word_type),
				      debruijn_depth,
                                      "translate_integer" ! callstack
                                )   );

			case (ln::rep_digits  s)
			  
			     []  =>  small 0u0;
			     [w] =>  small w;
			     ws  =>  APPLY (
                                         core_get (ln::is_negative s   ??   "make_neg_inf"
						                       ::   "make_pos_inf"
                                                  ),
				         translate_deep_syntax_expression_to_polylambda (build ws,  debruijn_depth, "translate_integer" ! callstack)
                                     );
                        esac;
		    };

		#  Wrap namings for integer::Int literals around body. 
		#
		fun wrap_intinf (body, callstack)
                    =
		    intinf_map::keyed_fold_left
			do_one
			body
		       *intinf_map
                    where 
                        fun do_one (n, v, b)
                            =
                            LET (v, translate_integer (di::top, "wrap_intinf" ! callstack) n, b);

		    end;



		fun wrap_picklehash_info
                    ( body: 	         polylambda::Polylambda_Expression,
                      picklehash_infos:  List( (picklehash::Picklehash, Picklehash_Info) )
                    )
                    : (polylambda::Polylambda_Expression, List((picklehash::Picklehash, import_tree::Import_Tree)))
                    = 
		    {   imports
                            = 
			    map
				(fn (p, pi) =  (p, p2itree pi))
				picklehash_infos
                            where
			        fun p2itree (ANON xl)
					=> 
					import_tree::IMPORT_TREE_NODE
                                            (map (fn (i, z) = (i, p2itree z))
                                                 xl
                                            );

				    p2itree (NAMED _)
					=>
					import_tree::IMPORT_TREE_NODE [];
                                end;
			    end;

		  /*
			{   say "\n ****************** \n";
			    say "\n the current include tree is :\n";

			    fun tree (import_tree::IMPORT_TREE_NODE [])
                                    =
                                    [ "\n" ];

			      | tree (import_tree::IMPORT_TREE_NODE xl)
                                    = 
				    fold_right (fn ((i, x), z)
						   =
						   {   ts = tree x;
						       u = (int::to_string i)  + "   ";
						       (map (fn y = (u + y)) ts) @ z;
						   }
                                               )
                                               []
                                               xl;

			    fun prettyprint (p, n)
                                = 
			        {   say ("Picklehash " + (picklehash::to_hex p) + "\n"); 
			            apply say (tree n));
			            apply prettyprint imports; say "\n ****************** \n";
			        }
		  */
			polylambda_expression
                            = 
			    {   fun get ((_, ANON xl), z)
                                        =>
                                        fold_left get z xl;

				    get ((_, u as NAMED (_, t, _)), (n, cs, ts))
                                        => 
				        (n+1, (n, u) ! cs, t ! ts);
                                end;

				#  Get the fringe information 

				getp =   fn ((_, pi), z) =  get((0, pi), z);

				my  (finfos, lts)
                                    = 
				    {   my  (_, fx, lx)
                                            =
                                            fold_left getp (0,[],[]) picklehash_infos;

				        (reverse fx, reverse lx);
				    };

				# Do the selection of all import variables:
				#
				fun make_selection (u, xl, be)
				    = 
				    fold_right g be xl
                                    where
				        fun g ((i, pi), be)
                                            = 
					    {   my  (v, xs)
                                                    =
                                                    case pi
                                                      
                                                         ANON z => (make_var(), z);
						         NAMED (v, _, z) => (v, z);
                                                    esac;

					        LET (v, SELECT (i, u), make_selection (VAR v, xs, be));
					    };
				    end;

				impvar =  make_var();
				implty =  lt::ltc_str lts;
				nbody  =  make_selection (VAR impvar, finfos, body) ;

                                FN (impvar, implty, nbody);
			    };

                        (polylambda_expression, imports);
		    };				                    # fun wrap_picklehash_info 

		# The list of things being exported
                # from the current compilation unit:
		#
		export_lexp = PACKAGE_RECORD (map VAR exported_highcode_variables);

		# Translate the deep_syntax_declaration
                # into a polylambda expression:
		# 
		body = translate_deep_syntax_declaration_to_polylambda' (given_declaration, di::top, []) export_lexp;


		# Add namings for intinf constants:
		#
		body = wrap_intinf (body, []);


		#  Wrap up the body with the imported variables:
		#
		my (polylambda_expression, imports)
                    =
                    wrap_picklehash_info (body, picklehash_map::keyvals_list  *picklehash_map);

		                                                                                  
                print_polylambda_expression
                    (controls::highcode::print, prettyprint_polylambda_expression::print_lexp)
                    "translate_deep_syntax_to_polylambda"
                    polylambda_expression
                where
		    fun print_polylambda_expression (flag, print_e) s e
			=
			if *flag
			     say ("\n\n[After " + s + " ...]\n\n");
			     print_e  e;
			fi;
                end;


#		# Normalize the polylambda expression
#                # into A-Normal form:
#		#
#		anormal
#                    =
#                    translate_polylambda_to_anormal::translate
#                        polylambda_expression;
#
#	    
		if *debugging
                    printf "\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
		    printf   "============= translate_deep_syntax_declaration_to_polylambda/BOTTOM ========== in translate-deep-syntax-to-polylambda.pkg\n";
		fi;

		{ polylambda_expression, imports };
#		{ anormal, imports };

	    };				#  fun translate_deep_syntax_declaration_to_polylambda 

    end;	#  top-level with
};		#  package translate_deep_syntax_to_polylambda 






##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## COPYRIGHT (c) 1996 Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
