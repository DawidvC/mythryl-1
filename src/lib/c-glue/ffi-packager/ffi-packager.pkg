/*
 * These are useful utilities for transforming C-GLUE-MAKER generated code 
 */
local

   #  Configuration parameters 

   /*
    * Dog tags 
    */
   author  = "Allen Leung"
   email   = "leunga@{ cs.nyu.edu, dorsai.org }"
   version = "0.1.4"
   program = "ffi-packager"

   /* Look for these keywords in the generated code; 
    * these cannot be identifiers! 
    */
   ml_keywords = 
      ["handle", "fun", "my", "REF", "TRUE", "FALSE", "end", "raise", "type", "in",
       "size", "mod", "fn", "where", "api", "sig", "op", "use", "enum"]

   #  We mangle the name with a ' whenever it's a keyword 
   fun mangle n = n + "'"

in

package ffi_packager:  Ffi_Packager {

   #  Definitions from CKit 
   package ca = Ast 
   package cb = Namings
   package tu = TypeUtil
   package parse_to_raw_syntax = parse_to_raw_syntax
   package symbol = symbol

   #  Definitions from ml_grinder 
   use ml_grinder       
   package a  = Ast
   package u  = AstUtil
   package re = RE
   package path = winix::path
   package i    = lib7_nlffi_gen_info
   package code= i::code

   package s = red_black_set_g (type Key = a::id compare = string::compare)
   package m = red_black_map_g (type Key = a::id compare = string::compare)

   exception MissingCname
   exception Unsupported

   #  Common definitions 
   stripNL = string::translate (fn '\n' => "" | c => str c)
   stripUnderscores = re::replace "^_*" ""
   to_upper = string::map char::to_upper
   to_lower = string::map char::to_lower

   fun join (dir, file)
       =
       winix::path::from_dir_file { dir, file=file }

   fun seq (l, s, r) ss
       = 
       {   fun f [] = [r]
	     | f [x] = [x, r]
	     | f (x . xs) = x . s . f xs;

           string::cat (l . f ss);
       }

   exception NOT_FOUND

   errorTy = a::IDty (a::IDENT([], "<error>"))


   fun apps (    [], e) =   e
     | apps (f . fs, e) =   a::APPexp (f, apps (fs, e))


   /*------------------------------------------------------------------------
    * Identification information
    *------------------------------------------------------------------------*/

   stamp = [io::VERSION version, io::PROGRAM program]

   fun write (f, comment, x)
       = 
       io::writeFile (io::OUTFILE f . io::comment comment . stamp, x)

  
   #  A ffi_info represents things generated by C-GLUE-MAKER 
   enum ffi_info =
      FFI of
         { cfile:         String,
           indir:         String,
           outdir:        String,
           files:         List( String ),
           cmfile:        String,
           undefinesdir:  String,
           astBundle:     parse_to_raw_syntax::astBundle,
           funtbl:         m::Map( List (ca::ctype * Ast::id) * ca::ctype),
           typtbl:        m::Map( cb::namedCtype ),
           enumTbl:       m::Map( enum_info ),
           fieldsTbl:     m::Map(  List(  field ) ),
           exports:       REF(  List(  String ) ),
           imports:       REF(  List(  String ) ),
           comment:       List( String ),
           filere:        re::regexp,
           transforms:     REF( List (String * (ffi_g * state -> ffi_g * state)))
        }
       #  Info on enums 
   and enum_info = ENUM of { cty:      Ast::id, #  name of its type in C 
                            members:   List (Ast::id * int32::Int),
                            rep:      REF(  Null_Or(  enum_rep ) )
                           }
       #  How an enum is represented in ML
   and enum_rep = 
     ENUM_REP of { structName: Ast::id, ty: Ast::id, kind: enum_rep_kind }
   and enum_rep_kind = 
     ENUM_AS_INT 
   | ENUM_AS_DATATYPE of { toC: Ast::id, toML: Ast::id }

   #  A ffi_str represents a package generated by C-GLUE-MAKER 
   and ffi_str =
      STR of
         { filename:    String,
           export:      Ref( Bool ),
           cm_options:  Ref( String ),
           info:        ffi_info,
           name:        Ref( Ast::id ),
           header:      REF(  List(  Ast::decl ) ), #  local declarations 
           sign:        REF(  List(  Ast::decl ) ), #  Api 
           body:        REF(  List(  Ast::decl ) ), #  global declarations 
           abs:         REF( Bool )           #  Abstract api matching 
         }

   and ffi_mode = 
           INmode     #  Argument is for input 
         | OUTmode    #  Argument is for output 
         | IOmode     #  Argument is for both 
         | IGNOREmode #  Argument has been deleted 

   #  A ffi_arg represents an input or output argument 
   and ffi_param = 
     PARAM of { cid:   Ast::id,               #  C name (optional) 
               id:    Ast::id,               #  name in ML 
               cty:   Ref( ca::ctype ),         #  C type (optional) 
               ty:    Ref( Ast::ty ),           #  ML type 
               coer:  REF(  List(  Ast::exp ) ),     #  Coercions applied 
               mode:  REF( ffi_mode )          #  input or output 
              }

   #  A ffi_g represents a function being transformed 
   and ffi_g =
      FN of
         { info:      ffi_info,
           name:      Ref( Ast::id ),
           cname:     Ast::id, 
           params:    REF(  List(  ffi_param ) ),
           initargs:  List( ffi_param ),
           initrets:  List( ffi_param ),
           body:      Ast::exp,
           init:      REF(  List(  Ast::decl ) ),
           cleanup:   REF(  List(  Ast::decl ) ),
           labeled:   Bool
         }
   and state = ST of { var: Ref( char ), opens: Ref( s::set ), 
                      encoding:  REF (Ast::decl -> Ast::decl) }

   withtype field = Ast::id * Ast::ty * ca::ctype * int32::Int Null_Or
 

   fun infile (FFI { indir, ... }, f) = join (indir, f)
   fun outfile (FFI { outdir, ... }, f) = join (outdir, f)
   fun undefinesfile (FFI { undefinesdir, ... }, f) = join (undefinesdir, f)
   fun isInt("sint" | "uint" | "ushort" | "sshort" | "ulong" | "slong" |
             "schar" | "uchar" ) = TRUE
     | isInt _ = FALSE
   fun isReal ( "real" | "float") = TRUE
     | isReal _ = TRUE
   fun isPrim t = isInt t or isReal t
 
   /* 
    * Extract C related information 
    */
   package c {

      fun tidtab (FFI { astBundle= { tidtab, ... }, ... } ) = tidtab

      fun cprog (FFI { astBundle= { ast, ... }, ... } ) = ast

      fun tidName info tid = 
          case Tidtab::find (tidtab info, tid) of
            THE { name=THE name, ... } => name
          | THE { name=NULL, ... } => ""
          | NULL => raise exception FAIL "tidName: bad typedef"


      fun allTypes info =
       fold_right
          (fn ( { name=THE n, ntype=THE (cb::Struct _), ... }, S) =>
               s::add (S, n)
            | ( { name=THE n, ntype=THE (cb::Union _), ... }, S) =>
               s::add (S, n)
            | ( { name=THE n, ntype=THE (cb::Typedef(_, ca::StructRef _)), ... }, S) =>               s::add (S, n)
            | ( { name=THE n, ntype=THE (cb::Typedef(_, ca::UnionRef _)), ... }, S) =>
               s::add (S, n)
            | (_, S) => S) s::empty (Tidtab::vals_list (tidtab info))

   }

   package c_type {

      fun op* info cty =
          case tu::deref (c::tidtab info) cty of
             THE t => t
           | NULL => raise exception FAIL "c_type.*"
   }

   #  CM stuff 
   package cm {

      init = reverse[ "$/basis.cm", 
	              "$c/internals/c-internals.make6", 
                      "$smlnj/init/init.cmi:  cm"
                    ]
      fun addImport (FFI { imports, ... }, x) = imports := x . *imports
      fun addImport'(FFI { imports, ... }, x, "") = imports := x . *imports
        | addImport'(FFI { imports, ... }, x, y) = imports := (x + " " + y) . *imports
      fun addExport (FFI { exports, ... }, x) = exports := x . *exports;
      fun add (cm, x, y) = (addExport (cm, x); addImport (cm, y))

      fun addDecl (cm, file, decl, options)
	  =
	  {   fun f (a::MARKdecl(_, d)) = f d
		| f (a::SEQdecl ds) = apply f ds
		| f (a::LOCALdecl(_, ds)) = apply f ds
		| f (a::GENERIC_DECL(x, _, _, _)) = addExport (cm, "generic package " + x)
		| f (a::PACKAGE_DECL (x,[], _, _)) = addExport (cm, "package " + x)
		| f (a::PACKAGE_DECL (x, _, _, _)) = addExport (cm, "generic package " + x)
		| f (a::API_DECL (x, _)) = addExport (cm, "api " + x)
		| f _ = ();

	      f decl;
              addImport'(cm, file, options);
	  }

      fun writeFile (info as FFI { cmfile, imports, exports, comment, ... } )
          =
          write (outfile (info, cmfile), comment,
          A.@@@("(primitive c-internals)" .
              "library" .
              map (fn x => "\t" + x) (reverse *exports) @
              ["is"] @
              map (fn x => "\t" + x) (reverse *imports)
             )
          )

      fun reexport info file
	  =
	  {   prog =   io::read_file (infile (info, file));

	      newfile =   join("..", infile (info, file));

	      addDecl (info, newfile, prog, "");
	  }

      fun reinclude info file
          =
          addImport (info, join("..", infile (info, file)))

      fun reinclude' (info, opts) file
          =
          addImport'(info, join("..", infile (info, file)), opts)
   }

   #  Initialization 

   fun init { cfile, indir, outdir, cmfile, undefinesdir, comment, filere }
       = 
       {   astBundle =   parse_to_raw_syntax::fileToAst cfile;

	   my { ast, tidtab, ... }
               =
               astBundle;

	   funtbl =   REF m::empty;

	   fun ins tab (k, x)
               =
               tab := m::set (*tab, k, x);

	   okFile =   re::matches filere;

	   fun okLoc (source_map::LOC { srcFile, ... } ) = okFile srcFile
	     | okLoc _ = FALSE;

	   #  Extract function type information 
	   fun enter (ca::DECL (ca::ExternalDecl decl, _, _)) = enterDecl decl
	     | enter _ = ()

	 also enterDecl (ca::VarDecl( { name, kind=ca::FUNCTION _,
				     ctype=ca::Function (ret, args), ... }, _))
	       =
	       {   args = map (fn (t, x) => 
			      (t, case x of 
				    NULL => ""
				 |  THE { name, ... } => symbol::name name))
				 args;

		   f    = symbol::name name;

		   ins funtbl (f, (args, ret));
	       }

	     | enterDecl _ = ();

	   apply enter ast;

	   #  Extract type information 

	   typtbl =
	       fold_right 
	       (fn ((_,{ ntype=THE t, global=TRUE, name=THE n, ... } ), tbl) =>
		     m::set (tbl, n, t)


		 | ((tid, { ntype=THE t, global=TRUE, name=NULL, ... } ), tbl)
		       =>
		       {   n =   int::to_string (unt::toInt (Tid::toWord tid));

			   m::set (tbl, n, t);
		       }

		 | (_, tbl) => tbl) m::empty (Tidtab::keyvals_list tidtab);

	  # Extract enum information. 
	  # If there is a typedef that refes to an enum type:
	  #
	  #    typedef enum { .... } t; 
	  #
	  # we use t as its C name.  Otherwise, we use its enum tag t
	  #
	  #    enum t { .... }
	  #
	  # as its C name.


	  enumTbl =   Tidtab::uidtab() : Tidtab::uidtab( enum_info );

	  fun enter (enumTid, name, members:   List (ca::member * int32::Int))
	      = 
	      {   members = map (fn ( { name, ... }, v) => (symbol::name name, v)) 
				       members;

		  cty = case name of THE x => x | NULL => Tid::to_string enumTid;

		  Tidtab::set (enumTbl, enumTid, 
				ENUM { cty, members, rep=REF NULL } );
	      };

	  apply
	      (fn { ntype=THE (cb::Enum (tid, members)), name, location, ... } =>
		   if okLoc location then
		   (case Tidtab::find (enumTbl, tid) of
		     NULL => enter (tid, name, members)
		   | THE _ => ()
		   ) else ()
		| { ntype=THE (cb::Typedef(_, ca::EnumRef tid)), name, location, ... } =>
		    if okLoc location then
		    (case Tidtab::find (tidtab, tid) of
		       THE { ntype=THE (cb::Enum (tid, members)), ... } =>
			  enter (tid, name, members)
		     | _ => ()
		    ) else ()
		| _ => ()) (Tidtab::vals_list tidtab);

	   enumTbl =
		 fold_right (fn (an_enum as ENUM { cty, ... }, tbl) =>  
			  m::set (tbl, cty, an_enum)) m::empty 
			     (Tidtab::vals_list enumTbl);

	   #  Create output directory 
	   winix::file::make_directory outdir
           except
               _ => ();

	   #  Read input directory 

	   dir =   winix::file::open_directory_stream indir;

	   fun loop ()
               =
	       case winix::file::read_directory_entry dir of
		 "" => []
	       | f  => f . loop();

	   files =   loop () ;

	   winix::file::close_directory_stream dir;

	   files =   list_mergesort::sort string::(>) files;

	   ubf =   a::IDty (a::IDENT([], "ubf"))
	   sbf =   a::IDty (a::IDENT([], "sbf"))

	   # Given a file representing a package 
	   # compute the field names, its type and its C type 

	   fun computeFields filename
	       =
	       {   cname =   i::filenameToCname filename;

		   ctypes = 
		       case m::find (typtbl, cname) of
			  THE (cb::Struct(_, fs)) => 
			    fold_right (fn ((t, THE { name, ... }, bits), m) =>
				       m::set (m, symbol::name name, (t, bits))
				    | (_, m) => m
				  ) m::empty fs
			| THE (cb::Union(_, fs)) => 
			    fold_right (fn ((t,{ name, ... } ), m) =>
				m::set (m, symbol::name name, (t, NULL))) m::empty fs
			| _ => m::empty;

			  # raise exception FAIL 
			  #	  ("can't find struct/union " + cname + " in " + filename)

		   fun look f
		       =
		       case m::find (ctypes, f)
			 of THE t => t 
			  | NULL => (ca::Void, NULL);

		   body =   io::read_file (join (indir, filename));

		   normalFields
		       = 
		       reverse
			 (decl::fold[Fold::D
			   (fn (a::DATATYPEdecl([],[a::TYPEbind (x,[], t)]), l) =>
			      (case re::grep "^t_f_([^']+)" x of
				THE[x] =>  {  my (cty, bits) = look x;
					      (x, t, cty, bits) . l;
					   }
			      | _ => l
			      )
			     | (_, l) => l)] [] body);

		   bitFields
		       = 
		       reverse
			(decl::fold[Fold::D
			    (fn (a::FUNdecl[a::FUNbind (f,
				   [a::CLAUSE(_, _,
				       a::APPexp(
					 a::APPexp (a::IDexp (a::IDENT([], make)), _), _))])], l) =>
			     (case (re::grep "^f_([^']+)" f, make) of
				(THE[x], "make_rw_ubf'") => 
				    { my (cty, b) = look x; (x, ubf, cty, b) . l; }
			      | (THE[x], "make_rw_sbf'") => 
				    { my (cty, b) = look x; (x, sbf, cty, b) . l; }
			      | _ => l
			      )
			     | (_, l) => l)] [] body);

		   (cname, normalFields @ bitFields);
	       };

	   fieldsTbl
	       =
	       fold_right
		   (fn (file, tbl)
		       =>
		       {   my (name, fields) = computeFields file;
			   m::set (tbl, name, fields);
		       }
		   )
		   m::empty
		   (list::filter (re::matches "^[su]-") files);

           FFI { cfile,
	       indir,
	       outdir,
	       undefinesdir,
	       astBundle,
	       funtbl       = *funtbl,
	       typtbl,
	       enumTbl,
	       fieldsTbl,
	       cmfile,
	       files,
	       imports      = REF (cm::init),
	       exports      = REF [],
	       comment,
	       filere,
	       transforms   = REF []
	      };
       }

   fun lookupFields (FFI { fieldsTbl, ... } ) name
       = 
       case m::find (fieldsTbl, name)
         of  THE fs => fs
          | NULL => raise exception FAIL ("can't find fields for struct/union " + name)

   fun writeFile (info as FFI { comment, ... }, f, x)
       =
       write (f, comment, x)


   # List files in the FFI directory 

   fun listFilesInDir dir regexp
       =
       {   dir =   winix::file::open_directory_stream dir;
	   ok  =   re::matches regexp;

	   fun loop ()
               =
	       case winix::file::read_directory_entry dir of
		 "" => []
	       | f  => if ok f then f . loop() else loop();

           loop() before winix::file::close_directory_stream dir;
       }
 
   fun listFiles (FFI { files, ... } ) pattern
       =
       list::filter (re::matches pattern) files

   package ml {


      isKeyword = re::matches (seq ("^(", "|", ") + ") ml_keywords)
    
      fun mangle n
	  = 
	  {   n =   stripUnderscores n;

	      if isKeyword n   then mangle n
                               else n;
	  }

      # Convert the first character and every character after _ to upper case 
      # Remove all _.  This creates a name suitable for package names.

      strName
	  =
	  {   fun f [] = [] | f ('_' . cs) = g cs | f (c . cs) = c . f cs
	     also g [] = [] | g (c . cs) = char::to_upper c . f cs;

	     string::implode o g o string::explode;
	  }

      # Make every character lowercase.  Add an underscore before each
      # upper case character (except the first one ) 
      # We use this to create an ml type name. 
      # Exception is when two uppercase characters are together.  Then
      # we join them together.

      typeName
	  =
	  {   fun f [] = []
		| f (c . cs) = if char::is_upper c then '_' . char::to_lower c . g cs;
			                           else c . f cs
	     also g [] = []
		| g (c . cs) = if char::is_upper c then char::to_lower c . g cs
			     else c . f cs;

	      mangle o string::implode o g o string::explode;
	  }

      valName = mangle

      /* Convert every character to uppercase. Insert underscore whenever
       * changing from lowercase to uppercase
       */
      sigName = to_upper o typeName

   }

   /* 
    * Functions for operating on ffi_param 
    */
   package parameter {

      #  Accessors 
      fun name (PARAM { id, ... } ) = id
      fun cname (PARAM { cid, ... } ) = cid
      fun cty (PARAM { cty, ... } ) = cty
      fun ty (PARAM { ty, ... } ) = ty
      fun mode (PARAM { mode, ... } ) = mode
      fun addCoercion (PARAM { coer, ... }, f) = coer := f . *coer

   }


   /* 
    * Functions for operating on ffi_g 
    */
   package fn {

      #  Accessors 
      fun name (FN { name, ... } ) = name
      fun cname (FN { cname, ... } ) = cname
      fun params (FN { params, ... } ) = *params
      fun info (FN { info, ... } ) = info
      fun but m (FN { params, ... } ) =
           list::filter (fn PARAM { mode, ... } => 
              *mode != IGNOREmode and *mode != m) *params
      args = but OUTmode
      rets = but INmode

      fun argPosOf f id
	  =
	  {   fun g (i, x . xs) = if parameter::name x == id then i else g (i+1, xs)
		| g(_,[]) = raise exception FAIL("argPosOf " +  *(name f) + " " + id);

	      g (0, args f);
	  }

      fun retPosOf f id
	  =
	  {   fun g (i, x . xs) = if parameter::name x == id then i else g (i+1, xs)
		| g(_,[]) = raise exception FAIL("retPosOf " +  *(name f) + " " + id);

	      g (0, rets f);
	  }


      #  Mutators 

      fun addCleanUp (FN { cleanup, ... }, f)
          =
          cleanup := *cleanup @ [f];

      fun addInit (FN { init, ... }, f)
          =
          init := *init @ [f];

      fun makeTy params
          = 
          case map (fn PARAM { ty, ... } => *ty) params of
            [t] => t
          | ts => a::TUPLEty ts;

      fun makeLabTy [PARAM { ty, ... } ] = *ty
        | makeLabTy params = 
          case map 
             (fn PARAM { id, ty, cid="", ... } => raise exception MissingCname
               | PARAM { id, ty, cid=x, ... } => (ml::mangle x,*ty)
             ) params of
            []      => a::TUPLEty []
          | [(_, t)] => t
          | lts     => a::RECORDty lts

      fun makeExp arg = a::TUPLEexp (map (fn PARAM { id, ... } => u::ID id) arg)

      fun makeLabExp [PARAM { id, ... } ] = u::ID id
        | makeLabExp arg = 
          case map 
             (fn PARAM { id, cid="", ... } => raise exception MissingCname
               | PARAM { id, cid=x, ... } => (ml::mangle x, u::ID id)
             ) arg of
            []      => a::TUPLEexp []
          | [(_, e)] => e
          | les     => a::RECORDexp les

      fun makePat arg = a::TUPLEpat (map (fn PARAM { id, ... } => a::IDpat id) arg)
      fun makeLabPat arg = 
          case map 
             (fn PARAM { id, cid="", ... } => raise exception MissingCname
               | PARAM { id, cid=x, ... } => (ml::mangle x, a::IDpat id)
             ) arg of
            []      => a::TUPLEpat []
          | [(_, p)] => p
          | lps     => a::RECORDpat (lps, FALSE)

      fun ty f = a::FUNty (makeTy (args f), makeTy (rets f))
      fun labTy f = a::FUNty (makeLabTy (args f), makeLabTy (rets f))

      fun newFn (info as FFI { funtbl, ... } ) (cf, f, arg, ret, makeBody)
          = 
          {   my (carg, cret)
                 =
                  case m::find (funtbl, cf) of
                    THE (arg, ret) => (arg, [(ret, "")])
                  | NULL => ([], [(ca::Void, "")]);

              fun makeArg (id, ty, cid, cty, mode)
                  = 
                  PARAM { id, ty=REF ty, coer=REF [], cty=REF cty, cid, 
                        mode=REF mode };

              fun var (p, i)
                  =
                  p + int::to_string i;

              fun makeArgs (p, ty, cty, mode)
		  =
		  {   fun f (i,[], _) = []
			| f (i, ty . tys,[]) = 
			    makeArg (var (p, i), ty, "", ca::Void, mode) . f (i+1, tys,[])
			| f (i, ty . tys, (cty, cid) . ctys) =
			    makeArg (var (p, i), ty, cid, cty, mode) . f (i+1, tys, ctys);

		      case ty of
			a::TUPLEty [t] => makeArgs (p, ty, cty, mode)
		      | a::TUPLEty ts  => f (1, ts, cty)
		      | t             => f (1,[t], cty);
		  };

              args =   makeArgs("x", arg, carg, INmode);
              rets =   makeArgs("y", ret, cret, OUTmode);

              FN  { info,
		    name    = REF f,
		    cname   = cf,
		    params  = REF (args @ rets),
		    initargs= args,
		    initrets= rets,
		    body    = makeBody (makeExp args),
		    init    = REF [],
		    cleanup = REF [],
		    labeled = FALSE
		  };
          }

      fun genCode (f as FN { name, body, init, cleanup, labeled, initrets, ... } )
	  = 
	  {   name   = *name;
	      makePat  = if labeled then makeLabPat else makePat;
	      makeExp  = if labeled then makeLabExp else makeExp;
	      makeCoer = list::fold_right
			     (fn (PARAM { id, coer=REF [], ... }, l) => l
			       | (PARAM { id, coer, ... }, l) =>
				 a::VALbind (a::IDpat id, apps (*coer, u::ID id)) . l
			     ) [] ;

	      args     = args f;
	      rets     = rets f;
	      pat      = makePat args;
	      argCoers = makeCoer args;
	      retCoers = makeCoer rets;

	      my (exp, complex)
                  = 
		  case (*init, argCoers, retCoers, *cleanup, length rets > 1) of
		    ([],[],[],[], FALSE) => (body, FALSE)
		  | (init, argCoers, retCoers, cleanup, _)
			=>
			{   retPat =   makePat initrets;

			    (   a::LETexp (init @ 
					 [a::VALdecl argCoers,
					  a::VALdecl [a::VALbind (retPat, body)],
					  a::VALdecl retCoers
					 ] @ cleanup,
					 [makeExp rets]),

			        TRUE
                            );
			};

	       exp = case exp
		       of a::LETexp (decls as _ . _, [a::TUPLEexp []])
                              =>
			      (case list::last decls

				 of  a::VALdecl[a::VALbind((a::TUPLEpat [] | a::WILDpat), e)]
					 => 
					 a::LETexp (list::take (decls, length decls -1), [e])

		                 |  _ => exp
		              )
		       | _ => exp;

	       fun makeFun()
                   =
                   a::FUNdecl[a::FUNbind (name,[a::CLAUSE([pat], NULL, exp)])]

	       fun same (a::TUPLEexp[e], p) = same (e, p)
		 | same (e, a::TUPLEpat[p]) = same (e, p)
		 | same (a::IDexp (a::IDENT([], x)), a::IDpat y) = x = y

		 | same (a::TUPLEexp es, a::TUPLEpat ps)
		       =
		       {   fun f ([], []) = TRUE
			     | f (e . es, p . ps) = same (e, p) and f (es, ps)
			     | f _ = FALSE;

		           f (es, ps);
                       }

		 | same _ = FALSE



	       #  complex = complex or labeled and length rets > 1 

	       decl = 
		    case (body, complex)

		      of (_, TRUE) => makeFun()

		       | (a::APPexp (a::IDexp (a::IDENT([], f)), args), _)
			     => 
			     if same (args, pat)
			     then a::VALdecl[a::VALbind (a::IDpat name, u::ID f)]
			     else makeFun()

		       | _ => makeFun()
	  in   decl
	  end

      fun genSig (f as FN { labeled, ... } ) = 
         a::VALSIGdecl([!(name f)], if labeled then labTy f else ty f)
   }

   /* 
    * Transformations on ffi functions
    */
   package tr {



      # An 'transform' is something that changes a ffi fn.
      # A  'condition' is something that checks whether an action applies
      #    and optionally returns some result

      enum state = enum state
      type data      = ffi_g * List( ffi_param ) * state
      type condition = data -> Bool
      type action    = data -> Void
      type transform = ffi_g * state -> ffi_g * state


      fun newState() = ST { var=REF 'a', opens=REF s::empty,
                          encoding=REF (fn e = e) }

      fun newVar (ST { var, ... } )
	  = 
	  {   x = "'" + str *var;
	      var := char::next *var;
              x;
	  }

      fun addOpen (ST { opens, ... }, x)
          =
          opens := s::add (*opens, x)

      fun declare (FFI { transforms, ... } ) regexp tr
          = 
          transforms := (regexp, tr) . *transforms

      fun apply (str as STR { filename, header, body, ... } ) 
                (f as FN { info=FFI { transforms, ... }, ... } )
	  = 
	  {   fun g [] f
                      =
                      f

		| g ((regexp, h) . hs) f
                      = 
		      g hs (if re::matches regexp filename then h f else f);

	      my (f, ST { opens, encoding, ... } )
                  =
                  g  *transforms  (f, newState());

	      opens =   s::vals_list  *opens;

	      body := map *encoding *body;

	      case opens
              of
		[] => ()

	      | _  => header := *header @
			 [a::OPENdecl (map (fn x => a::IDENT([], x)) opens)]
	      ;

	      f;
	  }

   }


   /* 
    * Functions for operating on ffi_str 
    */
   package str {

      #  Accessors 
      fun name (STR { name, ... } ) = name
      fun header (STR { header, ... } ) = header
      fun body (STR { body, ... } ) = body
      fun sign (STR { sign, ... } ) = sign
      fun abs (STR { abs, ... } ) = abs
      fun export (STR { export, ... } ) = export
      fun cm_options (STR { cm_options, ... } ) = cm_options
      fun filename (STR { filename, ... } ) = filename
      fun info (STR { info, ... } ) = info 
      isAnonymous = i::isAnonymousStruct o ! o name

      fun fieldsOf info name = lookupFields info (i::structnameToCname name)

      fun findSig (STR { sign, ... }, f)
	  = 
	  {   fun loop []
                      =
                      raise exception FAIL ("findSig: " + f)

		| loop (a::VALSIGdecl([f'], ty) . ds)
                      = 
		      if f == f' then ty else loop ds

		| loop(_ . ds)
                      =
                      loop ds;

	      loop *sign;
          }

      fun findFunSig (str, f)
          =
          case findSig (str, f) of
            a::FUNty (arg, ret) => (arg, ret)
          | _ => raise exception FAIL("findFunSig: " + f)

      fun create info { filename, name, export, header, body, sign, abs }
          =
          STR { filename,
              export=REF export,
              cm_options=REF "",
              info,
              name=REF name,
              header=REF header,
              body=REF body,
              sign=REF sign,
              abs=REF abs 
             }

      fun empty info { filename, name }
          = 
          create info { filename, name, export=TRUE, header=[],
                       body=[], sign=[], abs=FALSE }

      fun new (info, f, a::MARKdecl(_, d))
              =
              new (info, f, d)

        | new (info, f, a::LOCALdecl (h,[body]))
	      = 
	      {   str =   new (info, f, body);
	          header str := h;
                  str;
	      }

        | new (info, f, decl as a::PACKAGE_DECL (name,[], sign, a::DECLsexp d))
	      =
	      {   my (sign, abs)
                     = 
		      case sign of
			NULL => ([], FALSE)
		      | THE { abstract, api_expression=a::DECLsig d } => (d, abstract)
		      | _ => raise exception FAIL("str::new: " + decl::show decl)    ;

	          STR { filename = f,
			export = REF FALSE,
			cm_options = REF "",
			info,
			name = REF name,
			header = REF [],
			body = REF d,
			sign = REF sign,
			abs = REF abs
		     };
	      }

        | new (info, f, a::SEQdecl[d])
              =
              new (info, f, d)

        | new(_, f, d)
              =
              raise exception FAIL (f + ": str::new: " + decl::show d)
 
      fun genCode (STR { name, header, body, sign, abs, ... } )
	  =
	  {   str = a::PACKAGE_DECL (*name,[],
			   case *sign of
			     [] => NULL
			   | s => THE { abstract= *abs, api_expression=a::DECLsig s },
			   a::DECLsexp(*body));

	      case *header
	        of [] => str
	         | h  => a::LOCALdecl (h, [str]);
	  }

      fun filterValFromSig f (STR { sign, ... } )
          =
          sign := list::filter (fn a::VALSIGdecl([x], ty) => f x
                                 | _ => TRUE) (*sign)

      fun filterVal f (str as STR { body, ... } )
          =
          (body := list::filter (fn a::VALdecl[a::VALbind (a::IDpat x, _)] => f x
                                 | a::FUNdecl[a::FUNbind (x, _)] => f x
                                 | _ => TRUE) (*body);
           filterValFromSig f str
          )

      fun filterValDecl f (str as STR { body, ... } )
          =
          body := list::filter (fn a::VALdecl[a::VALbind (a::IDpat x, e)] => f (x, e)
                                 | _ => TRUE) (*body)
 
      fun filterTy f
          =
          list::filter 
                         (fn a::DATATYPEdecl([],[a::TYPEbind (x, _, _)]) => f x
                           | _ => TRUE)

      fun filterTypeFromSig f (STR { sign, ... } )
          =
          sign := filterTy f (*sign)

      fun filterType f (STR { body, sign, ... } )
          =
          {   body := filterTy f (*body);
              sign := filterTy f (*sign);
          }

      fun renameTy f (STR { body, sign, ... } )
	  = 
	  {   f =   ml::mangle o f ;

	      rename
                  =
                  decl::map
		    [Map::D (fn a::DATATYPEdecl([],[a::TYPEbind (t, x, e)])
                                =>
				a::DATATYPEdecl([],[a::TYPEbind (f t, x, e)])
			     | d => d),

		     Map::T (fn a::IDty (a::IDENT([], t)) => a::IDty (a::IDENT([], f t))
			    | t => t)
		    ];

              body := map rename (*body);
              sign := map rename (*sign);
          }
 
      fun renameVal f (STR { body, sign, ... } )
	  = 
	  {   f =   ml::mangle o f ;

	      rename
                  =
                  decl::map
		    [Map::D (fn a::VALdecl[a::VALbind (a::IDpat x, e)] => u::MY (f x, e)
			    | d => d),
		     Map::E (fn a::IDexp (a::IDENT([], x)) => u::ID (f x)
			    | e => e)
		    ];

	      body := map rename (*body);
              sign := map rename (*sign);
          }

      fun renameFun f (STR { body, sign, ... } )
	  = 
	  {   f =   ml::mangle o f;

	      rename = decl::map
		    [Map::D (fn a::FUNdecl[a::FUNbind (x, e)] => 
				 a::FUNdecl[a::FUNbind (f x, e)]
			    | d => d),
		     Map::E (fn a::IDexp (a::IDENT([], x)) => u::ID (f x)
			    | e => e)
		    ];

              body := map rename (*body);
              sign := map rename (*sign);
	  }
 
      fun write (out, str as STR { info as FFI { comment, ... }, filename,
                               export, cm_options, ... } )
	  = 
	  {   code =   genCode str;

	      if *export   then cm::addDecl (info, out, code,*cm_options)
                           

	      io::writeFile (io::OUTFILE (outfile (info, out)) .
			   io::INFILE (infile (info, filename)) .
			   io::comment comment . stamp,
			   code);
	  }

      fun addToHeader (STR { header, ... },  decl) =   header := *header @ [decl]
      fun addToBodyFront (STR { body, ... }, decl) =   body   := decl . *body
      fun addToBody (STR { body, ... },      decl) =   body   := *body @ [decl]
      fun addToSig (STR { sign, ... },       decl) =   sign   := *sign @ [decl]
   }

   fun read_file info f = 
         str::new (info, f, decl::nolocations (io::read_file (infile (info, f))))

   /* 
    * Functions for operating on an f-file 
    */
   package f_file {

      niceFunName = REF "f"
      labeledFunName = REF "g"

      fun makeNiceFun (str as STR { info, filename, ... } )
	  = 
	  {   my (arg, ret)
                  =
                  str::findFunSig (str, "f'");

	      cname =   re::extractGroup "^f-(.*)\\.sml" 1 filename;

	      fn::newFn info (cname,*niceFunName, arg, ret, fn x => u::APPLY("f'", x));
	  }

      fun copyParam (PARAM { cid, cty, ty, id, mode, ... } )
          =
          PARAM { cid, cty=REF(*cty),
                 ty=REF(*ty), coer=REF [], id, mode=REF(*mode) }

      fun makeLabeledFun (f as FN { info, cname, name, params, ... } )
	  =
	  {   args     =   fn::args f;
	      callArgs =   a::TUPLEexp (map (fn PARAM { id, ... } => u::ID id) args);
	      call     =   u::APPLY(*name, callArgs);

	      FN { info,
		   name    = REF(*labeledFunName),
		   cname,
		   params  = REF (map copyParam(*params)), 
		   initargs =fn::args f,
		   initrets= fn::rets f,
		   body    = call,
		   init    = REF [],
		   cleanup = REF [],
		   labeled = TRUE
		}
	  }
   }

   /*
    * Functions for operating on an [su]-file
    */
   package su_file {

      fun cstructname str = i::structnameToCname (*(str::name str))

      fun fields str = lookupFields (str::info str) (cstructname str)

      isStruct = re::matches "^s-" o str::filename 
      isUnion = re::matches "^u-" o str::filename 

      #  Find out what function to use to get(), given an ML type 
      fun makeGet ((x, ty, cty, bits) : field) e
	  =
	  {   fun toBool (code, signed)
                  =
		  case (bits, signed) of
		    (NULL, _) => code #  Default to code in the absence of type 
		  | (THE 1, TRUE) => code + " != (0:  mlrep::signed::Int)"
		  | (THE 1, FALSE) => code + " != (0w0:  mlrep::unsigned::word)"
		  | (THE _, _) => code

	      case ty of
		a::IDty (a::IDENT([], t)) =>
		(case t of
		  "ubf" => toBool("get::ubf " + e, FALSE)
		| "sbf" => toBool("get::sbf " + e, TRUE)
		| "voidptr" => "get::voidptr' " + e
		| t => if isPrim t then "Get." + t + "' " + e
		       else raise exception FAIL("makeGet: " + t)
	       )
	      | a::APPty (a::IDENT([], "enum"), _) => "get::sint' " + e
	      | a::APPty (a::IDENT([], "ptr"), _) => "get::ptr' " + e
	      | a::APPty (a::IDENT([], "fptr"), _) => "get::fptr' " + e
	      | a::APPty (a::IDENT([S], "iptr"), _) => S + ".get' " + e
	      | a::APPty (a::IDENT([], ("su" | "arr")), _) => e
	      | ty => raise exception FAIL("makeGet: " + Ty::show ty);
	  }

      #  Find out what function to use to set(), given an ML type 
      fun makeSet ((f, ty, cty, bits) : field) (x, y)
	  = 
	  {   fun fromBool signed
                   =
		  case (bits, signed) of
		    (NULL, _) => y #  Default in the absence of type 
		  | (THE 1, TRUE) => "(if " + y + " then 0 else 0)"
		  | (THE 1, FALSE) => "(if " + y + " then 0w1 else 0w0)"
		  | (THE _, _) => y;

	      case ty of
		a::IDty (a::IDENT([], t)) =>
		(case t of
		  "ubf" => "set::ubf(" + x + ", " + fromBool (FALSE) + ")"
		| "sbf" => "set::sbf(" + x + ", " + fromBool (TRUE) + ")"
		| "voidptr" => "set::voidptr'(" + x + ", " + y + ")"
		| t => if isPrim t then "Set." + t + "'(" + x + ", " + y + ")"
		       else raise exception FAIL("makeSet: " + t)
	       )
	      | a::APPty (a::IDENT([], "enum"), _) => "set::sint'(" + x + ", " + y + ")"
	      | a::APPty (a::IDENT([], "ptr"), _) => "set::ptr' (" + x + ", " + y + ")"
	      | a::APPty (a::IDENT([], "fptr"), _) => "set::fptr' (" + x + ", " + y + ")"
	      | a::APPty (a::IDENT([S], "iptr"), _) => S + ".set'(" + x + ", " + y + ")"
	      | a::APPty (a::IDENT([], "arr"), _) =>  
		let type = "typ_" + f
		in  "c::copy' (t::sizeof " + type + ") { to=" + x + ", from=" + y + "}" 
		end 
	      | a::APPty (a::IDENT([], "su"), [a::IDty (a::IDENT([S], "tag"))]) =>  
		 "c::copy' " + S + ".size { to=" + x + ", from=" + y + "}" 
	      | ty => raise exception FAIL("makeSet: " + Ty::show ty);
	  }

      fun accessor f x
          =
          exp::parse (makeGet f x);

      fun mutator f (x, y)
          =
          exp::parse (makeSet f (x, y));

      fun makeField f x
          =
          "(f_" + f + "' " + x + ")";

      fun emit str f
          =
          fn::genCode (tr::apply str f)

      fun makeAccessorFun str (field as (f, retTy, retCty, _))
          = 
          {   argTy =   a::IDty (a::IDENT([], "self"));

              fname =   "get_" + f;

              fn::newFn (str::info str) ("", fname, argTy, i::repTy i::LIGHT retTy,
                             fn _ => accessor field (makeField f "x1"));
          }

      fun makeAccessorFun' info (f, _, _, _)
          = 
           A.@@@["fun get'" + f + " x = get_" + f + "(ptr::deref' x)",
               "my " + ml::valName f + " = { get=get_" + f + ", deref=get'" + f + "}"
              ]

      fun showBits NULL = ""
        | showBits (THE i) = " : " + int32::to_string i;

      fun makeAccessor str (field as (f, ty, _, bits))
          =
          a::SEQdecl
          [comment ["Accessors for field " + f + " : " + Ty::show ty + showBits bits],
           emit str (makeAccessorFun str field),
           makeAccessorFun' str field
          ];

      fun makeMutatorFun str (field as (f, argTy, argCty, _))
          = 
          {   argTy =   a::TUPLEty[a::IDty (a::IDENT([], "self")), argTy];
              fname =   "set_"  +  f;

              fn::newFn (str::info str) ("", fname, argTy, a::TUPLEty [],
                             fn _ => mutator field (makeField f "x1", "x2"));
          }

      fun makeMutatorFun' str (f, _, _, _)
          = 
           A.@@@["fun set'" + f + " (x, y) = set_" + f + "(ptr::deref' x, y)"]

      fun makeMutator str (field as (f, ty, _, bits))
          =
          a::SEQdecl
          [comment ["Mutators for field " + f + " : " + Ty::show ty + showBits bits],
           emit str (makeMutatorFun str field),
           makeMutatorFun' str field
          ]

      fun makeConstructors str fields
	  = 
	  {   fun var f
                  =
                  "f_" + f

	      fun init (f, _, _, _)
                  =
                  "my () = set_" + f + "(obj, " + var f + ")"

	      vars =   map (fn (f, _, _, _) => var f) fields;
	      pat  = a::TUPLEpat (map a::IDpat vars);
	      exp  = a::TUPLEexp (map u::ID vars);

	      body = 
		   a::LETexp([A.@@@("obj = c::new' (t::sizeof type)" .
				 map init fields)], 
			    [u::ID "obj"]);

	      labpat = a::RECORDpat (map 
			      (fn (f, _, _, _) => (ml::mangle f, a::IDpat (var f))) 
				fields, FALSE);

	      init1 =   u::FUN("obj", pat, body);
	      init2 =   u::FUN("obj'", labpat, u::APPLY("obj", exp));
	      init3 =   A.@@@["fun ptr x = ptr::enref' (obj x)"];
	      init4 =   A.@@@["fun ptr' x = ptr::enref' (obj' x)"];
	      inits =   [init1, init2, init3, init4];

	      a::SEQdecl[
		comment ["Constructors"], 
		a::PACKAGE_DECL("new",[], NULL, a::DECLsexp inits)
	      ];
	  }

      fun addTypeAbbrev str
          = 
          str::addToBody (str,
             A.@@@["package t =",
                 "struct",
                 "  type obj  = su_obj (tag, rw)  ",
                 "  type obj' = su_obj'(tag, rw)  ",
                 "  type ptr  =  ptr (tag su, rw) ",
                 "  type ptr' =  ptr'(tag su, rw) ",
                 "  end"
                ]
          );

   }			# package


   # Functions for generating enums

   package enum {
 
      type enum_info = enum_info

      fun ctypeName info (ca::TypeRef tid) = c::tidName info tid
        | ctypeName info (ca::EnumRef tid) = c::tidName info tid
        | ctypeName info (ca::Qual(_, ctype)) = ctypeName info ctype
        | ctypeName info _ = ""

      fun lookup (info as FFI { enumTbl, ... } ) cty
          = 
          m::find (enumTbl, ctypeName info cty)

      fun enums (FFI { enumTbl, ... } )
          =
          m::vals_list enumTbl

      fun cty (ENUM { cty, ... } )
          =
          cty

      fun members (ENUM { members, ... } )
          =
          members

      mlrep =   a::IDty (a::IDENT(["mlrep", "Signed"], "int"));

      fun typed (v, ty)
          =
          a::TYPEDexp (a::LITexp (a::INT32lit v), ty)

      fun isEnumeration (ENUM { members, ... } )
	  = 
	  {   fun check (i: int32::Int, (_, j) . rest)
                      =
                      i==j   and   check (i+1, rest)

		| check(_,[]) = TRUE;

	      check (0, members);
          }

      fun isBitSet (ENUM { members, ... } )
	  = 
	  {   fun check (i: int32::Int, (_, j) . rest) = i=j and check (i+i, rest)
		| check(_,[]) = TRUE;

	      check (1, members);
          }
 
      fun mark (ENUM { rep as REF NULL, ... }, r)
              =
              rep := THE r;

        | mark (ENUM { rep, cty, ... }, _)
             = 
             raise exception FAIL("Code has already been generated for enum " + cty);


      type enum_g
          =
          {   info:         ffi_info,
              structName:   Ast::id,
              errorHandler: Ast::exp
          }

      # Generate values representing the enums.
      # This method just represent them as integers.

      fun genEnumsAsInts { info, structName, errorHandler } 
           (enums as ENUM { cty, members, ... } )
	  =
	  {   tyName =   stripUnderscores cty;
	      ty     =   a::IDty (a::IDENT([], tyName));

	      mark (enums, ENUM_REP { structName, ty=tyName,
				   kind=ENUM_AS_INT } );

	      a::SEQdecl[
		  comment ["C enum type " + cty],
		  a::DATATYPEdecl([],[a::TYPEbind (tyName,[], mlrep)]),
		  a::VALdecl (map (fn (x, v) => 
				 a::VALbind (a::IDpat (stripUnderscores x),
					   typed (v, ty))) members)
	       ];
	  }

      fun toML (ENUM { cty, ... } )
          =
          "ml_" + (ml::typeName cty);

      fun toC (ENUM { cty, ... } )
          =
          "c_" + (ml::typeName cty);


      # Generate a enum representing the enum
      # Also generate two functions for conversion between the enum
      # and mlrep::signed::Int.

      fun genDatatype info name (ENUM { members, cty, ... } )
          = 
          {   dt =   u::DATATYPE (
                         name,
                         [],
                         map
                             (fn (x, _) => u::CONS (stripUnderscores x, NULL))
                             members
                     );

              a::SEQdecl [
                  comment ["C enum type " + cty],
                  a::DATATYPEdecl([dt],[])
              ];
          }

      fun genCvtFuns info (toML, toC, errorHandler) (ENUM { cty, members, ... } )
          = 
          {   default =   [a::CLAUSE([a::WILDpat], NULL, errorHandler)];

              f1 =   a::FUNbind (toC,
                           map (fn (x, v) =>
                              a::CLAUSE([a::IDpat (stripUnderscores x)], NULL,
                                           typed (v, mlrep))) members);

              cases =   map (fn (x, v) =>
                              a::CLAUSE([a::TYPEDpat (u::INT32pat v, mlrep)],
                                       NULL, u::ID (stripUnderscores x))) members;

              f2 =   a::FUNbind (toML, cases @ default);
              a::FUNdecl [f1, f2];
          }

      fun genEnumsAsDatatype { info, structName, errorHandler } enums
          = 
          {   name    = stripUnderscores (cty enums);
              dt      = genDatatype info name enums;
              toML    = toML enums;
              toC     = toC enums;
              cvts    = genCvtFuns info (toML, toC, errorHandler) enums;

              mark (enums, ENUM_REP { structName, ty=name,
                                   kind=ENUM_AS_DATATYPE { toML, toC }} );

              a::SEQdecl[dt, cvts];
          }

      /* 
       * Generate a enum representing the enum
       * Also generate two functions for conversion between the enum
       * and mlrep::signed::Int.
       */
      fun genEnumsAsDatatypeList { info, structName, errorHandler } enums
          =
          {   name  = stripUnderscores (cty enums);
              name' = name + "'";
              dt'   = genDatatype info name' enums;
              dt    = A.@@@["type " + name + " = list " + name' + ""];
              toML  = toML enums;
              toC   = toC enums;
              toML' = toML + "'";
              toC'  = toC + "'";
              cvts' = genCvtFuns info (toML', toC', errorHandler) enums;
              cvts  = A.@@@["my " + toML + " = enum_util::toML " + toML',
                              "my " + toC + "  = enum_util::toC " + toC'];

              mark (enums, ENUM_REP { structName, ty=name,
                                   kind=ENUM_AS_DATATYPE { toML, toC }} );

              a::SEQdecl[dt', dt, cvts', cvts];
          }

   }

   /*
    * Dealing with iptr
    */
   package iptr {

      fun iptrs info
	  =
	  {   fun getIptr file
		  =
		  {   prog =   io::read_file (infile (info, file));
		      strname =
			decl::fold[Fold::D (fn (a::PACKAGE_DECL (x, _, _, _), _) => x
					  | (_, x) => x)] "" prog;

		      strname;
		  };

	      map getIptr (listFiles info "^i[su]-.*\\.sml + ");
	  }

      fun genCode info
	  =
	  {   iptrs =   iptrs info;

	      fun makeIS strname
		  =
		  {   cname   =   i::structnameToCname strname;
		      su      =   if re::matches "^IS" strname then "s" else "u";
		      tagdecl =   i::tagDecl { name=cname, ty="tag", su };

		      str = a::PACKAGE_DECL (
                                strname,
                                [],
                                NULL,
			        a::APPsexp (
                                    a::IDsexp (a::IDENT([], "PtrToIncompleteType")), 
				    a::DECLsexp [ tagdecl ]
                                )
                            );

		      filename =   strname  +  ".sml";	# XXX BUGGO FIXME
		      cmfilename = strname  +  ".cm" ;	# XXX BUGGO FIXME

		      #  cm::addExport (info, "package " + strname); 
		      write (undefinesfile (info, filename), [], str);
		      write (undefinesfile (info, cmfilename), [],
			 A.@@@["Library",
			     "\tpkg " + strname,
			     "is",
			     "\t$/c/internals/c-internals.make6",
			     "\t../common/smlnj-ffilib-basis.cm",
			     "\t" + filename
			    ]);
		      cm::addImport (info, "../"  +  undefinesfile (info, filename));
		  };

	      apply makeIS iptrs;
	  }

   }
 
   package define = define_g
 
};
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
