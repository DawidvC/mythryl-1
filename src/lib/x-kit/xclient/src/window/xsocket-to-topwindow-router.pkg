## xsocket-to-topwindow-router.pkg
#
# Primary functionality
# =====================
#
# For the big picture, see the dataflow diagram in:
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# We receive X events from the xsession xbuf_imp
# and decide what action to take for them.  The
# xbuf_imp just breaks the X event bytestream up
# into individual messages;  we are the first link
# in the chain which actually responds to X events
# on a semantic level.
#
# Typically we will route the X event from to
# the toplevel window for the relevant widget.
# 
# To do this we need to track all toplevel windows
# created by the application, keyed by their
# X-server-assigned IDs, so that we can translate
# the xid in the event to the corresponding widget
# for delivery.
#
# There are also a few X events which we divert to
# specialized imps for processing:
#
#  o  There following two X events we handle ourself,
#     updating our window registry appropriately:
#         CREATE_NOTIFY
#         DESTROY_NOTIFY
#
#  o  The following three X events get redirected
#     to our selection imp:
#         SELECTION_CLEAR
#         SELECTION_REQUEST
#         SELECTION_NOTIFY
#
#  o  The following X events get redirected
#     to our property imp:
#         PROPERTY_NOTIFY
#
#
# Secondary functionality
# =======================
#
# This file also implements a facility to
# freeze selected windows, with draw commands
# to them queueing up until they are unlocked:
# See make_overlay_buffer in
#     src/lib/x-kit/xclient/src/window/draw-imp.pkg  
#
# The idea might have been to allow XOR-implemented
# rubber-banding selection to work without anomalies
# due to the window contents changing between draw
# and undraw calls.
#
# The lock_window_tree entrypoint is called
# nowhere in the codebase, so this is apparently
# code that was just being phased in when
# development ceased.
#

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6



# TODO			XXX BUGGO FIXME
#   - refresh the keymap on ModifierMappingNotifyXEvt and KeyboardMappingNotifyXEvt
#     events.
#   - think about the relation of locks and changes in the tree structure
#     also locking already locked windows.


stipulate
    package xt  = xtypes;				# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  = event_types;				# event_types		is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package dy  = display;				# display		is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xok = xsocket;				# xsocket		is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg

herein
    package xsocket_to_topwindow_router: (weak)  Xsocket_To_Topwindow_Router {		# Xsocket_To_Topwindow_Router	is from   src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router.api

	include threadkit;								# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

	Envelope_Route
	  = ENVELOPE_ROUTE_END  xtypes::Window_Id
	  | ENVELOPE_ROUTE     (xtypes::Window_Id, Envelope_Route)
	  ;

	stipulate

	    package plea {
		#
		Mail
		  = NOTE_NEW_TOPLEVEL_WINDOW  xt::Window_Id
		  | LOCK_WINDOW               xt::Window_Id
		  | UNLOCK_WINDOW             xt::Window_Id
		  | IS_WINDOW_LOCKED          xt::Window_Id
		  ;
	    };

	    Window_Info
		=
		WINDOW_INFO
		  { window_id:    xt::Window_Id,
		    route:        Envelope_Route,
		    parent_info:  Null_Or( Window_Info ),

		    children:     Ref(  List(  Window_Info ) ),
		    lock:         Ref( Bool ),

		    event_slot:   Mailslot( (Envelope_Route, et::x::Event) )
		  };

	    # The various things we can do with a given X event?
	    #
	    Xevent_Action
	      #	
	      = TO_WINDOW                xt::Window_Id
	      | NOTE_WINDOW_DESTRUCTION  xt::Window_Id
	      | TO_KEYMAP_IMP					# This appears to be unused at present.
	      | TO_WINDOW_PROPERTY_IMP
	      | TO_SELECTION_IMP
	      | TO_ALL
	      | TO_TRASH
	      | NOTE_NEW_WINDOW
                  { parent_window_id:   xt::Window_Id,
		    created_window_id:  xt::Window_Id
		  }
	      ;

		# ddeboer test, fall 2004. 
		# rcref = REF 0

	    # Discard instances of an X-event that
	    # are the product of SubstructureNotify,
	    # instead of StructureNotify.
	    #
	    fun ignore_substructure_notify_xevents (w1, w2)
		=
		if (w1 == w2)  TO_WINDOW w1;
		else           TO_TRASH;
		fi;

	    # Decide what action to take for given X event:
	    #
	    fun pick_xevent_action (et::x::KEY_PRESS      { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::KEY_RELEASE    { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::BUTTON_PRESS   { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::BUTTON_RELEASE { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::MOTION_NOTIFY  { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::ENTER_NOTIFY   { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::LEAVE_NOTIFY   { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::FOCUS_IN       { event_window_id, ... } ) =>  TO_WINDOW event_window_id;
		pick_xevent_action (et::x::FOCUS_OUT      { event_window_id, ... } ) =>  TO_WINDOW event_window_id;

#		pick_xevent_action (et::x::KeymapNotify {, ... } ) = 
#		pick_xevent_action (et::x::GraphicsExpose ?? 
#		pick_xevent_action (et::x::NoExpose {, ... } ) =
#		pick_xevent_action (et::x::MapRequest {, ... } ) =
#		pick_xevent_action (et::x::ConfigureRequest {, ... } ) =
#		pick_xevent_action (et::x::ResizeRequest {, ... } ) =
#		pick_xevent_action (et::x::CirculateRequest {, ... } ) =

		pick_xevent_action (et::x::EXPOSE { exposed_window_id, ... } ) =>  TO_WINDOW  exposed_window_id;


		pick_xevent_action (et::x::VISIBILITY_NOTIFY { changed_window_id, ... } ) =>  TO_WINDOW  changed_window_id;

		pick_xevent_action (et::x::CREATE_NOTIFY { parent_window_id, created_window_id, ... } )
		    =>
		    NOTE_NEW_WINDOW { parent_window_id, created_window_id };

		pick_xevent_action (et::x::DESTROY_NOTIFY { event_window_id, destroyed_window_id, ... } )
		    =>
		    event_window_id == destroyed_window_id
			##
                        ??  NOTE_WINDOW_DESTRUCTION  event_window_id	# Remove window from registry. 
			::  TO_WINDOW                event_window_id;	# Report to parent that child is dead. 

		pick_xevent_action (et::x::UNMAP_NOTIFY { event_window_id, unmapped_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, unmapped_window_id);

		pick_xevent_action (et::x::MAP_NOTIFY { event_window_id, mapped_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, mapped_window_id);


		pick_xevent_action (et::x::REPARENT_NOTIFY _)
		    =>
		    TO_TRASH;

		pick_xevent_action (et::x::CONFIGURE_NOTIFY { event_window_id, configured_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, configured_window_id);


		pick_xevent_action (et::x::GRAVITY_NOTIFY { event_window_id, moved_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, moved_window_id);


		pick_xevent_action (et::x::CIRCULATE_NOTIFY { event_window_id, circulated_window_id, ... } )
		    =>
		    ignore_substructure_notify_xevents (event_window_id, circulated_window_id);


		pick_xevent_action (et::x::PROPERTY_NOTIFY   _) => TO_WINDOW_PROPERTY_IMP;    # We may have other uses of PropertyNotify someday.
		pick_xevent_action (et::x::SELECTION_CLEAR   _) => TO_SELECTION_IMP;
		pick_xevent_action (et::x::SELECTION_REQUEST _) => TO_SELECTION_IMP;
		pick_xevent_action (et::x::SELECTION_NOTIFY  _) => TO_SELECTION_IMP;

		pick_xevent_action (et::x::COLORMAP_NOTIFY { window_id, ... } ) => TO_WINDOW window_id;
		pick_xevent_action (et::x::CLIENT_MESSAGE  { window_id, ... } ) => TO_WINDOW window_id;

		pick_xevent_action  et::x::MODIFIER_MAPPING_NOTIFY     => TO_ALL;
		pick_xevent_action (et::x::KEYBOARD_MAPPING_NOTIFY _)  => TO_ALL;
		pick_xevent_action  et::x::POINTER_MAPPING_NOTIFY      => TO_ALL;

		pick_xevent_action e => {
		   xgripe::warning (string::cat [
		     "[xsocket-to-topwin: unexpected ", xevent_to_string::xevent_name e, " event]\n"]);
		   TO_TRASH;};
	      end;
    #  +DEBUG 

	stipulate

	    xid_to_string = xtype_to_string::xid_to_string;

	    fun xevent_action_to_string (TO_WINDOW w)
		    =>
		    ("TO_WINDOW(" + xid_to_string w + ")");

		xevent_action_to_string (NOTE_NEW_WINDOW { parent_window_id, created_window_id } )
		    =>
		    string::cat
		      [
			"NOTE_NEW_WINDOW { parent=",  xid_to_string  parent_window_id,
			      ", new_window=",  xid_to_string created_window_id,
			"}"
		      ];

		xevent_action_to_string (NOTE_WINDOW_DESTRUCTION w) => ("NOTE_WINDOW_DESTRUCTION(" + xid_to_string w + ")");
		xevent_action_to_string TO_KEYMAP_IMP               => "TO_KEYMAP_IMP";
		xevent_action_to_string TO_WINDOW_PROPERTY_IMP      => "TO_WINDOW_PROPERTY_IMP";
		xevent_action_to_string TO_SELECTION_IMP            => "TO_SELECTION_IMP";
		xevent_action_to_string TO_ALL                      => "TO_ALL";
		xevent_action_to_string TO_TRASH                    => "TO_TRASH";
	    end;

	herein

	    pick_xevent_action
		=
		fn xevent
		    =
		    {   xevent_action =  pick_xevent_action  xevent;

			xtracing::print_if xtracing::winreg_tracing .{
			    #
			    cat [ "xsocket_to_topwindow_router: ", xevent_to_string::xevent_name  xevent,
                                  " => ", xevent_action_to_string xevent_action
                                ];
			};

			xevent_action;
		    };
	end;
    #  -DEBUG 

	herein

	    Xsocket_To_Topwindow_Router
		=
		XSOCKET_TO_TOPWINDOW_ROUTER 
		  {
		    plea_slot:    Mailslot( plea::Mail ),
		    reply_slot:   Mailslot( Mailop( (Envelope_Route, et::x::Event) ) ),
		    lock_slot:    Mailslot( Bool )
		  };



	    stipulate

		fun set_window_subtree_locks_to
			(bool: Bool)	
		    =
		    set
		    where
			fun set (WINDOW_INFO { lock, children, ... } )
			    =
			    {   lock := bool;
				set_list *children;
			    }

			also
			fun set_list (wd ! r)
				=>
				{   set wd;
				    set_list r;
				};

			    set_list []
				=>
				();
			end;
		    end;
	    herein

		lock_tree   =  set_window_subtree_locks_to   TRUE;
		unlock_tree =  set_window_subtree_locks_to   FALSE;

	    end;

	    # This is called exactly one place, in
	    #     src/lib/x-kit/xclient/src/window/xsession.pkg
	    #
	    fun make_xsocket_to_topwindow_router
		{
		  display => dy::XDISPLAY { xsocket, ... },
		  keymap_imp,
		  to_window_property_imp_slot,
		  to_selection_imp_slot
		}
		=
		{
    #		/* testing: ddeboer, fall 2004. *
    #		rn = *rcref
    #		(file::print ("Started registry " + (int::to_string rn) + "\n");
    #			      rcref:= *rcref + 1)
    #		* end testing. */

		    xevent_in'
			=
			xok::wait_for_xevent  xsocket;

		    register_plea_slot  =   make_mailslot ();
		    register_reply_slot =   make_mailslot ();

		    lock_reply_slot     =   make_mailslot ();
								    # hash_xid	is from   src/lib/x-kit/xclient/src/stuff/hash-xid.pkg
		    window_id_to_window_info_map =  hash_xid::make_map ();
		    #
		    get_info  =  hash_xid::get     window_id_to_window_info_map;
		    set_info  =  hash_xid::set     window_id_to_window_info_map;
		    drop_info =  hash_xid::remove  window_id_to_window_info_map;

		    fun do_plea (plea::NOTE_NEW_TOPLEVEL_WINDOW  window_id)
			    =>
			    {   # Log a new top-level window:

				event_slot = make_mailslot ();

				set_info
				  ( window_id,
				    WINDOW_INFO
				      {
					window_id,
					event_slot,
					route       =>  ENVELOPE_ROUTE_END  window_id,
					parent_info =>  NULL,
					children    =>  REF [],
					lock        =>  REF FALSE
				      }
				  );

				give  (register_reply_slot,  take'  event_slot);
			    };

		       do_plea (plea::LOCK_WINDOW   window_id) =>   lock_tree (get_info  window_id);
		       do_plea (plea::UNLOCK_WINDOW window_id) => unlock_tree (get_info  window_id);

		       do_plea (plea::IS_WINDOW_LOCKED window_id)
			   =>
			   {   (get_info  window_id)
				   ->
				    WINDOW_INFO { lock, ... };

			       give  (lock_reply_slot,  *lock);
			   };
		    end;

		    fun note_new_subwindow (parent_window_id, child_window_id)
			=
			{
			    (get_info  parent_window_id)
				-> 
				parent_info as WINDOW_INFO { route, event_slot, children, lock, ... };

			    fun extend_route (ENVELOPE_ROUTE_END w)      =>  ENVELOPE_ROUTE (w, ENVELOPE_ROUTE_END child_window_id);
				extend_route (ENVELOPE_ROUTE (w, route)) =>  ENVELOPE_ROUTE (w, extend_route route);
			    end;

			    child_route = extend_route route;

			    child_info
				=
				WINDOW_INFO
				  {
				    window_id   =>  child_window_id,
				    route       =>  child_route,
				    parent_info =>  THE parent_info,
				    children    =>  REF [],
				    lock        =>  REF *lock,
				    event_slot
				  };

			    children := child_info ! *children;

			    set_info (child_window_id, child_info);
			};

		    # ddeboer, test, fall 2004 
		    # cref = REF 0

		    fun push_event (e, WINDOW_INFO { route, event_slot, ... } )
			= 
			give  (event_slot, (route, e));


		    fun push_event_to_window (e, window_id)
			=
			(push_event (e, get_info window_id))
			except
			    hash_xid::XID_NOT_FOUND = ();

		    fun do_xevent xevent
			=
			case (pick_xevent_action xevent)
			    #
			    TO_WINDOW window_id
				=>
				push_event_to_window (xevent, window_id);

			    NOTE_NEW_WINDOW { parent_window_id, created_window_id }
				=>
				{   note_new_subwindow (parent_window_id, created_window_id);
				    #
				    push_event_to_window (xevent, parent_window_id);
				};

			    NOTE_WINDOW_DESTRUCTION  window_id
				=>
				case (drop_info  window_id)
				    #
				    (window as WINDOW_INFO { parent_info => THE (WINDOW_INFO { children, ... } ), ... } )
					=>
					{   fun remove_child ((window_info as WINDOW_INFO { window_id => window_id', ... } ) ! rest)
						    =>
						    if (window_id' == window_id)  rest;
						    else                          (window_info ! (remove_child rest));
						    fi;

						remove_child []
						    =>
						    {   xgripe::warning "[xsocket-to-topwin: missing child]";
							[];
						    };
					    end;

					    children
						:=
						remove_child *children;

					    push_event (xevent, window);
					};

				    window
					=>
					push_event (xevent, window);
				esac;

			    TO_KEYMAP_IMP
				=>
				{   xgripe::warning "[xsocket-to-topwin: unexpected TO_KEYMAP_IMP]";
				    ();
				};

			    TO_WINDOW_PROPERTY_IMP  =>  give  (to_window_property_imp_slot, xevent);
			    TO_SELECTION_IMP        =>  give  (to_selection_imp_slot,       xevent);

			    TO_TRASH => ();
			    TO_ALL   => apply (fn (_, x) = push_event (xevent, x))
					      (hash_xid::list  window_id_to_window_info_map);
			esac;

		    mailop
			=
			choose [
			    take'  register_plea_slot
				==>
				do_plea,

			    xevent_in'
				==>
				do_xevent
			];

		    # fun loop () = { do_mailop mailop; loop(); };
	  /* DEBUG */ fun loop () = { xtracing::print_if xtracing::winreg_tracing .{ "Winreg::loop: waiting."; };
				      do_mailop mailop;
				      loop();
				    };

		    xtracing::make_thread  "xsocket-to-topwin"  loop;

		    XSOCKET_TO_TOPWINDOW_ROUTER
		      {
			plea_slot  => register_plea_slot,
			reply_slot => register_reply_slot,
			lock_slot  => lock_reply_slot
		      };
		};						# fun make_xsocket_to_topwindow_router


	    # Add 'toplevel_window' to our    window_id_to_window_info_map
	    # and return the event slot through which we will feed X events
	    # to that window.
	    #
	    # This function is called (only) from    make_topwindow_to_widget_router   in
	    #
	    #     src/lib/x-kit/xclient/src/window/topwindow-to-widget-router.pkg
	    #
	    fun note_new_toplevel_window (XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, reply_slot, ... },  toplevel_window)
		=
		{   give  (plea_slot,  plea::NOTE_NEW_TOPLEVEL_WINDOW toplevel_window);
		    take   reply_slot;
		};

	    # This is nowhere called:
	    #
	    fun lock_window_tree (XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, reply_slot, ... }, window)
		=
		{   give (plea_slot, plea::LOCK_WINDOW window);

		    .{  give (plea_slot, plea::UNLOCK_WINDOW window);  };
		};

	    # This gets called exactly one place, in
	    #
	    #     src/lib/x-kit/xclient/src/window/draw-imp.pkg
	    #
	    fun window_is_locked (XSOCKET_TO_TOPWINDOW_ROUTER { plea_slot, lock_slot, ... }, window)
		=
		{   give (plea_slot, plea::IS_WINDOW_LOCKED window);
		    take lock_slot;
		};
	end;					# stipulate
    };						# package xsocket_to_topwindow_router
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
