## rw-char-vector-slice.pkg
## Author: Matthias Blume (blume@tti-c.org)

# Compiled by:
#     src/lib/std/src/Base-imp.make6



###            "Any fool can know.  The
###             point is to understand."
###
###                     -- Albert Einstein



package rw_char_vector_slice : Monomorphic_Rw_Vector_Slice		# Monomorphic_Rw_Vector_Slice	is from   src/lib/std/src/monomorphic-rw-vector-slice.api
				where  Element == Char
				where  Rw_Vector == rw_char_vector::Rw_Vector
				where     Vector == char_vector::Vector
				where  Vector_Slice == char_vector_slice::Slice
= package {

     Element = Char;
     Rw_Vector = rw_char_vector::Rw_Vector;
     Vector = char_vector::Vector;
     Vector_Slice = char_vector_slice::Slice;

     Slice =
	     SL  { base:  Rw_Vector, start:  Int, stop:  Int };

    # Fast add/subtract avoiding
    # the overflow test:
    #
    infix val --- +++;
    #
    fun x --- y = inline_t::unt31::copyt_int31 (inline_t::unt31::copyf_int31 x - inline_t::unt31::copyf_int31 y);
    fun x +++ y = inline_t::unt31::copyt_int31 (inline_t::unt31::copyf_int31 x + inline_t::unt31::copyf_int31 y);

    unsafe_get = inline_t::rw_char_vector::get;
    unsafe_set = inline_t::rw_char_vector::set;

    ro_unsafe_get = inline_t::char_vector::get;
    ro_unsafe_set = inline_t::char_vector::set;

    rw_length = inline_t::rw_char_vector::length;
    ro_length = inline_t::char_vector::length;

    fun length (SL { start, stop, ... } ) = stop --- start;


    fun get (SL { base, start, stop }, i)
	=
	{
	    i' = start + i;

	    if (i' < start or i' >= stop ) raise exception SUBSCRIPT;
	    else unsafe_get (base, i');fi;
	};


    fun set (SL { base, start, stop }, i, x)
	=
	{
	    i' = start + i;

	    if  (i' < start
            or   i' >= stop
            )    raise exception SUBSCRIPT;
	    else unsafe_set (base, i', x);  fi;
	};


    fun make_full_slice arr
        =
        SL { base => arr, start => 0, stop => rw_length arr };


    fun make_slice (arr, start, olen)
	=
	{   al = rw_length arr;

	    SL { base => arr,

		 start => if (start < 0 or al < start)  raise exception SUBSCRIPT;
			  else                          start;
                          fi,

		 stop  => case olen   
			     NULL => al;

			     THE len =>
				{  stop = start +++ len;
				   if (stop < start or al < stop)  raise exception SUBSCRIPT;
				   else                            stop;
                                   fi;
				};
                          esac
               };
	};


    fun make_subslice (SL { base, start, stop }, i, olen)
	=
	{   start' = if (i < 0 or stop < i)  raise exception SUBSCRIPT;
		     else                    start +++ i;
                     fi;

	    stop'  = case olen   

			 NULL => stop;

			 THE len =>
			    { stop' = start' +++ len;
			     if (stop' < start' or stop < stop' ) raise exception SUBSCRIPT;
			       else stop';fi;
			    };
                     esac;

	    SL { base, start => start', stop => stop' };
	};


    fun base (SL { base, start, stop } )
        =
        (base, start, stop --- start);


    fun to_vector (SL { base, start, stop } )
        =
	case (stop --- start)
          
	    0 => "";
	   len => { s = assembly::a::create_s len;
		       fun fill (i, j) =
			   if (i >= len ) ();
			   else  ro_unsafe_set (s, i, unsafe_get (base, j));
				 fill (i +++ 1, j +++ 1); fi;
		   
		       fill (0, start); s;
		   };
        esac;

    fun copy { from => SL { base, start, stop }, to, di }
	=
	{
	    sl = stop --- start;
	    de = sl + di;

	    fun copy_dn (s, d)
                =
		if (s < start ) ();
                else unsafe_set (to, d, unsafe_get (base, s));
					   copy_dn (s --- 1, d --- 1);
                fi;

	    fun copy_up (s, d)
                =
		if (s >= stop ) ();
                else unsafe_set (to, d, unsafe_get (base, s));
					   copy_up (s +++ 1, d +++ 1);
                fi;

	    if   (di < 0 or de > rw_length to) raise exception SUBSCRIPT;
	    elif (di >= start )                  copy_dn (stop --- 1, de --- 1);
	    else                                 copy_up (start, di);
            fi;
	};

    fun copy_vec { from => vsl, to, di }
	=
	{
	    my (base, start, vlen) = char_vector_slice::base vsl;
	    de = di + vlen;

	    fun copy_up (s, d)
                =
		if (d < de )
                   unsafe_set (to, d, ro_unsafe_get (base, s));
		   copy_up (s +++ 1, d +++ 1);
                fi;

	    if (di < 0 or de > rw_length to) raise exception SUBSCRIPT;
	    #  Assuming vector and rw_vector are disjoint 
	    else copy_up (start, di);fi;
	};

    fun is_empty (SL { start, stop, ... } )
        =
        start == stop;

    fun get_item (SL { base, start, stop } )
        =
	if (start >= stop ) NULL;
	else THE (unsafe_get (base, start),
		   SL { base, start => start +++ 1, stop } );
        fi;

    fun keyed_apply f (SL { base, start, stop } )
	=
	{   fun apply i
		=
		if (i >= stop ) ();
		else f (i --- start, unsafe_get (base, i)); apply (i +++ 1);
		fi;

	    apply start;
	};

    fun apply f (SL { base, start, stop } )
	=
	{   fun apply i
                =
		if (i >= stop)  ();
		else            f (unsafe_get (base, i)); apply (i +++ 1);
                fi;

	    apply start;
	};

    fun modifyi f (SL { base, start, stop } )
	=
	{   fun mdf i
                =
		if (i >= stop ) ();
		else unsafe_set (base, i, f (i --- start, unsafe_get (base, i))); mdf (i +++ 1);
                fi;

	    mdf start;
	};

    fun modify f (SL { base, start, stop } ) = {
	fun mdf i =
	    if (i >= stop ) ();
	    else unsafe_set (base, i, f (unsafe_get (base, i))); mdf (i +++ 1); fi;
    
	mdf start;
    };

    fun keyed_fold_left f init (SL { base, start, stop } ) = {
	fun fold (i, a) =
	    if (i >= stop ) a;
	    else fold (i +++ 1, f (i --- start, unsafe_get (base, i), a));fi;
    
	fold (start, init);
    };

    fun fold_left f init (SL { base, start, stop } ) = {
	fun fold (i, a) =
	    if (i >= stop ) a;
	    else fold (i +++ 1, f (unsafe_get (base, i), a));fi;
    
	fold (start, init);
    };

    fun keyed_fold_right f init (SL { base, start, stop } ) = {
	fun fold (i, a) =
	    if (i < start ) a;
	    else fold (i --- 1, f (i --- start, unsafe_get (base, i), a));fi;
    
	fold (stop --- 1, init);
    };

    fun fold_right f init (SL { base, start, stop } ) = {
	fun fold (i, a) =
	    if (i < start ) a; else fold (i --- 1, f (unsafe_get (base, i), a));fi;
    
	fold (stop --- 1, init);
    };

    fun findi p (SL { base, start, stop } ) = {
	fun fnd i =
	    if (i >= stop ) NULL;
	    else { x = unsafe_get (base, i);
		 
		     if (p (i, x) ) THE (i --- start, x); else fnd (i +++ 1);fi;
		 };fi;
    
	fnd start;
    };

    fun find p (SL { base, start, stop } ) = {
	fun fnd i =
	    if (i >= stop ) NULL;
	    else { x = unsafe_get (base, i);
		 
		     if (p x ) THE x; else fnd (i +++ 1);fi;
		 };fi;
    
	fnd start;
    };

    fun exists p (SL { base, start, stop } ) = {
	fun ex i =
	    i < stop and (p (unsafe_get (base, i)) or ex (i +++ 1));
    
	ex start;
    };

    fun all p (SL { base, start, stop } ) = {
	fun al i =
	    i >= stop or (p (unsafe_get (base, i)) and al (i +++ 1));
    
	al start;
    };

    fun collate c (SL { base => b1, start => s1, stop => e1 },
		   SL { base => b2, start => s2, stop => e2 } ) = {
	fun col (i1, i2)
            =
	    if (i1 >= e1 )
		if (i2 >= e2)  EQUAL;
		else           LESS;
                fi;
	    elif   (i2 >= e2)  GREATER;
	    else
                 case (c (unsafe_get (b1, i1), unsafe_get (b2, i2)))
		      EQUAL => col (i1 +++ 1, i2 +++ 2);
		    unequal => unequal;
                 esac;
            fi;
    
	col (s1, s2);
    };
};



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright (c) 2003 by The Fellowship of SML/NJ
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
