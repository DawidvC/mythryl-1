# nowhere.pkg

# Compiled by:
#     src/lib/compiler/lower/tools/nowhere/nowhere.make6



###                     "Always try the problem that matters most to you."
###
###                                                   -- Andrew Wiles



package no_where {

    stipulate

	i2s = int::to_string;

	basis =  "enum List X = NIL | ! of X * List( X ) "
              +  "enum Null_Or X = NULL | THE of X "
              +  "enum order = LESS | EQUAL | GREATER ";

	version = "1.2.2";

	fun warning_fn file
	    =
	    "# WARNING: this is generated by running 'nowhere " + file + "'.\n" +
	    "# Do not edit this file directly.\n" +
	    "# Version " + version + "\n" + 
	    "\n";

	package raw_syntax= mdlast;			# mdlast	is from   src/lib/compiler/lower/tools/fake-sml-ast/ast.pkg

	package raw_syntax_stuff         = mdl_abstract_syntax_utilities(   mdlast );
	package raw_syntax_tree_pp       = mdl_raw_syntax_prettyprinter_g(  raw_syntax_stuff ); 
	package raw_syntax_tree_rewriter = mdl_raw_syntax_rewriter_g(       mdlast );

	package mg
	    =
	    match_gen_g(				# match_gen_g	is from   src/lib/compiler/lower/tools/match-compiler/match-gen-g.pkg

		package raw_syntax_tree_pp       =  raw_syntax_tree_pp;
		package raw_syntax_stuff         =  raw_syntax_stuff;
		package raw_syntax_tree_rewriter =  raw_syntax_tree_rewriter;
	    );

	package lit_map = mg::lit_map;

	package parser
	    =
	    mdl_parser_driver_g (
		package raw_syntax_tree_pp = raw_syntax_tree_pp;
		mdl_mode = FALSE;
		extra_cells = [];
	    );

	package mc =  mg::mc;
	package pp =  lowcode_prettyprinter;		# lowcode_prettyprinter		is from   src/lib/compiler/lower/tools/prettyprint/lowcode-prettyprinter.pkg

	include raw_syntax;
        include mdlerror;
        include raw_syntax_stuff;

	no =  raw_syntax_tree_rewriter::no_rewrite;
	rw =  raw_syntax_tree_rewriter::rewrite;

	my +++ = pp::(+++);

	infix val +++;

    herein

	fun gen filename
	    =
	    {   # Parse file:
		#
		program = parser::load filename;

		my ()      = mg::init();

		# By default, we take after ML:
		#
		fun failure ()
		    =
		    RAISE_EXPRESSION (id "MATCH");

		literals = REF mg::lit_map::empty;


		fun trans [ LOCALDECL (defs, body) ]
			=>
			{   basis = parser::parse_string basis;
			    dts   = mg::compile_types (basis @ defs);

			    #  Translate a case statement 
			    fun compile_case (root, clauses) = 
			    { dfa = mg::compile dts clauses;
				mg::report { warning, error,
						    log, dfa, rules=>clauses };
				#  print (mg::mc::to_string dfa) 
			      mg::code_gen { root, dfa, fail=>failure, 
					   literals };
			    } except mc::MATCH_COMPILER msg => 
				  { error msg; CASE_EXPRESSION (root, clauses);}; end ; #  just continue 

			    fun expression _ (e as CASE_EXPRESSION (r, cs))
				    => #  Case expr 
				    if (mg::is_complex cs ) compile_case (r, cs); else e;fi;
				expression _ e => e;
			    end;

			    fun fbind (fb as FUNBIND (f, cs as c ! _))
				    => 
				    if (mg::is_complex cs)
				         #  expand function 
					 my CLAUSE (args, _, _) = c;
					 arity = length args;
					 vars  = list::tabulate (arity, fn i => "p_" + i2s i; end );
					 root  = TUPLEEXP (map id vars);
					 cs'   = map (fn CLAUSE (ps, g, e) =>
							     CLAUSE ( [ TUPLEPAT ps ], g, e); end ) cs;
					 body  = compile_case (root, cs');
					 FUNBIND (f, [CLAUSE (map IDPAT vars, NULL, body)]);
				    else
					 fb;
				    fi; 

				fbind fb => fb;
			    end;

			    fun decl _ (FUNDECL (fbs)) => FUNDECL (map fbind fbs); 
				decl _ d  => d;
			    end;

			    program
				= 
				.decl (rw { expression, type=>no, pattern=>no, decl, sexp=>no } )
				    (SEQDECL body);

			    fun lit _ (VALDECL [ NAMED_VARIABLE (WILDCARD_PATTERN,
						       LITEXP (STRING_LIT "literals"))])
				    =>
				    VALDECL
					(lit_map::keyed_fold_right
					    (fn (l, v, d)
						=
						NAMED_VARIABLE (IDPAT v, LITEXP l) ! d
					    )
					    []
					    (*literals)
					)
					before
					    literals := lit_map::empty;

				lit _ d =>   d;
			    end; 

			    program = .decl (rw { expression=>no, type=>no, pattern=>no, decl=>lit, sexp=>no } ) program;

			    if   (lit_map::vals_count *literals > 0)
			        
				 fail "missing declaration my _ = \"literals\"";  
			    fi;

			    program;
			};
		      trans [ SEQDECL d ] => trans d;
		      trans [ MARKDECL (_, d)] => trans [d];
		      trans _ => fail "program must be wrapped with local";
		end;

		program = trans program;
		text    = pp::text (pp::setmode "code" +++ 
				      pp::text_width 160 +++ 
				      raw_syntax_tree_pp::decl program);
	      warning_fn filename + text; 
	    }; 

	fun main x
	    =
	    if (gen_file::gen { program=>"nowhere", file_suffix=>"sml", trans=>gen } x == 0  )
		 winix::process::success;
	    else
		 winix::process::failure;
	    fi;

    end;

};


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
