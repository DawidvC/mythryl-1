# match-compiler-g.pkg
# A pattern matching compiler. 
# This is based on Pettersson's 13p 1992 paper
# ``A Term Pattern-Match Compiler Inspired by Finite Automata Theory''
# ftp://ftp.ida.liu.se/pub/labs/pelab/papers/cc92pmc.ps.gz

# Compiled by:
#     src/lib/compiler/lower/tools/Match-Compiler.make6

###               "Concern should drive us into action
###                and not into depression. No man is
###                free who cannot control himself."
###
###                                    -- Pythagoras 



stipulate

    sanity_check = TRUE;
    debug        = FALSE;

herein

    # 2008-01-29 CrT:  So far as I can tell, this generic is invoked only by
    #
    #                      src/lib/compiler/lower/tools/match-compiler/match-gen-g.pkg
    #
    #                  which in turn appears not to be used in the compiler mainline.
    #                  Compiler mainline pattern-match compilation is handled by
    #
    #                       src/lib/compiler/upper/translate/compile-pattern.pkg 
    #

    #
    generic package match_compiler_g (

	package variable:   #  A variable 
	    api {  Var; 
		 compare:  (Var, Var) -> Order; 
		 to_string:  Var -> String;
	    };

	package con:  #  enum constructors 
	    api {
		Con;
		compare:      (Con, Con) -> Order;
		to_string:     Con -> String;
		variants:     Con -> { known: List( Con ), others: Bool };
		arity:        Con -> Int;
	    };  

	package literal:  #  literals 
	    api {
		Literal;
		compare:   (Literal, Literal) -> Order;
		to_string:  Literal -> String;
		variants:  Literal -> Null_Or { known: List( Literal ), others: Bool };
	    };

	package action:    
	    api {  Action;	#  An action 
		 to_string:  Action -> String;
		 free_vars:  Action -> List( variable::Var );
	    };

	package guard:   #  A guard expression 
	    api {  Guard;
		 to_string:    Guard -> String;
		 compare:     (Guard, Guard) -> Order;
		 logical_and:  (Guard, Guard) -> Guard;
	    };

	package expression:
	    api {  Expression;
		 to_string:  Expression -> String;
	    };
    )

    : (weak) Match_Compiler		# Match_Compiler	is from   src/lib/compiler/lower/tools/match-compiler/match-compiler.api

    {
	package pp =  lowcode_prettyprinter;

	i2s = int::to_string;

	fun listify (l, s, r) list
	    = 
	    l + list::fold_right
		    (   fn (x, "") => x;
			   (x,  y) => x + s + y;
			end
		    )
		    ""
		    list + r;

	#  paired_lists::all has the wrong semantics! 
	fun forall f ([],     []    ) =>  TRUE;
	    forall f (x ! xs, y ! ys) =>  f (x, y) and forall f (xs, ys);
	    forall f _                =>  FALSE;
	end;

	Index = INT  Int
	      | LABEL  variable::Var;

	Path  = PATH  List( Index );

	package index {

	   fun compare (INT i,   INT   j) =>  int::compare (i, j);
	       compare (LABEL i, LABEL j) =>  variable::compare (i, j);
	       compare (INT _,   LABEL _) =>  LESS;
	       compare (LABEL _, INT   _) =>  GREATER;
	   end;

	   fun equal (x, y)
	       =
	       compare (x, y) == EQUAL;

	   fun to_string (INT i) => i2s i;
	       to_string (LABEL l) => variable::to_string l;
	   end;
	};

	package path {

	   fun compare (PATH p1, PATH p2)
	       =
	       loop (p1, p2)
	       where
		   fun loop ([], []) => EQUAL;
		       loop([], _)  => LESS;
		       loop(_, [])  => GREATER;

		       loop (x ! xs, y ! ys)
			   =>
			   case (index::compare (x, y))

				EQUAL =>  loop (xs, ys);
				ord   =>  ord;
			   esac;

		   end;
	       end;


	   fun equal (p1, p2)
	       =
	       compare (p1, p2) == EQUAL;


	   fun append (PATH p1, PATH p2)
	       =
	       PATH (p1@p2);


	   fun dot (PATH p, i)
	       =
	       PATH (p @ [i]);


	   fun to_string (PATH p)
	       =
	       "["
	       +
	       list::fold_right
		   (fn (i, "") =>  index::to_string i;
		       (i, s ) =>  index::to_string i  +  "."  +  s;
		    end
		   )
		   ""
		   p
	       +
	       "]";


	   fun to_ident (PATH p)
	       = 
	       "v_"
	       +
	       list::fold_right
		   (fn (i, "") =>  index::to_string i;
		       (i,  s) =>  index::to_string i + "_" + s;
		    end
		   )
		   ""
		   p;


	    package map
		=
		red_black_map_g (						# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg
		    Key = Path;
		    compare = compare;
		);
        };

	Name = VAR  variable::Var
	     | PVAR Path;

	package name {

	    fun to_string (VAR  v) =>  variable::to_string  v;
		to_string (PVAR p) =>      path::to_string  p;
	    end; 

	    fun compare (VAR x, VAR y) => variable::compare (x, y); 
		compare (PVAR x, PVAR y) => path::compare (x, y); 
		compare (VAR  _, PVAR _) => LESS;
		compare (PVAR  _, VAR _) => GREATER;
	    end;

	    fun equal (x, y)
		=
		compare (x, y) == EQUAL;

	    package set
		=
		red_black_set_g ( Key = Name; compare = compare;);

	    fun set_to_string s
		= 
		"{ "
		+
		list::fold_right
		    (fn (v, "") =>  to_string v;
			(v, s ) =>  to_string v + "." + s;
		     end)
		     ""
		     (set::vals_list s)
		+
		" }";
	};

	package var_set
	    =
	    red_black_set_g (
		Key =  variable::Var;
		compare =  variable::compare;
	    );

	package subst
	    =
	    red_black_map_g (						# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg
		Key = variable::Var;
		compare = variable::compare;
	    );

					    # red_black_map_g	def in    src/lib/src/red-black-map-g.pkg

	Subst = subst::Map( Name );

	fun merge_subst (s1, s2)
	    =
	    subst::keyed_fold_right
		(fn (k, v, s) =  subst::set (s, k, v))
		s1
		s2;

	# Internal rep of pattern after
        # every variable has been renamed:
        #
	Pattern
	    = WILDCARD_PATTERN                                  #  wild card 
	    | APPLY_PATTERN  (Decon, List( Pattern ))           #  Constructor 
	    | TUPLEPAT  List( Pattern  )                        #  tupling 
	    | RECORD_PATTERN  List ((variable::Var, Pattern))   #  record 
	    | OR_PATTERN  List ((Subst, Pattern))               #  Disjunction 
	    | ANDPAT  List ((Subst, Pattern))                   #  conjunction
	    | NOTPAT  (Subst, Pattern)                          #  negation 
	    | WHEREPAT  (Pattern, Subst, guard::Guard)          #  guard 
	    | NESTEDPAT  (Pattern, Subst, Path, ((Int, expression::Expression)), Pattern)
	    | CONTPAT  (variable::Var, Pattern) 

	also
	Decon = CON  con::Con          
	      | LIT  literal::Literal
              ;   

	exception MATCH_COMPILER  String;

	fun error msg =  raise exception MATCH_COMPILER msg; 
	fun bug   msg =  error ("bug: " + msg);

	package con     = con;
	package action  = action;
	package literal = literal;
	package guard   = guard;

	package expression   = expression;
	package variable     = variable;

	package decon {

	   fun kind (CON _) => 0;
	       kind (LIT _) => 1;
	   end;

	   fun compare (CON x, CON y) =>  con::compare      (x, y);
	       compare (LIT x, LIT y) =>  literal::compare  (x, y);
	       compare (    x,     y) =>  int::compare (kind x, kind y);
	   end;

	   fun to_string (CON c) =>      con::to_string  c;
	       to_string (LIT l) =>  literal::to_string  l;
	   end;

	   fun equal (x, y)
	       =
	       compare (x, y) == EQUAL;

						    # red_black_map_g		is from   src/lib/src/red-black-map-g.pkg

	   package map =  red_black_map_g ( Key = Decon; compare = compare;);
	   package set =  red_black_set_g ( Key = Decon; compare = compare;);

	}; 

	package pattern {

	   fun sort_by_label l
	       =
	       list_mergesort::sort 
		   (fn ((x, _), (y, _)) =  variable::compare (x, y) == GREATER)
		   l;

	   fun to_string (WILDCARD_PATTERN) => "_";
	       to_string (APPLY_PATTERN (c,[])) => decon::to_string c;

	       to_string (APPLY_PATTERN (c, xs))
                   =>
                   decon::to_string c + listify("(", ", ", ")")  (map to_string xs);

	       to_string (TUPLEPAT patterns)
                   =>
                   listify("(", ", ", ")") (map to_string patterns);

	       to_string (RECORD_PATTERN lps)
                   =>
                   listify
                       ("{ ", ", ", " }") 
		       (map (fn (l, p) =  variable::to_string l + "=" + to_string p)
                            lps
                       );

	       to_string (OR_PATTERN ps) => listify("(", " | ", ")") (map to_string' ps);
	       to_string (ANDPAT ps) => listify("(", " and ", ")") (map to_string' ps);
	       to_string (NOTPAT p)  => "not " + to_string' p;
	       to_string (WHEREPAT (p, _, g)) => to_string p + " where " + guard::to_string g;

	       to_string (NESTEDPAT (p, _, _, (_, e), p'))
                   =>
		   to_string p + " where " + expression::to_string e + " in " + to_string p'; 

	       to_string (CONTPAT (v, p)) => to_string p  + " exception " +  variable::to_string v;
	   end 

	   also
	   fun to_string'(subst, p)
	       =
	       to_string p;

	};

	Rule_No = Int;

	Dfa = DFA { stamp:      Int,                 	# Unique dfa stamp 
		    free_vars:  Ref( name::set::Set ),	# Free variables 
		    ref_count:  Ref( Int ),          	# Reference count 
		    generated:  Ref( Bool ),         	# Has code been generated? 
		    height:     Ref( Int ),          	# Dag height 
		    test:       Test                 	# Type of tests 
		  }

	also
	Test
	    = CASE    (Path, List ((Decon, List( Path ), Dfa)), 
			Null_Or( Dfa ))		       #  multiway 
	    | WHERE   (guard::Guard, Dfa, Dfa)            #  if test 
	    | OK      (Rule_No, action::Action)            #  final dfa 
	    | BIND    (Subst, Dfa)                        #  Apply subst 
	    | LET     (Path, ((Int, expression::Expression)), Dfa)       #  let 
	    | SELECT  (Path, List ((Path, Index)), Dfa)   #  projections 
	    | CONT    (variable::Var, Dfa)                #  Bind fate 
	    | FAIL                                         #  error dfa 

	also
	Compiled_Dfa
	    = 
	    ROOT  { dfa:         Dfa, 
		    used:        name::set::Set,
		    exhaustive:  Bool,
		    redundant:   int_list_set::Set
		   }

	also
	Matrix
	    = 
	    MATRIX 
	    { rows:   List( Row ),
	      paths:  List( Path )                       #  path (per column) 
	    }


	withtype Row =  
		   { patterns:  List( Pattern ), 
		    guard:     Null_Or( (Subst, guard::Guard) ),
		    nested:     List( (Subst, Path, ((Int, expression::Expression)), Pattern)),
		    dfa:       Dfa
		   } 
	    also Compiled_Rule = 
		  (Rule_No, List( Pattern ), Null_Or( guard::Guard ), Subst, action::Action)

	    also Compiled_Pat = (Pattern, Subst);

	#  Utilities for dfas 
	#
	package dfa {

	   itow = unt::from_int; 

	   fun h (DFA { stamp, ... } )
	       =
	       itow stamp;

	   fun hash (DFA { stamp, test, ... } )
	       = 
	       case test

		    FAIL    => 0u0;
		    OK _    => 0u123 + itow stamp;

		    CASE (path, cases, default)
                        =>
                        0u1234
                        +
			fold_right
			      (fn ((_, _, x), y) =  h x + y) 
			      case default    THE x => h x;  NULL => 0u0; esac
			      cases;

		    SELECT(_, _, dfa) => 0u2313 + hash dfa;
		    CONT(_, dfa) => 0u1234 + hash dfa;
		    WHERE (g, yes, no) => 0u2343 + h yes + h no;
		    BIND(_, dfa) => 0u23234 + h dfa;
		    LET(_, (i, _), dfa) => itow i + h dfa + 0u843;
	      esac;

	   # Pointer equality:
	   #
	   fun eq (DFA { stamp=>s1, ... }, DFA { stamp=>s2, ... } )
	       =
	       s1 == s2;

	   fun eq_opt (NULL, NULL) => TRUE;
	       eq_opt (THE x, THE y) => eq (x, y);
	       eq_opt _ => FALSE;
           end;

	   # One-level equality:
	   #
	   fun equal ( DFA { test=>t1, stamp=>s1, ... },
		       DFA { test=>t2, stamp=>s2, ... }
		     )
	       =
	       case (t1, t2)

		   (FAIL, FAIL) => TRUE;

		   (OK _, OK _) => s1 == s2;

		   (SELECT (p1, b1, x), SELECT (p2, b2, y))
		       => 
		       path::equal (p1, p2)
		       and
		       eq (x, y)
		       and
		       forall
			   (fn ((px, ix), (py, iy)) =  path::equal (px, py) and index::equal (ix, iy))
			   (b1, b2);

		   (CONT (k1, x), CONT (k2, y))
		       => 
		       variable::compare (k1, k2) == EQUAL and eq (x, y);

		   (CASE (p1, c1, o1), CASE (p2, c2, o2))
		       =>
			path::equal (p1, p2)
                        and 
			forall
			   (fn ((u, _, x), (v, _, y))
                               = 
			       decon::equal (u, v) and eq (x, y)
                           ) 
			   (c1, c2)
                        and
                        eq_opt (o1, o2);

		   ( WHERE (g1, y1, n1), 
		     WHERE (g2, y2, n2)
		   )
		       =>
		       guard::compare (g1, g2) == EQUAL 
		       and eq (y1, y2) and eq (n1, n2); 

		   ( BIND (s1, x),
		     BIND (s2, y)
		   )
		       =>
		       eq (x, y)
                       and
		       forall
                           (fn ((p, x), (q, y))
                                =
				variable::compare (p, q) == EQUAL
                                and 
				name::equal (x, y)
                           )
			   ( subst::keyvals_list s1,
                             subst::keyvals_list s2
                           );

		   (LET (p1, (i1, _), x), LET (p2, (i2, _), y))
		       =>
		       path::equal (p1, p2) and i1==i2 and eq (x, y);

		  _ => FALSE;
	      esac;

									# monomorphic_hash_table_g	is from   src/lib/src/monomorphic-hash-table-g.pkg
	   package hash_table
	       = 
	       monomorphic_hash_table_g (
		   Hash_Key = Dfa;
		   same_key = equal;
		   hash_value = hash;
	       );

	   fun to_string (ROOT { dfa, ... } )
	       =
	       {   exception NOT_VISITED;

		   visited
		       =
		       int_hash_table::make_table (32, NOT_VISITED);

		   fun mark stamp
		       =
		       int_hash_table::set visited (stamp, TRUE);

		   fun is_visited stamp
		       = 
		       null_or::the_else (int_hash_table::find visited stamp, FALSE);

		   include pp;

		   infix val +++ ;

		   fun pr_args []
			   =>
			   nop;

		       pr_args ps
			   =>
			   seq
			       (!!"(",!!", ",!!")")
			       (map ((!_) o path::to_string) ps);
		   end;

		   fun walk (DFA { stamp, test=>FAIL, ... } )
			   =>
			   !"fail";

		       walk (DFA { stamp, test, ref_count=>REF n, ... } ) =>

		       if   (is_visited stamp)

			    !"goto" +++ int stamp; 
		       else
			    mark stamp;

			     !!"<" +++ int stamp +++ !!">" +++
			     if (n > 1 ) !! "*"; else nop; fi +++

			     case test

				  OK(_, a) => !"Ok" +++ !(action::to_string a);

				  FAIL => !"FAIL";

				  SELECT (root, namings, body)
				      => 
				      line(!"Stipulate") +++
				      block (seq (nop, nl, nop) 
					      (map (fn (p, i)
                                                       =
					               tab +++
					               !(path::to_string p) +++ !"=" +++ 
					               !(path::to_string root) +++ !"." +++ 
						       !(index::to_string i)
						   )
                                                   namings
                                              ) 
					   ) +++
				      line(!"in") +++
				      block (walk body);

				  CONT (k, x)
				      =>
				      line(!"Cont" +++ !(variable::to_string k) +++ walk x);

				  CASE (p, cases, default)
				      =>
				      line(!"Case" +++ !!(path::to_string p)) +++
				       block(
					  seq (nop, nl, nop) 
					   ((map (fn (decon, args, dfa) =>
					     tab +++ !(decon::to_string decon) +++ pr_args args
						 +++ !"=>" +++ sp +++ walk dfa; end )
					       cases)

					     @

					     case default

						  NULL    =>  [];
						  THE dfa =>  [!"_" +++ !"=>" +++ sp +++ walk dfa];
					     esac
					  )
				       );

				  WHERE (g, y, n)
				      =>
				      line(!"If" +++ !(guard::to_string g)) +++
				      block (tab +++ !"then" +++ walk y +++ nl +++
					    tab +++ !"else" +++ walk n);

				  BIND (subst, x)
				      =>
				      line (subst::keyed_fold_right
                                               (fn (v, n, prettyprint)
                                                   =
					           tab +++ !(variable::to_string v) +++ !!"<-" +++
						   !(name::to_string n) +++ prettyprint
                                               )
					       nop
                                               subst
                                           ) +++
					   walk x;

				  LET (path, ( _, e), x)
				      =>
				      line(!"Stipulate" +++ !(path::to_string path) +++ !"=" +++ 
					   !(expression::to_string e)) +++
				      block (walk x);
			  esac; 
		    fi;
		 end;				# fun walk

		 pp::text (walk dfa +++ nl);
	       };
	};

	#  Utilities for the pattern matrix 
	#
	package matrix {

	    fun row (MATRIX { rows, ... }, i)
		=
		list::nth (rows, i);

	    fun col (MATRIX { rows, ... }, i)
		= 
		list::map
		    (fn { patterns, ... } =  list::nth (patterns, i))
		    rows;

	    fun path_of (MATRIX { paths, ... }, i)
		=
		list::nth (paths, i);

	    fun column_count  m
		=
		list::length (.patterns (row (m, 0)));

	    fun is_empty (MATRIX { rows => [], ... } )
		    =>
		    TRUE;

		is_empty _
		    =>
		    FALSE;
	    end;

	    fun remove_first_row (MATRIX { rows=>_ ! rows, paths } )
		    => 
		    MATRIX { rows, paths };

		remove_first_row _
		    =>
		    error "removeFirstRow";
	    end;

	    fun check (MATRIX { rows, paths, ... } )
		=
		{   arity = length paths;

		    apply
			(fn { patterns, ... }
			    =
			    if   (length patterns  !=  arity   )   bug "bad matrix";   fi)
			rows;
		};

	    fun to_string (MATRIX { rows, paths, ... } )
		=
		listify
		    ("", "\n", "\n")
		    (map
			(fn { patterns, ... }
			    =
			    listify
				("[", "\t", "]")
				(map pattern::to_string patterns))
			rows
		    );


	    # Given a matrix, find the best column for matching.
	    #
	    # I'm using the heuristic that John (Reppy) uses:
	    # the first column i where pat_i0 is not a wild card, and
	    # with the maximum number of distinct constructors in the
	    # the column. 
	    #
	    # If the first row is all wild card, then return NULL.

	    fun find_best_match_column (m as MATRIX { rows, ... } )
		= 
		{   if  sanity_check    check m;  fi;

		    if  debug      print (to_string m);  fi;

		    n_col =  column_count m;

		    fun score i		# Score of doing pattern matching on column i 
			=
			{   patterns_i  =  col (m, i);
			    patterns_i0 =  head patterns_i; 

			    case patterns_i0

				 WILDCARD_PATTERN
				     =>
				     0;

				 _   =>
				     {   my (cons, score)
					     =
					     # Count distinct constructors; skip refutable cards. 
					     # Give records, tuples and or patterns, high scores
					     # so that they are immediately expanded

					     list::fold_right
						 fn (WILDCARD_PATTERN, (sss, n))
							 =>
							 (sss, n);

						     (APPLY_PATTERN (c, _), (sss, n))
							 => 
							 (decon::set::add (sss, c), n);

						     (_, (sss, n))
							 =>
							 (sss, 10000);
						 end
						 (decon::set::empty, 0)
						 patterns_i;

					 score + decon::set::vals_count cons;
				     };
			    esac;
			};

		    #  Find column with the highest score 
		    fun find_best (i, best_so_far)
			=
			if   (i >= n_col)
			     best_so_far;
			else 
			     score_i = score i;

			     best
				 =
				 if case best_so_far
					 NULL                =>  TRUE;
					 THE (_, best_score) =>  score_i > best_score;
				    esac

				      THE (i, score_i);
				 else
				      best_so_far;
				 fi;

			     find_best (i+1, best);
			fi;

		    case (find_best (0, NULL))

			 THE (i, 0) =>  NULL;   #  A score of zero means all wildcards 
			 THE (i, _) =>  THE i;
			 NULL       =>  NULL;
		    esac; 
		};					# fun find_best_match_column
	};		# package matrix 

	to_string =  dfa::to_string;


	# Rename user pattern into internal pattern.
	# The path business is hidden from the client.
	#
	fun rename do_it { number=>rule_no, patterns, guard, action, fate }
	    =
	    {   empty =  subst::empty;

		fun bind (subst, v, p)
		    =
		    case (subst::get (subst, v))

			 NULL  =>  subst::set (subst, v, PVAR p);
			 THE _ =>  error("duplicated pattern variable " + variable::to_string v);
		    esac;

		fun process (path, subst: Subst, pattern) : Compiled_Pat
		    = 
		    {   fun id_pattern id
			    =
			    (WILDCARD_PATTERN, bind (subst, id, path));

			fun as_pattern (id, p)
			    = 
			    {   my (p, subst)
				    =
				    process (path, subst, p);

				(p, bind (subst, id, path));
			    };

			fun wild_pattern ()
			    =
			    (WILDCARD_PATTERN, subst);

			fun lit_pattern  lit
			    =
			    (APPLY_PATTERN (LIT lit, []), subst);

			fun process_patterns  patterns
			    = 
			    {   fun loop ([], _, ps', subst)
					=>
					(reverse ps', subst);

				    loop (p ! ps, i, ps', subst)
					=> 
					{   path' =  path::dot (path, INT i);

					    my (p, subst)
						=
						process (path', subst, p);

					    loop (ps, i+1, p ! ps', subst);
					};
				end;

				loop (patterns, 0, [], subst);
			    };

			fun process_lpatterns (lpatterns)
			    = 
			    {   fun loop ([], ps', subst)
					=>
					(reverse ps', subst);

				    loop((l, p) ! ps, ps', subst)
					=> 
					{   path' =  path::dot (path, LABEL l);

					    my (p, subst)
						=
						process (path', subst, p);

					    loop (ps, (l, p) ! ps', subst);
					};
				end;

				loop (lpatterns, [], subst);
			    };

			fun cons_pattern (c, args) : Compiled_Pat
			    = 
			    {   my (patterns, subst)
				    =
				    process_patterns (args);

				# Arity check 
				if   (con::arity c != length args )

				     error ("arity mismatch " + con::to_string c);
				fi;

				(APPLY_PATTERN (CON c, patterns), subst); 
			    };

			fun tuple_pattern (patterns) : Compiled_Pat
			    = 
			    {   my (patterns, subst) = process_patterns (patterns);
				(TUPLEPAT patterns, subst);
			    };

			fun record_pattern (lpatterns) : Compiled_Pat
			    = 
			    {   my (lpatterns, subst) = process_lpatterns (lpatterns);
				(RECORD_PATTERN lpatterns, subst);
			    };

			fun no_dupl (subst, subst')
			    =
			    {   duplicated
				    =
				    var_set::vals_list ( 
					var_set::intersection (
					    var_set::add_list (var_set::empty, subst::keys_list subst'),
					    var_set::add_list (var_set::empty, subst::keys_list subst )
					)
				    );

				case duplicated

				     [] =>  ();
				     _  =>  error("duplicated pattern variables: " +
					     listify("", ", ", "") (map variable::to_string duplicated));
				esac;
			    };

			# Or patterns are tricky because the same variable name
			# may be bound to different components.  We handle this by renaming
			# all variables to some canonical set of paths, 
			# then rename all variables to these paths. 
			#
			fun logical_pattern (name, name2, f)  []
				=>
				error("empty " + name + " pattern");

			    logical_pattern (name, name2, f)  patterns
				=> 
				{   results   =  map (fn p => process (path, empty, p); end ) patterns;
				    ps        =  map #1 results;
				    or_substs =  map #2 results;

				    fun same_vars ([], s')
					    =>
					    TRUE;

					same_vars (s ! ss, s')
					    => 
					    forall
						(fn (x, y) =  variable::compare (x, y) == EQUAL) 
						(subst::keys_list s, s')
					    and
					    same_vars (ss, s');
				    end;

				    # Make sure all patterns use
                                    # the same set of variable names:

				    or_names = subst::keys_list (head or_substs);

				    if (not (same_vars (tail or_substs, or_names)))

					error("not all " + name2 + " have the same variable namings");
                                    fi;

				    no_dupl (subst, head or_substs);

				    # Build the new substitution to
                                    # include all names in the or   
				    # patterns.

				    subst = subst::keyed_fold_right  
						 (fn (v, _, subst) =  subst::set (subst, v, VAR v))
						 subst
						 (head or_substs); 

				  (f (paired_lists::zip (or_substs, ps)), subst);
				};
			end;

			fun or_pattern  patterns = logical_pattern ("or", "disjuncts", OR_PATTERN) patterns;
			fun and_pattern patterns = logical_pattern ("and", "conjuncts", ANDPAT) patterns;

			fun not_pattern pattern
			    = 
			    {   my (pattern, subst')  = process (path, empty, pattern);
				no_dupl (subst, subst');
			        (NOTPAT (subst', pattern), subst);
			    };

			fun where_pattern (pattern, e)
			    =
			    {   my (pattern, subst') = process (path, empty, pattern);
				no_dupl (subst, subst');
			        (WHEREPAT (pattern, subst', e), subst);
			    };

			fun nested_pattern (pattern1, e, pattern2)
			    =
			    {   path' = path::dot (path, INT -1);

				my (pattern1, subst1) = process (path, subst, pattern1);
				my (pattern2, subst2) = process (path', subst1, pattern2);

			        (NESTEDPAT (pattern1, subst1, path', e, pattern2), subst2);
			    }; 

		      do_it { id_pattern,
			      as_pattern,
			      wild_pattern,
			      cons_pattern,
			      tuple_pattern,
			      record_pattern,
			      lit_pattern,
			      or_pattern,
			      and_pattern,
			      not_pattern,
			      where_pattern,
			      nested_pattern
			     } pattern;
		    };	    			# fun process


		fun process_all_patterns (i, [], subst, ps')
			=>
			(reverse ps', subst);

		    process_all_patterns (i, p ! ps, subst, ps')
			=>
			{   my (p, subst) = process (PATH [INT i], subst, p);
			    process_all_patterns (i+1, ps, subst, p ! ps');
			};
		end;

		my (patterns, subst)
                    =
                    process_all_patterns (0, patterns, empty, []);  

	        (rule_no, patterns, guard, subst, action);
	    };

	package dfamap
	   = 
	   red_black_map_g (						# red_black_map_g		is from   src/lib/src/red-black-map-g.pkg
	       Key = Dfa; 
	       fun st (DFA { stamp, ... } ) = stamp;
	       fun compare (x, y) = int::compare (st x, st y);
	    );


	# Give the arguments to case,
	# factor out the common case
	# and make it  the default.
	#
	fun factor_case (p, cases, d as THE _)
		=>
		(p, cases, d);

	    factor_case (p, cases, NULL)
		=> 
		{   fun count (m, dfa)
			=
			the_else (dfamap::get (m, dfa), 0);

		    fun inc ((_, _, dfa), m)
			=
			dfamap::set (m, dfa, 1 + count (m, dfa));

		     m =  fold_right  inc  dfamap::empty  cases;

		     best
			 =
			 dfamap::keyed_fold_right 

			     fn (dfa, c, NULL)
				    =>
				    THE (dfa, c);

				(dfa, c, best as THE(_, c'))
				    =>
				    if (c > c')   THE (dfa, c);
				    else          best;
                                    fi;
			     end

			     NULL
			     m;  

		     fun neq (DFA { stamp=>x, ... }, DFA { stamp=>y, ... } )
			 =
			 x != y;

		     case best

			  NULL       =>  (p, cases, NULL); 
			  THE (_, 1) =>  (p, cases, NULL); 

			  THE (default_case, n)
			      => 
			      {   others
				      =
				      list::filter
					  (fn (_, _, x) =  neq (x, default_case))
					  cases;

				  (p, others, THE default_case); 
			      };
		     esac;
		};
	end;			# fun factor_case



	# The main pattern matching compiler.
	# The dfa states are constructed with hash consing at the same time
	# so no separate DFA minimization step is needed.

	fun compile { compiled_rules, compress }
	    =
	    {   exception NO_SUCH_STATE;

		Expand_Type
		    = SWITCH  (List ((Decon, List( Path ), Matrix)), Null_Or( Matrix ))
		    | PROJECT  (Path,  List ((Path, Index)), Matrix);

		fun simp x
		    =
		    if compress      factor_case x;
		    else             x;
                    fi;

		# Table for hash consing:
		#
		dfa_table
		    =
		    dfa::hash_table::make_table (32, NO_SUCH_STATE) :
				     dfa::hash_table::Hash_Table( Dfa );

		lookup_state
		    =
		    dfa::hash_table::get  dfa_table;

		insert_state
		    =
		    dfa::hash_table::set  dfa_table;

		stamp_counter =  REF 0;

		fun mk_state (test)
		    =   
		    {   stamp = *stamp_counter;
			stamp_counter := stamp + 1;

			DFA { stamp, free_vars=>REF name::set::empty, 
			      height=>REF 0, ref_count=>REF 0, generated=>REF FALSE, test
                            };
		    };

		fun new_state test
		    =
		    {   s = mk_state (test);

			lookup_state s
			except
			    NO_SUCH_STATE = {  insert_state (s, s);
					       s;
					    };
		    };


		# State constructors 

		fail =  new_state (FAIL);

		fun ok x
		    =
		    new_state (OK x);

		fun case'(_, [], THE x) =>   x;
		    case'(_, [], NULL)  =>   fail;

		    case' (p, cases as (_, _, c) ! cs, default)
			=> 
			if ( list::all
				 (fn (_, _, c') =  dfa::eq (c, c'))
				 cs

			     and

			     case default

				  THE x =>  dfa::eq (c, x);     
				  NULL  =>  TRUE;
			     esac
			)
			     c;
			else
			     new_state (CASE (simp (p, cases, default)));
			fi;
		end;

		fun select (x) =  new_state  (SELECT (x));
		fun cont   (x) =  new_state  (CONT   (x));

		fun where' (g, yes, no)
		    = 
		    if   (dfa::eq (yes, no))

			 yes;
		    else
			 new_state (WHERE (g, yes, no));
		    fi;

		fun bind (subst, x)
		    =
		    subst::vals_count subst == 0
                      ??  x
                      ::  new_state (BIND (subst, x));


		fun let' x
		    =
		    new_state (LET x);


		# Expand column i, 
		# Return a new list of matrixes indexed by the deconstructors.

		fun expand_column (m as MATRIX { rows, paths, ... }, i)
		    = 
		    {   ith_col =  matrix::col     (m, i);
			path_i  =  matrix::path_of (m, i);

			if debug
			     print ("Expanding column " +  i2s i  + "\n");
			fi;

			fun split_i ps
			    =
			    loop (0, ps, [])
			    where
				fun loop (j, p ! ps, ps')
					=>
					if (i == j)

					     (reverse ps', p, ps); 
					else
					     loop (j+1,  ps,  p ! ps');
					fi;

				    loop _
					=>
					bug "split_i";
				end;
			    end;

			# If the ith column cfind out what to expand 
			#
			fun expand ((p as OR_PATTERN _) ! ps, this) =>  THE p;
			    expand ((p as ANDPAT _) !     ps, this) =>  THE p;
			    expand ((p as NOTPAT _) !     ps, this) =>  THE p;
			    expand ((p as WHEREPAT _) !   ps, this) =>  THE p;
			    expand ((p as NESTEDPAT _) !  ps, this) =>  THE p;
			    expand ((p as CONTPAT _) !    ps, this) =>  THE p;

			    expand ((p as TUPLEPAT _) !       ps, this) =>  expand (ps, THE p);
			    expand ((p as RECORD_PATTERN _) ! ps, this) =>  expand (ps, THE p);
			    expand ((p as APPLY_PATTERN _) !  ps, this) =>  expand (ps, THE p);
			    expand (WILDCARD_PATTERN !        ps, this) =>  expand (ps, this);

			    expand([], this) =>  this;
			end;

			# Split the paths:
			# 
			my (prev_paths, _, next_paths)
                            =
                            split_i paths;

			case (expand (ith_col, NULL))

			     THE (NOTPAT _)  #  expand not patterns 
				 =>
				 expand (rows, [])
				 where

				     fun expand ([], _)
					     =>
					     bug "expand NOT"; 

					 expand ((row as { patterns, guard, nested, dfa } ) ! rows, rows')
					     => 
					     {   my (prev, pat_i, next)
						     =
						     split_i  patterns;

						 case pat_i

						      NOTPAT (subst, p)
							  =>
							  {   rows' = reverse rows';

							      yes   = { patterns => prev @ [WILDCARD_PATTERN] @ next,
									nested,
									guard,
									dfa
								      };

							      m2 = MATRIX { rows, paths };

							      no = { patterns =>  prev @ [p] @ next,
								     guard    =>  NULL, 
								     nested   =>  [],
								     dfa      =>  bind (subst, match m2)
								   };

							      m1 = MATRIX { rows  => rows' @ [no, yes] @ rows,
									    paths
									  };

							      expand_column (m1, i);
							  };

						      _ => expand (rows, row ! rows');
						 esac;
					     };
				     end;   			# fun expand
				 end;				# THE (NOTPAT _)

			     THE (OR_PATTERN _ | WHEREPAT _ | NESTEDPAT _)
				 => 
				 # If we have or/where patterns then expand all rows
				 # with these patterns

				 {   fun expand (row as { patterns, dfa, nested, guard } )
					 =
					 {   my (prev, pat_i, next)
						 =
						 split_i  patterns;

					     case pat_i

						  OR_PATTERN ps
						      =>
						      map
							  (fn (subst, p)
							      =
							      { patterns =>  prev @ [p] @ next,
								dfa      =>  bind (subst, dfa),
								nested,
								guard
							      }
							  )
							  ps;

						  WHEREPAT (p, subst', g)
						      =>
						      [   { patterns =>  prev @ [p] @ next,
							    dfa,
							    nested,
							    guard    =>  case guard

									      NULL
										  =>
										  THE (subst', g);

									      THE (subst, g')
										  => 
										  THE ( merge_subst (subst, subst'),
											guard::logical_and (g, g')
										      );
									 esac
							  }
						      ];

						  NESTEDPAT (pattern, subst, path, expression, pattern')
						      =>
						      [   { patterns =>  prev @ [pattern] @ next,
							    dfa,
							    nested     =>  (subst, path, expression, pattern') ! nested,
							    guard
							  }
						      ];

						  _ =>  [row];

					     esac;
					 };				# fun expand

				     new_matrix
					 =
					 MATRIX { rows  => list::cat (map expand rows),
						  paths
						};

				     expand_column (new_matrix, i);
				 };						# THE (OR_PATTERN _ | WHEREPAT _ | NESTEDPAT _)

			     THE (TUPLEPAT patterns) 	#  expand a tuple along all the columns 
				 =>
				 {   arity =  length patterns;

				     wilds =  map
						  (fn _ =  WILDCARD_PATTERN)
						  patterns;

				     fun process_row { patterns, nested, dfa, guard }
					 =
					 {   my (prev, pat_i, next)
						 =
						 split_i  patterns;

					     case pat_i

						  TUPLEPAT ps'
						      =>
						      {   n =  length ps';

							  if   (n != arity)

							       error ("tuple arity mismatch");
							  fi;

							  { patterns => prev @ ps' @ next,
							    nested,
							    dfa,
							    guard
							  };
						      };

						  WILDCARD_PATTERN
						      => 
						      { patterns=>prev @ wilds @ next,
							nested,
							dfa,
							guard
						      };

						  pattern
						      =>
						      error ("mixing tuple and: " + pattern::to_string pattern);
					     esac;
					 };

				     rows    =  map process_row rows;

				     path_i' =  list::tabulate (
						  arity,
						  fn i =  path::dot (path_i, INT i)
						);

				     paths   =  prev_paths @ path_i' @ next_paths;

				     namings =  list::tabulate (
						  arity,
						  fn i =  (path::dot (path_i, INT i), INT i)
						);

				     PROJECT (
					 path_i,
					 namings,
					 MATRIX { rows, paths }
				     );
				 };					# THE (TUPLEPAT patterns)


			     THE (RECORD_PATTERN _)    #  expand a tuple along all the columns 
				 =>
				 {   # All the labels that are in this column 
				     labels
					 = 
					 var_set::vals_list (
					     list::fold_right 
						 fn (RECORD_PATTERN lps, lll)
							=> 
							list::fold_right
							    (fn ((l, p), lll) =  var_set::add (lll, l))
							    lll
							    lps;
						    (_, lll)
							=>
							lll;
						 end
					     var_set::empty
					     ith_col
					 );

				     if debug
					  print("Labels=" + listify("", ", ", "") 
							 (map variable::to_string labels) + "\n");
				     fi;

				     fun lp2s (l, p)
					 =
					 variable::to_string l + "=" + pattern::to_string p;

				     fun lps2s lps
					 =
					 listify ("", "\t", "") (map lp2s lps);

				     fun ps2s ps
					 =
					 listify ("", "\t", "") (map pattern::to_string ps);

				     wilds
					 =
					 map
					     (fn _ =  WILDCARD_PATTERN)
					     labels;

				     fun process_row { patterns, nested, dfa, guard }
					 =
					 {   my (prev, pat_i, next)
						 =
						 split_i (patterns);

					     case pat_i

						  RECORD_PATTERN lps
						      =>
						      #  Put lps in canonical order 
						      {   lps = pattern::sort_by_label lps;

							  debug   ?:   print ("lpatterns=" + lps2s lps + "\n");

							  fun collect ([], [], ps')
								  =>
								  reverse ps';

							      collect (x ! xs, [], ps')
								  => 
								  collect (xs, [], WILDCARD_PATTERN ! ps');

							      collect (x ! xs, this as (l, p) ! lps, ps')
								  =>
								  case (variable::compare (x, l))

								       EQUAL   =>  collect (xs, lps, p ! ps');
								       LESS    =>  collect (xs, this, WILDCARD_PATTERN ! ps');
								       GREATER =>  error "labels out of order";
								  esac;

							      collect _
								  =>
								  bug "processRow";
							  end;

							  ps = collect (labels, lps, []);

							  debug   ?:   print("new patterns=" + ps2s ps + "\n");

							  { patterns =>  prev @ ps @ next,
							    nested,
							    dfa,
							    guard
							  };
						      };					# RECORD_PATTERN lps


						  WILDCARD_PATTERN
						      => 
						      { patterns =>  prev @ wilds @ next,
							nested,
							dfa,
							guard
						      };

						  pattern
						      =>
						      error ("mixing record and: " + pattern::to_string pattern);
					     esac;
					 };				# fun process_row 


				     rows  =  map  process_row  rows;

				     path_i'
					 =
					 map
					     (fn l =  path::dot (path_i, LABEL l))
					     labels;

				     paths =  prev_paths
					   @  path_i'
					   @  next_paths;

				     namings
					 =
					 map
					     (fn l =  (path::dot (path_i, LABEL l), LABEL l))
					     labels;

				     PROJECT (
					 path_i,
					 namings,
					 MATRIX { rows, paths }
				     );
				 };

			    THE (APPLY_PATTERN (decon, _))
				=> 
				# Find out how many variants
				# there are in this case:
				#
				{   fun get_variants ()
					= 
					decon::set::vals_list 
					  (list::fold_right 
					      fn (APPLY_PATTERN (x, _), sss) => decon::set::add (sss, x);
						  (_, sss)                    => sss;
					      end
					      decon::set::empty
					      ith_col
					  );

				    my (all_variants, has_default)
					=
					case decon

					     CON c
						 => 
						 {   my { known, others } = con::variants c;

						     ( case known
							    [] => get_variants(); 
							    _  => map CON known;
						       esac,

						       others
						     ); 
						 };

					     LIT l
						 => 
						 case (literal::variants l)

						      THE { known, others } => (map LIT known, others);
						      NULL => (get_variants(), TRUE);
						 esac;
					esac; 

				    # function from con -> matrix; initially no rows 
				    #
				    fun insert (table, key, x)
					=
					decon::map::set (table, key, x);

				    fun lookup (table, key)
					= 
					case (decon::map::get (table, key))

					     THE x => x;
					     NULL  => bug("can't find constructor " + decon::to_string key);
					esac;


				    empty = decon::map::empty;


				    fun create ([], table)
					    =>
					    table;

					create((con as CON c) ! cons, table)
					    =>
					    {   n     =  con::arity c;
						paths =  list::tabulate
						      (n, fn i = path::dot (path_i, INT i));
						create (cons, insert (table, con, { args => paths, rows => [] } ));
					    };

					create((con as LIT l) ! cons, table)
					    =>
					    create (cons, insert (table, con, { args => [], rows => [] } ));
				    end;


				    table =   create (all_variants, empty);


				    fun insert_row (table, decon, row)
					=
					{   my { args, rows } = lookup (table, decon);
					    insert (table, decon, { args, rows => rows @ [row] } );
					};


				    fun foreach_row ([], table)
					    =>
					    table;

					foreach_row( { patterns, dfa, nested, guard } ! rows, table)
					    =>
					    {   my (prev, pat_i, next) =   split_i patterns;

						fun add_row (table, decon, patterns)
						    = 
						    insert_row (table, decon, 
							   { patterns, nested,
							    dfa, guard } );

						fun add_wild_to_every_row (table)
						    =
						    fold_right
							(fn (c, table)
							    =
							    {   my { args, rows } = lookup (table, c);
								wilds = map (fn _ => WILDCARD_PATTERN; end ) args;
								patterns  = prev @ wilds @ next;
								add_row (table, c, patterns);
							    }
							)
							table
							all_variants;

						table
						   = 
						   case pat_i

						       WILDCARD_PATTERN
							   =>
							   add_wild_to_every_row table;

						       APPLY_PATTERN (decon, args)
							   =>
							   {   patterns = prev @ args @ next;
							       add_row (table, decon, patterns);
							   };

						       _ => error "expecting constructor but found tuple/record";
						   esac;

						foreach_row (rows, table);
					    };
				    end;

				    table =   foreach_row (rows, table);

				    fun collect_cases (decon, { args, rows }, rules)
					= 
					{   matrix = MATRIX { rows, paths=>prev_paths @ args @ next_paths };

					    (decon, args, matrix) ! rules;
					};

				    cases =   decon::map::keyed_fold_right collect_cases [] table;

				    # If we have a default then the default matrix
				    # contains the original matrix with rows whose
				    # column i is the wild card.
				    #
				    default
					=
					if has_default  

					    THE(
						MATRIX { rows=>list::filter 
								   (fn { patterns, ... }
								      =
								      case (list::nth (patterns, i))

									   WILDCARD_PATTERN =>  TRUE;
									   _                =>  FALSE;
								      esac
								   )
								   rows,
								   paths
						       }
					   );   
					else
					    NULL;
					fi;

				    SWITCH (decon::map::keyed_fold_right collect_cases [] table, default);
				};

			    THE p => bug ("expand_column: " + pattern::to_string p);
			    NULL  => bug "expand_column";
                        esac;
		    }				# fun expand_column 


		# Generate the DFA

		also
		fun match matrix
		    =
		    if (matrix::is_empty matrix)

			fail;
		    else
			case (matrix::find_best_match_column matrix)

			    NULL =>
				# First row is all wild cards.
				#
				case (matrix::row (matrix, 0))

				    { guard => THE (subst, g), nested => [], dfa, ... }
					=> 
					# Generate guard 
					bind (subst,
					    where' (g, dfa, 
						  match (matrix::remove_first_row matrix)));

				    { guard => NULL, dfa, nested => [], ... }
					=>
					dfa;

				    { guard, patterns, nested=>n ! ns, dfa, ... }
					=> 
					# Handle nested patterns
					# 
					{   n      ->  (subst, path, expression, pattern);
					    matrix ->  MATRIX { rows, paths };

					    row0  = { guard, patterns=>pattern ! patterns,
							 nested=>ns, dfa };
					    rows' = tail rows;

					    rows' = map (fn { patterns, nested, dfa, guard }
							    =
							    { patterns=>WILDCARD_PATTERN ! patterns, nested, dfa, guard }
							)
							rows';

					    m = MATRIX { rows=>row0 ! rows', paths=>path ! paths };

					   bind (subst, let' (path, expression, match m));
					};
				esac;

			    THE i => 
				# Mixture rule; split at column i
				# 
				case (expand_column (matrix, i))

				    # Splitting a constructor:
				    # 
				    SWITCH (cases, default)
					=>
					{   cases = map (fn (c, p, m) = (c, p, match m))
							cases;

					    case' (matrix::path_of (matrix, i), cases, 
						 null_or::map match default);
					};

				    # Splitting a tuple or record;
				    # recompute new namings.
				    #
				    PROJECT (p, namings, m)
					=>
					select (p, namings, match m);
				esac;
			esac;
		   fi;

		fun make_matrix rules
		    =
		    {   my (_, patterns0, _, _, _)
			    =
			    head rules;

			arity =  length patterns0;

			fun make_row (r, patterns, NULL, subst, action)
				=>
				{ patterns,
				  guard  =>  NULL,
				  nested =>  [],
				  dfa    =>  bind (subst, ok (r, action))
				};

			    make_row (r, patterns, THE g, subst, action)
				=> 
				{ patterns,
				  guard  =>  THE (subst, g),
				  nested =>  [],
				  dfa    =>  ok (r, action)
				};
			end;

			MATRIX {
			  rows  =>  map  make_row  rules,
			  paths =>  list::tabulate (arity,  fn i =  PATH [INT i] )
			};
		    };

		dfa =  match (make_matrix compiled_rules);

		rule_nos =  map #1 compiled_rules;


		# 1. Update the reference counts. 
		# 2. Compute the set of free path variables at each state. 
		# 3. Compute the set of path variables that are actually used.
		# 4. Compute the height of each node.

		exception NOT_VISITED;

		visited =   int_hash_table::make_table (32, NOT_VISITED);

		fun mark s
		    =
		    int_hash_table::set visited (s, TRUE);

		fun is_visited s
		    =
		    the_else (int_hash_table::find visited s, FALSE);

		fun set (fv, s)
		    =
		    {   fv := s;
			s;
		    };

		fun set_h (height, h)
		    =
		    {   height := h;
			h;
		    };

		union =  name::set::union;
		diff  =  name::set::difference;
		add   =  name::set::add;
		empty =  name::set::empty;

		fun diff_paths (fvs, ps)
		    = 
		    diff (fvs, name::set::add_list (name::set::empty, map PVAR ps));

		used = REF name::set::empty;

		fun occurs s
		    =
		    used := name::set::union (*used, s);

		redundant =   REF (int_list_set::add_list (int_list_set::empty, rule_nos));

		fun rule_used r
		    =
		    redundant := int_list_set::delete(*redundant, r);

		fun vars subst
		    =
		    name::set::add_list (empty, subst::vals_list subst);

		fun visit (DFA { stamp, ref_count, test, free_vars, height, ... }, pvs)
		    = 
		    {   ref_count :=  *ref_count + 1;

			if (is_visited stamp)

			    (*free_vars, *height);
			else
			    mark stamp;

			    case test

				 FAIL =>
				     (empty, 0);

				 BIND (subst, dfa)
				     => 
				     {   patvars =  name::set::add_list (empty, 

					 map VAR (subst::keys_list subst));

					 my (s, h)
					     =
					     visit (dfa, union (pvs, patvars));

					 variables =  vars subst;
					 s'        =  union (s, variables);
					 s'        =  diff  (s', patvars); 

					 occurs s'; 

					 (set (free_vars, s'), set_h (height, h + 1));
				     };

				 LET (p, _, dfa)
				     =>
				     {   my (s, h)
					     =
					     visit (dfa, pvs);

					 (set (free_vars, s), set_h (height, h+1));
				     };

				 OK (rule_no, action)
				     => 
				     {   fvs =  name::set::add_list (empty, 
						     map VAR (action::free_vars action));

					 #   (print("Action = " + Action::to_string action + "\n");
					 #    print("PVs = " + Name::setToString PVs + "\n");
					 #    print("FVs = " + Name::setToString fvs + "\n")
					 #   )

					 fvs = name::set::intersection (pvs, fvs);
					 rule_used rule_no; 
					 (set (free_vars, fvs), 0);
				     };

				 CASE (p, cases, opt)
				     =>
				     {   my (fvs, h)
					     = 
					     list::fold_right
						 (fn ((_, ps, x), (s, h))
						     =
						     {   my (fv, h')
							     =
							     visit (x, pvs);

							 fv =  diff_paths (fv, ps);

							 (union (fv, s), int::max (h, h'));
						     }
						 )
						 (empty, 0)
						 cases; 

					 my (fvs, h)
					     =  
					     case opt

						  NULL =>  (fvs, h); 

						  THE x
						      => 
						      {   my (fv, h')
							      =
							      visit (x, pvs);

							  (union (fvs, fv), int::max (h, h'));
						      };
					     esac;

					 fvs =  add (fvs, PVAR p); 

					 occurs fvs; 

					 (set (free_vars, fvs), set_h (height, h+1));
				     }; 

				 WHERE(_, y, n)
				     => 
				     {   my (sy, hy) =  visit (y, pvs);
					 my (sn, hn) =  visit (n, pvs);

					 s =  union (sy, sn);
					 h =  int::max (hy, hn) + 1;

					 occurs s; 

					 (set (free_vars, s), set_h (height, h));
				     };

				 SELECT (p, bs, x)
				     => 
				     {   my (s, h) =  visit (x, pvs);

					 s   =  add (s, PVAR p);

					 bs  =  fold_right
						    (fn ((p, _), sss) =  add (sss, PVAR p))
						    s
						    bs; 

					 fvs =  diff (s, bs);
					 occurs bs; 

					 (set (free_vars, fvs), set_h (height, h+1)); 
				     }; 

				 CONT (k, x)
				     =>
				     {   my (s, h) =  visit (x, pvs);	#  Always generate a state function 

					 ref_count :=  *ref_count + 1; 

					 (set (free_vars, s), set_h (height, h+1));
				     };
			    esac; 
		       fi;
		    };

		visit (dfa, empty); 

		my DFA { ref_count=>fail_count, ... }
		    =
		    fail;

		ROOT {
		  used       =>   *used, 
		  dfa, 
		  exhaustive =>   *fail_count == 0, 
		  redundant  =>   *redundant
		};
	    };

	fun exhaustive (ROOT { exhaustive, ... } ) =   exhaustive;
	fun redundant  (ROOT { redundant,  ... } ) =   redundant;


	# Generate final code for pattern matching.
	#
	fun code_gen 
	     { gen_fail:  Void -> A_expression,
	       gen_ok,   
	       gen_path,   
	       gen_bind,   
	       gen_case,
	       gen_if:    (guard::Guard, A_expression, A_expression) -> A_expression,
	       gen_goto,
	       gen_fun, 
	       gen_let:   (List( A_decl ), A_expression) -> A_expression,
	       gen_proj:  (Path,  List( (Null_Or( Path ), Index) )) -> A_decl,
	       gen_variable:   Path -> variable::Var,
	       gen_val:   (variable::Var, A_expression) -> A_decl,
	       gen_cont 
	     } (root, dfa)
	= 
	{   my ROOT { dfa, used, ... }
		=
		dfa;

	    fun gen_pattern p
		=
		if   (name::set::member (used, PVAR p))

		     THE p;
		else
		     NULL;
		fi; 

	    #  fun arg p = THE p 

	    fun make_vars free_var_set
		= 
		map (fn PVAR p =>  gen_variable p;
			VAR  v =>  v;
		     end 
		    )
		    (name::set::vals_list *free_var_set);

	    fun enque (dfa, (fff, bbb))
		=
		(fff, dfa ! bbb);

	    empty_queue =  ([], []);


	    # Walk a state, if it is shared then
            # just generate a goto to the state
	    # function; otherwise expand it: 
	    #
	    fun walk (dfa as DFA { stamp, ref_count, generated, free_vars, ... },
				work_list)
		= 
		if (*ref_count > 1)

		     # Just generate a goto 
		     code =  gen_goto (stamp, make_vars free_vars);

		     if *generated

			  (code, work_list);
		     else
			  generated := TRUE;

			  (code, enque (dfa, work_list));
		     fi;
		else
		     expand_dfa (dfa, work_list);
		fi 

	    # Generate a new function definition:
            #
	    also
	    fun gen_new_fun (dfa as DFA { stamp, free_vars, height, ... }, work_list)
		=
		{   my (body, work_list)
			=
			expand_dfa (dfa, work_list);

		    ((*height, gen_fun (stamp, make_vars free_vars, body)), work_list); 
		}

	    also
	    fun expand_yes_no (yes, no, work_list)
		=
		(yes, no, work_list)
		where
		    my (yes, work_list) =  walk (yes, work_list);
		    my (no,  work_list) =  walk (no,  work_list);
		end

	    # Expand the dfa always:
            #
	    also
	    fun expand_dfa (DFA { stamp, test, free_vars, ... }, work_list)
		=  
		case test

		    OK (rule_no, action)		#  Action 
			=>
			(gen_ok (action), work_list);

		    FAIL				#  failure 
			=>
			(gen_fail(), work_list);

		    BIND (subst, dfa)			#  guard 
			=>
			{   my (code, work_list)
                                =
                                walk (dfa, work_list);

			    namings
				= 
				subst::keyed_fold_right 
				    fn (v, PVAR p, b) => (v, gen_path p) ! b;
				       (v, VAR v', b) => b;
				    end
				    []
				    subst;

			    (gen_let (gen_bind namings, code), work_list);
			};

		    LET (path, (_, e), dfa)
			=>
			{   my (code, work_list)
				=
				walk (dfa, work_list);

			    (gen_let (gen_bind [(gen_variable path, e)], code), work_list);
			};

		    WHERE (g, yes, no)
			=>
			{   my (yes, no, work_list)
				=
				expand_yes_no (yes, no, work_list);

			    (gen_if (g, yes, no), work_list);
			};

		    CASE (path, cases, default)
			=>
			{   my (cases, work_list)
				= 
				list::fold_right 
				    (fn ((con, paths, dfa), (cases, work_list))
					=
					{   my (code, work_list)
						=
						walk (dfa, work_list);

					    ((con, map gen_pattern paths, code) ! cases, work_list); 
					}
				    )
				    ([], work_list)
				    cases;


			    # Find the most common case
                            # and make it the default:
			    #
			    my (default, work_list)
				= 
				case default

				     NULL
					 =>
					 (NULL, work_list);

				     THE dfa
					 => 
					 {   my (code, work_list)
						 =
						 walk (dfa, work_list);

					     (THE code, work_list);
					 };
				esac;

			    (gen_case (gen_variable path, cases, default), work_list);
			};

		    SELECT (path, namings, body)
			=>
			{   my (body, work_list)
				=
				walk (body, work_list);

			    namings
				=
				map
				    (fn (p, v) =  (THE p, v))
				    namings;

			    (gen_let([gen_proj (path, namings)], body), work_list);
			};

		    CONT (k, body)
			=>
			{   my (body, work_list)
				=
				walk (body, work_list);

			    (gen_let([gen_cont (k, stamp, make_vars free_vars)], body), work_list);
			};
		esac;


	    # Generate code for the dfa;
            # accumulate all the auxiliary   
	    # functions together and generate a let.
	    #
	    fun gen_all (root, dfa)
		=
		{   my (expression, work_list)
			=
			walk (dfa, empty_queue);


		    fun gen_aux_functions (([], []), funs)
			    =>
			    funs;   

			gen_aux_functions (([], bbb), funs)
			     => 
			    gen_aux_functions ((reverse bbb,[]), funs);

			gen_aux_functions ((dfa ! fff, bbb), funs)
			    =>
			    {   my (new_fun, work_list)
				    =
				    gen_new_fun (dfa, (fff, bbb));

				gen_aux_functions (work_list, new_fun ! funs);
			    };
		    end;


		    root_decl
			=
			gen_val (gen_variable (PATH [INT 0]), root);

		    funs =  gen_aux_functions (work_list, []);


		    # Order the functions by dependencies;
		    # sort by lowest height:
		    #
		    funs =  list_mergesort::sort
				(fn ((h, _), (h', _)) =  h > h')
				funs;

		    funs =  map #2 funs; 

		    gen_let (root_decl ! funs, expression);
		};

	    gen_all (root, dfa);
	};

    };

end;			# stipulate





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

