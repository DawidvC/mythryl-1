## compile-treewalk-g.pkg -- make7 dependency graph treewalks.
## (C) 1999 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)

# Compiled by:
#     src/app/make7/Make7.make6



#                  MOTIVATION
#
# If a package A calls a function in a package B.
# then we say package A "depends upon" package B.
#
# This is important during compiles, when we must
# have access to type information from B in order
# to compile A, and also during linking, when we
# must remember to link in B whenever we link A
# into a process or program.
# 
# We represent the detailed dependency relationships
# between a set of packages using a dependency graph
# -- see
#
#     src/app/make7/depend/intra-library-dependency-graph.pkg
# 
# We represent less detailed dependency relationships,
# accurate only to the granularity of libraries,
# using library dependency graphs.  See
#
#     src/app/make7/depend/inter-library-dependency-graph.pkg
# 
# We need to do two kinds of treewalks over these graphs,
# compile treewalks and link treewalks.
# 
# To achieve good separation of concerns, we implement
# the mechanics of doing these treewalks separately
# from the code needing them done, and hide the
# implementation details behind an abstract api.
#
# Link treewalks are implemented in
#
#     ./make-link-traversal-g.pkg
#
# Compile treewalks are implemented here.




#                  DATA STRUCTURE
#
# 'object_code_cache':
#
#     We use a 'object_code_cache' dictionary to remember which
#     source code files we have already compiled, and to record
#     for each such file the result of compiling it -- in
#     particular, the resulting o7 and its creation date, and
#     the interface information needed to compile other files
#     dependent upon this file, namely the symboltable of
#     exported values and types, and the dictionary of
#     inlinable functions.
#
#     object_code_cache keys:       Bare_O7 records.
#
#         The 'object_code_cache' dictionary keys are 'Bare_O7' records,
#         which summarize what we know about a given o7
#         including its sourcefile and parsetree.
#
#         In particular, the Bare_O7 record includes
#         a function make_oh7_file_name() which will generate and
#         return the name of the corresponding .o7 file to generate
#         presuming it is known to exist and be current. See
#
#             src/app/make7/o7/bare-o7.pkg
#
#
#     object_code_cache values:     Object_Code_Cache_Entry records.
#
#         Each 'object_code_cache' dictionary value is an 'object_code_cache_entry'
#         record (defined in this file -- see below).
#
#         This record includes a 'creation_time' timestamp field which
#         may be used to determine whether the compiled .o7 file is
#         currently valid, by checking to see if the sourcefile has
#         been modified since the .o7 file was generated.
#
#         The record also includes pickle hashes for the oh7_file:
#         If recompiling the sourcefile results in a new .o7 file with
#         the same picklehashes, then the source edit didn't introduce any
#         interesting (to a compiler) changes (maybe just some new comments)
#         and we don't need to run around recompiling all files which
#         depend on thaat sourcefile.  This can often avoid a lot of useless
#         recompilations.
#
#         Finally, the 'object_code_cache_entry' record also includes all
#         the interface information produced by compiling the corresponding
#         sourcefile -- which is to say, all the information needed
#         to recompile files which depend upon that sourcefile.




#                  ALGORITHM
#
# Our basic algorithm is quite simple.
#
# In essence we do a post-order treewalk of
# the dependency tree for the program, compiling
# each node after all of its children.
#
# Oure dependency 'tree' is really a lattice
# (it has shared subtrees due to multiple libraries
# calling the same library fns &tc) but we use
# datastructures such as our 'object_code_cache'
# dictionary to ensure that we don't compile a
# given makefile or sourcefile more than once.
#
#
# In a bit more detail, the heart of the
# post-order dependency graph treewalk is
#
#     fun compile_dependencies_then_sourcefile
#
# Key points of interest:
#
#
# o  Our 'dependency tree' is actually factored
#    into one 'inter-library' dependency graph
#    recording dependencies between complete
#    libraries (a "library" being essentially
#    the set of sourcefiles compiled by one
#    .make6 file) plus one 'intra-library' graph
#    per library recording dependencies between
#    individual source files.
#
#    This factoring adds some complexity to the
#    tree-traversal code, but does not change it
#    in any essential way.
#
#
# o  Before we compile a given sourcefile,
#    we queue up compiles of all other sourcefiles
#    that it depends upon, and wait for them to complete.
#
#    Each of them do the same thing recursively, so
#    we wind up compiling the dependency tree in a
#    wave that starts at the leafs and ripples up
#    to the root.
#
#    This ensures that when we compile a given file,
#    all needed info from other files is available.
#
#   (The structure of our source language
#    guarantees we can order our compiles
#    in this fashion:  We allow no cyclic
#    dependencies between source files.
#    To the frequent irritation of programmers!)
#
#
# o  We use one 'scheduled_compiles' map per library
#    to ensure that we don't queue up multiple compiles
#    of a sourcefile.
#
#
#
#                 COMPLICATING FACTORS
#
# As usual, most of the code complexity derives from attempts
# to improve speed and efficiency.  In this case, they include:
#
# o  To improve wallclock compile times, we support using
#    multiple Unix processes to compile files in parallel
#    during a build.  These processes may be on the same
#    machine (to take advantage of multi-processor boxes)
#    or on other machines.  (In the latter case, we assume
#    use of a shared filesystem such as NFS.)
#
# o  To minimize redundant work done, particularly parsing
#    of source code files, we do much of the work lazily,
#    using thunks and memos.  As usual, this makes the code
#    harder to understand and maintain. *wrygrin*
#
# o  To buy efficiency in cases where we do need to parse
#    a file multiple times, where possible we work from a
#    custom abstraction of the source code called a
#    'module dependencies summary' which contains just
#    the information we need from a source file.  See
#
#        src/app/make7/o7/module-dependencies-summary.pkg
#
#
#
#             JUST LIKE UNIX 'make'
#
# We retain enough information on disk between
# runs (in particular, the .o7 files) that
# the above algorithm also provides us with
# 'make' functionality, in the sense that if
# we compile everything, edit one or more files,
# and then recompile, only the logically required
# recompiles will be done.







# GENERIC INVOCATION CONTEXT
#
#     Our compile_treewalk_g generic is invoked
#     in two places,
#
#         src/app/make7/make-compiler/make-compiler-g.pkg
#         src/app/make7/main/make7-g.pkg
#
#     which is to say, in the definitions of both the
#     bootstrap and production compilers.
#
#
#
# RUNTIME INVOCATION CONTEXT
#
#     Our main two entrypoints are
#
#         make_intra_library_dependency_graph_walker
#         walk_inter_library_dependency_graph
#
#     Both are invoked by both bootstrap and standard compiler:
#
#         src/app/make7/make-compiler/make-compiler-g.pkg
#         src/app/make7/main/make7-g.pkg
#
#
#
# KNOWN GOTCHAS
#
#     This generic currently maintains a
#     lot of persistent state, which must be explicitly
#     reset by our client before each new compile, and
#     which (for now) precludes using multiple threads
#     to run multiple compiles in parallel within a
#     single process.		XXX BUGGO FIXME




###                      "In software as elsewhere,
###                       good engineering is whatever
###                       gets the job done without
###                       calling attention to itself."
###
###                           -- Citadel 2.21 release notes, 1982



stipulate
    #
    package m7 =  make7_state;				# make7_state				is from   src/app/make7/main/make7-state.pkg
    package sg =  intra_library_dependency_graph;	# intra_library_dependency_graph	is from   src/app/make7/depend/intra-library-dependency-graph.pkg
    package lg =  inter_library_dependency_graph;	# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg
    package st =  symbol_table;				# symbol_table				is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
    package pp =  prettyprint;				# prettyprint				is from   src/lib/prettyprint/src/prettyprint.pkg
    package pu =  unparse_stuff;			# unparse_stuff				is from   src/lib/compiler/front/typechecker/print/unparse-stuff.pkg
    package em =  error_message;			# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package ph =  picklehash;				# picklehash				is from   src/lib/compiler/front/basics/mlcomp/picklehash.pkg
    package ad =  anchor_dictionary;			# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg

    Picklehash
        =
        ph::Picklehash;

    Symbol_Table
        =
        symbol_table::Symbol_Table;		# symbol_table			is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg

    Inlining_Table
        =
        inlining_table::Dictionary;		# inlining_table		is from   src/lib/compiler/toplevel/compiler-state/inlining-table.pkg


    # Per package table of exported symbols (functions, types...)
    # and of exported inlinable functions:
    #
    Symbol_And_Inlining_Tables
         =
         { symbol_table:    Symbol_Table,
           inlining_table:  Inlining_Table
         };



herein

    api Make_Compile_Treewalk {

	Oh7_File_Contents;
	Byte_Sizes;

	reset:  Void -> Void;                             #  Reset internal persistent state. 



        # Support for hook which notifies
        # linkage module of recompilations.
        # The linker needs to know about these so it
        # can flush stale information from its caches:
        #
        #                "You can observe a lot just by watching." -- Yogi Berra
	#
	Bare_O7_Watcher
             =
             m7::Make7_State					# Master make7 state record. 
             ->
             bare_o7::Bare_O7			# What is being recompiled.  
             ->
             Void; 						# Send the notification.



	Oh7_File_Contents_Sink				# Type of a function which stores away oh7_file contents:
             =
             ( bare_o7::Bare_O7,
	       { contents:  Oh7_File_Contents,
		 byte_sizes: Byte_Sizes
	       }
             )
	     ->
             Void;


	get_o7_exports
            :
            bare_o7::Bare_O7
            ->
            o7_exports::Oh7_Exports;

								# bare_o7	is from   src/app/make7/o7/bare-o7.pkg
								# o7_exports	is from   src/app/make7/semant/o7-exports.pkg
	 evict_stale:  Void -> Void;
	 evict_all:    Void -> Void;


	 make_intra_library_dependency_graph_walker
            : 
            Void
	    ->
            sg::Bare_Or_Iced_O7					#  Root node of graph to traverse.	
	    ->
            m7::Make7_State					#  Master make7 state record.		
	    ->
            Null_Or( o7_exports::Oh7_Exports );


	 walk_inter_library_dependency_graph
            :
            ( Bare_O7_Watcher,					#  Notify linker of recompiles.		
	      Oh7_File_Contents_Sink,				#  					
	      lg::Library					#  Root library for treewalk.
	    )
	    ->
            { symbol_and_inlining_tables:  m7::Make7_State -> Null_Or( Symbol_And_Inlining_Tables ),
	      all_libraries:               m7::Make7_State -> Bool,
	      exports:                     symbol_map::Map (m7::Make7_State -> Null_Or( Symbol_And_Inlining_Tables ) )
	    };

    };
							# symbol_map			is from   src/app/make7/util/symbolmap.pkg
							# Compiler_Client_Interface	is from   src/lib/compiler/toplevel/backend/compiler-client-interface.api
							# Freezefile_Map		is from   src/app/make7/freezefile/freezefile-map-g.pkg
							# freezefile_map_g		def in    src/app/make7/freezefile/freezefile-map-g.pkg
							# file				is from   src/lib/std/src/unix/file.pkg

    # Compile-time arguments:
    #
    #     read_eval_print_from_stream
    #
    #         When we're invoked by
    #             src/app/make7/main/make7-g.pkg
    #         this is a simple wrapper for the global
    #             read_eval_print_from_stream_hook
    #         there, which is initialized to
    #             read_eval_print_from_stream
    #         which comes ultimately from
    #             src/lib/compiler/toplevel/interact/read-eval-print-loop-g.pkg
    #
    #         When we're invoke by
    #             src/app/make7/make-compiler/make-compiler-g.pkg
    #         we get its argument
    #             read_eval_print_from_stream_hook
    #         supplied to it by
    #             src/lib/core/make-compiler/x86-unix.pkg
    #         (and kin) as
    #             compiler_client_interface::interact::read_eval_print_from_stream;
    #
    #         I think that comes out the same, give or take
    #         indirection through the hook ref.
    #
    generic package  compile_treewalk_g (
	#
        package compiler_client_interface:    Compiler_Client_Interface;	# We use this to compile parsetrees down to .o7 files.
	#
	package freezefile_map:             Freezefile_Map;


	read_eval_print_from_stream:        file::Input_Stream -> Void;
	compile_in_subprocess:              ad::File -> Bool;		#  We use this to fire off a remote compile. 

    )
    :
    Make_Compile_Treewalk				# Make_Compile_Treewalk	is from   src/app/make7/compile/compile-treewalk-g.pkg
    where  Oh7_File_Contents == oh7_file::Oh7_File_Contents
    where  Byte_Sizes       == oh7_file::Byte_Sizes
    =
    package {

        architecture_name = compiler_client_interface::architecture_name;		# "ppc", "sparc" or "x86".
	version           = lib7_version::version.version_id;

							# lib7_version		is from   src/lib/core/internal/version.pkg
							# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
	Bare_O7_Watcher
             =
             m7::Make7_State
             ->
             bare_o7::Bare_O7
             ->
             Void;
							# oh7_file		is from   src/lib/compiler/execution/o7-file/oh7-file.pkg
	package ob =  oh7_file;				# "ob" == "OBject file"
	package c  =  compiler_client_interface::compile;

	Oh7_File_Contents =  ob::Oh7_File_Contents;
	Byte_Sizes        =  ob::Byte_Sizes;

	Oh7_File_Contents_Sink
             =
             ( bare_o7::Bare_O7,
               { contents:   Oh7_File_Contents,
	         byte_sizes: Byte_Sizes
	       }
             )
	     ->
             Void;



        # #####################################################
        #             filtered_symbol_tables_picklehash_cache
        #
        # Mythryl "strong sealing" (":>") allows one to
        # restrict the visible exports of a package to
        # just those present in a given API.
        #
        # To implement this, we frequently wind up taking
        # a symbol table (representing the exports of a
        # compiled .pkg file, or more precisely, of one
        # pkg...end clause) and filtering it to contain
        # only the symbols in a given symbol set (representing
        # the symbols from a given compiled api...end
        # clause).
        #
        # Doing so changes the symbol table's picklehash,
        # forcing us to recompute this, which is a
        # moderately expensive operation.
        #
        # To avoid repeating such computations pointlessly,
        # we keep a cache of their results and re-use
        # rather than re-computing them were possible:
        # ######################################################
	#
	package filtered_symbol_tables_picklehash_cache
	    =
	    map_g (					# map_g		def in    src/app/make7/util/map-g.pkg

		package {

		    Key = (Picklehash, symbol_set::Set);
		    #	
		    fun compare ((u, f), (u', f'))
			=
			case (ph::compare (u, u'))
			  
			     EQUAL   =>  symbol_set::compare (f, f');
			     unequal =>  unequal;
			esac;
		}
	    );

	filtered_symbol_tables_picklehash_cache							# More thread-hostile global mutable state :(        XXX BUGGO FIXME.
            =
            REF (filtered_symbol_tables_picklehash_cache::empty: filtered_symbol_tables_picklehash_cache::Map( Picklehash ));



							# symbol_set		is from   src/app/make7/util/symbolset.pkg
							# picklehash_set	is from   src/app/make7/util/picklehash-set.pkg
							# o7_exports		is from   src/app/make7/semant/o7-exports.pkg




        # ######################################################
        #                   object_code_cache
        #
        # 'object_code_cache' is our core "state-of-the-compilation"
        # datastructure. It maps
        #         Bare_O7
        # records representing what we knew about a sourcefile before compiling it to
        #         Object_Code_Cache_Entry
        # records representing what we learned about a sourcefile by compiling it.
        # ######################################################

	Object_Code_Cache_Entry
            =
            { o7_exports:      o7_exports::Oh7_Exports,
              creation_time:   time_stamp::Time_Stamp,         
              picklehash_set:  picklehash_set::Set
            };
		#  creation_time is the cache entry creation date.
		#  If it is older than the source file
		#  last-modification time, then the
		#  cache entry is outdated and needs
		#  to be discarded.

	object_code_cache							# More thread-hostile global mutable state :(        XXX BUGGO FIXME.
            =
            REF (bare_o7_map::empty:  bare_o7_map::Map( Object_Code_Cache_Entry ));


	#
	fun reset ()
            =
            {
                object_code_cache :=  bare_o7_map::empty;

                filtered_symbol_tables_picklehash_cache
                    :=
                    filtered_symbol_tables_picklehash_cache::empty;
            };
									# Object_Code_Cache_Entry	def is    above
									# filtered_symbol_tables_picklehash_cache is defined above
									# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
									# bare_o7_map		is from   src/app/make7/o7/bare-o7-map.pkg
									# time_stamp		is from   src/app/make7/paths/timestamp.pkg
									# picklehash_set	is from   src/app/make7/util/picklehash-set.pkg
	#
	fun object_code_cache_entry_is_usable
	    (
	      object_code_cache_entry: Object_Code_Cache_Entry,
	      provided_picklehashes,
	      bare_o7
	    )
            =
            not (
                time_stamp::needs_update {
                  source =>  bare_o7::last_sourcefile_modification_time_seen  bare_o7,
                  target =>  object_code_cache_entry.creation_time
                }
            )
	    and
            picklehash_set::equal (
                provided_picklehashes,
                object_code_cache_entry.picklehash_set
            );



	#
	fun oh7_file_contents_to_object_code_cache_entry
            (
              oh7_file_contents,
              creation_time,
              context_symboltable
            )
            =
	    { o7_exports,
	      creation_time,
	      picklehash_set
	    }
            where
		#
                fun symbol_table_thunk ()
		    =
		    {
                        modmap0
                            =
                            freezefile_map::get ();


			context_module_map
                            =
                            symbol_table_to_module_map::make_map'
                                (
                                  context_symboltable,
                                  modmap0
                                );

				# freezefile_map is a parameter, above.
				# freezefile_map_g		def in    src/app/make7/freezefile/freezefile-map-g.pkg
				# symbol_table_to_module_map	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table-to-modulemap.pkg
				# unpickle_module		is from   src/lib/compiler/front/semantic/pickle/unpickle-module.pkg


			my { picklehash, pickle }
                            =
                            ob::pickle_of_symbol_table  oh7_file_contents;
		    

			unpickle_module::unpickle_symboltable
                            (fn _ =  context_module_map)
                            (picklehash, pickle);

		    };

		#
		fun inlining_table_thunk ()
                    =
		    {
                        my { pickle, ... }
                            =
                            ob::pickle_of_inlinables
                                oh7_file_contents;


			inlinables_list
                            =
                            if   (unt8_vector::length pickle == 0)
			        
                                 NULL;
			    else
                                 unpickle_module::unpickle_highcode  pickle;
                            fi;

							# unt8_vector		is from   src/lib/std/src/unt8-vector.pkg
							# unpickle_module	is from   src/lib/compiler/front/semantic/pickle/unpickle-module.pkg
							# inlining_table	is from   src/lib/compiler/toplevel/compiler-state/inlining-table.pkg
		    
			inlining_table::make
                            (
                                ob::hash_of_pickled_exports
                                    oh7_file_contents,

                                inlinables_list
                            );
		    };


		o7_exports
                    =
                    { symbol_table_thunk        =>  memoize::memoize  symbol_table_thunk,
		      inlining_table_thunk      =>  memoize::memoize  inlining_table_thunk,

		      symbol_table_picklehash   =>  ob::hash_of_symbol_table_pickle  oh7_file_contents,
		      inlining_table_picklehash =>  ob::hash_of_pickled_inlinables   oh7_file_contents,
		      version                   =>  ob::version_of                   oh7_file_contents
		    };

							# memoize		is from   src/app/make7/util/memoize.pkg
							# picklehash_set	is from   src/app/make7/util/picklehash-set.pkg
		picklehash_set
                    =
                    picklehash_set::add_list
			(
                          picklehash_set::empty,

                          ob::picklehash_list
                              oh7_file_contents
                        );
	    
	    end;                           #  oh7_file_contents_to_object_code_cache_entry 


	#
	fun picklehash_set (p1, p2)
            =
            picklehash_set::add (picklehash_set::singleton p1, p2);


	# A typical source file S makes direct
        # and indirect reference to types, values
        # and functions from many other sourcefiles,
        # collectively termed its "dependencies".
        #
        # Before S can be compiled, all of its
        # dependencies must be compiled, and the
        # resulting symbol and inlining tables
        # combined to produce the environment
        # in which P can be compiled.
        #
        # Also, if a given dependency D is sealed
        # against some API, we must filter D's
        # exports to reveal only those symbols
        # permitted by the API before combining
        # with the exports from other dependencies.
        #
        # For efficiency, symbol and inlining tables
        # are exported lazily as thunks which construct
        # those tables only if and when actually needed.
        #
        # To avoid wasting time and space by evaluating
        # any such thunk more than once, we also memo-ize
        # these thunks as we combine them to produce
        # the overall compilation environment for S.
        #
        # When we filter a symbol table we change its
        # picklehash and must compute a new one.  This
        # is an expensive operation, likely to be
        # repeated during a make, so we keep a cache,
        # filtered_symbol_tables_picklehash_cache, and re-use
	# rather than recomputing when possible.
        #
        # Below are two routines which handle this
        # processing of dependency exports, one for the
        # filtered case and one for the unfiltered:
        #
        #     fun memoize_unfiltered_dependency_exports
        #     fun   memoize_filtered_dependency_exports
        #
        # One of the two will be called for each
        # dependency.

	#
	fun memoize_unfiltered_dependency_exports (o7_exports:  o7_exports::Oh7_Exports)
            =
            {
                o7_exports
                    ->
                    { symbol_table_thunk,
                      inlining_table_thunk,

                      symbol_table_picklehash,
                      inlining_table_picklehash,

                      version
                    };
                    

		symbol_table_thunk'
                    =
                    memoize::memoize  symbol_table_thunk;
	    

		{ symbol_and_inlining_tables_thunk
                      =>
                      fn ()
                          =
                          { symbol_table   =>  symbol_table_thunk'  (),
			    inlining_table =>  inlining_table_thunk ()
			  },

		  picklehashes
                      =>
                      picklehash_set
                         ( symbol_table_picklehash,
                           inlining_table_picklehash
                         )
		};
	    };

	#
	fun memoize_filtered_dependency_exports (o7_exports, symbol_set)
            =
            {
		# Even if a the exports from a dependency
		# are sealed against an API, it may be that
		# explicit filtering of the exports is not
		# needed, because all exported symbols are
		# allowed visibility by the API.
		#
		# Here we check for this case, so as to avoid
		# wasted explicit filtering, returning NULL
		# if no filtering is required, and otherwise
		# THE filtering symbol set:
		#
		fun required_filtering  symbol_set  symbol_table
		    =
		    {
			domain
			    =
			    symbol_set::add_list (
				symbol_set::empty,
				browse_symbol_table::catalog  symbol_table
			    );
								# symbol_set		is from   src/app/make7/util/symbolset.pkg
								# browse_symbol_table	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/browse.pkg
			symbol_set'
			    =
			    symbol_set::intersection (
				symbol_set,
				domain
			    );

			if   (symbol_set::equal (domain, symbol_set'))
			     NULL;
			else THE symbol_set'; fi;
		    };

                o7_exports					# unpack exports from compiled dependency.
                    ->
                    { symbol_table_thunk,
                      inlining_table_thunk,

                      symbol_table_picklehash,
                      inlining_table_picklehash,

                      version
                    };


		# We cannot filter a symbol table
                # (or even decide not to filter it)
                # without constructing it explicitly,
                # so at this point we must force the
                # symbol table thunk:
	 	#
		symbol_table
                    =
                    symbol_table_thunk ();
	    

		# If in fact no filtering is required, we
		# can essentially revert to the unfiltered
		# case (above):
		#
		case (required_filtering  symbol_set  symbol_table)
		  
		     NULL					# No exported symbol table filtering needed.
                         =>
                         {   picklehashes
				=>
				picklehash_set
				    ( symbol_table_picklehash,
				      inlining_table_picklehash
				    ),

			     symbol_and_inlining_tables_thunk
				 =>
				 fn ()
				     =
				     { symbol_table,
				       inlining_table => inlining_table_thunk ()
				     }
			 };

		     THE symbol_set				# Exported symbol table must be filtered per API.
			 =>
			 {   symbol_table'			# Construct filtered version of exports symbol table.
                                 =
                                 st::filter
                                     ( symbol_table,
                                       symbol_set::vals_list  symbol_set
                                     );
										# symbol_set	is from   src/app/make7/util/symbolset.pkg


			     # If an appropriate filtered symbol table picklehash
			     # is already in our cache we can just re-use it,
			     # otherwise we must compute the new one from scratch:
			     #
			     key = (symbol_table_picklehash, symbol_set);	# key for searching the cache.

			     symbol_table_picklehash'
				 =
				 case (filtered_symbol_tables_picklehash_cache::get
                                          (
                                            *filtered_symbol_tables_picklehash_cache,
                                            key
                                          ))
				   
				      THE symbol_table_picklehash'		# Found a cached exports record, just return it.
					  =>
					  symbol_table_picklehash';

				      NULL					# No cached exports record, construct one.
					  =>
					  {   symbol_table_picklehash'		# Filtering a symbol table changes its hash, so compute the new one.
						  =
						  rehash_module::rehash {
                                                    symbol_table        =>  symbol_table',
						    original_picklehash =>  symbol_table_picklehash,
						    version
						  };
										# rehash_module	is from   src/lib/compiler/front/semantic/pickle/rehash-module.pkg
										# filtered_symbol_tables_picklehash_cache is defined above

					      filtered_symbol_tables_picklehash_cache	# Enter new picklehash into our cache.
                                                  :=
                                                  filtered_symbol_tables_picklehash_cache::set (
                                                      *filtered_symbol_tables_picklehash_cache,
                                                      key,
                                                      symbol_table_picklehash'
                                                  );

					      symbol_table_picklehash';
					  };
                                 esac;

			     # Construct	
			     { picklehashes
                                   =>
                                   picklehash_set (symbol_table_picklehash', inlining_table_picklehash),

			       symbol_and_inlining_tables_thunk
                                   =>
                                   fn ()
                                       =
                                       { symbol_table   =>  symbol_table',
					 inlining_table =>  inlining_table_thunk ()
				       }
			     };
			};
                esac;
	    };              #  fun memoize_filtered_dependency_exports 


	# Combine two symbol+inlining table pairs,
        # with the first pair logically atop the
        # second (i.e., searched first):
	#
	fun symbol_and_inlining_tables_atop
            (
              { symbol_table , inlining_table  },
              { symbol_table => symbol_table', inlining_table => inlining_table' }
            )
            =
	    { symbol_table
                  =>
                  st::consolidate_lazy (
                      st::atop
                          (symbol_table, symbol_table')
                  ),

	      inlining_table
                  =>
                  inlining_table::atop
                      (inlining_table, inlining_table')      #  "Let's not do stale picklehashes here..." 
            };



	empty_hashes_and_dictionaries
            =
	    { picklehashes
                  =>
                  picklehash_set::empty,

              symbol_and_inlining_tables_thunk
                  =>
                  fn ()
                      =
                      { symbol_table
                            =>
                            st::empty,

                        inlining_table
                            =>
                            inlining_table::empty
                      }
            };
							# inlining_table	is from   src/lib/compiler/toplevel/compiler-state/inlining-table.pkg
							# picklehash_set	is from   src/app/make7/util/picklehash-set.pkg

	# Combine two sets of dependency exports.
	#
        # This is always an assymetric operation
	# in which one shadows the other in case
	# of conflicting symbol definitions.
	#
	# As usual, we do things lazily to avoid
	# explicitly constructing the result
	# unless or until provably necessary:
	#
	fun layer ( { symbol_and_inlining_tables_thunk => dicts,  picklehashes => hashes  },
                    { symbol_and_inlining_tables_thunk => dicts', picklehashes => hashes' }
                  )
            =
	    { symbol_and_inlining_tables_thunk
                  =>
                  .{  symbol_and_inlining_tables_atop (
                          dicts  (),
                          dicts' ()
                      );
                   },

	      picklehashes
                  =>
                  picklehash_set::union (hashes, hashes')
            };




	# I would rather not use an exception here, but short of a better
	# implementation of concurrency I see no choice.
	# The problem is that at each node we sequentially wait for the
	# children nodes.  But the scheduler might (and probably will)
	# let a child run that we are not currently waiting for, so an
	# error there will not result in "wait"  returning immediately
	# as it should for clean error recovery.
	# Using the exception avoids having to implement a
	# "wait for any child -- whichever finishes first" kind of call:
	#
	exception ABORT;



        # We're given a symbol-plus-inlining-table pair,
        # plus a thread which represents a compilation
        # in progress, which will return another such
        # symbol-plus-inlining-table pair once finished.
	#
        # Wait for the compilation to complete, then
	# return the combination of the two dictionary pairs:
	#
	fun layer_wait  priority  (thread, NULL  )			# Ok, actually we were NOT given input symbol-plus-inlining tableplair.
		=>
		{
                    simple_thread::result_at  priority  thread;		# Wait for the compile to finish.
		    NULL;						# NULL input, so NULL output.
		};
									# thread	is from   src/app/make7/simple-concurrency/thread.pkg

	    layer_wait  priority  (thread, THE symbol_and_inlining_tables)
		=>
		case (simple_thread::result_at  priority  thread)
		  
		    THE symbol_and_inlining_tables'			# Success, return combination of the two tablepairs.
			=>
			THE (layer (symbol_and_inlining_tables',
				    symbol_and_inlining_tables
			    )      );

		    NULL =>  NULL;					# Compile returned NULL, so we do too.
                esac;
        end;

	# We have two levels of compile-dependency graphs,
	# one which records which complete libraries have
	# compile dependencies on which other complete
	# libraries, and then one per library recording
	# which individual sourcefiles have compile
	# dependencies upon other individual sourcefiles.
	#
	# Here we walk an intra-library individual-sourcefile
	# level dependency graph compiling sourcefiles in
	# post-order, so that each sourcefile is compiled
	# only after all the libraries it needs have been
	# compiled (making available the relevant type
	# declarations &tc):
	#
	fun make_intra_library_dependency_graph_walker' (
                bare_o7_watcher,					# A hook letting us notify the linker when we re/compile a file. 
                cache_oh7_file_contents,					# A dummy or else oh7_file_cache::cache, which caches a copy in ram. 
                get_priority						# Prioritizes a sourcefile compile by # of files depending on it.
            )
            = 
            {    # We use 'scheduled_compiles' to keep track
                 # of which o7 files we've already compiled
                 # (or are in the process of compiling).
                 # 
                 # We use bare_o7 records as keys, to
                 # represent the individual .o7 files.
                 # 
                 # The values are memoized fates
                 # representing compiles already fired off.
		 #
                scheduled_compiles
                    =
                    REF  bare_o7_map::empty;

									# bare_o7_map	is from   src/app/make7/o7/bare-o7-map.pkg
                # To process the mutually recursive
                # o7-resolution dependency-graph
                # datatypes defined in
                #
                #     src/app/make7/depend/intra-library-dependency-graph.pkg
                #
                # we here define a matching set of
                # mutually recursive functions,
                # one per type.

                # Since o7 is a trivial wrapper around
                # the two possibilities of
                #     O7_IS_BARE   (.o7 file not stored in freezefile)
                #     O7_IS_ICED   (.o7 file     stored in freezefile)
                # our work here is just trivially delegating
                # as appropriate:
		#
		fun compile_near_o7
                        make7_state
                        (sg::O7_IS_BARE bare_o7)
			=>
			compile_bare_o7
                            make7_state
                            bare_o7;

		    compile_near_o7
                        make7_state
                        (sg::O7_IS_ICED  (_, o7_exports, _))
			=>
			THE o7_exports;

			    # We never recompile anything in a
			    # FROZEN REAL library,
			    # so we have nothing to do here.
                end 


                # The only thing distinguishing a far o7
                # (.o7 file in another library) from a
                # near o7 (.o7 file in current library)
                # is the export filter list, so the only
                # work we can't delegate here is applying
                # that filter list to the result:
		#
		also
		fun compile_far_o7'
                        make7_state
                        (a_filter, near_o7)
		    =
		    case ( compile_near_o7
                               make7_state
                               near_o7,

                           a_filter
                         )
		      
			 (NULL,           _             ) =>  NULL;
			 (THE o7_exports, NULL          ) =>  THE (memoize_unfiltered_dependency_exports o7_exports);
			 (THE o7_exports, THE symbol_set) =>  THE (memoize_filtered_dependency_exports  (o7_exports, symbol_set));
                    esac



                # Here's where the buck stops:
                # compiling a .o7 file in the
                # current library.
		#
		also
		fun compile_bare_o7
                        make7_state
                        (   sg::BARE_O7
			        { bare_o7,
				  near_imports,
				  far_imports
				}
                        )
                    =
                    {   youngest    =  make7_state.youngest;			# Most recent (known) edit of any sourcefile in the library.

			oh7_file_name =  bare_o7::oh7_file_name     bare_o7;	# "foo.pkg.o7".

										# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
										# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg
										# say			is from   src/lib/std/src/io/say.pkg
										# winix			is from   src/lib/std/winix.pkg
										# sfprintf		is from   src/lib/src/sfprintf.pkg

			#
			fun make_temporary_filename  filename
			    =
			    {   pid =  winix::process::get_process_id ();
				include sfprintf;
				pid =  sprintf' "%d" [ INT pid ];

				temporary_filename
                                    =
                                    filename + "." + pid + ".tmp";

				temporary_filename;
			    };

			temporary_oh7_file_name
			    =
			    make_temporary_filename oh7_file_name;


										# bare_o7_map	is from   src/app/make7/o7/bare-o7-map.pkg
										# null_or	is from   src/lib/std/src/null-or.pkg
										# thread	is from   src/app/make7/simple-concurrency/thread.pkg
                        # If we've already hit this .o7 file
                        # during this treewalk, it may already
                        # have a compile running, otherwise we
                        # need to start one:
		        #
			case (bare_o7_map::get
                                 (*scheduled_compiles, bare_o7))
			  
			    THE memoized_optional_fate
				=>
				# We already have a compile
				# running/done for this file,
				# so we just return it:
				#
				null_or::map
				    .o7_exports
				    (simple_thread::result  memoized_optional_fate);

			    NULL
				=>
				{   memoized_optional_fate
					=
					simple_thread::make_simple_thread

					    .{  compile_dependencies_then_sourcefile () 
						before
						    bare_o7::forget_parsetree bare_o7;
							#
							# "We have not processed this file before,
							#  so we should remove its parse tree afterward." -- Matthias Blume
					     };

				    scheduled_compiles
					:=
					bare_o7_map::set
					    ( *scheduled_compiles,
					      bare_o7,
					      memoized_optional_fate
					);

								       # bare_o7_map	is from   src/app/make7/o7/bare-o7-map.pkg

				    # Here we just wait (no "wait_at") so we don't get
				    # priority over threads that may have to clean up
				    # after errors:
				    #
				    null_or::map
					.o7_exports
					(simple_thread::result  memoized_optional_fate);
				};
                        esac
                        where
			    # Print the size-in-bytes of each of the
			    # four major components of an oh7_file --
			    # code, data, pickled symbol table and
			    # pickled inlining table:
			    #
			    fun print_sizes stream (byte_sizes: ob::Byte_Sizes)
				= 
				{   fun info ((selector, label), (l, t))
					=
					case (selector  byte_sizes)
					  
					     0 => (l, t);				# Do not report zero-length segments.

					     n => (   (   label				# "code"/"data"/"dictionary"/"inlinable".
						      !   ": "
						      !   int::to_string  n		# Number of bytes in segment.
						      !   t				# ", " or "".
						      !   " "
						      !   l				# list-of-strings result accumulator.
						      ),
						      ", "
						  );
					esac;


				    string
					=
					cat ( "["
                                              !
					      #1 (fold_right
						     info
						     (["bytes]\n"], "")
						     [  (.code,      "code"     ),
							(.data,      "data"     ),
							(.dictionary,      "dictionary"     ),
							(.inlinable, "inlinable")
						     ]
						 )
					    );

				    file::write (stream, string);
				    file::flush stream;   
				};


			    #
			    fun unparse_sizes
				    (pp:         prettyprinter::Prettyprinter)
				    (byte_sizes: ob::Byte_Sizes)
				= 
				{   fun info ((selector, label), result_so_far)
					=
					(   int::to_string  (selector byte_sizes)	# Number of bytes in segment.
					!   " "
					!   label					# "code"/"data"/"dictionary"/"inlinable".
					!   " bytes\n"
					!   result_so_far				# list-of-strings result accumulator.
					);

				    pp.out "\n\nCode segment byte sizes:\n";

				    string
					=
					cat
					    (fold_right
						info
						["\n"]
						[  (.code,      "code"     ),
						   (.data,      "data"     ),
						   (.dictionary,      "dictionary"     ),
						   (.inlinable, "inlinable")
						]
					    );

				    pp.lit string;
				};





			    #
			    fun announce_load _
				=
				file::vsay ["      .../compile/compile-treewalk-g.pkg:   Loading                 ", (ad::os_string'  (bare_o7::sourcepath bare_o7)), "\n"];

			    #
			    fun announce_o7_receipt  byte_sizes
				=
				{   file::vsay  ["      .../compile/compile-treewalk-g.pkg:  Receiving ", (bare_o7::describe bare_o7), "\n"];
				    print_sizes  file::stdout byte_sizes;
				};

			    #
			    fun handle_compile_error ()
				=
				if   (make7_state.make7_session.keep_going) 
				     NULL;
				else raise exception ABORT;  fi;



			    # In general, a parallel 'make' may be spread
			    # across multiple unix processes and/or machines.		(Except that is hopelessly broken! :-)
			    #
			    # We use 'compile_in_subprocess' to fire off remote compiles
			    # on other machines or by other processes.
			    #
			    # We use 'compile_in_this_process' to do a compile in our own
			    # process on our own machine.
			    #
			    # The compile server processes will compile by doing
			    # 'compile_in_this_process' calls in their own process spaces,
			    # of course, so ultimately all compiles are done via
			    # this 'compile_in_this_process' function.  
			    #
			    # To keep life simple for the programmer, any 'remote' compiles
			    # which generate errors are re-run locally, so as to have all
			    # the error messages show up on the local console &tc.
			    #
			    fun compile_in_this_process
                                    (
				      symbol_table,		# These args constitute the exports
				      inlining_table,		# from the o7s we depend upon.
				      picklehashes,
				      cross_module_inlining
				    )
				    # We also get from our enclosing
                                    # 'compile_bare_o7' fn the critical args:
				    #
				    #     make7_state,
				    #     bare_o7,
				    #     far_imports,
				    #     near_imports
				=
				{   # 'set_up' is a hack to support the make7 tools
				    #  "setup" facility.
				    #
				    # This facility allows the tool to specify some source
				    # code to be compiled immediately before ("pre") or
				    # after ("post") the main body of code to be compiled
				    # by the tool.
				    #
				    # It might be used, for example, to turn on some debugging
				    # checks, or change some code optimizer settings.
				    #
				    # This function takes care of the mechanics of actually
				    # compiling and running these code fragments, if present.
				    #
				    fun set_up _ NULL
					    =>
					    ();

					set_up
					    what		# Either "pre" or "post", for human narration. 
					    (THE code)		# Literal source code to compile+run.		
					    =>
					    {   file::vsay [
						    "      .../compile/compile-treewalk-g.pkg:  Setting up (",
						    what,
						    "): ",
						    code,
						    "]\n"
						];
							    # say	is from   src/lib/std/src/io/say.pkg
							    # safely	is from   src/lib/std/safely.pkg

						safely::do
						    {	# This should be a supported, exported 'eval' function.

						      open_it  =>   .{ file::open_string code; },
						      close_it =>   file::close_input,
						      cleanup  =>   fn _  =  ()
						    }
                                                    read_eval_print_from_stream;
					    };
				    end;



				    # Given 'oh7_file_contents' (the in-hand result
				    # of compiling one sourcefile), write it to
				    # disk to create the actual .o7 file recording
				    # the result of the compile:
				    #
				    fun write_oh7_file  oh7_file_contents
					=
					{   fun verbosely_write_oh7_file_contents_to_stream
						    stream
						=
						{   byte_sizes
							=
							ob::write {  architecture_name,		# "ppc", "sparc" or "x86".
								     version,
								     no_pickle =>  FALSE,
								     stream,
								     oh7_file_contents
								 };

						 #  print_sizes  byte_sizes;  # 2006-09-10 CrT:  This is just clutter for now. 
						    byte_sizes;
						};
					    #
					    fun cleanup _
						=
						winix::file::remove_file	# Remove any half-built compiled code file.
						    temporary_oh7_file_name			# 'foo.pkg.o7.12345.tmp'
						except
						    _ = ();

					    # Notify linker that we're about to re/create
					    # the .o7 file for our sourcefile.  This lets
					    # the linker flush from cache any stale
					    # versions of that .o7 file, or whatever:
					    #
					    bare_o7_watcher  make7_state  bare_o7;

									    # bare_o7 was an arg to fun 'compile_bare_o7'
									    # winix		is from   src/lib/std/winix.pkg
									    # safely		is from   src/lib/std/safely.pkg
									    # autodir		is from   src/app/make7/util/autodir.pkg
									    # binary_io		is from   src/lib/std/src/unix/posix-binary-io.pkg
									    # time_stamp	is from   src/app/make7/paths/timestamp.pkg
									    # bare_o7		is from   src/app/make7/o7/bare-o7.pkg
									    # exceptions	is from   src/lib/std/exceptions.pkg

					    (   safely::do
                                                    { open_it   =>  .{ autodir::open_binary_output  temporary_oh7_file_name; },
						      close_it  =>  binary_io::close_output,
						      cleanup
						    }
						    verbosely_write_oh7_file_contents_to_stream
						before
                                                    {   time_stamp::set_last_file_modification_time (
							    temporary_oh7_file_name,
							    bare_o7::last_sourcefile_modification_time_seen
								bare_o7
							);

							# Make .o7 file writes effectively atomic
							# by renaming them to final filename only
							# once they are completely written out:
							#
							winix::file::rename_file
							    {
							      from =>  temporary_oh7_file_name,
							      to   =>            oh7_file_name
							    };
                                                    }
					    )
					    except
						any_exception
						=
						{   fun ppb pps
							=
							{   pp::newline  pps;
							    pp::string   pps (exceptions::exception_message  any_exception);
							};

						    bare_o7::error
							make7_state
							bare_o7
							em::WARNING
							("failed to write " + temporary_oh7_file_name)
							ppb;

						    { code      => 0,
						      dictionary      => 0,
						      inlinable => 0,
						      data      => 0
						    };
						};
					};						#  fn write_oh7_file  

    # XXX BUGGO DELETEME
				    unparse_generic
				       =
				       print_raw_syntax_tree_as_nada::print_declaration_as_nada;

					    # print_raw_syntax_tree_as_nada	is from   src/lib/compiler/front/typechecker/print/print-raw-syntax-as-nada.pkg


				    # Get the raw parsetree for the
				    # file we're compiling.
				    #
				    # It may already be cached in ram.
				    #
				    # If not, we'll parse the sourcefile
				    # at this point:
				    #
				    case (bare_o7::parsetree
					     make7_state				# make7_state was an arg to fun 'compile_bare_o7'
					     NULL                             		# Or, to prettyprint every file parsed: (THE (symbol_table, unparse_generic))
					     bare_o7)					# bare_o7 was an arg to fun 'compile_bare_o7'


				      
					NULL => handle_compile_error ();		#  Syntax errors, couldn't parse sourcefile. 

										    # bare_o7			is from   src/app/make7/o7/bare-o7.pkg
										    # core_hack			is from   src/app/make7/compile/corehack.pkg
										    # raw_syntax		is from   src/lib/compiler/front/parse/raw-syntax/raw-syntax.pkg
										    # source_code_source	is from   src/lib/compiler/front/basics/source/source-code-source.pkg

					THE  ( raw_syntax_declaration:   raw_syntax::Declaration,
					       source:                   source_code_source::Input_Source
					     )
					     =>
					     {   # Maybe replace 'xcore' symbol with
						 # '_Core' symbol throughout parsetree.
						 # This is an obscure internal kludge
						 # we use to set up the original
						 # pervasive dictionary.
						 #	
						 raw_syntax_declaration
						     =
						     case (.explicit_core_symbol  (bare_o7::attributes  bare_o7))
						       
							  NULL       =>  raw_syntax_declaration;
							  THE symbol =>  core_hack::rewrite  (raw_syntax_declaration, symbol);
						     esac;


						 my (pre, post)
						     =
						     bare_o7::setup   bare_o7;



						 # 'controllers' is a hack to set controllers
						 # (essentially, unix commandline switches) to a new
						 # value for just the duration of this compile.
						 # It is more support for the make7 'tools' code:
						 #
						 controllers
						     =
						     bare_o7::controllers  bare_o7;



						 top_level					# Get set of packages, generics &tc
						     =						# currently defined at the interactive toplevel.
						     compiler_state::top_level ();

										    		# compiler_state	is from   src/lib/compiler/toplevel/interact/compiler-state.pkg




						 original_settings				# Save all current controller settings,
						     =						# so we can restore them when done.
						     map
							 (fn controller =  controller.save'restore ())
							 controllers;


						 original_toplevel_dictionary			# Ditto with defined packages.
						     =
						     top_level.get ();



						 # A function to restore original controller
						 # settings and known packages/generics. Below
						 # we use a safely::do to ensure that this gets
						 # called if for any reason we bomb out of the
						 # following work () fn, which is the heart of
						 # compile_in_this_process:	
						 #
						 fun restore_antecedent_global_compiler_state _
						     =
						     {   top_level.set  original_toplevel_dictionary;

							 apply
							     (fn r =  r ())
							     original_settings;
						     };


						 # Here at last we arrive at the beating heart of
						 #
						 #     fun compile_in_this_process
						 #
						 # and thus
						 #
						 #     fun compile_bare_o7
						 #
						 # and ultimately
						 #
						 #     fun make_intra_library_dependency_graph_walker'
						 #
						 # itself:
						 #
						 fun compile_one_sourcefile ()
						     =
						     {   set_up  "pre"  pre;		# 'pre' was extracted from 'bare_o7', above.

							 # Clear error flag -- could still
							 # be set from earlier run:
							 #
							 source.any_errors
							     :=
							     FALSE;

							 err =  em::errors  source;		# 'source' was extracted from 'bare_o7', above.
								    				# compilation_exception		is from   src/lib/compiler/front/basics/mlcomp/compilation-exception.pkg
							 #
							 fun check_errors  phase
							     =
							     if   (em::any_errors  err)
							         
								  raise exception compilation_exception::COMPILE (phase + " failed");
							     fi;



							 fun do_verbose_logging_for  filename
							     =
							     string::is_suffix  "oop-crib-tmp.pkg"  filename    or  
							     string::is_suffix  "oop-crib.pkg"      filename    or  
							     string::is_suffix  "oop-test.pkg"      filename    or  
							     string::is_suffix  "test-class.pkg"    filename    or  
							     string::is_suffix  "test-subclass.pkg" filename    or  
    							     string::is_suffix  "test.pkg"          filename    or
string::is_suffix  "rewrite-raw-syntax-expression.pkg"          filename    or
    							     string::is_suffix  "x.pkg"             filename;
								       # XXX BUGGO FIXME Above check is a quick hack. Ideally, the check should be (say)
								       # against a regular expression stored in a control, settable by a commandline
								       # switch, but one thing at a time...! *grin*


							 source_file_name
							     =
							     ad::os_string'  (bare_o7::sourcepath  bare_o7);

							 prettyprinter_or_null
							     =
							     if   (not (make7_defaults::make_compile_logs.get ()))
							         
								  NULL;
							     else

								  unparse_filename
								      =
								      cat [  source_file_name, ".COMPILE_LOG" ];


								  pp  = prettyprinter::make_file_prettyprinter  unparse_filename;

								  pps = pp.stream;



								  if   (not (do_verbose_logging_for   source_file_name))
								      
								       pp::newline  pps;
								       pp::newline  pps;
								       pp::string   pps   "This is a concise compile log.";	pp::newline  pps;
								       pp::string   pps   "To get a verbose compile log, edit";	pp::newline  pps;
								       pp::string   pps	  "    do_verbose_logging_for";		pp::newline  pps;
								       pp::string   pps	  "in";					pp::newline  pps;
								       pp::string   pps   "   src/app/make7/compile/compile-treewalk-g.pkg";
								       pp::newline  pps;

# pp::string   pps   "Next is raw syntax tree for foo:";
# pp::newline  pps;
# foo = printf_format_string_to_raw_syntax::make_anonymous_curried_function ("%d %6.2f %-15s\n", 12, 13); 
# unparse_raw_syntax::unparse_expression
#     (symbol_table, NULL)
#     pps
#     (raw_syntax::PRE_FIXITY_EXPRESSION foo, 1000);
# pp::string   pps   "Done raw syntax tree for foo:";
# pp::newline  pps;

								       pp::flush_stream  pps;
								  else
								       pp::newline  pps;
								       pp::newline  pps;
								       pp::string   pps   "This is a verbose compile log.";		pp::newline  pps;
								       pp::string   pps   "To get a concise compile log, edit";	pp::newline  pps;
								       pp::string   pps	  "    do_verbose_logging_for";		pp::newline  pps;
								       pp::string   pps	  "in";					pp::newline  pps;
								       pp::string   pps   "   src/app/make7/compile/compile-treewalk-g.pkg";

								       pp::newline  pps;
								       pp::newline  pps;
								       pp::string   pps   "(Following printed by src/lib/compiler/toplevel/main/compile-treewalk-g.pkg.)";
								       pp::newline  pps;

								       pp::newline  pps;
								       pp::newline  pps;
								       pp::newline  pps;
								       pp::string   pps   "Raw syntax tree unparsed:";
								       pp::newline  pps;

								       unparse_raw_syntax::unparse_declaration
									   (symbol_table, THE source)
									   pps
									   (raw_syntax_declaration, 1000);


								       pp::newline  pps;
								       pp::newline  pps;
								       pp::newline  pps;
								       pp::string   pps   "Raw syntax tree prettyprinted (source code region records mostly suppressed for brevity):";
								       pp::newline  pps;

								       prettyprint_raw_syntax::prettyprint_declaration
									   (symbol_table, THE source)
									   pps
									   (raw_syntax_declaration, 1000);


# pp::newline  pps;
# pp::string   pps   "Above fiddledeedee fn";
# pp::newline  pps;
# fun fiddledeedee arg1 arg2 arg3 = sfprintf::printf' "%d %6.2f %-15s\n" [ sfprintf::INT arg1, sfprintf::FLOAT arg2, sfprintf::STRING arg3 ];
# pp::newline  pps;
# pp::string   pps   "Below fiddledeedee fn";
# pp::newline  pps;
# pp::newline  pps;
# pp::string   pps   "Starting raw syntax tree for foo:";
# pp::newline  pps;
# foo = printf_format_string_to_raw_syntax::make_anonymous_curried_function ("%d %6.2f %-15s\n", 12, 13); 
# unparse_raw_syntax::unparse_expression
#     (symbol_table, NULL)
#     pps
#     (raw_syntax::PRE_FIXITY_EXPRESSION foo, 1000);
# pp::newline  pps;
# pp::string   pps   "Done raw syntax tree for foo.";
# pp::newline  pps;
								       pp::flush_stream  pps;



									     # unparse_raw_syntax	is from   src/lib/compiler/front/typechecker/print/unparse-raw-syntax.pkg
									     # unparse_symbol_table	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/prettyprint-symbol-table.pkg
									     # unparse_code_segments	is from   src/lib/compiler/execution/code-segments/unparse-code-segments.pkg
								  fi;

								  THE pp;
							     fi;

							 # What's the point of this?  We pass 'source'
							 # separately anyhow, and 'transform' is always
							 # null.  That leaves just the (here implicit) stamp generator.
							 # Should be either expanded or eliminated. XXX BUGGO FIXME
							 #
							 compile_info
							     =
							     c::make_compile_info {

								 source     =>  (source:  source_code_source::Input_Source),
								 transform  =>  fn x = x,

								 prettyprinter_or_null
								     =>
								     (do_verbose_logging_for   source_file_name)
									 ?? prettyprinter_or_null
									 :: NULL
							     };

							 cross_module_inlining
                                                             =
                                                             controls::inline::get'   cross_module_inlining;

							 version  =   bare_o7::version  bare_o7;


										    # make_compile_info		def in    src/lib/compiler/toplevel/main/compile-g.pkg
										    # source_code_source	is from   src/lib/compiler/front/basics/source/source-code-source.pkg
										    # raw_syntax		is from   src/lib/compiler/front/parse/raw-syntax/raw-syntax.pkg
										    # symbol_table		is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
										    # inlining_table		is from   src/lib/compiler/toplevel/compiler-state/inlining-table.pkg
										    # compile_info		is from   src/lib/compiler/front/typecheck-stuff/main/compile-info.pkg
										    # code_segments		is from   src/lib/compiler/execution/code-segments/code-segments.pkg
										    # picklehash		is from   src/lib/compiler/front/basics/mlcomp/picklehash.pkg
										    # controls			is from   src/lib/compiler/toplevel/main/controls.pkg
										    # bare_o7			is from   src/app/make7/o7/bare-o7.pkg
										    # Compile0			is from   src/lib/compiler/toplevel/main/compile.api
										    # compile_g			def in    src/lib/compiler/toplevel/main/compile-g.pkg


							 # This is the central call of make7,
							 # where we actually compile a raw
							 # syntax tree all the way down to
							 # executable binary code:
							 #				We do this one other place:    src/lib/compiler/toplevel/interact/read-eval-print-loop-g.pkg
							 (c::compile

							     { source                 => source:                 source_code_source::Input_Source,
							       raw_syntax_declaration => raw_syntax_declaration: raw_syntax::Declaration,

							       # Next two args constitute the exports
							       # from the o7s we depend upon:
							       #
							       symbol_table     => symbol_table:    symbol_table::Symbol_Table,
							       inlining_table   => inlining_table:  inlining_table::Dictionary,

							       compile_info     => compile_info:    compile_info::Compile_Info( deep_syntax::Declaration ), 
							       check_errors     => check_errors:    String -> Void,

							       cross_module_inlining => cross_module_inlining:        Null_Or( Int ),
							       version				# Opaque here, ultimately either Void or String, 
							     })

							     ->

							     { code_segments             => code_segments:	    code_segments::Code_Segments,		# Compiled binary code.
							       new_symbol_table          => new_symbol_table:	    symbol_table::Symbol_Table,			# 'symbol_table' above augmented by stuff from 'raw_syntax_declaration'.  Not used.
							       export_picklehash         => export_picklehash:      Null_Or( picklehash::Picklehash ),
							       inline_expression         => inline_expression:      Null_Or( anormal::Program ),		# A-normal code for inlining into other modules.
							       imports                   => imports:                List( import_tree::Import ),		# How to find our imports at linktime.
							       symbol_table_picklehash,
							       pickle => symbol_table_pickle,
							       ...
							      };
										    # code_segments	is from   src/lib/compiler/execution/code-segments/code-segments.pkg
										    # symbol_table	is from   src/lib/compiler/front/typecheck-stuff/symbol-table/symbol-table.pkg
										    # picklehash	is from   src/lib/compiler/front/basics/mlcomp/picklehash.pkg
										    # import_tree	is from   src/lib/compiler/execution/main/importtree.pkg
										    # anormal		is from   src/lib/compiler/upper/anormal/anormal.pkg
										    # import_tree	is from   src/lib/compiler/execution/main/importtree.pkg

							 # The 'inline_expression' returned by the compiler
							 # contains highcode-format (machine-independent)
							 # code for exported functions worth inlining in
							 # other modules.
							 #
							 # This will become part of the exported state
							 # of the module, so we pickle it now for inclusion
							 # in the .o7 file:
							 #
							 (pickle_module::pickle_highcode_program   inline_expression)
							     ->
							     { picklehash =>  inlinables_picklehash,
							       pickle     =>  inlinables_pickle
							     };
										    # pickle_module	is from   src/lib/compiler/front/semantic/pickle/pickle-module.pkg
										    # byte			is from   src/lib/std/src/byte.pkg
										    # picklehash_set	is from   src/app/make7/util/picklehash-set.pkg
							 inlinables_pickle
							     =
							     case inline_expression
							       
								  NULL  =>  byte::string_to_bytes "";
								  THE _ =>  inlinables_pickle;
							     esac;


							 oh7_file_contents
							     =
							     ob::create {
							       imports,
							       export_picklehash,
							       picklehash_list => picklehash_set::vals_list   picklehashes,
													    # picklehashes was an arg to fun 'compile_in_this_process'
							       version,
							       code_segments,

							       symbol_table
								   =>
								   { pickle     =>  symbol_table_pickle,
								     picklehash =>  symbol_table_picklehash
								   },

							       inlinables
								   =>
								   { pickle     =>  inlinables_pickle,
								     picklehash =>  inlinables_picklehash
								   }
							     };


							 object_code_cache_entry
							     =
							     oh7_file_contents_to_object_code_cache_entry (

								 oh7_file_contents,
								 bare_o7::last_sourcefile_modification_time_seen   bare_o7,
								 symbol_table
							     );


							 set_up "post" post;
							 restore_antecedent_global_compiler_state ();


							 (write_oh7_file  oh7_file_contents)             # Write the foo.o7 file.
							     ->
							     byte_sizes;	


							 case prettyprinter_or_null
							   
							      NULL => ();

							      THE pp
								  =>
								  {   pps = pp.stream;

								      if (do_verbose_logging_for
									     source_file_name
                                                                      )

									   pp::newline  pps;
									   pp::newline  pps;
									   pp::string   pps   "(Following printed by src/app/make7/compile/compile-treewalk-g.pkg.)";
									   pp::newline  pps;

									   unparse_sizes   pp   byte_sizes;

									   pp::newline  pps;
									   pp::newline  pps;
									   pp::string   pps   "Version: ";
									   pp::string   pps   version;

									   pp::newline  pps;
									   pp::newline  pps;
									   pp::string   pps   "Compiled code saved in: ";
									   pp::string   pps   oh7_file_name;

									   pp::newline  pps;
									   pp::newline  pps;
									   pp::string   pps   "inline_expression: ";
									   pp::string   pps   case inline_expression
                                                                                                  NULL => "NULL";
                                                                                                  _    => "(non-NULL)";
                                                                                              esac;

									   pp::newline  pps;
									   pp::newline  pps;
									   pp::string   pps   "Symbol table picklehash: ";
									   pp::string   pps   (picklehash::to_hex symbol_table_picklehash);
									   pp::newline  pps;
									   pp::string   pps   "Inlinables   picklehash: ";
									   pp::string   pps   (picklehash::to_hex inlinables_picklehash);



									   unparse_code_segments::unparse_code_segments   pps   code_segments;


								      fi;

								      pp.flush ();
								      pp.close ();
								  };
							 esac;


							 # When cache_oh7_file_contents is not a dummy,
							 # it is oh7_file_cache::cache, which caches a
							 # copy of the .o7 file contents in memory,
							 # on the presumption we may shortly want it.
							 #
							 cache_oh7_file_contents (
							     bare_o7,
							     {   contents   =>  oh7_file_contents,
								 byte_sizes
							     }
							 );

							 THE object_code_cache_entry;
						     };							# fun compile_one_sourcefile

					     safely::do
						 {
						   open_it  =>   fn () = (),
						   close_it =>   fn () = (),
						   cleanup  =>   restore_antecedent_global_compiler_state
						 }
						 compile_one_sourcefile;

					 }
					 except
					     (em::COMPILE_ERROR | compilation_exception::COMPILE _)
					     =
					     handle_compile_error ();
				    esac;               # At this point we handle only
							# explicit compiler bugs and ordinary
							# compilation errors because for those
							# there will already have been
							# explanatory messages.  Everything
							# else "falls through" and will be
							# treated at top level.

				};									# fun compile_in_this_process 

			    #
			    fun compile_dependencies_then_sourcefile ()
				=
				{
				    youngest				# Track most recent (known) edit of any sourcefile in the library.
					:=
					time_stamp::max (
					    *youngest,
					    bare_o7::last_sourcefile_modification_time_seen
						bare_o7
					);

				    priority
					=
					get_priority   bare_o7;


									    # safely			is from   src/lib/std/safely.pkg
									    # compilation_exception	is from   src/lib/compiler/front/basics/mlcomp/compilation-exception.pkg
									    # time_stamp		is from   src/app/make7/paths/timestamp.pkg
									    # bare_o7			is from   src/app/make7/o7/bare-o7.pkg
									    # thread			is from   src/app/make7/simple-concurrency/thread.pkg

				    # Our .o7 file isn't in our 'scheduled_compiles'
				    # so we're going to have schedule a compile for it.
				    #
				    # But before we can compile it, we must make sure
				    # that everything it depends upon has been compiled,
				    # to ensure that all the type declarations &tc that
				    # it needs will be available at compile time.


				    # Fire up compiles of all our far
				    # dependencies, which is to say,
				    # all .o7 files in other libraries
				    # from which we import something:
				    #
				    far_imports_fate_list
					=
					map (fn far_imports_node
						=
						simple_thread::make_simple_thread
						    .{ compile_far_o7  far_imports_node; }
					    )
					    far_imports			# 'far_imports' is from 'fun compile_bare_o7' argument.
					where
					    fun compile_far_o7  far_imports_node
						=
						compile_far_o7'  make7_state  far_imports_node;
					end; 

				    # Similarly, fire up compiles of all
				    # our local dependencies, which is
				    # to say, all .o7 files in this library
				    # from which we import something:
				    #
				    near_imports_fate_list
					=
					map
					    (fn near_imports_node
						=
						simple_thread::make_simple_thread
						    .{ compile_near_o7  near_imports_node; }
					    )
					    near_imports			# 'far_imports' is also from 'fun compile_bare_o7' argument.
					where
					    fun compile_near_o7  near_imports_node
						=
						null_or::map
						    memoize_unfiltered_dependency_exports
						    (compile_bare_o7  make7_state  near_imports_node);

					end;


				    # Accumulate and combine the exports
				    # of all the above compiles:
				    #
				    combined_symbol_and_inlining_tables
					=
					fold_left

					    (layer_wait priority)

					    (fold_left
						(layer_wait priority)
						(THE empty_hashes_and_dictionaries)
						far_imports_fate_list
					    )

					    near_imports_fate_list;


				    case combined_symbol_and_inlining_tables
				      
					 NULL		# We can't compile our sourcefile because
					     =>		# one or more of the sourcefiles it depends upon
					     NULL;		# failed to compile.

					 THE { symbol_and_inlining_tables_thunk, picklehashes }
					     =>
					     {   # We have successfully compiled all
						 # dependencies (imports) which needed it.
						 # (Which might be none.)
						 #
						 # Now we need to find/make object code
						 # appropriate to our source code.
						 #
						 # If we've compiled this sourcefile
						 # recently, we may have the needed
						 # object code cached in memory.
						 #
						 # If not, we'll have to either load
						 # the object code from its .o7 file,
						 # if any, or else generate it by
						 # compiling the source code.
						 #
						 #	We start by checking our in-memory
						 # object-code cache:	
						 #		
						 case (bare_o7_map::get					# bare_o7_map	is from   src/app/make7/o7/bare-o7-map.pkg
							  (*object_code_cache, bare_o7))
						   
						      NULL
							  =>
							  # No appropriate object code
							  # in our in-memory cache:
							  #
							  must_load_or_compile_o7_file ();

						      THE object_code_cache_entry
							  =>
							  # Found matching object code in cache.
							  # Use it unless the source code has been
							  # modified since the object code was compiled:
							  #		
							  if (object_code_cache_entry_is_usable
								(
								  object_code_cache_entry,
								  picklehashes,
								  bare_o7
								)
                                                          )
							       THE object_code_cache_entry;			# Use cached object code.
							  else must_load_or_compile_o7_file (); fi;		# Don't use cached object code.
						 esac
						 where
						     fun must_load_or_compile_o7_file ()
							 =
							 # Our in-memory cache doesn't contain
							 # usable compiled object code for our
							 # sourcefile, so we must either load 
							 # object code memory from a .o7 file
							 # (if one exists), or else actually
							 # compile the sourcefile:
							 #
							 case (load_else_compile_o7_file ())
							   
							      NULL
								  =>
								  # No memory-cached object code,
								  # no .o7 file on disk, and
								  # the source code won't compile.
								  # Just give up:
								  #	
								  NULL;

							      THE object_code_cache_entry
								  =>
								  # Save object code in our
								  # cache, then return it:
								  #
								  {  object_code_cache
									 :=
									 bare_o7_map::set (
									     *object_code_cache,
									     bare_o7,
									     object_code_cache_entry
									 );

								     THE object_code_cache_entry;
								  };
							 esac
							 where
							     # Get object code for our sourcefile,
							     # by just reading it off disk if we can,
							     # by actually compiling it if we must:
							     #
							     fun load_else_compile_o7_file ()
								 =
								 # If anything goes wrong loading
								 # the .o7 file, we re/compile it.
								 #
								 # Compiling may mean compiling it
								 # in a subprocess, and if so, we
								 # must load the resulting .o7.
								 #
								 # If the second load also goes wrong,
								 # we recompile locally to gather error
								 # messages and make everything look
								 # "normal", which is to say local
								 # within this process:in-process:
								 #
								 load_else_compile_o7_file' (
								     announce_load,
								     compile_preferably_in_subprocess
								 )
								 where

								     # As a general policy, we avoid actually
								     # constructing symbol and inlining tables
								     # until we're sure we need them.
								     #
								     # We now definitely need the tables constituting
								     # the combined exports from our dependencies,
								     # so we go ahead and build them explicitly:
								     #
								     (symbol_and_inlining_tables_thunk ())
									 ->
									 { symbol_table, inlining_table };

								     # Unpack	some relevant information
								     # about the file to be compiled:
								     #
								     (bare_o7::attributes   bare_o7)
									 ->
									 { cross_module_inlining, extra_static_compile_dictionary, ... };


											# bare_o7		is from   src/app/make7/o7/bare-o7.pkg


								     # If an 'extra_static_compile_dictionary' was
								     # supplied, fold it into our symbol table.
								     #
								     # This is an obscure special-case hack used (only) in
								     #
								     #     src/app/make7/make-compiler/primordial-make7file.pkg
								     #
								     # where it serves to supply modules flagged as "primitive" in
								     #
								     #     src/lib/core/init/init.cmi
								     #
								     # with access to   primitives_symbol_table::primitives_symbol_table   from
								     #
								     #     src/lib/compiler/front/semantic/symbol-table/primitives-symbol-table.pkg
								     #
								     # which contains various foundation-of-the-universe things
								     # like 'Bool' which must be predefined in order to bootstrap
								     # everything else:
								     #
								     symbol_table
									 =
									 case extra_static_compile_dictionary
									   
									      NULL              =>  symbol_table;
									      THE symbol_table' =>  st::atop (symbol_table, symbol_table');
									 esac;


								     # We need compiled code for some "foo.pkg" sourcefile.
								     # If we've already compiled a matching "foo.pkg.o7"
								     # objectcode, just read it into memory, otherwise
								     # compile "foo.pkg" to to generate the required
								     # object code:
								     #	
								     fun load_else_compile_o7_file'
									     (
									       announce,	# A narration function to keep the guy at the console awake.
									       compile_it	# A function to re/compile the file -- either "compile" or "verbosely_compile_in_this_process".
									     )
									 =
									 case (load_oh7_file ())
									   
									      NULL => compile_it ();

									      THE (oh7_file_contents, creation_time, byte_sizes)
										  =>
										  {
										      object_code_cache_entry
											  =
											  oh7_file_contents_to_object_code_cache_entry (
											      oh7_file_contents,
											      creation_time,
											      symbol_table
											  );

										      contents_and_sizes
											  =
											  {   contents  => oh7_file_contents,
											      byte_sizes
											  };

										      if (object_code_cache_entry_is_usable
											     (
											       object_code_cache_entry,
											       picklehashes,
											       bare_o7
											     )
                                                                                      )

											   announce  byte_sizes;
											   cache_oh7_file_contents (bare_o7, contents_and_sizes);

											   THE object_code_cache_entry;
										      else
											    compile_it ();
										      fi;
										   };
									 esac
									 where
									     fun load_oh7_file ()
										  =
										  # A function to read the .o7 object-code file
										  # corresponding to our sourcefile, if it exists.
										  #
										  # On failure (usually because it doesn't exist) we return NULL.
										  # On success we return THE( oh7_file_contents, oh7_file_creation_time, oh7_file_bytesizes):
										  #
										  {   creation_time
											  =
											  time_stamp::last_file_modification_time
											      oh7_file_name;

												# time_stamp	is from   src/app/make7/paths/timestamp.pkg
												# binary_io	is from   src/lib/std/src/unix/posix-binary-io.pkg
										       #
										      fun open_o7_file ()
											  =
											  binary_io::open_for_read  oh7_file_name;


										      fun read_o7_file  stream
											  =
											  {   my { contents, byte_sizes }
												  =
												  ob::read { architecture_name,		# "ppc", "sparc" or "x86".
													     version,
													     stream
													   };

											      bare_o7::set_version
												  (bare_o7, ob::version_of contents);

											      (contents, creation_time, byte_sizes);
											  };

												  # bare_o7		is from   src/app/make7/o7/bare-o7.pkg
												  # safely		is from   src/lib/std/safely.pkg
												  # binary_io		is from   src/lib/std/src/unix/posix-binary-io.pkg

										      # Return NULL immediately if .o7 file is unreadable.
										      # This isn't strictly necessary, but avoids
										      # generating background failed-to-open-file
										      # errors that can be distracting when debugging:
										      #
										      if (not (winix::file::access
											         ( oh7_file_name,
												   [winix::file::MAY_READ]
										      )	  )   )

											   NULL;
										      else
											    # Our .o7 file looks readable,
											    # so go ahead and try to read it:
											    #
											    THE (
												safely::do {
												    open_it  =>  open_o7_file,
												    close_it =>  binary_io::close_input,
												    cleanup  =>  fn _ = ()
												}
												read_o7_file
											    )
											    except
												_ = NULL;
										      fi;
										  };                    
									 end;

								     #	
								     fun we_are_only_runnable_task ()
									 =
									 compile_client::all_idle ()
									 and
									 simple_thread::no_runnable_threads ();

											# servers		is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
											# thread		is from   src/app/make7/simple-concurrency/thread.pkg
											# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
											# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg
											# say			is from   src/lib/std/src/io/say.pkg
								     #	
								     fun verbosely_compile_in_this_process ()
									 =
									 {
									     sourcefile =  bare_o7::sourcepath  bare_o7;
									     sourcepath =  ad::os_string'  sourcefile;		# Full host-os filename for sourcefile to be compiled.

									     # List the source and object files to
									     # keep the guy at the console awake:
									     #
									     {   # Keep narrative verbosity down by maybe
										 # stripping the root directory prefix
										 # off of oh7_file_name before printing it:
										 #
										 root = (the (ad::get_anchor (ad::dictionary, "ROOT"))) + "/";
										 #
										 oh7_file_name
										     =
										     if   (string::is_prefix  root  oh7_file_name)
										         
											  string::extract (oh7_file_name, string::length root, NULL);
										     else
											  oh7_file_name;
										     fi;

										 file::vsay [
										     "      .../compile/compile-treewalk-g.pkg:   Compiling source file   ",
										     (string_conversion::pad_right ' ' 50 sourcepath),
										     "\tto object file   ",
										     oh7_file_name,
										     "\n"
										 ];
									     };

									     compile_in_this_process
                                                                                 (
                                                                                   symbol_table,
                                                                                   inlining_table,
                                                                                   picklehashes,
                                                                                   cross_module_inlining
                                                                                 );
									 };
								     #	
								     fun compile_in_subprocess' p
									 =
									 not (we_are_only_runnable_task ())
									 and   compile_in_subprocess p;

								     # Compile a sourcefile.
								     #
								     # If we have running compile server
								     # subprocesses, have one of them do
								     # the compile, so as to maybe get
								     # some parallelism on multicore machines.
								     #
								     # If we have no compile server
								     # subprocesses, then perforce we
								     # just do a vanilla compile within
								     # this process:
								     #
								     fun compile_preferably_in_subprocess ()
									 =
									 {
									     source_path
										 =
										 bare_o7::sourcepath  bare_o7;

									     winix::file::remove_file
										 oh7_file_name					# "foo.pkg.o7"
									     except
										 _ = ();

									     youngest := time_stamp::NO_TIMESTAMP;		# Set up to track most recent (known) edit of any sourcefile in the library.

								             if   (compile_in_subprocess' source_path)
									         
										  wait_for_nonzero_oh7_file_filesize ();	# Can this possibly make any sense?!
										  load_else_compile_o7_file'
										      ( announce_o7_receipt,
											verbosely_compile_in_this_process
										      );
									     else
										  verbosely_compile_in_this_process ();
									     fi
									     where
										 #
										 fun wait_for_nonzero_oh7_file_filesize ()
										     =
										     {   fun ready ()
											     =
											     (winix::file::file_size  oh7_file_name)  >  0
											     except
												  _ = FALSE;

											 # BUGGO XXX FIXME busy wait for file to appear;
											 # this is obviously very bad!

											 file::vsay ["[ENTERING BUSYWAIT LOOP]\n"];

											 for (not (ready ())) {
											     # This whole design sucks, obviously :(                             XXX BUGGO FIXME
											     #
											     # Also, one second is an awfully long
											     # time to sleep, but we apparently don't
											     # currently have a library call capable
											     # of waiting for less than a second
											     # (e.g., I can't find ML level access to
											     # select().                             XXX BUGGO FIXME
											     #
											     posix::sleep (time::from_seconds (large_int::from_int 1));	# A quick hack to ameliorate a spinwait loop.
											 };
											 file::vsay ["[EXITING BUSYWAIT LOOP]\n"];
										     };

											    # say	is from   src/lib/std/src/io/say.pkg
											    # winix	is from   src/lib/std/winix.pkg
									     end;
									 };			# fun compile_preferably_in_subprocess

								 end;			# fun load_else_compile_o7_file 

							 end;

						 end;

					     };						# Dependencies compiled ok.
				    esac;
				};								# fun compile_dependencies_then_sourcefile
                        end;
		    };							# fun compile_bare_o7 


		#
		fun compile_far_o7  make7_state  (node_thunk, _, _) 
		    =
                    compile_far_o7'  make7_state  (node_thunk ());
	    

		{   compile_near_o7,
		    compile_far_o7
		};
	    };                                        #  fun make_intra_library_dependency_graph_walker'

	# We have two levels of compile-dependency graphs,
	# one which records which complete libraries have
	# compile dependencies on which other complete
	# libraries, and then one per library recording
	# which individual sourcefiles have compile
	# dependencies upon other individual sourcefiles.
	#
	# Here we walk the library-level dependency graph
	# making libraries in post-order, so that each
	# library is compiled only after all the libraries
	# it needs have been compiled (making available the
	# relevant type declarations &tc):
	#
	fun walk_inter_library_dependency_graph (
                bare_o7_watcher,					#  A hook letting us notify the linker when we re/compile a file. 
		cache_oh7_file_contents,					#  A dummy or else oh7_file_cache::cache, which caches a copy in ram. 
		this_library as lg::LIBRARY  { o7_views_by_name, ... }
	    )
		=>
		{   symbol_and_inlining_tables,
		    all_libraries,
		    exports
			=>
			symbol_map::map					# symbol_map		is from   src/app/make7/util/symbolmap.pkg
			    make_export
			    o7_views_by_name
		}
                where

		    # As a heuristic to try and save wall-clock
		    # time when doing parallel makes on multicore
		    # machines, we try to compile first those
                    # sourcefiles on which many other sourcefiles
                    # depend, since doing so is most likely to
                    # open up opportunities to do multiple compiles
                    # in parallel:
                    #
		    priority_memo
			=
			memoize::memoize
                            .{   indegree::indegrees  this_library;   };

									# memoize	is from   src/app/make7/util/memoize.pkg
									# indegree	is from   src/app/make7/depend/indegree.pkg
		    #
		    fun get_priority  bare_o7
			=
			the_else (
                            bare_o7_map::get
                                ( priority_memo (),
                                  bare_o7
                                ),
			    0
			);


		    # Generate the intra-library treewalker lazily:
		    #
		    do_intra_library_treewalk
			=
			memoize::memoize
			   .{   .compile_far_o7
				    (   make_intra_library_dependency_graph_walker'
					    (bare_o7_watcher, cache_oh7_file_contents, get_priority)
				    );
                            };


		    # Accept an import_export_list. ("make7_state list"?)
		    # Return a symboltable-plus-inlining-dictionary combination
		    # which is the result of concurrently compiling everything
		    # on the input list and combining all the results.
		    #
		    fun concurrently_compile_import_exports
                            ( make7_state,
                              import_export_list
                            )
			=
			{
                            eo_cl							#  "export closure list"?          
				=
				map
                                    (fn import_export
                                        =
                                        simple_thread::make_simple_thread
                                            .{  do_intra_library_treewalk ()  make7_state  import_export;  }
                                    )
				    import_export_list;

			    eo  =
                                fold_left
                                    (layer_wait 0)
                                    (THE  empty_hashes_and_dictionaries)
                                    eo_cl;

			    case eo							# "eo" might have been "environment option", originally? Or "exports option"?
			      
				THE e =>  THE (e.symbol_and_inlining_tables_thunk ());

				NULL  =>  {   compile_client::reset  FALSE;		# compile_client	is from   src/app/make7/simple-concurrency/unix-compile-client.pkg
					      NULL;
					  };
			    esac;
			}
			except
			    ABORT =  {   compile_client::reset  FALSE;
                                         NULL;
                                     };

		    #
		    fun symbol_and_inlining_tables  make7_state
			=								# It returns all the info resulting from compiling a batch of libraries.
			concurrently_compile_import_exports
                            ( make7_state,
                              symbol_map::vals_list  o7_views_by_name			# 'o7_views_by_name' is walk_inter_library_dependency_graph(... library.o7_views_by_name )
                            );

											# symbol_map	is from   src/app/make7/util/symbolmap.pkg

		    #
		    fun all_libraries  make7_state
			=
			{   # A little helper function for collect().
			    # It takes an entry from a library.sublibraries list
			    # and adds the library to our libraries-left-to-do list.
			    #
			    # (The ignored first and third components of the
			    # first argtuple element are respectively a
			    # path naming the library and the set of anchor
			    # renamings for the library.)
			    #
			    fun add_library ((_, library_thunk
                                                              , _	# MUSTDIE
                                                              ), libraries_left)
				=
				library_thunk ()
                                !
                                libraries_left;


			    # all_exported_symbols() constructs a list of all .exports-ed symbols
			    # of a makefile/library node plus its direct and indirect sublibraries.
			    #
			    # First argument is the list of library graph nodes yet to process.
			    # Initially, this is just the root library of the .sublibraries tree.
			    #
			    # Second argument is the set of library graph nodes already processed,
			    # so we can avoid processing a given node more than once.
			    #
			    # Third argument is the accumulating result list of
			    # symbols exported via the library .exports lists. -- CrT
			    #
			    fun all_exported_symbols (                                         [],                _,   result_so_far)
				    =>
				    result_so_far;


				# Ignore bogus entries on left-to-do list:
				#
				all_exported_symbols (lg::ERROR_LIBRARY          ! libraries_left,   libraries_done,   result_so_far)
				    =>
				    all_exported_symbols (libraries_left, libraries_done, result_so_far);

							# source-path_set	is from   x


				all_exported_symbols (lg::LIBRARY library_record ! libraries_left,   libraries_done,   result_so_far)
				    =>
				    if (source_path_set::member
					   (
					     libraries_done,
					     library_record.library_path
					   )
				    )
			                 # Skip library -- already done it:
					 #
                                         all_exported_symbols ( libraries_left, libraries_done, result_so_far );
				    else
                                         all_exported_symbols (

                                             # Add all sublibraries of this lib to our left-to-do list:
					     #
                                             fold_left
                                                 add_library
                                                 libraries_left
                                                 library_record.sublibraries,

                                             # Remember we've processed this library:
					     #
					     source_path_set::add
                                                 (
                                                   libraries_done,
                                                   library_record.library_path
                                                 ),

                                             # Add all exports of this library to our results:
					     #
					     symbol_map::fold_left
                                                 (!)
                                                 result_so_far
                                                 library_record.o7_views_by_name
					 );
				    fi;
			    end;

			    exported_symbols_list
				=
				all_exported_symbols  ([this_library], source_path_set::empty, []);

			    not_null
                                (concurrently_compile_import_exports
                                    (make7_state, exported_symbols_list)
                                );
			};        			                            #  fun all_libraries 

		    #
		    fun make_export  ie  make7_state
			=
			case (do_intra_library_treewalk ()  make7_state  ie
                             except
                                 ABORT = NULL)
			  
			     NULL  =>  { compile_client::reset FALSE;   NULL; };
			     THE e =>  THE (e.symbol_and_inlining_tables_thunk ());
			esac;
		end;

	    walk_inter_library_dependency_graph (_, _, lg::ERROR_LIBRARY)
		=>
		{  symbol_and_inlining_tables =>   fn _ = NULL,
		   all_libraries              =>   fn _ = FALSE,
		   exports                    =>   symbol_map::empty
		};
        end;                                                               #  walk_inter_library_dependency_graph 


	#
	fun make_intra_library_dependency_graph_walker ()
            =
	    do_o7_treewalk
            where
                my { compile_near_o7, ... }
                    =
                    make_intra_library_dependency_graph_walker' (
                        fn _ = fn _ = (),
			fn _ = (),
			fn _ = 0 
		    );
		#
		fun do_o7_treewalk  o7  make7_state
                    =
                    {   r =  compile_near_o7  make7_state  o7
			     except
                                 ABORT = NULL;
		    
			if   (not_null r)
                             ();
			else compile_client::reset FALSE;  fi;

			r;
		    };
	    
	    end;

	#
	fun evict_stale ()
            =
            object_code_cache
                :=
                bare_o7_map::keyed_filter
                    (bare_o7::is_known o #1)
                    *object_code_cache;

	#
	fun evict_all ()
            =
            object_code_cache
                :=
                bare_o7_map::empty;

	#
	fun get_o7_exports  bare_o7
            =
            .o7_exports (
                the (
                    bare_o7_map::get
                        (*object_code_cache, bare_o7)
                )
            );
    };
end;










##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"				 	 #
# End:									 #
##########################################################################

