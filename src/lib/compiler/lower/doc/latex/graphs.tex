\section{The Graph Library}

\subsection{Overview}

Graphs are the most fundamental data package in the \MLRISC{} system,
and in fact in many optimizing compilers.
\MLRISC{} now contains an extensive library for working with graphs.

All graphs in \MLRISC{} 
are modeled as edge- and node-labeled directed multi-graphs.
Briefly, this means that nodes and edges can carry user supplied data, and  
multiple directed edges can be attached between any two nodes.
Self-loops are also allowed.

A node is uniquely identified by its \sml{node_id}, which is
simply an integer.  Node ids can be assigned externally 
by the user, or else generated automatically by a graph.  All graphs
keep track of all node ids that are currently used,
and the method \sml{new_id : Void -> node_id} generates a new unused id.

A node is modeled as a node id and node label pair, $(i,l)$.
An edge is modeled as a triple $i \edge{l} j$, which contains
the \newdef{source} and \newdef{target} node ids $i$ and $j$,
and the edge label $l$.  These types are defined as follows:
\begin{SML}
   type 'n node = node_id * 'n 
   type 'e edge = node_id * node_id * 'e
\end{SML}

\subsubsection{The graph api}

All graphs are accessed through an abstract interface
of the polymorphic type \sml{('n,'e,'g) graph}.
Here, \sml{'n} is the type of the node labels, \sml{'e} is the type
of the edge labels, and \sml{'g} is the type of any extra information
embedded in a graph.  We call the latter \sml{graph info}.

Formally, a graph $G$ is a quadruple $(V,L,E,I)$
where $V$ is a set of node ids, $L : V -> 'a$ is a node labeling
function from vertices to node labels, $E$ is a multi-set
of labeled-edges of type $V * V * 'e$, and $I: 'g$
is the graph info.

The interface of a graph is packaged into a 
record of methods that manipulate the base representation:  
\begin{SML}
 api \mlrischref{graph/graph.api}{GRAPH} = sig
   type node_id = int
   type 'n node = node_id * 'n 
   type 'e edge = node_id * node_id * 'e

   exception GRAPH of String
   exception SUBGRAPH        
   exception NOT_FOUND        
   exception UNIMPLEMENTED        
   exception READ_ONLY        

   enum graph ('n,'e,'g) = GRAPH of ('n,'e,'g) graph_methods
   withtype ('n,'e,'g) graph_methods = 
       \{  name            : String,
          graph_info      : 'g,
          #  selectors 
          #  mutators 
          #  iterators 
       \}
 end
\end{SML}

A few exceptions are predefined in this api, which have
the following informal interpretation.
Exception \sml{Graph} is raised when a bug is encountered.
The exception \sml{Subgraph} is raised if certain semantics constraints
imposed on a graph are violated.
The exception \sml{NOT_FOUND} is raised if lookup of a node id fails.
The exception \sml{UNIMPLEMENTED} is raised if a certain feature
is accessed but is undefined on the graph.  The exception 
\sml{READ_ONLY} is raised if the graph is readonly and an update operation
is attempted.

\subsubsection{Selectors}

Methods that access the package of a graph are listed below:
\begin{methods}
   nodes : Void -> $'n$ node list &
       Return a list of all nodes in a graph em \\
    edges : Void -> $'e$ edge list &
       Return a list of all edges in a graph \\
    order : Void -> int &
       Return the number of nodes in a graph.  The graph is empty
       if its order is zero \\
    size : Void -> int &
       Return the number of edges in a graph \\
    capacity : Void -> int & 
       Return the maximum node id in the graph, plus 1. 
       This can be used as a new id  \\
    next : node\_id -> node\_id list &
       Given a node id $i$, return the node ids of all its successors,
       i.e. $\{ j | i \edge{l} j \in E\}$. \\
    prior : node\_id -> node\_id list &
      Given a node id $j$, return the node ids of all its predecessors,
       i.e. $\{ i | i \edge{l} j \in E\}$. \\
    out\_edges : node\_id -> $'e$ edge list &
       Given a node id $i$, return all the out-going edges from node $i$, 
       i.e. all edges whose source is $i$. \\
    in\_edges : node\_id -> $'e$ edge list &
       Given a node id $j$, return all the in-coming edges from node $j$,
       i.e. all edges whose target is $j$. \\
    has\_edge : node\_id * node\_id -> Bool &
       Given two node ids $i$ and $j$, find out if an edge 
       with source $i$ and target $j$ exists. \\
    has\_node : node\_id -> Bool &
        Given a node id $i$, find out if a node of id $i$ exists. \\
    node\_info : node\_id -> $'n$ &
       Given a node id, return its node label.  If the node does not
       exist, raise exception \sml{NOT_FOUND}. \\
\end{methods}

\subsubsection{Graph hierarchy}

A graph $G$ may in fact be a subgraph of a \newdef{base graph} $G'$, or
obtained from $G'$ via some transformation $T$.
In such cases the following methods may be used to determine of the
relationship between $G$ and $G'$.  
An \newdef{entry edge} is an edge
in $G'$ that terminates at a node in $G$, but is not an edge in $G$.
Similarly, an \newdef{exit edge} is an edge in $G'$ that originates from
a node in $G$, but is not an edge in $G$.  An \newdef{entry node}
is a node in $G$ that has an incoming entry edge.  
An \newdef{exit node} is a node in $G$ that has an out-going exit edge.  
If $G$ is not
a subgraph, all these methods will return NIL.
\begin{methods}
    entries : Void -> node\_id list &
        Return the node ids of all the entry nodes. \\
    exits : Void -> node\_id list &
        Return the node ids of all the exit nodes. \\
    entry\_edges : node\_id -> $'e$ edge list &
       Given a node id $i$, return all the entry edges whose sources are
       $i$. \\
    exit\_edges : node\_id -> $'e$ edge list &
       Given a node id $i$, return all the exit edges whose targets are $i$.
\end{methods}

\subsubsection{Mutators}

Methods to update a graph are listed below:  
\begin{methods}
   new\_id : Void -> node\_id &
     Return a unique node id guaranteed to be
     absent in the current graph. \\
   add\_node : 'n node -> Void &
     Insert node into the graph.  If a node of the same node id
     already exists, replace the old node with the new. \\
   add\_edge : 'e edge -> Void & 
     Insert an edge into the graph. \\
   remove\_node : node\_id -> Void &
     Given a node id $n$, remove the node with the node id from the graph.
     This also automatically removes all edges with source or target $n$. \\
   set\_out\_edges : node\_id * 'e edge list -> Void &
      Given a node id $n$, and a list of edges $e_1,\ldots,e_n$
      with sources $n$, replace all out-edges of $n$ by $e_1,\ldots,e_n$. \\
   set\_in\_edges : node\_id * 'e edge list -> Void &
      Given a node id $n$, and a list of edges $e_1,\ldots,e_n$ 
      with targets $n$, replace all in-edges of $n$ by $e_1,\ldots,e_n$. \\
   set\_entries : node\_id list -> Void &
      Set the entry nodes of a graph. \\
   set\_exits : node\_id list -> Void &
      Set the exit nodes of a graph. \\
   garbage\_collect : Void -> Void &
      Reclaim all node ids of nodes that have been removed by 
     \sml{remove_node}.  Subsequent \sml{new_id} will reuse these
      node ids.  \\
\end{methods}

\subsubsection{Iterators}

Two primitive iterators are supported in the graph interface. 
Method \sml{forall_nodes} iterates over all the nodes in a graph,
while method \sml{forall_edges} iterates over all the edges.
Other more complex iterators can be found in other modules. 
\begin{methods}
 forall\_nodes : ($'n$ node -> Void) -> Void &
    Given a function $f$ on nodes, apply $f$ on all the nodes in the graph. \\
 forall\_edges : ($'e$ edge -> Void) -> Void &
    Given a function $f$ on edges, apply $f$ on all the edges in the graph.
\end{methods}

\subsubsection{Manipulating a graph}
 
Since operations on the graph type are packaged into
a record, an ``chunk oriented'' style of graph manipulation should be used.
For example, if \sml{G} is a graph chunk, then we can obtain all the
nodes and edges of \sml{G} as follows.
\begin{SML}
 my GRAPH g = G
 edges = g.edges ()
 nodes = g.nodes ()
\end{SML}
We can view \sml{g.edges} as sending the message to \sml{G}.
While all this seems like mere syntactic deviation from the usual
 api/package approach, there are two crucial differences which
we will exploit:
\emph{(i)} records are first ilk chunks 
while packages are not (consequently
late naming of ``methods'' and cannot be easily simulated on the
package level); \emph{(ii)} recursion
is possible on the type level, while recursive packages are not available.
The extra flexibility of this choice becomes apparent with the
introduction of views later. 

\subsubsection{Creating a Graph}

A graph implementation has the following api
\begin{SML}
 api \mlrischref{graph/graph-guts.api}{Graph_Guts} = sig
   my graph : String * 'g * int -> ('n,'e,'g) graph
 end
\end{SML}
The function \sml{graph} takes a string (the name of the graph),
graph info, and a default size as arguments and create an empty graph.

The generic package \sml{directed_graph}:
\begin{SML}
 generic package directed_graph(A : ARRAY_SIG) : Graph_Guts
\end{SML}
implements a graph using adjacency lists as internal representation.
It takes an array type as a parameter.  For graphs with
node ids that are dense enumerations, the \sml{DynamicArray} package
should be used as the parameter to this generic. 
The package \sml{directed_graph} is predefined as follows:
\begin{SML}
 package \mlrischref{graph/digraph.pkg}{directed_graph} = directed_graph(DynamicArray)
\end{SML}

For node ids that are sparse enumerations, the package \sml{sparse_rw_vector}, 
which implements integer-keyed hash tables
with the api of arrays, can be used
as argument to \sml{directed_graph}.  
For graphs with fixed sizes determined at creation time,
the package \sml{rw_vector} can be used (see also 
generic package \mlrischref{library/undoable-array.pkg}{\sml{UndoableArray}},
which creates arrays with undoable updates, and transaction-like semantics.)

\subsubsection{Basic Graph Algorithms}

\subsubsection{Depth-/Breath-First Search}

\begin{SML}
   my dfs : ('n,'e,'g) graph  ->
             (node_id -> Void) ->
             ('e edge -> Void) ->
             node_id list -> Void
\end{SML}
   The function \sml{dfs} takes as arguments a graph,
a function \sml{f : node_id -> Void}, a function 
\sml{g : 'e edge -> Void}, and a
set of source vertices.  It performs depth first search on the
graph.  The function \sml{f} is invoked 
whenever a new node is being visited, while the function \sml{g}
is invoked whenever a new edge is being traversed.
This algorithm has running time $O(|V|+|E|)$.

\begin{SML}
   my dfsfold : ('n,'e,'g) graph  ->
                 (node_id * 'a -> 'a) ->
                 ('e edge * 'b -> 'a) ->
                 node_id list -> 'a * 'b -> 'a * 'b
   my dfsnum :  ('n,'e,'g) graph  ->
                 (node_id * 'a -> 'a) ->
                 { dfsnum : int Rw_Vector, compnum : int Rw_Vector }
\end{SML}

   The function \sml{bfs} is similar to \sml{dfs}
except that breath first search is performed.
\begin{SML} 
   my bfs : ('n,'e,'g) graph  ->
             (node_id -> Void) ->
             ('e edge -> Void) ->
             node_id list -> Void
   my bfsdist : ('n,'e,'g) graph -> node_id list -> int Rw_Vector
\end{SML} 

\subsubsection{Preorder/Postorder numbering}
\begin{SML}
   my preorder_numbering  : ('n,'e,'g) graph -> int -> int Rw_Vector
   my postorder_numbering : ('n,'e,'g) graph -> int -> int Rw_Vector
\end{SML}  
   Both these functions take a tree $T$ and a root $v$, and return
the preorder numbering and the postorder numbering of the tree respectively. 

\subsubsection{Topological Sort}
\begin{SML}
  my topologicalSort : ('n,'e,'g) graph -> node_id list -> node_id list
\end{SML}
   The function 
\sml{topologicalSort} takes a graph $G$ and a set of source vertices $S$
as arguments.  It returns a topological sort of all the nodes reachable from
the set $S$.  
This algorithm has running time $O(|S|+|V|+|E|)$.

\subsubsection{Strongly Connected Components}
\begin{SML}
 my strong_components : ('n,'e,'g) graph -> 
   (node_id list * 'a -> 'a) -> 'a -> 'a
\end{SML}
   The function \sml{strong_components} takes a graph $G$ and
an aggregate function $f$ with type 
\begin{SML}
  node_id list * 'a -> 'a
\end{SML}
\noindent and an identity element \sml{x : 'a} as arguments.  
Function $f$ is invoked with a strongly connected component 
(represented as a list of node ids) as each is discovered.   
That is, the function \sml{strong_components} computes 

\[ 
   f(SCC_n,f(SCC_{n-1},\ldots, f(SCC_1,x)))
\] 

where $SCC_1,\ldots,SCC_n$ are the strongly connected components
in topological order.  This algorithm has running time $O(|V|+|E|)$.

\subsubsection{Biconnected Components}
\begin{SML}
 my biconnected_components : ('n,'e,'g) graph -> 
        ('e edge list * 'a -> 'a) -> 'a -> 'a
\end{SML}
   The function \sml{biconnected_components} takes a graph $G$ and
an aggregate function $f$ with type 
\begin{SML}
  'e edge list * 'a -> 'a
\end{SML}
\noindent and an identity element \sml{x : 'a} as arguments.  
Function $f$ is invoked with a biconnected component 
(represented as a list of edges) as each is discovered.
That is, the function \sml{biconnected_components} computes 

\[
   f(BCC_n,f(BCC_{n-1},\ldots, f(BCC_1,x))) 
\]

where $BCC_1,\ldots,BCC_n$ are the biconnected components.
This algorithm has running time $O(|V|+|E|)$.

\subsubsection{Cyclic Test}
\begin{SML}
 my is_cyclic : ('n,'e,'g) graph -> Bool
\end{SML}
Function \sml{is_cyclic} tests if a graph is cyclic.
This algorithm has running time $O(|V|+|E|)$.

\subsubsection{Enumerate Simple Cycles}
\begin{SML}
 my cycles : ('n,'e,'g) graph -> ('e edge list * 'a -> 'a) -> 'a ->'a
\end{SML}
  A simple cycle is a circuit that visits each vertex only once.
  The function \sml{cycles} enumerates all simple cycles in a graph $G$.
  It takes as argument an aggregate function $f$ of type 
  \begin{SML}
       'e edge list * 'a -> 'a
  \end{SML}
  and an identity element $e$, and computes as result the expression
  \[
     f(c_n,f(c_{n-1},f(c_{n-2},\ldots, f(c_1,e)))) 
  \]
  where $c_1,\ldots,c_n$ are all the simple cycles in the graph.   
  All cycles $c_1,\ldots,c_n$ are guaranteed to be distinct.  
  A cycle is represented as a sequence of
  adjacent edges, i.e. in the order of 
  \[ 
     v_1 -> v_2, v_2 -> v_3, v_3 -> v_4, \ldots, v_{n-1} -> v_n, v_n -> v_1 
  \]
  Our implementation works by first decomposing the graph into
  its strongly connected components, then uses backtracking to enumerate
  simple cycles in each component.
\subsubsection{Minimal Cost Spanning Tree}
\begin{SML}
 api \mlrischref{graph/spanning-tree.api}{Minimal_Cost_Spanning_Tree} = sig
   exception UNCONNECTED

   my spanning_tree : \{ weight    : 'e edge -> 'a,
                         <         : 'a * 'a -> Bool
                       \} -> ('n, 'e, 'g) graph
                         -> ('e edge * 'a -> 'a) -> 'a -> 'a
 end
 package \mlrischref{graph/kruskal.pkg}{kruskals_minimum_cost_spanning_tree} : Minimal_Cost_Spanning_Tree
\end{SML}

Package \sml{kruskals_minimum_cost_spanning_tree} implements kruskals_minimum_cost_spanning_tree's algorithm for
computing a minimal cost spanning tree of a graph.
The function \sml{spanning_tree} takes as arguments:
\begin{itemize}
\item a \sml{weight} function which when given an edge returns its weight
\item an ordering function \sml{<}, which is used to compare the weights
\item a graph $G$
\item an accumulator function $f$, and
\item an identity element $x$
\end{itemize}
The function \sml{spanning_tree} computes
\[
   f(e_{n},f(e_{n-1},\ldots, f(e_1,x))) 
\]

where $e_1,\ldots,e_n$ are the edges in a minimal cost spanning tree 
of the graph.
The exception \sml{UNCONNECTED} is raised if the graph is unconnected.

\subsubsection{Abelian Groups}
  Graph algorithms that deal with numeric weights or distances
are parameterized with respect to the apis
\sml{Abelian_Group} or \sml{Abelian_Group_With_Infinity}.
These are defined as follows:
\begin{SML}
 api \mlrischref{graph/groups.sig}{Abelian_Group} = sig 
   type elem 
   my +    : elem * elem -> elem
   my -    : elem * elem -> elem
   my      : elem -> elem
   my zero : elem
   my <    : elem * elem -> Bool
   my ==   : elem * elem -> Bool
 end
 api \mlrischref{graph/groups.sig}{Abelian_Group_With_Infinity} = sig
   include Abelian_Group
   my inf : elem
 end
\end{SML}
Api \sml{Abelian_Group} specifies an ordered commutative group,
while api \sml{Abelian_Group_With_Infinity} specifies an ordered commutative
group with an infinity element \sml{inf}. 

\subsubsection{Single Source Shortest Paths}
\begin{SML}
 api \mlrischref{graph/shortest-paths.api}{Single_Source_Shortest_Paths} = sig 
   package Num : Abelian_Group_With_Infinity
   my single_source_shortest_paths :
                 \{ graph : ('n,'e,'g) graph,
                   weight : 'e edge -> Num.elem,
                   s : node_id
                 \} ->
                 \{ dist : Num.elem Rw_Vector,
                   prior :  node_id Rw_Vector
                 \}
 end
 generic package \mlrischref{graph/dijkstra.pkg}{dijkstras_single_source_shortest_paths}(Num : Abelian_Group_With_Infinity) 
    : Single_Source_Shortest_Paths
\end{SML}
The generic package \sml{dijkstras_single_source_shortest_paths} implements Dijkstra's algorithm
for single source shortest paths.  The function \linebreak
\sml{single_source_shortest_paths} takes as arguments: 
\begin{itemize}
\item a graph $G$, 
\item a \sml{weight} function on edges, and
\item the source vertex $s$.
\end{itemize}
It returns two arrays \sml{dist} and \sml{prior}
indexed by vertices.  These arrays have the following
interpretation.  Given a vertex $v$,
\begin{itemize}
\item \sml{dist}[$v$] contains the distance of $v$ from the source $s$
\item \sml{prior}[$v$] contains the predecessor of $v$ in the shortest
path from $s$ to $v$, or -1 if $v=s$.
\end{itemize}

Dijkstra's algorithm fails to work on graphs that have
negative edge weights.  
To handle negative weights, Bellman-Ford's algorithm can be used. 
The exception \sml{NEGATIVE_CYCLE} is raised if a cycle of
negative total weight is detected.
\begin{SML}
 generic package \mlrischref{graph/bellman-ford.pkg}{bellman_fords_single_source_shortest_paths}(Num : Abelian_Group_With_Infinity) : sig
    include Single_Source_Shortest_Paths
    exception NEGATIVE_CYCLE
 end
\end{SML}
\subsubsection{All Pairs Shortest Paths}
\begin{SML}
 api \mlrischref{graph/shortest-paths.api}{All_Pairs_Shortest_Paths} = sig 
   package Num : Abelian_Group_With_Infinity
   my all_pairs_shortest_paths :
                 \{ graph : ('n,'e,'g) graph,
                   weight : 'e edge -> Num.elem
                 \} ->
                 \{ dist : Num.elem rw_matrix.Rw_Vector,
                   prior :  node_id rw_matrix.Rw_Vector
                 \}
 end
 generic package \mlrischref{graph/floyd-warshall.pkg}{floyd_warshals_all_pairs_shortest_path}(Num : Abelian_Group_With_Infinity) 
    : All_Pairs_Shortest_Paths
\end{SML}
The generic package \sml{floyd_warshals_all_pairs_shortest_path} implements Floyd-Warshall's algorithm
for all pairs shortest paths.  The function 
\sml{all_pairs_shortest_paths} takes as arguments: 
\begin{itemize}
\item a graph $G$, and
\item a \sml{weight} function on edges
\end{itemize}
It returns two 2-dimensional arrays \sml{dist} and \sml{prior}
indexed by vertices $(u,v)$.  These arrays have the following
interpretation.  Given a pair $(u,v)$,
\begin{itemize}
\item \sml{dist}[$u,v$] contains the distance from $u$ to $v$.
\item \sml{prior}[$u,v$] contains the predecessor of $v$ in the shortest
path from $u$ to $v$, or $-1$ if $u=v$.
\end{itemize}
This algorithm runs in time $O(|V|^3+|E|)$.

An alternative implementation is available that uses Johnson's algorithm, 
which works better for sparse graphs:
\begin{SML}
 generic package \mlrischref{graph/johnson.pkg}{johnsons_all_pairs_shortest_paths}(Num : Abelian_Group_With_Infinity) 
    : sig include All_Pairs_Shortest_Paths
          exception Negative Cycle
      end
\end{SML}

\subsubsection{Transitive Closure}
\begin{SML}
 api \mlrischref{graph/trans-closure.pkg}{Transitive_Closure} = sig
    my acyclic_transitive_closure : {  + : ('e * 'e -> 'e), simple : Bool }
        -> ('n,'e,'g) graph -> Void
    my acyclic_transitive_closure2 : 
       \{  + : 'e * 'e -> 'e,
          max : 'e * 'e -> 'e
       \}  -> ('n,'e,'g) graph -> Void
    my transitive_closure : ('e * 'e -> 'e) -> ('n,'e,'g) graph -> Void
 package \mlrischref{graph/trans-closure.pkg}{transitive_closure} : Transitive_Closure
\end{SML}
Package \sml{transitive_closure} implements
in-place transitive closures on graphs.   Three functions are implemented.
Functions \sml{acyclic_transitive_closure} and 
\sml{acyclic_transitive_closure2} can be used
to compute the transitive closure of an acyclic graph, whereas the
function \sml{transitive_closure} computes the transitive closure of
a cyclic graph.  All take a binary function 
\begin{SML}
  + : 'e * 'e -> 'e
\end{SML}
defined on edge labels.  
Transitive edges are inserted in the following manner:

\begin{itemize}
 \item \sml{acyclic_transitive_closure}:
   given $u \edge{l} v$ and $v \edge{l'} w$, 
if the flag \sml{simple} is false or if 
the transitive edge $u \rightarrow w$ does not exists,
then $u \edge{l + l'} w$ is added to the graph.
 \item \sml{acyclic_transitive_closure2}:
   given $u \edge{l} v$ and $v \edge{l'} w$, 
the transitive $u \edge{l + l'} w$ is added to the graph.
  Furthermore, all parallel edges 
\[ 
   u \edge{l_1} w, \ldots, u \edge{l_n} w 
\]
are coalesced into a single edge $u \edge{l} w$, where 
$l = {\tt max}_{i = 1 \ldots n} l_i$ 
\end{itemize}

\subsubsection{Max Flow}

   The function \sml{max_flow} computes the
maximum flow between the source vertex \sml{s} and the sink vertex
\sml{t} in the \sml{graph} when given a \sml{capacity} function. 
\begin{SML}
 api \mlrischref{graph/max-flow.api}{Maximum_Flow} = sig
   package Num : Abelian_Group
   my max_flow : \{ graph    : ('n,'e,'g) graph,
                    s        : node_id, 
                    t        : node_id, 
                    capacity : 'e edge -> Num.elem, 
                    flows    : 'e edge * Num.elem -> Void
                  \} -> Num.elem
 end
 generic package \mlrischref{graph/max-flow.pkg}{max_flow}(Num : Abelian_Group) : Maximum_Flow
\end{SML}
The function \sml{max_flow} returns its result in the follow manner:
The function returns the total flow as its result value.
Furthermore, the function \sml{flows} is called once for each edge $e$ in the
graph with its associated flow $f_e$.  

This algorithm uses Goldberg's preflow-push approach, and runs
in $O(|V|^2|E|)$ time.
\subsubsection{Min Cut}
   The function \sml{min_cut} computes the
minimum (undirected) cut in a \sml{graph} 
when given a \sml{weight} function on
its edges.  
\begin{SML}
 api \mlrischref{graph/min-cut.api}{Min_Cut} = sig
   package Num : Abelian_Group
   my min_cut : \{ graph    : ('n,'e,'g) graph,
                   weight : 'e edge -> Num.elem
                 \} -> node_id list * Num.elem
 end
 generic package \mlrischref{graph/min-cut.pkg}{min_cut}(Num : Abelian_Group) : Min_Cut
\end{SML}
The function \sml{min_cut} returns a list of node ids denoting
one side of the cut $C$ (the other side of the cut is $(V - C)$ and
the weight cut.

\subsubsection{Max Cardinality Matching}

\begin{SML}
   my matching : ('n,'e,'g) graph -> ('e edge * 'a -> 'a) -> 'a -> 'a * int
\end{SML}

The function \sml{bipartite_matching.matching} computes the
maximal cardinality matching of a bipartite graph.  As result, 
the function iterates over all the matched edges and returns the
number of matched edges.  The algorithm runs in time $O(|V||E|)$.

\subsubsection{Node Partition}
\begin{SML}
 api Node_Partition = sig 
   type 'n node_partition

   my node_partition : ('n,'e,'g) graph -> 'n node_partition
   my !!    : 'n node_partition -> node_id -> 'n node
   my ==    : 'n node_partition -> node_id * node_id -> Bool
   my union : 'n node_partition -> ('n node * 'n node -> 'n node) ->
                                        node_id * node_id -> Bool
   my union': 'n node_partition -> node_id * node_id -> Bool

 end
\end{SML}

\subsubsection{Node Priority Queue}
\begin{SML}
 api Node_Priority_Queue = sig 
   type node_priority_queue

   exception EMPTY_PRIORITY_QUEUE

   my create         : (node_id * node_id -> Bool) -> node_priority_queue
   my fromGraph      : (node_id * node_id -> Bool) -> 
      ('n,'e,'g) graph -> node_priority_queue
   my is_empty        : node_priority_queue -> Bool
   my clear          : node_priority_queue -> Void
   my min            : node_priority_queue -> node_id
   my deleteMin      : node_priority_queue -> node_id
   my decreaseWeight : node_priority_queue * node_id -> Void
   my insert         : node_priority_queue * node_id -> Void
   my toList         : node_priority_queue -> node_id list
 end
\end{SML}

\subsection{Views}\label{sec:views}
Simply put, a view is an alternative presentation
of a data package to a client.  A graph, such as the control flow
graph, frequently has to be presented in different ways in a compiler.  
For example, when global scheduling is applied on a region 
(a subgraph of the control_flow_graph),
we want to be able to concentrate on just the region and ignore all
nodes and edges that are not part of the current focus.  
All transformations that are applied on the current region view should be
automatically reflected back to the entire control_flow_graph as a whole.
Furthermore, we want to be able to freely intermix
graphs and subgraphs of the same type in our program, without having
to introducing sums in our type representations.

The \sml{subgraph_view} view combinator accomplishes this.  \sml{Subgraph}
takes a list of nodes and produces a graph chunk which is a view of the
node induced subgraph of the original graph.
All modification to the subgraph are automatically
reflected back to the original graph.  From the client point of view,
a graph and a subgraph are entirely indistinguishable, and furthermore,
graphs and subgraphs can be freely mixed together (they are the same
type from ML's point of view.)

This transparency is obtained by selective method overriding, composition,
and delegation.  For example, a generic graph chunk provides the
following methods for setting and looking up the entries and exits
from a graph.
\begin{SML}
   set_entries  : node_id list -> Void
   set_exits    : node_id list -> Void
   entries      : Void -> node_id list
   exits        : Void -> node_id list
\end{SML}

For example, a control_flow_graph usually has a single entry and a single exit.
These methods allow the client to destinate one node as the
entry and another as
the exit.  In the case of subgraph view, these methods are overridden so
that the proper conventions are preserved:
a node in a subgraph is an entry (exit) iff there is an in-edge (out-edge)
from (to) outside the (sub-)graph.
Similarly, the methods \sml{entry_edges} and \sml{exit_edges} can be used
return the entry and exit edges associated with a node in a subgraph.
\begin{SML}
   entry_edges  : node_id -> 'e edge list
   exit_edges   : node_id -> 'e edge list
\end{SML}
These methods are initially defined to return \sml{[]} in a graph and
subsequently overridden in a subgraph.

\subsubsection{ Update Transparency }

Suppose a view $G'$ is created from some base graphs or views.
\newdef{Update transparency} refers to the fact that 
$G'$ behaves
consistently according to its conventions and semantics when updates
are performed. There are 4 different type of update transparencies:
\begin{itemize}
\item\newdef{update opaque}  A update opaque view disallows updates to both
itself and its base graphs.
\item\newdef{globally update transparent} A globally update transparent
view allows updates to its base graphs but not to itself.  Changes
will then be automatically reflected in the view.
\item\newdef{locally update transparent}  A locally update transparent
view allows updates to itself but not to its base graphs.
Changes will be automatically reflected to the base graphs.
\item\newdef{fully update transparent}  A fully update transparent
view allows updates through its methods or through its base
graphs'.  
\end{itemize}

\subsubsection{Structural Views}\label{sec:structural-views}

\subsubsection{Reversal}
\begin{SML}
   my \mlrischref{graph/revgraph.pkg}{reversed_graph_view.rev_view} : ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
   This combinator takes a graph $G$ and produces a view $G^R$
which reverses the direction
of all its edges, including entry and exit edges.  Thus 
the edge $i \edge{l} j$ in $G$ becomes the edge
$j \edge{l} i$ in $G^R$.  This view is fully update transparent.

\subsubsection{Readonly}
\begin{SML}
   my \mlrischref{graph/readonly.pkg}{read_only_graph_view.readonly_view} : ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML} 
  This function takes a graph $G$ and produces a view $G'$
in which no mutator methods can be used.  Invoking a mutator
method raises the exception \sml{Readonly}.
This view is globally update transparent.

\subsubsection{Snapshot}
\begin{SML}
   generic package \mlrischref{graph/snap-shot.pkg}{graph_snap_shot}(GI : Graph_Guts) : Graph_Snapshot 
   api Graph_Snapshot = sig
      my snapshot : ('n,'e,'g) graph -> 
        \{ picture : ('n,'e,'g) graph, button : Void -> Void \}
   end
\end{SML}

The function \sml{snapshot} can be used to keep a cached copy
of a view a.k.a the \sml{picture}.    This cached copy
can be updated locally but the modification will not be reflected back
to the base graph.  The function \sml{button} can be used to
keep the view and the base graph up-to-date.

\subsubsection{Map}
\begin{SML}
   my \mlrischref{graph/isograph.pkg}{isomorphic_graph_view.map} :
     ('n node -> 'n') -> ('e edge -> 'e') -> ('g -> 'g') -> 
     ('n,'e,'g) graph -> ('n','e','g') graph
\end{SML}
The function \sml{map} is a generalization of the \sml{map}
function on lists.  It takes three functions 
\begin{SML}
f : 'n node -> 'n
g : 'e edge -> 'e
h : 'g -> g'
\end{SML}
and a graph $G=(V,L,E,I)$ as arguments.  
It computes the view $G'=(V,L',E',I')$ where
\begin{eqnarray*}
  L'(v) & = & f(v,L(v)) \mbox{\ for all $v \in V$} \\
  E'    & = & { i \edge{g(i,j,l)} j | i \edge{l} j \in E } \\
  I'    & = & h(I) 
\end{eqnarray*}

\subsubsection{Singleton}
\begin{SML}
   my \mlrischref{graph/singleton.pkg}{singleton_graph_view.singleton_view} : ('n,'e,'g) graph -> node_id -> ('n,'e,'g) graph
\end{SML}
Function \sml{singleton_view} 
takes a graph $G$ and a node id $v$ (which must exists in $G$)
and return an edge-free graph with only one node ($v$).
This view is opaque.

\subsubsection{Node id renaming}
\begin{SML}
   my \mlrischref{graph/renamegraph.pkg}{renamed_graph_view.rename_view} : int -> ('n,'e,'g) graph -> ('n','e','g') graph
\end{SML}
The function \sml{rename_view} takes an integer $n$ and
a graph $G$ and create a fully update transparent
view where all node ids are incremented by $n$.  Formally,
given graph $G=(V,E,L,I)$ it computes the view $G'=(V',E',L',I)$
where
\begin{eqnarray*}
   V' & = & { v + n | v \in V } \\
   E' & = & { i+n \edge{l} j+n | i \edge{l} j \in E } \\
   L' & = & \lambda v. L(v-n) 
\end{eqnarray*}

\subsubsection{Union and Sum}
\begin{SML}
   my \mlrischref{graph/uniongraph.pkg}{union_graph_view.union_view} : ('g * 'g') -> 'g'') ->
      ('n,'e,'g) graph * ('n,'e,'g') graph -> ('n','e','g'') graph
   graph_combination.unions : ('n,'e,'g) graph list -> ('n,'e,'g) graph
   graph_combination.sum : ('n,'e,'g) graph * ('n,'e,'g) graph -> ('n,'e,'g) graph
   graph_combination.sums : ('n,'e,'g) graph list -> ('n,'e,'g) graph
\end{SML}

Function \sml{union_view} takes as arguments
a function $f$, and two graphs
$G=(V,L,E,I)$ and $G'=(V',L',E',I')$, it computes the union $G+G'$ of
these graphs.  Formally, $G \union G'=(V'',L'',E'',I'')$ where
\begin{eqnarray*}
   V'' & = & V \union V' \\
   L'' & = & L \overrides L' \\
   E'' & = & E \union E' \\
   I'' & = & f(I,I')
\end{eqnarray*}

The function \sml{sum} constructs a \newdef{disjoint sum} of two
graphs.
\subsubsection{Simple Graph View}
\begin{SML}
  my \mlrischref{graph/simple-graph.pkg}{simple_graph.simple_graph} : (node_id * node_id * 'e list -> 'e) ->
   ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
  Function \sml{simple_graph} takes a merge function $f$ 
  and a multi-graph $G$ as arguments and return a view in which
  all parallel multi-edges (edges with the same source and target) are combined
  into a single edge: i.e. any collection of multi-edges between
  the same source $s$ and target $t$ and with labels $l_1,\ldots,l_n$, 
  are replaced by the edge $s \edge{l_{st}} t$ in the view, where
  $l_{st} = f(s,t,[l_1,\ldots,l_n])$.  The function $f$ is assumed
  to satisfy the equality $l = f(s,t,[l])$ for all $l$, $s$ and $t$.

\subsubsection{No Entry or No Exit} 
\begin{SML}
  my \mlrischref{graph/no-exit.pkg}{no_entry_view.no_entry_view} : ('n,'e,'g) graph -> ('n,'e,'g) graph
  no_entry_view.no_exit_view : ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}

The function \sml{no_entry_view} creates a view in which
all entry edges (and thus entry nodes) are removed.   The function
\sml{no_exit_view} is the dual of this and creates a view in which
all exit edges are removed.  This view is fully update transparent.
It is possible to remove all entry and exit edges by composing these
two functions.

\subsubsection{Subgraphs} 
\begin{SML}
   my \mlrischref{graph/subgraph.pkg}{subgraph_view.subgraph_view} : node_id list -> ('e edge -> Bool) -> 
     ('n,'e,'g) graph -> (n','e','g') graph
\end{SML}

   The function \sml{subgraph_view} takes as arguments a set of node ids
$S$, an edge predicate $p$ and a graph $G=(V,L,E,I)$.  It
returns a view in which only the visible nodes are $S$ and
the only visible edges $e$ are those that satisfy $p(e)$ and
with sources and targets in $S$.  $S$ must be a subset of $V$.

\begin{SML}
   my \mlrischref{graph/subgraph-p.pkg}{subgraph_p_view.subgraph_p_view} : node_id list -> 
     (node_id -> Bool) -> (node_id * node_id -> Bool) ->
     ('n,'e,'g) graph -> ('n','e','g') graph
\end{SML}

   The function \sml{subgraph_view} takes as arguments a set of node ids
$S$, a node predicate $p$, an edge predicate $q$ and a graph $G=(V,L,E,I)$.  It
returns a view in which only the visible nodes $v$ are those 
in $S$ satisfying $p(v)$, and
the only visible edges $e$ are those that satisfy $q(e)$ and
with sources and targets in $S$.  $S$ must be a subset of $V$.

\subsubsection{Trace}
\begin{SML}
   my \mlrischref{graph/trace-graph.pkg}{trace_view.trace_view} : node_id list -> ('n,'e,'g) graph -> ('n','e','g') graph
\end{SML}

\begin{wrapfigure}{r}{3in}
  \begin{Boxit}
  \psfig{figure=../pictures/eps/trace.eps,width=2.8in}
  \end{Boxit}
  \label{fig:trace-view}
  \caption{A trace view}
\end{wrapfigure}
A \newdef{trace} is an acyclic path in a graph.
The function \sml{trace_view} takes a trace of node ids
$v_1,\ldots,v_n$ and a graph $G$ and 
returns a view in which only the nodes are visible.
Only the edges that connected two adjacent nodes on the trace, i.e. 
$v_i -> v_{i+1}$ for some $i = 1 \ldots n-1$ are considered be within
the view.  Thus if there is an edge $v_i -> v_j$ in $G$ where
$j \ne i+1$ this edge is not considered to be within the view --- it
is considered to be an exit edge from $v_i$ and an entry edge
from $v_j$ however.  Trace views can be used to construct a control_flow_graph region
suitable for trace scheduling \cite{trace-scheduling,bulldog}.   

Figure \ref{fig:trace-view} illustrates this concept graphically.
Here, the trace view is formed from the
nodes \sml{A, C, D, F} and \sml{G}.  The
solid edges linking the trace is visible within the view.  All other
dotted edges are considered to be either entry of exit edges into
the trace.  The edge from node \sml{G} to \sml{A} is considered to
be both since it exits from \sml{G} and enters into \sml{A}.

\subsubsection{Acyclic Subgraph}
\begin{SML}
   my \mlrischref{graph/acyclic-graph.pkg}{acyclic_subgraph_view.acyclic_view} : 
     node_id list -> 
     ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
\begin{wrapfigure}{r}{3in}
  \begin{Boxit}
  \psfig{figure=../pictures/eps/subgraph.eps,width=2.8in}
  \end{Boxit}
  \label{fig:acyclic-subgraph-view}
  \caption{An acyclic subgraph}
\end{wrapfigure}
The function \sml{acyclic_view} takes an ordered
list of node ids $v_1,\ldots,v_n$ and a graph $G$ as arguments
and return a view $G'$ such that only the nodes $v_1,\ldots,v_n$
are visible.  In addition, only the edges with directions consistent
with the order list are considered to be within the view.
Thus an edge $v_i -> v_j$ from $G$ is in $G'$ iff $1 \le i < j \le n$.
Acyclic views can be used to construct a control_flow_graph region suitable
for DAG scheduling.
Figure \ref{fig:acyclic-subgraph-view} illustrates this concept graphically.

\subsubsection{Start and Stop}
\begin{SML}
   my \mlrischref{graph/start-stop.pkg}{start_stop_view.start_stop_view} :
     \{ start : 'n node,
        stop  : 'n node,
        edges : 'e edge list
     \} -> ('n,'e,'g) graph -> ('n','e','g') graph
\end{SML}

The function \sml{start_stop_view}

\subsubsection{Single-Entry/Multiple-Exits}
\begin{SML}
   \mlrischref{graph/seme.sml}{single_entry_multiple_exit.seme}
     exit : 'n node -> ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}

The function \sml{seme} converts a single-entry/multiple-exits 
graph $G$ into a single entry/single exit graph.
It takes an exit node $e$ and a graph $G$ and returns
a view $G'$.  Suppose $i \edge{l} j$ is an exit edge in $G$.
In view $G$ this edge is replaced by a new normal edge $i \edge{l} e$
and a new exit edge $e \edge{l} j$.  Thus $e$ becomes the sole exit
node in the new view.  

\subsubsection{Behavioral Views}

\subsubsection{Behavioral Primitives}

Figure \ref{fig:behavioral-view-primitives} lists
the set of behavioral primitives defined
in package \mlrischref{graph/wrappers.pkg}{\sml{graph_wrappers}}.  
These functions allow the user
to attach an action $a$ to a mutator method $m$ such that whenever $m$
is invoked so does $a$.  Given a graph $G$, the combinator 
\begin{SML}
   do_before_\(xxx\) : f -> ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
\noindent returns a view $G'$ such that whenever method $xxx$ is invoked
in $G'$, the function $f$ is called. 
Similarly, the combinator 
\begin{SML}
   do_after_\(xxx\) : f -> ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
\noindent creates a new view $G''$ such that the function $f$
is called after the method is invoked.
\begin{Figure}
\begin{boxit}
\begin{SML}
 do_before_new_id : (Void -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_new_id : (node_id -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_add_node : ('n node -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_add_node : ('n node -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_add_edge : ('e edge -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_add_edge : ('e edge -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_remove_node : (node_id -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_remove_node : (node_id -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph 
 do_before_set_in_edges : (node_id * 'e edge list -> Void) -> 
    ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_set_in_edges : (node_id * 'e edge list -> Void) -> 
    ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_set_out_edges : (node_id * 'e edge list -> Void) -> 
    ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_set_out_edges : (node_id * 'e edge list -> Void) -> 
    ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_set_entries : (node_id list -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_set_entries : (node_id list -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_before_set_exits : (node_id list -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
 do_after_set_exits : (node_id list -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}
\end{boxit}
\label{fig:behavioral-view-primitives} 
\caption{Behavioral view primitives}
\end{Figure}

Frequently it is not necessary to know precisely by which method a graph's
package has been modified, only that it is.  The following two methods
take a notification function $f$ and returns a new view.  $f$ is
invoked before a modification is attempted in a view created
by \sml{do_before_changed}.  It is invoked after the modification in
a view created by \sml{do_after_changed}.
\begin{SML}
   do_before_changed : (('n,'e,'g) graph -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
   do_after_changed : (('n,'e,'g) graph -> Void) -> ('n,'e,'g) graph -> ('n,'e,'g) graph
\end{SML}

Behavioral views created by the above functions are all fully update
transparent.
