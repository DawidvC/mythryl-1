#
# ffi_packager:
# 
# This library contains a bunch routines for repackaging 
# C-GLUE-MAKER generated code into more usable formats.
# Only "light" foreign functions are supported.
#
# Some useful features:
#
#   1. Rename functions, packages, and types to something else.
#   2. Generate a version of the function with labeled arguments.
#   3. Insert automatic type conversions.  
#   4. Convert call by REF arguments into call by value.
#
# Allen Leung (leunga@{ cs.nyu.edu, dorsai.org } )

local
   package ca = Ast      #  CKit 
   package cb = Namings #  CKit 
in

api Ffi_Packager =
api

   #  ------------------------------------------------------------------------
   #
   # ml_grinder is a library for transforming ML ast 
   # 
   #  ------------------------------------------------------------------------
   include Ml_Grinder  

   package s:  Set where type key::Key = String
   package m:  Map where type key::Key = String

   type ffi_info  #  represents information generated by C-GLUE-MAKER 
   type ffi_str   #  represents a package generated by C-GLUE-MAKER 
   type ffi_g    #  A ffi function 
   type ffi_param #  A parameter to a function 

   enum enum_info = 
       ENUM of { cty:      Ast::id, #  name of its type in C 
                members:   List( Ast::id * int32::Int ),
                rep:      REF(  Null_Or(  enum_rep ) )
              }
       #  How an enum is represented in ML
   and enum_rep = 
     ENUM_REP of { structName: Ast::id, ty: Ast::id, kind: enum_rep_kind }
   and enum_rep_kind = 
     ENUM_AS_INT  
   | ENUM_AS_DATATYPE of { toC: Ast::id, toML: Ast::id }
   withtype field = Ast::id * Ast::ty * ca::ctype * int32::Int Null_Or


   #  ------------------------------------------------------------------------
   #
   # A ffi_mode represents the mode of a parameter 
   # 
   #  ------------------------------------------------------------------------
   enum ffi_mode = INmode  #  input 
                     | OUTmode #  output 
                     | IOmode  #  input and output 
                     | IGNOREmode

   #  ------------------------------------------------------------------------
   #
   # This exception is raised if some function fails because some name
   # information in C is missing.
   #
   #  ------------------------------------------------------------------------
   exception MissingCname 

   #  ------------------------------------------------------------------------
   #
   # This exception is raised if some function cannot support certain
   # operation or transformation
   #
   #  ------------------------------------------------------------------------
   exception Unsupported 

   #  ------------------------------------------------------------------------
   #
   # Call the following function to initialize the module 
   # 
   #  ------------------------------------------------------------------------
   my init:  
       { indir: io::filename,   #  stuff generated by C-GLUE-MAKER 
        outdir: io::filename,  #  Directory for placing the new stuff 
        cfile: io::filename,   #  name of the .h file; input to C-GLUE-MAKER 
        cmfile: io::filename,  #  Cm file generated by C-GLUE-MAKER 
        undefinesdir: io::filename, # undefined packages are sent to this 
                                   # directory 

        filere: re::regexp,
        comment: List( String )
       } -> ffi_info

   my infile:  ffi_info * String -> io::filename
   my outfile:  ffi_info * String -> io::filename

   # ------------------------------------------------------------------------
   #
   # Write a declaration to a file
   #
   # ------------------------------------------------------------------------
   my write:  io::filename * List( String ) * Ast::decl -> Void

   # ------------------------------------------------------------------------
   #    
   # Write a declaration to the work directory specified in ffi_info
   #
   # ------------------------------------------------------------------------
   my writeFile:  ffi_info * io::filename * Ast::decl -> Void

   # ------------------------------------------------------------------------
   #    
   # Read a file from the input directory
   #
   # ------------------------------------------------------------------------
   my read_file:  ffi_info -> io::filename -> ffi_str
   
   # ------------------------------------------------------------------------
   # 
   # Enumerate files in the FFI directory by a regexp 
   # 
   # ------------------------------------------------------------------------
   my listFilesInDir:  String -> re::regexp -> List( io::filename )
   my listFiles:     ffi_info -> re::regexp -> List( io::filename )

   # ------------------------------------------------------------------------
   #
   # Extract C related information 
   #
   # ------------------------------------------------------------------------
   package c :
   api
      my cprog:     ffi_info -> ca::ast
      my tidtab:    ffi_info -> Tidtab::uidtab( cb::tidNaming )
      my tidName:   ffi_info -> ca::tid -> Ast::id 
      my allTypes:  ffi_info -> s::set

   end

   package c_type :
   api
      #  Type utilities 
      my * : ffi_info -> ca::ctype -> ca::ctype #  Dereference 
   end

   # ------------------------------------------------------------------------
   #
   # Parameters related functions
   #
   # ------------------------------------------------------------------------
   package parameter :
   api 
      my name:   ffi_param -> Ast::id
      my cname:  ffi_param -> Ast::id
      my cty:    ffi_param -> Ref( ca::ctype )
      my ty:     ffi_param -> Ref( Ast::ty )
      my mode:   ffi_param -> Ref( ffi_mode )
   end

   # ------------------------------------------------------------------------
   #
   # For mangling ML names:
   # 
   #   type names are like this:      type_name
   #   package names are like this:   TypeName
   #   api names are like this:       TYPE_NAME
   #   my names are anything you want.  The function will attach a '
   #   to all ML keywords.
   #
   # ------------------------------------------------------------------------
   package ml :
   api
      # These functions make up a legal identifier name 

      my typeName:  String -> String
      my strName:   String -> String
      my sigName:   String -> String
      my valName:   String -> String
   end

   # ------------------------------------------------------------------------
   #
   # CM file handling 
   #
   # ------------------------------------------------------------------------
   package cm :
   api
       #  Add to the file list of the CM file 
       my addImport:  ffi_info * String -> Void
       my addImport' : ffi_info * String * String -> Void

       #  Add to the export list of the CM file 
       my addExport:  ffi_info * String -> Void
       my add:        ffi_info * String * String -> Void
       my addDecl:    ffi_info * String * Ast::decl * String -> Void

       #  Write out the CM file 
       my writeFile:  ffi_info -> Void

       #  Reexport the packages from a file 
       my reexport:   ffi_info -> String -> Void

       #  Reinclude a file, but don't export its definitions 
       my reinclude:  ffi_info -> String -> Void
       my reinclude' : ffi_info * String -> String -> Void
   end

   # ------------------------------------------------------------------------
   #
   # Operations on an ffi function
   #
   # ------------------------------------------------------------------------
   package fn :
   api
          #  extract information 
      my info:     ffi_g -> ffi_info
      my cname:    ffi_g -> Ast::id              #  name in C 
      my name:     ffi_g -> Ref( Ast::id )       #  Current name 
      my ty:       ffi_g -> Ast::ty              #  Current type 
      my labTy:    ffi_g -> Ast::ty              #  Current type 
      my params:   ffi_g -> List( ffi_param )    #  All parameters 
      my args:     ffi_g -> List( ffi_param )    #  input parameters 
      my rets:     ffi_g -> List( ffi_param )    #  output parameters 
      my argPosOf: ffi_g -> Ast::id -> Int
      my retPosOf: ffi_g -> Ast::id -> Int
   
      my addInit:  ffi_g * Ast::decl -> Void
      my addCleanUp:  ffi_g * Ast::decl -> Void

      my genCode:  ffi_g -> Ast::decl #  generate code 
      my genSig:   ffi_g -> Ast::decl #  generate its api 
   end

   # ------------------------------------------------------------------------
   # 
   # The following combinators are used to specify 
   # transformations on ffi functions.
   #
   # ------------------------------------------------------------------------
   package tr :
   api

      # An 'action' is something which transforms a parameter
      # A  'condition' is something that checks whether an action applies
      # An 'transform' is something which transforms a ffi function.

      enum state = ST of { var: Ref( char ), opens: Ref( s::set ),
                              encoding: REF( (Ast::decl -> Ast::decl) ) }
      type data       = ffi_g * List( ffi_param ) * state
      type condition  = data -> Bool
      type action     = data -> Void
      type transform  = ffi_g * state -> ffi_g * state

      my newState:     Void -> state
      my newVar:       state -> String
      my addOpen:      state * String -> Void

          #  Attach a transformation 
      my declare:            ffi_info -> String -> transform -> Void
      my apply:              ffi_str -> ffi_g -> ffi_g
   end

   # ------------------------------------------------------------------------
   #
   # Operations on ffi_str 
   #
   # ------------------------------------------------------------------------
   package str :
   api
      my create:   ffi_info ->
                    { filename:  io::filename,
                      name:      Ast::id,
                      export:    Bool,
                      header:    List( Ast::decl ),
                      sign:      List( Ast::decl ),
                      abs:       Bool,
                      body:      List( Ast::decl )
                    } -> ffi_str
      my empty:    ffi_info ->
                    { filename:  io::filename,
                      name:      Ast::id
                    } -> ffi_str
 
      my genCode:  ffi_str -> Ast::decl  #  generate code 
      my write:    io::filename * ffi_str -> Void

      my fieldsOf:  ffi_info -> Ast::id -> List( field )

      #  extract information 
      my name:      ffi_str -> Ref( Ast::id )
      my header:    ffi_str -> Ref( List( Ast::decl ) )
      my body:      ffi_str -> Ref( List( Ast::decl ) ) #  Body of the package 
      my sign:      ffi_str -> Ref( List( Ast::decl ) ) #  Api 
      my abs:       ffi_str -> Ref( Bool )              #  Abstract constraint 
      my export:    ffi_str -> Ref( Bool )
      my cm_options:   ffi_str -> Ref( String )
      my isAnonymous:  ffi_str -> Bool            #  Anonymous struct? 

      #  filter out unnecessary stuff 
      my filterValFromSig:   (String -> Bool) -> ffi_str -> Void
      my filterTypeFromSig:  (String -> Bool) -> ffi_str -> Void
      my filterVal:          (String -> Bool) -> ffi_str -> Void
      my filterValDecl:      (Ast::id * Ast::exp -> Bool) -> ffi_str -> Void
      my filterType:         (String -> Bool) -> ffi_str -> Void

      #  Renaming 
      my renameTy:   (Ast::id -> Ast::id) -> ffi_str -> Void
      my renameVal:  (Ast::id -> Ast::id) -> ffi_str -> Void
      my renameFun:  (Ast::id -> Ast::id) -> ffi_str -> Void

      #  Insert stuff 
      my addToHeader:     ffi_str * Ast::decl -> Void
      my addToBodyFront:  ffi_str * Ast::decl -> Void
      my addToSig:        ffi_str * Ast::decl -> Void
      my addToBody:       ffi_str * Ast::decl -> Void
   end

   # ------------------------------------------------------------------------
   #
   # Operations on a f-files generated by ML_NLFFIGEN
   #
   # ------------------------------------------------------------------------
   package f_file :
   api

          # Make a version of the function which has all 
          # the type conversions applied. 
          # The function is named f by default

      my niceFunName:  REF(  Ast::id )
      my makeNiceFun:   ffi_str -> ffi_g
 
          /* Make a version of the function that has labeled arguments.
           * The function is named g by default
           */
      my labeledFunName:  REF(  Ast::id )
      my makeLabeledFun:   ffi_g -> ffi_g
   end

   # ------------------------------------------------------------------------
   #
   # Operations on a [su]-files generated by ML_NLFFIGEN 
   #
   # ------------------------------------------------------------------------
   package su_file :
   api

      #  Is it a C union? 
      my isStruct:  ffi_str -> Bool
      my isUnion:  ffi_str -> Bool

      #  The original C struct/union name 
      my cstructname:  ffi_str -> String

      #  Extract the fields of a struct/union 
      my fields:  ffi_str -> List( field )

      #  Create accessors and mutators expressions from a field 
      my accessor:          field -> Ast::id -> Ast::exp
      my mutator:           field -> Ast::id * Ast::id -> Ast::exp
      my makeAccessorFun:   ffi_str -> field -> ffi_g
      my makeMutatorFun:    ffi_str -> field -> ffi_g
      my makeAccessorFun' : ffi_str -> field -> Ast::decl
      my makeMutatorFun'  : ffi_str -> field -> Ast::decl
      my makeAccessor:      ffi_str -> field -> Ast::decl
      my makeMutator:       ffi_str -> field -> Ast::decl
      my makeConstructors:  ffi_str -> List( field ) -> Ast::decl
   end

   # ------------------------------------------------------------------------
   #
   # How to generate nice code for enums 
   #
   # ------------------------------------------------------------------------
   package enum :
   api

       type enum_info

       #  All enums in the program 
       my enums:  ffi_info -> List( enum_info )

       my lookup:  ffi_info -> ca::ctype -> Null_Or( enum_info )

       #  Its type name 
       my cty:    enum_info -> Ast::id    

       #  Its members 
       my members:  enum_info -> List( Ast::id * int32::Int )

       #  Are the enum values numbered consecutively from 0? 
       my isEnumeration:  enum_info -> Bool 

       #  Does the enum represent bits in a bit set? 
       my isBitSet:  enum_info -> Bool 
 
       # Emit my definitions for the enum.
       # This is the simplest strategy

       type enum_g = { info: ffi_info, structName: Ast::id, errorHandler: Ast::exp }
       my genEnumsAsInts:  enum_g -> enum_info -> Ast::decl

       # Emit a enum plus conversion functions between
       # the enum and the values.
       # This strategy is suitable for enumeration types.

       my genEnumsAsDatatype:  enum_g -> enum_info -> Ast::decl

       # Emit an enum.
       # The enum is assumed to be a bit mask and we use 
       # represent the enum as a list of enum values.

       my genEnumsAsDatatypeList:  enum_g -> enum_info -> Ast::decl

   end

   # ------------------------------------------------------------------------
   #
   # How to generate nice code for iptr 
   #
   # ------------------------------------------------------------------------
   package iptr :
   api
      my iptrs:  ffi_info -> List( Ast::id )
      my genCode:  ffi_info -> Void
   end

   #  ------------------------------------------------------------------------
   #
   # How to generate nice code for #defines 
   #
   #  ------------------------------------------------------------------------
   package define:  Define_Gen
 
end
end #  local 
