## draw-types.pkg
#
# Types of chunks that can be drawn on (or are pixel sources).

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6






###                    "The Universe is a grand book which cannot be read
###                     until one first learns to comprehend the language
###                     and become familiar with the characters in which
###                     it is composed.  It is written in the language of
###                     mathematics..."
###
###                                             -- Galilei Galileo  



stipulate
    include threadkit;				# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package g  =  geometry;			# geometry		is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    package xt =  xtypes;			# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package sn =  xsession;			# xsession		is from   src/lib/x-kit/xclient/src/window/xsession.pkg
    package di =  draw_imp;			# draw_imp		is from   src/lib/x-kit/xclient/src/window/draw-imp.pkg
    package pg =  pen_guts;			# pen_guts		is from   src/lib/x-kit/xclient/src/window/pen-guts.pkg
herein

    package draw_types: (weak) Draw_Types {		# Draw_Types		is from   src/lib/x-kit/xclient/src/window/draw-types.api


	#  An on-screen bitmap 
	#
	Window
	    =
	    WINDOW
	      {
		id:            xt::Window_Id,
		#
		screen:        sn::Screen,
		screen_depth:  sn::Screen_Depth_Imps,
		#
		draw_fn:       di::Draw_Mail -> Void
	      };

	#  An off-screen rectangular pixel array on X server:
	#
	Rw_Pixmap
	    =
	    RW_PIXMAP
	      {  
		id:            xt::Pixmap_Id,
		screen:        sn::Screen,
		size:          g::Size,
		screen_depth:  sn::Screen_Depth_Imps
	      };

	# Immutable pixmaps 
	#
	Ro_Pixmap = RO_PIXMAP  Rw_Pixmap;

	#  identity tests 

	fun same_window (   WINDOW { id=>id1, screen=>s1, ... },
			    WINDOW { id=>id2, screen=>s2, ... }   )
	    =
	   (id1 == id2) and sn::same_screen (s1, s2);

	fun same_rw_pixmap
            (
              RW_PIXMAP { id=>id1, screen=>s1, ... }, 
	      RW_PIXMAP { id=>id2, screen=>s2, ... }
            )
	    =
	    (id1 == id2) and sn::same_screen (s1, s2);

	fun same_ro_pixmap
	    (  RO_PIXMAP p1,
	       RO_PIXMAP p2
	    )
	    =
	    same_rw_pixmap (p1, p2);

	#  Sources for bitblt operations 
	Draw_From
	  = FROM_WINDOW          Window
	  | FROM_RW_PIXMAP    Rw_Pixmap
	  | FROM_RO_PIXMAP    Ro_Pixmap
	  ;

	fun depth_of_window                   (WINDOW { screen_depth=>sn::SCREEN_DEPTH_IMPS { depth, ... }, ... } )  = depth;
	fun depth_of_rw_pixmap             (RW_PIXMAP { screen_depth=>sn::SCREEN_DEPTH_IMPS { depth, ... }, ... } )  = depth;
	fun depth_of_ro_pixmap  (RO_PIXMAP (RW_PIXMAP { screen_depth=>sn::SCREEN_DEPTH_IMPS { depth, ... }, ... } )) = depth;

	fun depth_of_draw_src (FROM_WINDOW    w) =>  depth_of_window     w;
	    depth_of_draw_src (FROM_RW_PIXMAP w) =>  depth_of_rw_pixmap  w;
	    depth_of_draw_src (FROM_RO_PIXMAP w) =>  depth_of_ro_pixmap  w;
	end;

	fun shape_of_window (WINDOW { id, screen=>sn::SCREEN { xsession, ... }, ... } )
	    =
	    {   include value_to_wire;					# value_to_wire	is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
		include wire_to_value;					# wire_to_value	is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg

		reply = do_mailop
			    (sn::request_reply
				xsession
				(encode_get_geometry { drawable=>id } )
			    );

		my { depth, geometry=>g::WINDOW_FOOTPRINT { upperleft, size, border_width }, ... }
		    =
		    decode_get_geometry_reply reply;

		{ upperleft, size, depth, border_width };
	    };

	fun shape_of_rw_pixmap (RW_PIXMAP { size, screen_depth=>sn::SCREEN_DEPTH_IMPS { depth, ... }, ... } )
	    =
	    { upperleft => g::point_00,
	      size,
	      depth,
	      border_width => 0
	    };

	fun shape_of_ro_pixmap (RO_PIXMAP pm)
	    =
	    shape_of_rw_pixmap  pm;

	fun shape_of_draw_src (FROM_WINDOW w)       =>  shape_of_window     w;
	    shape_of_draw_src (FROM_RW_PIXMAP pm)   =>  shape_of_rw_pixmap  pm;
	    shape_of_draw_src (FROM_RO_PIXMAP (RO_PIXMAP pm)) =>  shape_of_rw_pixmap  pm;
	end;


	fun size_of_window window
	    =
	    {   my { size, ... }
		    =
		    shape_of_window window;

		size;
	    };


	fun size_of_rw_pixmap (RW_PIXMAP { size, ... } )
	    =
	    size;


	fun size_of_ro_pixmap (RO_PIXMAP pm)
	    =
	    size_of_rw_pixmap  pm;


	# drawables **
	#
	# these are abstract views of drawable chunks (e.g., windows or pixmaps).
	#
	Draw_Root
          #
          = DWIN    Window
          | DPM  Rw_Pixmap
          ;
	#
	Drawable_Window
	    =
	    DRAWABLE_WINDOW
	      {
		root:      Draw_Root,
		draw_fn:  di::Draw_Mail -> Void
	      };

	# Make a drawable from a window 
	#
	fun drawable_of_window (w as WINDOW { draw_fn, ... } )
	    =
	    DRAWABLE_WINDOW { root => DWIN w, draw_fn };


	# Make a drawable from a rw_pixmap 
	#
	fun drawable_of_rw_pixmap (pm as RW_PIXMAP { size, screen_depth=>sn::SCREEN_DEPTH_IMPS { draw_fn, ... }, ... } )
	    =
	    DRAWABLE_WINDOW { root => DPM pm, draw_fn=>draw_command' }
	    where 

		fun draw_command' (di::DMSG { to, pen, op => di::DOP_CLEAR_AREA (g::BOX { col, row, wide, high } ) } )
			=>
			{   fun clip (z, 0, max) =>   max - z;
				clip (z, w, max) =>   if  ( (z + w) > max   )   max - z;   else   w;   fi;
			    end;

			    my g::SIZE { wide => pm_wide,
					 high => pm_high
				       }
				=
				size;

			    to_box
				=
				g::BOX
				  { col,
				    row,
				    wide => clip (col, wide, pm_wide),
				    high => clip (row, high, pm_high)
				  };

			    draw_fn (di::DMSG {
				  to,
				  pen => pg::default_pen,
				  op  => di::DOP_POLY_FILL_BOX [ to_box ]
				} );

			    # The following is needed to
			    # avoid race between updating
			    # the rw_pixmap and using it as
			    # the source of a blt:
			    #
			    draw_fn di::DMSG_FLUSH;
			};

		    draw_command' dmsg
			=>
			draw_fn dmsg;
		end;
	    end;

	fun depth_of_drawable (DRAWABLE_WINDOW { root => DWIN w, ... } ) =>   depth_of_window      w;
	    depth_of_drawable (DRAWABLE_WINDOW { root => DPM pm, ... } ) =>   depth_of_rw_pixmap  pm;
	end;

	# An unbuffered drawable is used to provide immediate
	# graphical response to user interaction.  Currently
	# this is implemented by transparently adding a flush
	# command after each draw command. There is probably
	# a better way.
	#
	# This call is used in many of the src/lib/x-kit/tut
	# programs, for an example in:
	#
	#     src/lib/x-kit/tut/ml-viewer/util/get-mouse-selection.pkg
	#
	fun make_unbuffered_drawable (DRAWABLE_WINDOW { root as DWIN w, draw_fn } )
		=>
		DRAWABLE_WINDOW
		  {
		    root,
		    draw_fn =>   fn msg =  {   draw_fn  msg;
						draw_fn  di::DMSG_FLUSH;
					    }
		  };

	    make_unbuffered_drawable d
		=>
		d;
	end;

	# The following exception is raised
	# if an attempt is made to use a stale
	# overlay drawable (i.e., one that has been released).
	#
	exception STALE_OVERLAY;


	# Create a locked version of the given window.
	# This provides exclusive access to its drawing
	# surface (and that of its descendents) during
	# OP_XOR rubber-banding.  Usually used in conjunction
	# with unbuffered drawing (below).	
	# 
	# The first result is the locked window on which to draw,
	# the second is the unlock operation for the drawable.
	# By convention, the overlay drawable is unbuffered.
	#
	#
	# This call appears to be unused at present, but see
	# much related-looking "overlay" code in
	#     src/lib/x-kit/xclient/src/window/draw-imp.pkg
	# this may be a half-implemented idea.
	fun make_locked_window (w as WINDOW { draw_fn, ... } )
	    =
	    {

		release_1shot  = make_oneshot_maildrop ();

		new_draw_slot = make_mailslot ();

		# The draw command for the overlay.
		# It raises STALE_OVERLAY if called
		# after the overlay is released.

		error_mailop
		    =
		    get'  release_1shot
			==>
			.{   raise exception STALE_OVERLAY;   };

		fun draw_fn msg
		    =
		    select [
			give'  (new_draw_slot,  msg),
			error_mailop
		    ];

		fun draw_and_flush  msg
		    =
		    {   draw_fn  msg;
			draw_fn  di::DMSG_FLUSH;
		    };

		# The function used to release the overlay.
		# Multiple calls are allowed,
		# so we must handle WriteTwice.
		#
		fun release_fn ()
		    =
		    set (release_1shot, ())
		    except
			_ = ();

		draw_fn (
		    di::DMSG_MAKE_LOCKED_WINDOW
		     {
		       draw_slot => new_draw_slot,
		       release'  => get' release_1shot
		     }
		);

		{ drawable =>   DRAWABLE_WINDOW { root => DWIN w, draw_fn => draw_and_flush },
		  release  =>   release_fn
		};
	    };

    };	#  draw_types 
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
