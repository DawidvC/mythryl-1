## hash-cons-set.api

# Compiled by:
#     src/lib/hash-consing/hash-cons-lib.make6


# Finite sets of hash-consed values.

api Hash_Cons_Set {

     Chunk( X ) = hash_cons::Chunk( X );

     Set( X);

     empty:  Set( X );
	#  The empty set 

     singleton:  Chunk( X ) -> Set( X );
	#  Create a singleton set 

     add:   (Set( X ), Chunk( X )) -> Set( X );
     add' : ((Chunk( X ), Set( X ))) -> Set( X );
	#  Insert an item. 

     add_list:  (Set( X ), List( Chunk( X ) )) -> Set( X );
	#  Insert items from list. 

     delete:  (Set( X ), Chunk( X )) -> Set( X );
	#  Remove an item. Raise NOT_FOUND if not found. 

     member:  (Set( X ), Chunk( X )) -> Bool;
	#  Return TRUE if and only if item is an element in the set 

     is_empty:  Set( X ) -> Bool;
	#  Return TRUE if and only if the set is empty 

     equal:  ((Set( X ), Set( X ))) -> Bool;
	#  Return TRUE if and only if the two sets are equal 

     compare:  ((Set( X ), Set( X ))) -> Order;
	#  Does a lexical comparison of two sets 

     is_subset:  ((Set( X ), Set( X ))) -> Bool;
	#  Return TRUE if and only if the first set is a subset of the second 

     vals_count:  Set( X ) ->  Int;
	#  Return the number of items in the table 

     vals_list:  Set( X ) -> List( Chunk( X ) );
	#  Return an ordered list of the items in the set 

     union:  (Set( X ), Set( X )) -> Set( X );
        #  Union 

     intersection:  (Set( X ), Set( X )) -> Set( X );
        #  Intersection 

     difference:  (Set( X ), Set( X )) -> Set( X );
        #  Difference 

     map:  (Chunk( X ) -> Chunk( Y ) ) -> Set( X ) -> Set( Y );
	# Create a new set by applying a function to the elements
	# of the set.

     map_maybe_null_fn:  (Chunk( X ) -> Null_Or( Chunk( Y ) ) ) -> Set( X ) -> Set( Y );
	# Create a new set by applying a partial function to the elements
	# of the set.

     apply:  (Chunk( X ) -> Void) -> Set( X ) -> Void;
	# Apply a function to the entries of the set 
        # in decreasing order

     fold_left:  ((Chunk( X ), Y) -> Y) -> Y -> Set( X ) -> Y;
	# Apply a folding function to the entries of the set 
        # in increasing order

     fold_right:  ((Chunk( X ), Y) -> Y) -> Y -> Set( X ) -> Y;
	# Apply a folding function to the entries of the set 
        # in decreasing order

     partition:  (Chunk( X ) -> Bool) -> Set( X ) -> ((Set( X ), Set( X )));

     filter:  (Chunk( X ) -> Bool) -> Set( X ) -> Set( X );

     exists:  (Chunk( X ) -> Bool) -> Set( X ) -> Bool;

     find:  (Chunk( X ) -> Bool) -> Set( X ) -> Null_Or( Chunk( X ) );

};


## COPYRIGHT (c) 2001 Bell Labs, Lucent Technologies
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
