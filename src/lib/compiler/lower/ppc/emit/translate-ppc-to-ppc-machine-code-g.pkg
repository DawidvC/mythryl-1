## translate-ppc-to-ppc-machine-code-g.pkg
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "ppc/ppc.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/lower/make7/ppc.make6


# We are invoked from:
#
#     src/lib/compiler/codegen/ppc/ppc-codetree.pkg

generic package translate_ppc_to_ppc_machine_code_g (

    package instruction_set:  Instruction_Set_Ppc;				# Instruction_Set_Ppc	is from   src/lib/compiler/lower/ppc/instruction/instruction-set-ppc.api

    package codetree_eval
        :
        Codetree_Eval								# Codetree_Eval		is from   src/lib/compiler/lower/codetree/codetree-eval.api
        where codetree == instruction_set::codetree;

    package instruction_stream
	:
	Instruction_Stream; 							# Instruction_Stream	is from   src/lib/compiler/lower/instruction/instruction-stream.api

    package code_string:  Code_String;						# Code_String		is from   src/lib/compiler/lower/emit/code-string.api
)

: (weak)  Instruction_Emitter							# Instruction_Emitter	is from   src/lib/compiler/lower/emit/instruction-emitter.api

{
    package instruction_stream = instruction_stream;
    package instruction_set    = instruction_set;
    package cells              = instruction_set::cells;
    package codetree           = instruction_set::codetree;
    package constant           = instruction_set::constant;

    package i = instruction_set;
    package c = cells;
    package t = codetree;
    package s = instruction_stream;
    package p = s::pseudo_op;
    package w = unt32;								# unt32			is from   src/lib/std/unt32.pkg

    #  PPC is big endian 

    fun error msg
	=
	lowcode_error_message::error("PPCMC", msg);

    fun make_stream _
	=
	{   infix val  & | << >> >>> ;
	    #
	    (<<)  = w::(<<);
	    (>>)  = w::(>>);
	    (>>>) = w::(>>>);
	    (|)   = w::bitwise_or;
	    (&)   = w::bitwise_and;

	    itow  = w::from_int;

	    fun emit_bool FALSE => 0u0:  w::Unt;
	        emit_bool TRUE  => 0u1:  w::Unt;
            end;

	    emit_int = itow;

	    fun emit_word w = w;
	    fun emit_label l = itow (label::addr_of l);
	    fun emit_labexp le = itow (codetree_eval::value_of le);
	    fun emit_const c = itow (constant::value_of c);

	    loc = REF 0;

	    # Emit a byte:
 	    #	
	    fun e_byte b
		=
		{   i = *loc;
                    loc := i + 1;
                    code_string::update (i, b);
                };

	    # Emit the low order byte of a word. 
	    # Note: from_large_unt strips the high order bits! 
	    #
	    fun e_byte_w w
		=
		{   i = *loc;
		    loc := i + 1;
		    code_string::update (i, unt8::from_large_unt w);
		};

	    fun do_nothing _ = ();
	    fun fail _ = raise exception FAIL "MCEmitter";
	    fun get_notes () = error "get_notes";

	    fun emit_pseudo_op p_op
                =
                p::emit_value { p_op, loc=> *loc, emit=>e_byte };

	    fun begin_cluster n
                =
                {   code_string::init n;
                    loc := 0;
	        };


	    fun e_word32 w
		= 
		{   b8 = w;
		    w = w >> 0ux8;
		    b16 = w;
		    w = w >> 0ux8;
		    b24 = w;
		    w = w >> 0ux8;
		    b32 = w;

		   { e_byte_w b32; 
		     e_byte_w b24; 
		     e_byte_w b16; 
		     e_byte_w b8 ;
		   };
		};

	    fun emit_gp r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_fp r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_cc r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_spr r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_mem r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_ctrl r = itow (cells_basis::physical_register_num r)

	    also
	    fun emit_cellset r = itow (cells_basis::physical_register_num r);

	    fun emit_operand (i::REG_OP gp) => emit_gp gp;
		emit_operand (i::IMMED_OP int) => itow int;
		emit_operand (i::LABEL_OP labexp) => itow (codetree_eval::value_of labexp);
	    end 

	    also
	    fun emit_fcmp (i::FCMPO) => (0ux20:  unt32::Unt);
		emit_fcmp (i::FCMPU) => (0ux0:  unt32::Unt);
	    end 

	    also
	    fun emit_unary (i::NEG) => (0ux68:  unt32::Unt);
		emit_unary (i::EXTSB) => (0ux3ba:  unt32::Unt);
		emit_unary (i::EXTSH) => (0ux39a:  unt32::Unt);
		emit_unary (i::EXTSW) => (0ux3da:  unt32::Unt);
		emit_unary (i::CNTLZW) => (0ux1a:  unt32::Unt);
		emit_unary (i::CNTLZD) => (0ux3a:  unt32::Unt);
	    end 

	    also
	    fun emit_funary (i::FMR) => (0ux3f, 0ux48);
		emit_funary (i::FNEG) => (0ux3f, 0ux28);
		emit_funary (i::FABS) => (0ux3f, 0ux108);
		emit_funary (i::FNABS) => (0ux3f, 0ux88);
		emit_funary (i::FSQRT) => (0ux3f, 0ux16);
		emit_funary (i::FSQRTS) => (0ux3b, 0ux16);
		emit_funary (i::FRSP) => (0ux3f, 0uxc);
		emit_funary (i::FCTIW) => (0ux3f, 0uxe);
		emit_funary (i::FCTIWZ) => (0ux3f, 0uxf);
		emit_funary (i::FCTID) => (0ux3f, 0ux32e);
		emit_funary (i::FCTIDZ) => (0ux3f, 0ux32f);
		emit_funary (i::FCFID) => (0ux3f, 0ux34e);
	    end 

	    also
	    fun emit_farith (i::FADD) => (0ux3f, 0ux15);
		emit_farith (i::FSUB) => (0ux3f, 0ux14);
		emit_farith (i::FMUL) => (0ux3f, 0ux19);
		emit_farith (i::FDIV) => (0ux3f, 0ux12);
		emit_farith (i::FADDS) => (0ux3b, 0ux15);
		emit_farith (i::FSUBS) => (0ux3b, 0ux14);
		emit_farith (i::FMULS) => (0ux3b, 0ux19);
		emit_farith (i::FDIVS) => (0ux3b, 0ux12);
	    end 

	    also
	    fun emit_farith3 (i::FMADD) => (0ux3f, 0ux1d);
		emit_farith3 (i::FMADDS) => (0ux3b, 0ux1d);
		emit_farith3 (i::FMSUB) => (0ux3f, 0ux1c);
		emit_farith3 (i::FMSUBS) => (0ux3b, 0ux1c);
		emit_farith3 (i::FNMADD) => (0ux3f, 0ux1f);
		emit_farith3 (i::FNMADDS) => (0ux3b, 0ux1f);
		emit_farith3 (i::FNMSUB) => (0ux3f, 0ux1e);
		emit_farith3 (i::FNMSUBS) => (0ux3b, 0ux1e);
		emit_farith3 (i::FSEL) => (0ux3f, 0ux17);
	    end 

	    also
	    fun emit_bo (i::TRUE) => (0uxc:  unt32::Unt);
		emit_bo (i::FALSE) => (0ux4:  unt32::Unt);
		emit_bo (i::ALWAYS) => (0ux14:  unt32::Unt);

		emit_bo (i::COUNTER { eq_zero, cond } )
                    => 
		    case cond   
		       NULL =>  if (eq_zero)  0ux12;
			        else          0ux10;
                                fi;

		       THE cc
			   => 
			   case (eq_zero, cc)   
			     (FALSE, FALSE) => 0ux0;
			     (FALSE, TRUE) => 0ux8;
			     (TRUE, FALSE) => 0ux2;
			     (TRUE, TRUE) => 0uxa;
			   esac;
		    esac;
	    end 

	    also
	    fun emit_arith (i::ADD) => (0ux10a:  unt32::Unt);
		emit_arith (i::SUBF) => (0ux28:  unt32::Unt);
		emit_arith (i::MULLW) => (0uxeb:  unt32::Unt);
		emit_arith (i::MULLD) => (0uxe9:  unt32::Unt);
		emit_arith (i::MULHW) => (0ux4b:  unt32::Unt);
		emit_arith (i::MULHWU) => (0uxb:  unt32::Unt);
		emit_arith (i::DIVW) => (0ux1eb:  unt32::Unt);
		emit_arith (i::DIVD) => (0ux1e9:  unt32::Unt);
		emit_arith (i::DIVWU) => (0ux1cb:  unt32::Unt);
		emit_arith (i::DIVDU) => (0ux1c9:  unt32::Unt);
		emit_arith (i::AND) => (0ux1c:  unt32::Unt);
		emit_arith (i::OR) => (0ux1bc:  unt32::Unt);
		emit_arith (i::XOR) => (0ux13c:  unt32::Unt);
		emit_arith (i::NAND) => (0ux1dc:  unt32::Unt);
		emit_arith (i::NOR) => (0ux7c:  unt32::Unt);
		emit_arith (i::EQV) => (0ux11c:  unt32::Unt);
		emit_arith (i::ANDC) => (0ux3c:  unt32::Unt);
		emit_arith (i::ORC) => (0ux19c:  unt32::Unt);
		emit_arith (i::SLW) => (0ux18:  unt32::Unt);
		emit_arith (i::SLD) => (0ux1b:  unt32::Unt);
		emit_arith (i::SRW) => (0ux218:  unt32::Unt);
		emit_arith (i::SRD) => (0ux21b:  unt32::Unt);
		emit_arith (i::SRAW) => (0ux318:  unt32::Unt);
		emit_arith (i::SRAD) => (0ux31a:  unt32::Unt);
	    end 

	    also
	    fun emit_arithi (i::ADDI) => (0uxe:  unt32::Unt);
		emit_arithi (i::ADDIS) => (0uxf:  unt32::Unt);
		emit_arithi (i::SUBFIC) => (0ux8:  unt32::Unt);
		emit_arithi (i::MULLI) => (0ux7:  unt32::Unt);
		emit_arithi (i::ANDI_RC) => (0ux1c:  unt32::Unt);
		emit_arithi (i::ANDIS_RC) => (0ux1d:  unt32::Unt);
		emit_arithi (i::ORI) => (0ux18:  unt32::Unt);
		emit_arithi (i::ORIS) => (0ux19:  unt32::Unt);
		emit_arithi (i::XORI) => (0ux1a:  unt32::Unt);
		emit_arithi (i::XORIS) => (0ux1b:  unt32::Unt);
		emit_arithi (i::SRAWI) => error "SRAWI";
		emit_arithi (i::SRADI) => error "SRADI";
	    end 

	    also
	    fun emit_ccarith (i::CRAND) => (0ux101:  unt32::Unt);
		emit_ccarith (i::CROR) => (0ux1c1:  unt32::Unt);
		emit_ccarith (i::CRXOR) => (0uxc1:  unt32::Unt);
		emit_ccarith (i::CRNAND) => (0uxe1:  unt32::Unt);
		emit_ccarith (i::CRNOR) => (0ux21:  unt32::Unt);
		emit_ccarith (i::CREQV) => (0ux121:  unt32::Unt);
		emit_ccarith (i::CRANDC) => (0ux81:  unt32::Unt);
		emit_ccarith (i::CRORC) => (0ux1a1:  unt32::Unt);
	    end;

	    fun x_form { opcd, rt, ra, rb, xo, rc } = 
		{ rc = emit_bool rc;
		 e_word32 ((opcd << 0ux1a) + ((rt << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((xo << 0ux1) + rc)))));
		}
	    also
	    fun xl_form { opcd, bt, ba, bb, xo, lk } = 
		{ lk = emit_bool lk;
		 e_word32 ((opcd << 0ux1a) + ((bt << 0ux15) + ((ba << 0ux10) + ((bb << 0uxb) + ((xo << 0ux1) + lk)))));
		}
	    also
	    fun m_form { opcd, rs, ra, rb, mb, me, rc } = 
		{ rc = emit_bool rc;
		 e_word32 ((opcd << 0ux1a) + ((rs << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((mb << 0ux6) + ((me << 0ux1) + rc))))));
		}
	    also
	    fun a_form { opcd, frt, fra, frb, frc, xo, rc } = 
		{ rc = emit_bool rc;
		 e_word32 ((opcd << 0ux1a) + ((frt << 0ux15) + ((fra << 0ux10) + ((frb << 0uxb) + ((frc << 0ux6) + ((xo << 0ux1) + rc))))));
		}
	    also
	    fun loadx { rt, ra, rb, xop } = 
		{ rt = emit_gp rt;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((rt << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((xop << 0ux1) + 0ux7c000000))));
		}
	    also
	    fun loadd { opcd, rt, ra, d } = 
		{ rt = emit_gp rt;
		    ra = emit_gp ra;
		    d = emit_operand d;
		 e_word32 ((opcd << 0ux1a) + ((rt << 0ux15) + ((ra << 0ux10) + (d & 0uxffff))));
		}
	    also
	    fun loadde { opcd, rt, ra, de, xop } = 
		{ rt = emit_gp rt;
		    ra = emit_gp ra;
		    de = emit_operand de;
		 e_word32 ((opcd << 0ux1a) + ((rt << 0ux15) + ((ra << 0ux10) + (((de & 0uxfff) << 0ux4) + xop))));
		}
	    also
	    fun load { ld, rt, ra, d }
                = 
		case (d, ld)   
		  (i::REG_OP rb, i::LBZ) => loadx { rt, ra, rb, xop=>0ux57 };
		 (i::REG_OP rb, i::LBZE) => loadx { rt, ra, rb, xop=>0ux5f };
		 (i::REG_OP rb, i::LHZ) => loadx { rt, ra, rb, xop=>0ux117 };
		 (i::REG_OP rb, i::LHZE) => loadx { rt, ra, rb, xop=>0ux11f };
		 (i::REG_OP rb, i::LHA) => loadx { rt, ra, rb, xop=>0ux157 };
		 (i::REG_OP rb, i::LHAE) => loadx { rt, ra, rb, xop=>0ux15f };
		 (i::REG_OP rb, i::LWZ) => loadx { rt, ra, rb, xop=>0ux17 };
		 (i::REG_OP rb, i::LWZE) => loadx { rt, ra, rb, xop=>0ux1f };
		 (i::REG_OP rb, i::LDE) => loadx { rt, ra, rb, xop=>0ux31f };
		 (d, i::LBZ) => loadd { opcd=>0ux22, rt, ra, d };
		 (de, i::LBZE) => loadde { opcd=>0ux3a, rt, ra, de, xop=>0ux0 };
		 (d, i::LHZ) => loadd { opcd=>0ux28, rt, ra, d };
		 (de, i::LHZE) => loadde { opcd=>0ux3a, rt, ra, de, xop=>0ux2 };
		 (d, i::LHA) => loadd { opcd=>0ux2a, rt, ra, d };
		 (de, i::LHAE) => loadde { opcd=>0ux3a, rt, ra, de, xop=>0ux4 };
		 (d, i::LWZ) => loadd { opcd=>0ux20, rt, ra, d };
		 (de, i::LWZE) => loadde { opcd=>0ux3a, rt, ra, de, xop=>0ux6 };
		 (de, i::LDE) => loadde { opcd=>0ux3e, rt, ra, de, xop=>0ux0 };
		 (i::REG_OP rb, i::LHAU) => loadx { rt, ra, rb, xop=>0ux177 };
		 (i::REG_OP rb, i::LHZU) => loadx { rt, ra, rb, xop=>0ux137 };
		 (i::REG_OP rb, i::LWZU) => loadx { rt, ra, rb, xop=>0ux37 };
		 (d, i::LHZU) => loadd { opcd=>0ux29, rt, ra, d };
		 (d, i::LWZU) => loadd { opcd=>0ux21, rt, ra, d };
                esac

	    also
	    fun floadx { ft, ra, rb, xop } = 
		{ ft = emit_fp ft;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((ft << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((xop << 0ux1) + 0ux7c000000))));
		}
	    also
	    fun floadd { opcd, ft, ra, d } = 
		{ ft = emit_fp ft;
		    ra = emit_gp ra;
		    d = emit_operand d;
		 e_word32 ((opcd << 0ux1a) + ((ft << 0ux15) + ((ra << 0ux10) + (d & 0uxffff))));
		}
	    also
	    fun floadde { opcd, ft, ra, de, xop } = 
		{ ft = emit_fp ft;
		    ra = emit_gp ra;
		    de = emit_operand de;
		 e_word32 ((opcd << 0ux1a) + ((ft << 0ux15) + ((ra << 0ux10) + (((de & 0uxfff) << 0ux4) + xop))));
		}
	    also
	    fun fload { ld, ft, ra, d }
                = 
		case (d, ld)   
		  (i::REG_OP rb, i::LFS) => floadx { ft, ra, rb, xop=>0ux217 };
		 (i::REG_OP rb, i::LFSE) => floadx { ft, ra, rb, xop=>0ux21f };
		 (i::REG_OP rb, i::LFD) => floadx { ft, ra, rb, xop=>0ux257 };
		 (i::REG_OP rb, i::LFDE) => floadx { ft, ra, rb, xop=>0ux25f };
		 (i::REG_OP rb, i::LFDU) => floadx { ft, ra, rb, xop=>0ux277 };
		 (d, i::LFS) => floadd { ft, ra, d, opcd=>0ux30 };
		 (de, i::LFSE) => floadde { ft, ra, de, opcd=>0ux3e, xop=>0ux4 };
		 (d, i::LFD) => floadd { ft, ra, d, opcd=>0ux32 };
		 (de, i::LFDE) => floadde { ft, ra, de, opcd=>0ux3e, xop=>0ux6 };
		 (d, i::LFDU) => floadd { ft, ra, d, opcd=>0ux33 };
                esac

	    also
	    fun storex { rs, ra, rb, xop } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((xop << 0ux1) + 0ux7c000000))));
		}
	    also
	    fun stored { opcd, rs, ra, d } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    d = emit_operand d;
		 e_word32 ((opcd << 0ux1a) + ((rs << 0ux15) + ((ra << 0ux10) + (d & 0uxffff))));
		}
	    also
	    fun storede { opcd, rs, ra, de, xop } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    de = emit_operand de;
		 e_word32 ((opcd << 0ux1a) + ((rs << 0ux15) + ((ra << 0ux10) + (((de & 0uxfff) << 0ux4) + xop))));
		}
	    also
	    fun store { st, rs, ra, d }
                = 
		case (d, st)   
		  (i::REG_OP rb, i::STB) => storex { rs, ra, rb, xop=>0uxd7 };
		 (i::REG_OP rb, i::STBE) => storex { rs, ra, rb, xop=>0uxdf };
		 (i::REG_OP rb, i::STH) => storex { rs, ra, rb, xop=>0ux197 };
		 (i::REG_OP rb, i::STHE) => storex { rs, ra, rb, xop=>0ux19f };
		 (i::REG_OP rb, i::STW) => storex { rs, ra, rb, xop=>0ux97 };
		 (i::REG_OP rb, i::STWE) => storex { rs, ra, rb, xop=>0ux9f };
		 (i::REG_OP rb, i::STDE) => storex { rs, ra, rb, xop=>0ux39f };
		 (d, i::STB) => stored { rs, ra, d, opcd=>0ux26 };
		 (de, i::STBE) => storede { rs, ra, de, opcd=>0ux3a, xop=>0ux8 };
		 (d, i::STH) => stored { rs, ra, d, opcd=>0ux2c };
		 (de, i::STHE) => storede { rs, ra, de, opcd=>0ux3a, xop=>0uxa };
		 (d, i::STW) => stored { rs, ra, d, opcd=>0ux24 };
		 (de, i::STWE) => storede { rs, ra, de, opcd=>0ux3a, xop=>0uxe };
		 (de, i::STDE) => storede { rs, ra, de, opcd=>0ux3e, xop=>0ux8 };
                esac

	    also
	    fun fstorex { fs, ra, rb, xop } = 
		{ fs = emit_fp fs;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((fs << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((xop << 0ux1) + 0ux7c000000))));
		}
	    also
	    fun fstored { opcd, fs, ra, d } = 
		{ fs = emit_fp fs;
		    ra = emit_gp ra;
		    d = emit_operand d;
		 e_word32 ((opcd << 0ux1a) + ((fs << 0ux15) + ((ra << 0ux10) + (d & 0uxffff))));
		}
	    also
	    fun fstorede { opcd, fs, ra, de, xop }
		= 
		{   fs = emit_fp fs;
		    ra = emit_gp ra;
		    de = emit_operand de;

		    e_word32 ((opcd << 0ux1a) + ((fs << 0ux15) + ((ra << 0ux10) + (((de & 0uxfff) << 0ux4) + xop))));
		}

	    also
	    fun fstore { st, fs, ra, d }
		= 
		case (d, st)

		    (i::REG_OP rb, i::STFS ) => fstorex { fs, ra, rb, xop=>0ux297 };
		    (i::REG_OP rb, i::STFSE) => fstorex { fs, ra, rb, xop=>0ux29f };
		    (i::REG_OP rb, i::STFD ) => fstorex { fs, ra, rb, xop=>0ux2d7 };
		    (i::REG_OP rb, i::STFDE) => fstorex { fs, ra, rb, xop=>0ux2f7 };

		    (d,  i::STFS)            => fstored  { fs, ra, d,   opcd=>0ux34 };
		    (de, i::STFSE)           => fstorede { fs, ra, de, opcd=>0ux3e, xop=>0uxc };
		    (d,  i::STFD)            => fstored  { fs, ra, d,   opcd=>0ux36 };
		    (de, i::STFDE)           => fstorede { fs, ra, de, opcd=>0ux3e, xop=>0uxe };
		esac

	    also
	    fun unary' { ra, rt, oe, oper, rc }
		= 
		{   ra   = emit_gp ra;
		    rt   = emit_gp rt;
		    oe   = emit_bool oe;
		    oper = emit_unary oper;
		    rc   = emit_bool rc;

		    e_word32 ((ra << 0ux15) + ((rt << 0ux10) + ((oe << 0uxa) + ((oper << 0ux1) + (rc + 0ux7c000000)))));
		}
	    also
	    fun unary { ra, rt, oper, oe, rc }
		= 
		case oper

		    i::NEG =>   unary' { ra=>rt, rt=>ra, oper, oe, rc };
		    _      =>   unary' { ra,     rt,     oper, oe, rc };
		esac

	    also
	    fun arith' { rt, ra, rb, oe, oper, rc } = 
		{ rt = emit_gp rt;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		    oe = emit_bool oe;
		    oper = emit_arith oper;
		    rc = emit_bool rc;
		 e_word32 ((rt << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + ((oe << 0uxa) + ((oper << 0ux1) + (rc + 0ux7c000000))))));
		}
	    also
	    fun arithi' { oper, rt, ra, im } = 
		{ oper = emit_arithi oper;
		    rt = emit_gp rt;
		    ra = emit_gp ra;
		    im = emit_operand im;
		 e_word32 ((oper << 0ux1a) + ((rt << 0ux15) + ((ra << 0ux10) + (im & 0uxffff))));
		}
	    also
	    fun srawi { rs, ra, sh } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    sh = emit_operand sh;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + (((sh & 0ux1f) << 0uxb) + 0ux7c000670)));
		}
	    also
	    fun sradi' { rs, ra, sh, sh2 } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((sh2 << 0ux1) + 0ux7c000674))));
		}
	    also
	    fun sradi { rs, ra, sh } = 
		{ sh = emit_operand sh;
		 sradi' { rs, ra, sh=>(sh & 0ux1f), sh2=>((sh << 0ux5) & 0ux1) };
		}

	    also
	    fun arith { oper, rt, ra, rb, oe, rc }
                = 
		case oper   
		  (i::ADD | i::SUBF | i::MULLW | i::MULLD | i::MULHW | i::MULHWU | i::DIVW | i::DIVD | i::DIVWU | i::DIVDU) => 
		     arith' { oper, rt, ra, rb, oe, rc };
		 _ => arith' { oper, rt=>ra, ra=>rt, rb, oe, rc };
                esac

	    also
	    fun arithi { oper, rt, ra, im }
                =
		case oper   
		  (i::ADDI | i::ADDIS | i::SUBFIC | i::MULLI) => arithi' { oper, rt, 
		     ra, im };
		 i::SRAWI => srawi { rs=>ra, ra=>rt, sh=>im };
		 i::SRADI => sradi { rs=>ra, ra=>rt, sh=>im };
		 _ => arithi' { oper, rt=>ra, ra=>rt, im };
                esac

	    also
	    fun cmpl { bf, l, ra, rb } = 
		{ bf = emit_cc bf;
		    l = emit_bool l;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((bf << 0ux17) + ((l << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c000040))));
		}
	    also
	    fun cmpli { bf, l, ra, ui } = 
		{ bf = emit_cc bf;
		    l = emit_bool l;
		    ra = emit_gp ra;
		    ui = emit_operand ui;
		 e_word32 ((bf << 0ux17) + ((l << 0ux15) + ((ra << 0ux10) + ((ui & 0uxffff) + 0ux28000000))));
		}
	    also
	    fun cmp { bf, l, ra, rb } = 
		{ bf = emit_cc bf;
		    l = emit_bool l;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((bf << 0ux17) + ((l << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c000000))));
		}
	    also
	    fun cmpi { bf, l, ra, si } = 
		{ bf = emit_cc bf;
		    l = emit_bool l;
		    ra = emit_gp ra;
		    si = emit_operand si;
		 e_word32 ((bf << 0ux17) + ((l << 0ux15) + ((ra << 0ux10) + ((si & 0uxffff) + 0ux2c000000))));
		}
	    also
	    fun compare { cmp', bf, l, ra, rb }
                =
		case (cmp', rb)   
		  (i::CMP, i::REG_OP rb) => cmp { bf, l, ra, rb };
		  (i::CMPL, i::REG_OP rb) => cmpl { bf, l, ra, rb };
		  (i::CMP, si) => cmpi { bf, l, ra, si };
		  (i::CMPL, ui) => cmpli { bf, l, ra, ui };
                esac

	    also
	    fun fcmp { bf, fa, fb, cmp } = 
		{ bf = emit_cc bf;
		    fa = emit_fp fa;
		    fb = emit_fp fb;
		    cmp = emit_fcmp cmp;
		 e_word32 ((bf << 0ux17) + ((fa << 0ux10) + ((fb << 0uxb) + ((cmp << 0ux1) + 0uxfc000000))));
		}
	    also
	    fun funary { oper, ft, fb, rc } = 
		{ oper = emit_funary oper;
		    ft = emit_fp ft;
		    fb = emit_fp fb;

		   { 
	 ###line 455.12 "ppc/ppc::mdl"
		       my (opcd, xo) = oper;

		      case oper   

			(0ux3f, 0ux16) => a_form { opcd, frt=>ft, fra=>0ux0, frb=>fb, 
			   frc=>0ux0, xo, rc };

		        (0ux3b, 0ux16) => a_form { opcd, frt=>ft, fra=>0ux0, frb=>fb, 
			   frc=>0ux0, xo, rc };
		       _ => x_form { opcd, rt=>ft, ra=>0ux0, rb=>fb, xo, rc };
                      esac;

		   };
		}
	    also
	    fun farith { oper, ft, fa, fb, rc } = 
		{ ft = emit_fp ft;
		    fa = emit_fp fa;
		    fb = emit_fp fb;

		   { 
	 ###line 468.12 "ppc/ppc::mdl"
		       my (opcd, xo) = emit_farith oper;

		      (case oper   
			(i::FMUL | i::FMULS) => a_form { opcd, frt=>ft, fra=>fa, frb=>0ux0, 
			   frc=>fb, xo, rc };
		       _ => a_form { opcd, frt=>ft, fra=>fa, frb=>fb, frc=>0ux0, xo, 
			   rc }; esac
		      );
		   };
		}
	    also
	    fun farith3 { oper, ft, fa, fc, fb, rc } = 
		{ oper = emit_farith3 oper;
		    ft = emit_fp ft;
		    fa = emit_fp fa;
		    fc = emit_fp fc;
		    fb = emit_fp fb;

		   { 
	 ###line 477.12 "ppc/ppc::mdl"
		       my (opcd, xo) = oper;
		    a_form { opcd, frt=>ft, fra=>fa, frb=>fb, frc=>fc, xo, rc };
		   };
		}
	    also
	    fun cr_bit { cc } = 
		{ 
	 ###line 482.12 "ppc/ppc::mdl"
		    my (cr, bit) = cc;
		 ((emit_cc cr) << 0ux2) + (itow 
		   (case bit   
		     i::LT => 0;
		    i::GT => 1;
		    i::EQ => 2;
		    i::SO => 3;
		    i::FL => 0;
		    i::FG => 1;
		    i::FE => 2;
		    i::FU => 3;
		    i::FX => 0;
		    i::FEX => 1;
		    i::VX => 2;
		    i::OX => 3; esac
		   ));
		}
	    also
	    fun ccarith { oper, bt, ba, bb } = 
		{ oper = emit_ccarith oper;
		 xl_form { opcd=>0ux13, bt=>cr_bit { cc=>bt }, ba=>cr_bit { cc=>ba }, bb=>cr_bit { cc=>bb }, 
		      xo=>oper, lk=>FALSE };
		}
	    also
	    fun twr { to, ra, rb } = 
		{ to = emit_int to;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((to << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c000008)));
		}
	    also
	    fun twi { to, ra, si } = 
		{ to = emit_int to;
		    ra = emit_gp ra;
		    si = emit_operand si;
		 e_word32 ((to << 0ux15) + ((ra << 0ux10) + ((si & 0uxffff) + 0uxc000000)));
		}

	    also
	    fun tw { to, ra, si }
                =
		case si   
		  i::REG_OP rb => twr { to, ra, rb };
		  _ => twi { to, ra, si };
                esac

	    also
	    fun tdr { to, ra, rb } = 
		{ to = emit_int to;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((to << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c000088)));
		}
	    also
	    fun tdi { to, ra, si } = 
		{ to = emit_int to;
		    ra = emit_gp ra;
		    si = emit_operand si;
		 e_word32 ((to << 0ux15) + ((ra << 0ux10) + ((si & 0uxffff) + 0ux8000000)));
		}
	    also
	    fun td { to, ra, si }
                =
		case si   
		  i::REG_OP rb => tdr { to, ra, rb };
		 _ => tdi { to, ra, si };
                esac

	    also
	    fun mcrf { bf, bfa } = 
		{ bf = emit_cc bf;
		    bfa = emit_cc bfa;
		 e_word32 ((bf << 0ux17) + ((bfa << 0ux12) + 0ux4c000000));
		}
	    also
	    fun mtspr' { rs, spr } = 
		{ rs = emit_gp rs;
		 e_word32 ((rs << 0ux15) + ((spr << 0uxb) + 0ux7c0003a6));
		}
	    also
	    fun mtspr { rs, spr } = 
		{ spr = emit_spr spr;
		 mtspr' { rs, spr=>((spr & 0ux1f) << 0ux5) + ((spr << 0ux5) & 0ux1f) };
		}
	    also
	    fun mfspr' { rt, spr } = 
		{ rt = emit_gp rt;
		 e_word32 ((rt << 0ux15) + ((spr << 0uxb) + 0ux7c0002a6));
		}
	    also
	    fun mfspr { rt, spr } = 
		{ spr = emit_spr spr;
		 mfspr' { rt, spr=>((spr & 0ux1f) << 0ux5) + ((spr << 0ux5) & 0ux1f) };
		}
	    also
	    fun b { li, aa, lk } = 
		{ aa = emit_bool aa;
		    lk = emit_bool lk;
		 e_word32 (((li & 0uxffffff) << 0ux2) + ((aa << 0ux1) + (lk + 0ux48000000)));
		}
	    also
	    fun be { li, aa, lk } = 
		{ aa = emit_bool aa;
		    lk = emit_bool lk;
		 e_word32 (((li & 0uxffffff) << 0ux2) + ((aa << 0ux1) + (lk + 0ux58000000)));
		}
	    also
	    fun bc { bo, bi, bd, aa, lk } = 
		{ bo = emit_bo bo;
		    aa = emit_bool aa;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (((bd & 0ux3fff) << 0ux2) + ((aa << 0ux1) + (lk + 0ux40000000)))));
		}
	    also
	    fun bce { bo, bi, bd, aa, lk } = 
		{ bo = emit_bo bo;
		    aa = emit_bool aa;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (((bd & 0ux3fff) << 0ux2) + ((aa << 0ux1) + (lk + 0ux40000000)))));
		}
	    also
	    fun bclr { bo, bi, lk } = 
		{ bo = emit_bo bo;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (lk + 0ux4c000020)));
		}
	    also
	    fun bclre { bo, bi, lk } = 
		{ bo = emit_bo bo;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (lk + 0ux4c000022)));
		}
	    also
	    fun bcctr { bo, bi, lk } = 
		{ bo = emit_bo bo;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (lk + 0ux4c000420)));
		}
	    also
	    fun bcctre { bo, bi, lk } = 
		{ bo = emit_bo bo;
		    lk = emit_bool lk;
		 e_word32 ((bo << 0ux15) + ((bi << 0ux10) + (lk + 0ux4c000422)));
		}
	    also
	    fun rlwnm { rs, ra, sh, mb, me } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    sh = emit_gp sh;
		    mb = emit_int mb;
		    me = emit_int me;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((me << 0ux1) + 0ux5c000000)))));
		}
	    also
	    fun rlwinm { rs, ra, sh, mb, me } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		    me = emit_int me;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((me << 0ux1) + 0ux54000000)))));
		}
	    also
	    fun rldcl { rs, ra, sh, mb } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    sh = emit_gp sh;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + 0ux78000010))));
		}
	    also
	    fun rldicl { rs, ra, sh, mb, sh2 } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((sh2 << 0ux1) + 0ux78000000)))));
		}
	    also
	    fun rldcr { rs, ra, sh, mb } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    sh = emit_gp sh;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + 0ux78000012))));
		}
	    also
	    fun rldicr { rs, ra, sh, mb, sh2 } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((sh2 << 0ux1) + 0ux78000004)))));
		}
	    also
	    fun rldic { rs, ra, sh, mb, sh2 } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((sh2 << 0ux1) + 0ux78000008)))));
		}
	    also
	    fun rlwimi { rs, ra, sh, mb, me } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		    me = emit_int me;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((me << 0ux1) + 0ux50000000)))));
		}
	    also
	    fun rldimi { rs, ra, sh, mb, sh2 } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    mb = emit_int mb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((sh << 0uxb) + ((mb << 0ux6) + ((sh2 << 0ux1) + 0ux7800000c)))));
		}
	    also
	    fun rotate { oper, ra, rs, sh, mb, me } = 
		(case (oper, me)   
		  (i::RLWNM, THE me) => rlwnm { ra, rs, sh, mb, me };
		 (i::RLDCL, _) => rldcl { ra, rs, sh, mb };
		 (i::RLDCR, _) => rldcr { ra, rs, sh, mb };
		 _ => error "rotate"; esac
		)
	    also
	    fun rotatei { oper, ra, rs, sh, mb, me } = 
		{ sh = emit_operand sh;

		   (case (oper, me)   
		     (i::RLWINM, THE me) => rlwinm { ra, rs, sh, mb, me };
		    (i::RLWIMI, THE me) => rlwimi { ra, rs, sh, mb, me };
		    (i::RLDICL, _) => rldicl { ra, rs, sh=>(sh & 0ux1f), sh2=>((sh << 0ux5) & 0ux1), 
			mb };
		    (i::RLDICR, _) => rldicr { ra, rs, sh=>(sh & 0ux1f), sh2=>((sh << 0ux5) & 0ux1), 
			mb };
		    (i::RLDIC, _) => rldic { ra, rs, sh=>(sh & 0ux1f), sh2=>((sh << 0ux5) & 0ux1), 
			mb };
		    (i::RLDIMI, _) => rldimi { ra, rs, sh=>(sh & 0ux1f), sh2=>((sh << 0ux5) & 0ux1), 
			mb };
		    _ => error "rotatei"; esac
		   );
		}
	    also
	    fun lwarx { rt, ra, rb } = 
		{ rt = emit_gp rt;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((rt << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c000028)));
		}
	    also
	    fun stwcx { rs, ra, rb } = 
		{ rs = emit_gp rs;
		    ra = emit_gp ra;
		    rb = emit_gp rb;
		 e_word32 ((rs << 0ux15) + ((ra << 0ux10) + ((rb << 0uxb) + 0ux7c00012d)));
		};

	 ###line 578.7 "ppc/ppc::mdl"
	    fun relative (i::LABEL_OP lambda_expression) => (itow ((codetree_eval::value_of lambda_expression) - *loc)) >>> 0ux2;
	       relative _ => error "relative"; end;
		fun emitter instruction =
		{

	    fun emit_instruction (i::LL { ld, rt, ra, d, mem } ) => load { ld, rt, ra, d };
		emit_instruction (i::LF { ld, ft, ra, d, mem } ) => fload { ld, ft, ra, d };
		emit_instruction (i::ST { st, rs, ra, d, mem } ) => store { st, rs, ra, d };
		emit_instruction (i::STF { st, fs, ra, d, mem } ) => fstore { st, fs, ra, 
		    d };
		emit_instruction (i::UNARY { oper, rt, ra, rc, oe } ) => unary { oper, rt, 
		    ra, oe, rc };
		emit_instruction (i::ARITH { oper, rt, ra, rb, rc, oe } ) => arith { oper, rt, 
		    ra, rb, oe, rc };
		emit_instruction (i::ARITHI { oper, rt, ra, im } ) => arithi { oper, rt, ra, 
		    im };
		emit_instruction (i::ROTATE { oper, ra, rs, sh, mb, me } ) => rotate { oper, 
		    ra, rs, sh, mb, me };
		emit_instruction (i::ROTATEI { oper, ra, rs, sh, mb, me } ) => rotatei { oper, 
		    ra, rs, sh, mb, me };
		emit_instruction (i::COMPARE { cmp, l, bf, ra, rb } ) => compare { cmp'=>cmp, bf, 
		    l, ra, rb };
		emit_instruction (i::FCOMPARE { cmp, bf, fa, fb } ) => fcmp { cmp, bf, fa, 
		    fb };
		emit_instruction (i::FUNARY { oper, ft, fb, rc } ) => funary { oper, ft, fb, 
		    rc };
		emit_instruction (i::FARITH { oper, ft, fa, fb, rc } ) => farith { oper, ft, 
		    fa, fb, rc };
		emit_instruction (i::FARITH3 { oper, ft, fa, fb, fc, rc } ) => farith3 { oper, 
		    ft, fa, fb, fc, rc };
		emit_instruction (i::CCARITH { oper, bt, ba, bb } ) => ccarith { oper, bt, 
		    ba, bb };
		emit_instruction (i::MCRF { bf, bfa } ) => mcrf { bf, bfa };
		emit_instruction (i::MTSPR { rs, spr } ) => mtspr { rs, spr };
		emit_instruction (i::MFSPR { rt, spr } ) => mfspr { rt, spr };
		emit_instruction (i::LWARX { rt, ra, rb } ) => lwarx { rt, ra, rb };
		emit_instruction (i::STWCX { rs, ra, rb } ) => stwcx { rs, ra, rb };
		emit_instruction (i::TW { to, ra, si } ) => tw { to, ra, si };
		emit_instruction (i::TD { to, ra, si } ) => td { to, ra, si };
		emit_instruction (i::BC { bo, bf, bit, address, lk, fall } ) => bc { bo, bi=>cr_bit { cc=>(bf, 
		    bit) }, bd=>relative address, aa=>FALSE, lk };
		emit_instruction (i::BCLR { bo, bf, bit, lk, labels } ) => bclr { bo, bi=>cr_bit { cc=>(bf, 
		    bit) }, lk };
		emit_instruction (i::BB { address, lk } ) => b { li=>relative address, aa=>FALSE, lk };
		emit_instruction (i::CALL { def, uses, cuts_to, mem } ) => bclr { bo=>i::ALWAYS, bi=>0ux0, 
		    lk=>TRUE };
		emit_instruction (i::SOURCE { } ) => ();
		emit_instruction (i::SINK { } ) => ();
		emit_instruction (i::PHI { } ) => ();
	    end;

		     emit_instruction instruction;
		 };

	    fun emit_instruction (i::NOTE { instruction, ... } ) => emit_instruction  instruction;
		emit_instruction (i::BASE_INSTRUCTION i) => emitter i;
		emit_instruction (i::LIVE _)  => ();
		emit_instruction (i::DEAD _)  => ();
		emit_instruction _ => error "emit_instruction";
	    end;

	      s::STREAM { begin_cluster,
			  emit_pseudo_op,
			  emit=>emit_instruction,
			  end_cluster=>fail,
			  define_local_label => do_nothing,
			  define_global_label  => do_nothing,
			  emit_comment => do_nothing,
			  end_procedure  => do_nothing,
			  add_note     => do_nothing,
			  get_notes
			};
	};
};

