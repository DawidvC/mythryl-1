## xgeometry.api
#
# The api of the basic geometry types and operations.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6


###            "Life without geometry is pointless."

###            "Let no one ignorant of Geometry enter here."    -- Pythagoras





# This api is implemented in:
#
#     src/lib/x-kit/xclient/src/window/geometry.pkg

# Used in:
#     src/lib/x-kit/draw/band.pkg
#     src/lib/x-kit/draw/scan-convert.pkg


api Xgeometry {


    # Geometric types (from Xlib::h) 
    #
    Point =
	POINT
	  { row:  Int,
            col:  Int
          };

    Line =
	LINE (Point, Point);

    Size =
	SIZE
	  { wide:  Int,
            high:  Int
          };

    # Screen rectangles represented as
    # upper-left corner plus size.
    #
    # For two-corner box representation see
    #     src/lib/x-kit/draw/box2.pkg
    Box =
	BOX
	  { row:   Int,
	    col:   Int,
	    wide:  Int,
	    high:  Int
	  };

    Arc = ARC { row:  Int,
                col:  Int,

	        wide:  Int,
                high:  Int,

	        angle1:  Int,
                angle2:  Int
              };

    # The size and position of a window
    # relative to its parent.
    #
    # Note that position does not take
    # border_width into account.
    #
    Window_Site
	=
	WINDOW_SITE
	  {
	    upperleft:     Point,
	    size:          Size,
	    border_width:  Int		# In pixels.
	  };



    # Points: 
    #
    point_00:  Point;			# Point (0,0).

    row_coord_of_pt:  Point -> Int;
    col_coord_of_pt:  Point -> Int;

    scale_point:     (Int,   Point) -> Point;

    add_points:      (Point, Point) -> Point;
    subtract_points: (Point, Point) -> Point;

    point_ne:        (Point, Point) -> Bool;	# x1 != x2 or  y1 != y2.
    point_eq:        (Point, Point) -> Bool;	# x1 == x2 and y1 == y2.
    point_lt:        (Point, Point) -> Bool;	# x1 <  x2 and y1 <  y2.
    point_le:        (Point, Point) -> Bool;	# x1 <= x2 and y1 <= y2
    point_gt:        (Point, Point) -> Bool;	# x1 >  x2 and y1 >  y2
    point_ge:        (Point, Point) -> Bool;	# x1 >= x2 and y1 >= y2



    # Sizes:
    #
    add_size:   (Size, Size) -> Size;
    sub_size:   (Size, Size) -> Size;
    scale_size:  (Int, Size) -> Size;
    #
    add_size_to_pt:  (Point, Size) -> Point;
    limit_pt:        (Size, Point) -> Point;		# Clip point to be within box defined by point_00 and size, using orthogonal projection..



    # Boxes:
    #
    make_box:         (Point, Size) -> Box;
    upperleft_of_box:  Box -> Point;
    lowerright_of_box: Box -> Point;
    size_of_box:       Box -> Size;
    #
    upperleft_and_size_of_box:  Box -> (Point, Size);
    #
    clip_point:    (Box, Point) -> Point;		# Clip point to be within box, using orthogonal projection.
    translate:     (Box, Point) -> Box;			# box.upperleft += point.
    rtranslate:    (Box, Point) -> Box;			# box.upperleft -= point.
    intersect:     (Box, Box) -> Bool;			# TRUE iff the boxes overlap.

    exception INTERSECTION;
    intersection:  (Box,   Box) -> Box;			# Construct largest box contained by both input boxes.
    union:         (Box,   Box) -> Box;			# Construct smallest box containing  both input boxes.

    within:        (Point, Box) -> Bool;		# TRUE iff point is within box.
    inside:        (Box,   Box) -> Bool;		# TRUE iff fixt box is within second.

    bounding_box:   List(Point)  -> Box;		# Construct bounding box for given points.
							# Empty list returns BOX { col=>0, row=>0, wide=>0, high=>0 };
};


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
