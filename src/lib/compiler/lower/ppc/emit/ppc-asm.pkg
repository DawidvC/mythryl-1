/*
 * WARNING: This file was automatically generated by mdl_g (v3.0)
 * from the machine description file "ppc/ppc.mdl".
 * DO NOT EDIT this file directly
 */

# Compiled by:
#     src/lib/compiler/lower/make7/ppc.make6


# We are invoked by:
# 
#     src/lib/compiler/codegen/ppc/ppc-codetree.pkg

generic package ppc_asm_emitter_g (

    package instruction_stream
	:
	Instruction_Stream;					# Instruction_Stream	is from   src/lib/compiler/lower/instruction/instruction-stream.api

    package instruction_set
	:
	Instruction_Set_Ppc					# Instruction_Set_Ppc	is from   src/lib/compiler/lower/ppc/instruction/instruction-set-ppc.api
	where
            codetree
            ==
            instruction_stream::pseudo_op::codetree;

    package shuffle
	:
	Ppcshuffle						# Ppcshuffle		is from   src/lib/compiler/lower/ppc/instruction/ppc-shuffle.api
	where instruction_set == instruction_set;

    package codetree_eval
	:
	Codetree_Eval						# Codetree_Eval		is from   src/lib/compiler/lower/codetree/codetree-eval.api
	where codetree == instruction_set::codetree;
)

: (weak)  Instruction_Emitter					# Instruction_Emitter	is from   src/lib/compiler/lower/emit/instruction-emitter.api

{
    package instruction_stream =  instruction_stream;
    package instruction_set    =  instruction_set;
    package cells              =  instruction_set::cells;
    package codetree           =  instruction_set::codetree;
    package constant           =  instruction_set::constant;

    package i  = instruction_set;
    package c  = cells;
    package t  = codetree;
    package s  = instruction_stream;
    package p  = s::pseudo_op;


    include asm_flags;

    fun error msg
        =
        lowcode_error_message::error("ppc_asm_emitter_g", msg);

    fun make_stream format_annotations
	=
	{   stream = *asm_stream::asm_out_stream;

	    fun emit' s
                =
                file::write (stream, s);

	    newline = REF TRUE;
	    tabs = REF 0;

	    fun tabbing 0 => ();
	        tabbing n => { emit' "\t"; tabbing (n - 1);};
            end;

	    fun emit s = { tabbing *tabs; tabs := 0; newline := FALSE; emit' s;};
	    fun nl () = { tabs := 0; if (not *newline)  newline := TRUE;  emit' "\n";  fi; };
	    fun comma () = emit ", ";
	    fun tab () = tabs := 1;
	    fun indent () = tabs := 2;

	    fun ms n
                =
                {   s = int::to_string n;

		    if   (n < 0)
                         "-" + string::substring (s, 1, size s - 1);
		    else s;
                    fi;
		};

	    fun emit_label lab = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEL lab));
	    fun emit_labexp le = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEXP le));

	    fun emit_const c = emit (constant::to_string c);
	    fun emit_int i = emit (ms i);

	    fun paren f = { emit "("; f(); emit ")";};

	    fun define_local_label lab = emit (p::client::asm_pseudo_ops::define_local_label lab + "\n");
	    fun define_global_label lab = define_local_label lab;

	    fun emit_comment msg = { tab(); emit("/* " + msg + " */"); nl();};

	    fun add_note a = emit_comment (note::to_string a);
	    fun get_notes () = error "get_notes";

	    fun do_nothing _ = ();
	    fun fail _ = raise exception FAIL "AsmEmitter";

	    fun emit_region mem = emit_comment (i::region::to_string mem);

	    emit_region
                = 
	        if *show_region  emit_region;
                else             do_nothing;
                fi;

	    fun emit_pseudo_op p_op = { emit (p::to_string p_op); emit "\n";};
	    fun begin_cluster size  = { emit_comment("Code Size = " + ms size); nl();};

	    emit_cell_info
                =
                asm_formatting_utilities::reginfo
		    (emit, format_annotations);

	    fun emit_cell r
                =
                {   emit (cells_basis::to_string r);
                    emit_cell_info r;
                };

	    fun emit_cellset (title, cellset)
                =
	        {   nl();
                    emit_comment (title + cells_basis::cell_set::to_string cellset);
                };

	    emit_cellset
                = 
	        if *show_cellset  emit_cellset; else do_nothing;fi;

	    fun emit_defs cellset = emit_cellset("defs: ", cellset);
	    fun emit_uses cellset = emit_cellset("uses: ", cellset);

	    emit_cuts_to
                = 
	        if *show_cuts_to  asm_formatting_utilities::emit_cuts_to emit;
	        else              do_nothing;
                fi;

	    fun emitter instruction
		=
		{
		    fun asm_spr (i::XER) => "xer";
			asm_spr (i::LR) => "lr";
			asm_spr (i::CTR) => "ctr";
		    end 

		    also
		    fun emit_spr x
                        =
                        emit (asm_spr x)

		    also
		    fun emit_operand (i::REG_OP gp) => emit_cell gp;
		        emit_operand (i::IMMED_OP int) => emit_int int;
		        emit_operand (i::LABEL_OP labexp) => emit_labexp labexp;
                    end 

		    also
		    fun asm_load (i::LBZ) => "lbz";
			asm_load (i::LBZE) => "lbze";
			asm_load (i::LHZ) => "lhz";
			asm_load (i::LHZE) => "lhze";
			asm_load (i::LHA) => "lha";
			asm_load (i::LHAE) => "lhae";
			asm_load (i::LWZ) => "lwz";
			asm_load (i::LWZE) => "lwze";
			asm_load (i::LDE) => "lde";
			asm_load (i::LBZU) => "lbzu";
			asm_load (i::LHZU) => "lhzu";
			asm_load (i::LHAU) => "lhau";
			asm_load (i::LWZU) => "lwzu";
			asm_load (i::LDZU) => "ldzu";
                    end 

		    also
		    fun emit_load x = emit (asm_load x)

		    also
		    fun asm_store (i::STB) => "stb";
			asm_store (i::STBE) => "stbe";
			asm_store (i::STH) => "sth";
			asm_store (i::STHE) => "sthe";
			asm_store (i::STW) => "stw";
			asm_store (i::STWE) => "stwe";
			asm_store (i::STDE) => "stde";
			asm_store (i::STBU) => "stbu";
			asm_store (i::STHU) => "sthu";
			asm_store (i::STWU) => "stwu";
			asm_store (i::STDU) => "stdu";
                    end 

		    also
		    fun emit_store x = emit (asm_store x)

		    also
		    fun asm_fload (i::LFS) => "lfs";
			asm_fload (i::LFSE) => "lfse";
			asm_fload (i::LFD) => "lfd";
			asm_fload (i::LFDE) => "lfde";
			asm_fload (i::LFSU) => "lfsu";
			asm_fload (i::LFDU) => "lfdu";
                    end 

		    also
		    fun emit_fload x = emit (asm_fload x)

		    also
		    fun asm_fstore (i::STFS) => "stfs";
			asm_fstore (i::STFSE) => "stfse";
			asm_fstore (i::STFD) => "stfd";
			asm_fstore (i::STFDE) => "stfde";
			asm_fstore (i::STFSU) => "stfsu";
			asm_fstore (i::STFDU) => "stfdu";
                    end 

		    also
		    fun emit_fstore x = emit (asm_fstore x)

		    also
		    fun asm_cmp (i::CMP) => "cmp";
		        asm_cmp (i::CMPL) => "cmpl";
                    end 

		    also
		    fun emit_cmp x = emit (asm_cmp x)

		    also
		    fun asm_fcmp (i::FCMPO) => "fcmpo";
		        asm_fcmp (i::FCMPU) => "fcmpu";
                    end 

		    also
		    fun emit_fcmp x = emit (asm_fcmp x)

		    also
		    fun asm_unary (i::NEG) => "neg";
			asm_unary (i::EXTSB) => "extsb";
			asm_unary (i::EXTSH) => "extsh";
			asm_unary (i::EXTSW) => "extsw";
			asm_unary (i::CNTLZW) => "cntlzw";
			asm_unary (i::CNTLZD) => "cntlzd";
                    end 

		    also
		    fun emit_unary x = emit (asm_unary x)

		    also
		    fun asm_funary (i::FMR) => "fmr";
			asm_funary (i::FNEG) => "fneg";
			asm_funary (i::FABS) => "fabs";
			asm_funary (i::FNABS) => "fnabs";
			asm_funary (i::FSQRT) => "fsqrt";
			asm_funary (i::FSQRTS) => "fsqrts";
			asm_funary (i::FRSP) => "frsp";
			asm_funary (i::FCTIW) => "fctiw";
			asm_funary (i::FCTIWZ) => "fctiwz";
			asm_funary (i::FCTID) => "fctid";
			asm_funary (i::FCTIDZ) => "fctidz";
			asm_funary (i::FCFID) => "fcfid";
                    end 

		    also
		    fun emit_funary x = emit (asm_funary x)

		    also
		    fun asm_farith (i::FADD) => "fadd";
			asm_farith (i::FSUB) => "fsub";
			asm_farith (i::FMUL) => "fmul";
			asm_farith (i::FDIV) => "fdiv";
			asm_farith (i::FADDS) => "fadds";
			asm_farith (i::FSUBS) => "fsubs";
			asm_farith (i::FMULS) => "fmuls";
			asm_farith (i::FDIVS) => "fdivs";
                    end 

		    also
		    fun emit_farith x = emit (asm_farith x)

		    also
		    fun asm_farith3 (i::FMADD) => "fmadd";
			asm_farith3 (i::FMADDS) => "fmadds";
			asm_farith3 (i::FMSUB) => "fmsub";
			asm_farith3 (i::FMSUBS) => "fmsubs";
			asm_farith3 (i::FNMADD) => "fnmadd";
			asm_farith3 (i::FNMADDS) => "fnmadds";
			asm_farith3 (i::FNMSUB) => "fnmsub";
			asm_farith3 (i::FNMSUBS) => "fnmsubs";
			asm_farith3 (i::FSEL) => "fsel";
                    end 

		    also
		    fun emit_farith3 x = emit (asm_farith3 x)

		    also
		    fun asm_arith (i::ADD) => "add";
			asm_arith (i::SUBF) => "subf";
			asm_arith (i::MULLW) => "mullw";
			asm_arith (i::MULLD) => "mulld";
			asm_arith (i::MULHW) => "mulhw";
			asm_arith (i::MULHWU) => "mulhwu";
			asm_arith (i::DIVW) => "divw";
			asm_arith (i::DIVD) => "divd";
			asm_arith (i::DIVWU) => "divwu";
			asm_arith (i::DIVDU) => "divdu";
			asm_arith (i::AND) => "and";
			asm_arith (i::OR) => "or";
			asm_arith (i::XOR) => "xor";
			asm_arith (i::NAND) => "nand";
			asm_arith (i::NOR) => "nor";
			asm_arith (i::EQV) => "eqv";
			asm_arith (i::ANDC) => "andc";
			asm_arith (i::ORC) => "orc";
			asm_arith (i::SLW) => "slw";
			asm_arith (i::SLD) => "sld";
			asm_arith (i::SRW) => "srw";
			asm_arith (i::SRD) => "srd";
			asm_arith (i::SRAW) => "sraw";
			asm_arith (i::SRAD) => "srad";
                    end 

		    also
		    fun emit_arith x = emit (asm_arith x)

		    also
		    fun asm_arithi (i::ADDI) => "addi";
			asm_arithi (i::ADDIS) => "addis";
			asm_arithi (i::SUBFIC) => "subfic";
			asm_arithi (i::MULLI) => "mulli";
			asm_arithi (i::ANDI_RC) => "andi.";
			asm_arithi (i::ANDIS_RC) => "andis.";
			asm_arithi (i::ORI) => "ori";
			asm_arithi (i::ORIS) => "oris";
			asm_arithi (i::XORI) => "xori";
			asm_arithi (i::XORIS) => "xoris";
			asm_arithi (i::SRAWI) => "srawi";
			asm_arithi (i::SRADI) => "sradi";
                    end 

		    also
		    fun emit_arithi x = emit (asm_arithi x)

		    also
		    fun asm_rotate (i::RLWNM) => "rlwnm";
			asm_rotate (i::RLDCL) => "rldcl";
			asm_rotate (i::RLDCR) => "rldcr";
                    end 

		    also
		    fun emit_rotate x
                        =
                        emit (asm_rotate x)

		    also
		    fun asm_rotatei (i::RLWINM) => "rlwinm";
			asm_rotatei (i::RLWIMI) => "rlwimi";
			asm_rotatei (i::RLDICL) => "rldicl";
			asm_rotatei (i::RLDICR) => "rldicr";
			asm_rotatei (i::RLDIC) => "rldic";
			asm_rotatei (i::RLDIMI) => "rldimi";
                    end 

		    also
		    fun emit_rotatei x
                        =
                        emit (asm_rotatei x)

		    also
		    fun asm_ccarith (i::CRAND) => "crand";
			asm_ccarith (i::CROR) => "cror";
			asm_ccarith (i::CRXOR) => "crxor";
			asm_ccarith (i::CRNAND) => "crnand";
			asm_ccarith (i::CRNOR) => "crnor";
			asm_ccarith (i::CREQV) => "creqv";
			asm_ccarith (i::CRANDC) => "crandc";
			asm_ccarith (i::CRORC) => "crorc";
                    end 

		    also
		    fun emit_ccarith x
                        =
                        emit (asm_ccarith x)

		    also
		    fun asm_bit (i::LT) => "lt";
		       asm_bit (i::GT) => "gt";
		       asm_bit (i::EQ) => "eq";
		       asm_bit (i::SO) => "so";
		       asm_bit (i::FL) => "lt";
		       asm_bit (i::FG) => "gt";
		       asm_bit (i::FE) => "eq";
		       asm_bit (i::FU) => "un";
		       asm_bit (i::FX) => "lt";
		       asm_bit (i::FEX) => "gt";
		       asm_bit (i::VX) => "eq";
		       asm_bit (i::OX) => "so";
                    end 

		    also
		    fun emit_bit x
                        =
                        emit (asm_bit x);

		 # #line 608.7 "ppc/ppc::mdl"

		    fun emitx (s, i::REG_OP _)
                        =>
                        (if (((string::get (s, (size s) - 1)) == 'e'))
			        
			     emit (string::substring (s, 0, (size s) - 1)); 
			     emit "xe" ;
			   else 
			     emit s; 
			     emit "x" ;
                           fi);
		       emitx (s, _) => emit s; end;

		 # #line 614.7 "ppc/ppc::mdl"
		    fun e_oerc { oe=>FALSE, rc=>FALSE } => ();
			e_oerc { oe=>FALSE, rc=>TRUE } => emit ".";
			e_oerc { oe=>TRUE, rc=>FALSE } => emit "o";
			e_oerc { oe=>TRUE, rc=>TRUE } => emit "o.";
		    end;

		 # #line 618.7 "ppc/ppc::mdl"
		    fun e_rc FALSE => "";
		       e_rc TRUE => "."; end;

		 # #line 619.7 "ppc/ppc::mdl"
		    fun cr_bit (cr, bit) = (4 * (cells_basis::physical_register_num cr)) + 
			(case bit   
			  i::LT => 0;
			 i::GT => 1;
			 i::EQ => 2;
			 i::SO => 3;
			 i::FL => 0;
			 i::FG => 1;
			 i::FE => 2;
			 i::FU => 3;
			 i::FX => 0;
			 i::FEX => 1;
			 i::VX => 2;
			 i::OX => 3; esac
			);

		 # #line 626.7 "ppc/ppc::mdl"
		    fun e_crbit x = emit (int::to_string (cr_bit x));

		 # #line 627.7 "ppc/ppc::mdl"
		    fun e_lk TRUE => emit "l";
		       e_lk FALSE => (); end;

		 # #line 628.7 "ppc/ppc::mdl"
		    fun e_i (i::REG_OP _) => ();
		       e_i _ => emit "i"; end;

		 # #line 629.7 "ppc/ppc::mdl"
		    fun e_bi (bo, bf, bit) = 
			(case (bo, cells_basis::physical_register_num bf)   
			  (i::ALWAYS, _) => ();
			 (i::COUNTER { cond=>NULL, ... }, _) => ();
			 (_, 0) => emit (asm_bit bit);
			 (_, n) => emit ((("4*cr" + (int::to_string n)) + "+") + (asm_bit bit)); esac
			);

		 # #line 635.7 "ppc/ppc::mdl"
		    fun emit_bo bo = emit 
			case bo   
			  i::TRUE => "t";
			 i::FALSE => "f";
			 i::ALWAYS => "";
			 i::COUNTER { eq_zero, cond=>NULL }
                             =>
                             (eq_zero ?? "dz" :: "dnz");
			 i::COUNTER { eq_zero, cond=>THE cc }
                             =>
                             (eq_zero ?? "dz" :: "dnz")
                             +
                             (cc      ?? "t"  :: "f");
                        esac;


		 # #line 646.7 "ppc/ppc::mdl"
		    fun e_me (THE me) => 
			{ emit ", "; 
			  emit_int me ;};
		       e_me NULL => (); end;

		 # #line 649.7 "ppc/ppc::mdl"
		    fun address (ra, i::REG_OP rb) => 
			{ emit_cell ra; 
			  emit ", "; 
			  emit_cell rb ;};
		       address (ra, d) => 
			{ emit_operand d; 
			  emit "("; 
			  emit_cell ra; 
			  emit ")" ;}; end;
		    fun emit_instruction' instruction
			= 
			case instruction
			  
			    i::LL { ld, rt, ra, d, mem } => 
			    { emitx (asm_load ld, d); 
			      emit "\t"; 
			      emit_cell rt; 
			      emit ", "; 
			      address (ra, d); 
			      emit_region mem;
			    };
			   i::LF { ld, ft, ra, d, mem } => 
			    { emitx (asm_fload ld, d); 
			      emit "\t"; 
			      emit_cell ft; 
			      emit ", "; 
			      address (ra, d); 
			      emit_region mem ;};
			   i::ST { st, rs, ra, d, mem } => 
			    { emitx (asm_store st, d); 
			      emit "\t"; 
			      emit_cell rs; 
			      emit ", "; 
			      address (ra, d); 
			      emit_region mem ;};
			   i::STF { st, fs, ra, d, mem } => 
			    { emitx (asm_fstore st, d); 
			      emit "\t"; 
			      emit_cell fs; 
			      emit ", "; 
			      address (ra, d); 
			      emit_region mem ;};
			   i::UNARY { oper, rt, ra, rc, oe } => 
			    { emit_unary oper; 
			      e_oerc { rc, oe }; 
			      emit "\t"; 
			      emit_cell rt; 
			      emit ", "; 
			      emit_cell ra ;};
			   i::ARITH { oper, rt, ra, rb, rc, oe } => 
			    { emit_arith oper; 
			      e_oerc { rc, oe }; 
			      emit "\t"; 
			      emit_cell rt; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_cell rb ;};
			   i::ARITHI { oper, rt, ra, im } => 
			    { emit_arithi oper; 
			      emit "\t"; 
			      emit_cell rt; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_operand im ;};
			   i::ROTATE { oper, ra, rs, sh, mb, me } => 
			    { emit_rotate oper; 
			      emit "\t"; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_cell rs; 
			      emit ", "; 
			      emit_cell sh; 
			      emit ", "; 
			      emit_int mb; 
			      e_me me ;};
			   i::ROTATEI { oper, ra, rs, sh, mb, me } => 
			    { emit_rotatei oper; 
			      emit "\t"; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_cell rs; 
			      emit ", "; 
			      emit_operand sh; 
			      emit ", "; 
			      emit_int mb; 
			      e_me me ;};
			   i::COMPARE { cmp, l, bf, ra, rb } => 
			    { emit_cmp cmp; 
			      e_i rb; 
			      emit "\t"; 
			      emit_cell bf; 
			      emit ", "; 
			      emit (l ?? "1" :: "0"); 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_operand rb ;};
			   i::FCOMPARE { cmp, bf, fa, fb } => 
			    { emit_fcmp cmp; 
			      emit "\t"; 
			      emit_cell bf; 
			      emit ", "; 
			      emit_cell fa; 
			      emit ", "; 
			      emit_cell fb ;};
			   i::FUNARY { oper, ft, fb, rc } => 
			    { emit_funary oper; 
			      e_rc rc; 
			      emit "\t"; 
			      emit_cell ft; 
			      emit ", "; 
			      emit_cell fb ;};
			   i::FARITH { oper, ft, fa, fb, rc } => 
			    { emit_farith oper; 
			      e_rc rc; 
			      emit "\t"; 
			      emit_cell ft; 
			      emit ", "; 
			      emit_cell fa; 
			      emit ", "; 
			      emit_cell fb ;};
			   i::FARITH3 { oper, ft, fa, fb, fc, rc } => 
			    { emit_farith3 oper; 
			      e_rc rc; 
			      emit "\t"; 
			      emit_cell ft; 
			      emit ", "; 
			      emit_cell fa; 
			      emit ", "; 
			      emit_cell fb; 
			      emit ", "; 
			      emit_cell fc ;};
			   i::CCARITH { oper, bt, ba, bb } => 
			    { emit_ccarith oper; 
			      emit "\t"; 
			      e_crbit bt; 
			      emit ", "; 
			      e_crbit ba; 
			      emit ", "; 
			      e_crbit bb ;};
			   i::MCRF { bf, bfa } => 
			    { emit "mcrf\t"; 
			      emit_cell bf; 
			      emit ", "; 
			      emit_cell bfa ;};
			   i::MTSPR { rs, spr } => 
			    { emit "mt"; 
			      emit_cell spr; 
			      emit "\t"; 
			      emit_cell rs ;};
			   i::MFSPR { rt, spr } => 
			    { emit "mf"; 
			      emit_cell spr; 
			      emit "\t"; 
			      emit_cell rt ;};
			   i::LWARX { rt, ra, rb } => 
			    { emit "lwarx\t"; 
			      emit_cell rt; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_cell rb ;};
			   i::STWCX { rs, ra, rb } => 
			    { emit "stwcx.\t"; 
			      emit_cell rs; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_cell rb ;};
			   i::TW { to, ra, si } => 
			    { emit "tw"; 
			      e_i si; 
			      emit "\t"; 
			      emit_int to; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_operand si ;};
			   i::TD { to, ra, si } => 
			    { emit "td"; 
			      e_i si; 
			      emit "\t"; 
			      emit_int to; 
			      emit ", "; 
			      emit_cell ra; 
			      emit ", "; 
			      emit_operand si ;};
			   i::BC { bo, bf, bit, address, lk, fall } => 
			    { emit "b"; 
			      emit_bo bo; 
			      e_lk lk; 
			      emit "\t"; 
			      e_bi (bo, bf, bit); 
			      emit ", "; 
			      emit_operand address ;};
			   i::BCLR { bo, bf, bit, lk, labels } => 
			    { emit "b"; 
			      emit_bo bo; 
			      emit "lr"; 
			      e_lk lk; 
			      emit "\t"; 
			      e_bi (bo, bf, bit);};
			   i::BB { address, lk } => 
			    { emit "b"; 
			      e_lk lk; 
			      emit "\t"; 
			      emit_operand address ;};
			   i::CALL { def, uses, cuts_to, mem } => 
			    { emit "blrl"; 
			      emit_region mem; 
			      emit_defs def; 
			      emit_uses uses; 
			      emit_cuts_to cuts_to ;};
			   i::SOURCE { } => emit "source";
			   i::SINK { } => emit "sink";
			   i::PHI { } => emit "phi";
			 esac;

			 tab(); emit_instruction' instruction; nl();
	       } #  emitter 

	   also
	   fun emit_instr_indented i
               =
               {   indent();
                   emit_instruction i;
                   nl();
               }

	   also
	   fun emit_instrs  instrs
               =
	       apply (*indent_copies  ??  emit_instr_indented
		                      ::  emit_instruction
                     )
                     instrs

	   also
	   fun emit_instruction (i::NOTE { instruction, note } )
                   =>
		   {   emit_comment (note::to_string note);
		       nl();
		       emit_instruction instruction;
                   };

	       emit_instruction (i::LIVE { regs, spilled } )
                   => 
		   emit_comment("live= " + cells_basis::cell_set::to_string regs +
			 "spilled= " + cells_basis::cell_set::to_string spilled);

	       emit_instruction (i::DEAD { regs, spilled } )
                   => 
		   emit_comment("killed . " + cells_basis::cell_set::to_string regs +
			 "spilled . " + cells_basis::cell_set::to_string spilled);

	       emit_instruction (i::BASE_INSTRUCTION i)
                   =>
                   emitter i;

	       emit_instruction (i::COPY { kind => cells_basis::REGISTER, size_in_bits, src, dst, tmp } )
                   =>
		   emit_instrs (shuffle::shuffle { tmp, src, dst } );

	       emit_instruction (i::COPY { kind => cells_basis::FLOAT_REGISTER, size_in_bits, src, dst, tmp } )
                   =>
		   emit_instrs (shuffle::shufflefp { tmp, src, dst } );

	       emit_instruction _ => error "emit_instruction";
           end;

	  s::STREAM { begin_cluster,
		      emit_pseudo_op,
		      emit        => emit_instruction,
		      end_cluster => fail,
		      define_local_label,
		      define_global_label,
		      emit_comment,
		      end_procedure => do_nothing,
		      add_note,
		      get_notes
		    };
	};
};

