## xsession.pkg
#
# This package has the highest-level responsibility for
# managing all the state and operations relating to
# communication with a given X server.
#
#
# Architecture
# ------------
#
# Nomenclature:  An 'imp' is a server thread.
#               (Like a daemon, but smaller!)
# 
# An xsession is built of seven imps.
#
# Adapting from the page 8 diagram in
#     http:://mythryl.org/pub/exene/1991-ml-workshop.pdf 
# our dataflow network for xsession looks like:
#
#       ----------------------
#       |  X server process  |
#       ----------------------
#            ^          |
#            |          v 
#   -------<network socket>------------- network and process boundary.
#            ^          |
#            |          v                            ---           ---
#       ----------  ----------                        .             .
#       | outbuf |  | inbuf  |                        .             .
#       | imp    |  | imp    |                        .             .
#       ----------  ----------                        .             .
#            ^          |                             .             .
#            |          v                             .             .
#  ---------------------------    -----------------   .             .
#  |   sequencer imp         |--> | error handler |   ... xsocket   .
#  ---------------------------    -----------------   .   imps      .
#        ^       ^      |                             .             .
#        |       |      | xevents                     .             .
#        |       |      v                             .             ... xsession
#        |       |   ----------                       .             .   imps
#        |       |   | xbuf   |                       .             .
#        |       |   | imp    |                       .             .
#        |       |   ----------                       .             .
#        |       |      |                            ---            .
#        |       |      | xevents                                   .
#        v       |      v                                           .
#  ----------    |   ---------------    ----------                  .
#  | font   |    |   | xbuf to     |    | keymap |                  .
#  | imp    |    |   | widgettree  |--> | imp    |                  .
#  ----------    |   | root xevent |--> |        |                  .
#        ^       |   | router imp  |    |        |                  .
#        |       |   ---------------    ----------                  .
#        |       |      |                  ^                        .
#        |       |      | xevents          |                        .
#        v       v      v                  v                       ---
#   (..........to/from widget threads............)
#                       |
#                       | xevents
#                       v
#                    ---------------
#                    | widgettree  |
#                    | root xevent |
#                    | router imp  |
#                    ---------------
#                       /      \
#                      / widget \
#                     /   tree   \
#                    /            \ 
#                   /     ...      \ 
#
# Dramatis Personae:
#
#  o  The sequencer imp matches replies to requests.
#     All traffic to/from the X server goes through it.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket.pkg   
#
#  o  The outbuf imp optimizes network usage by
#     combining multiple requests per network packet.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket.pkg   
#
#  o  The inbuf imp breaks the incoming bytestream
#     into individual replies and forwards them individually
#     to the sequencer thread.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket.pkg   
#
#  o  The xbuf imp combines multiple related expose events
#     into a single logical message for ease of downstream
#     processing.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket.pkg   
#
#  o  The   xsocket_to_topwindow_router   imp receives all X events
#     (e.g. keystrokes and mouseclicks) and feeds each one to the
#     appropriate toplevel window, or more precisely to the
#     topwindow_to_widget_router   at the root of the widgettree for
#     that window, there to trickle down the widgettree to its ultimate
#     target widget.
#
#     To do this, the xsocket_to_topwindow_router imp
#     tracks all toplevel windows created by the application,
#     keyed by their X-server-assigned IDs.
#
#         Implemented in:  src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router.pkg
#         See also:        src/lib/x-kit/xclient/src/window/topwindow-to-widget-router.pkg
# 
#  o  The font imp ... 
#         Implemented in:  src/lib/x-kit/xclient/src/window/font-imp.pkg
#
#  o  The keymap imp ... 
#         Implemented in:  src/lib/x-kit/xclient/src/window/keymap-imp.pkg
#
#
#
#
# All mouse and keyboard events flow down through the
# inbuf, sequencer, xbuf and xbuf-to-widgettree imps
# and thence down through the widget hierarchy
# associated with a the relevant topwindow.
#
# Client xserver requests and responses are sent
# directly to the sequencer imp, with the exception
# of font requests and responses, whic run through
# the font imp.
#
# Keysym translations are handled by the keymap imp.


# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.make6



###                "I have always wished that my computer
###                 would be as easy to use as my telephone.
###                 My wish has come true ... I no longer
###                 know how to use my telephone."
###
###                               -- Bjarne Stroustrup



stipulate
    include threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package s2t =  xsocket_to_topwindow_router;		# xsocket_to_topwindow_router	is from   src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router.pkg
    #
    package ge  =  geometry;				# geometry			is from   src/lib/x-kit/xclient/src/window/geometry.pkg
    package xok =  xsocket;				# xsocket			is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package dy  =  display;				# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package ai  =  atom_imp;				# atom_imp			is from   src/lib/x-kit/xclient/src/iccc/atom-imp.pkg
    package cs  =  color_spec;				# color_spec			is from   src/lib/x-kit/xclient/src/window/color-spec.pkg
    package di  =  draw_imp;				# draw_imp			is from   src/lib/x-kit/xclient/src/window/draw-imp.pkg
    package fti =  font_imp;	# "fi" is taken! :-)	# font_imp			is from   src/lib/x-kit/xclient/src/window/font-imp.pkg
    package gci =  graphics_context_cache;		# graphics_context_cache	is from   src/lib/x-kit/xclient/src/window/graphics-context-cache.pkg
    package ki  =  keymap_imp;				# keymap_imp			is from   src/lib/x-kit/xclient/src/window/keymap-imp.pkg
    package si  =  selection_imp;			# selection_imp			is from   src/lib/x-kit/xclient/src/window/selection-imp.pkg
    package v2w =  value_to_wire;			# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package s2w =  sendevent_to_wire;			# sendeven_to_wire		is from   src/lib/x-kit/xclient/src/wire/sendevent-to-wire.pkg
    package w2v =  wire_to_value;			# wire_to_value			is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package wpi =  window_property_imp;			# window_property_imp		is from   src/lib/x-kit/xclient/src/window/window-property-imp.pkg
    package xt  =  xtypes;				# xtypes			is from	  src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package xtr =  xtracing;				# xtracing			is from   src/lib/x-kit/xclient/src/stuff/xtracing.pkg
    trace =  xtr::print_if  xtr::io_tracing;		# Conditionally write strings to tracing.log or whatever.
herein

    package xsession: Xsession {			# Xsession			is from   src/lib/x-kit/xclient/src/window/xsession.api

	Xsession
	    =
	    XSESSION  {
		xdisplay:          	dy::Xdisplay,          		#  
		screens:           	List( Screen_Info ),

		default_screen:    	Screen_Info,

		xsocket_to_topwindow_router:   s2t::Xsocket_To_Topwindow_Router,          # Feeds X events to appropriate toplevel window.

		font_imp:          	fti::Font_Imp,
		atom_imp:          	ai::Atom_Imp,

		window_property_imp:    wpi::Window_Property_Imp,
		selection_imp:     	si::Selection_Imp,

		keymap_imp:             ki::Keymap_Imp
	    }

	also
	Screen_Info
	    =
	    SCREEN_INFO
	      {
		xscreen:    dy::Xscreen,			# Xscreen	def in    src/lib/x-kit/xclient/src/wire/display.pkg
		imps:       List( Screen_Depth_Imps ),		# The graphics-context and draw imps for the allowed depths.
				  				# of this screen.
		root_imps:  Screen_Depth_Imps
	      }

	also
	Screen_Depth_Imps
	    =
	    # For each combination of visual and depth
	    # we allocate a pair of imps, one to draw,
	    # one to manage graphics contexts.  This
	    # is forced because X requires that each
	    # gc and pixmap be associated with a
	    # particular screen, visual and depth:
	    #
	    SCREEN_DEPTH_IMPS  {				# The graphics context imp and draw_imp
								# for a given  depth of a screen.
		depth:      Int,    

		gcontext_imp:     gci::Graphics_Context_Cache,	# The graphics context imp for this screen.

		draw_fn:    di::m::Draw_Mail -> Void		# The draw-imp connection for
								# the root  window of the screen. 
	    }

	also
	Screen							# A screen handle for users.
	    =
	    SCREEN  {
		xsession:   Xsession,
		screen:     Screen_Info
	    }; 

	#  An on-screen bitmap 
	#
	Window
	    =
	    WINDOW
	      {
		window_id:     xt::Window_Id,
		#
		screen:        Screen,
		screen_depth:  Screen_Depth_Imps,
		#
		draw_fn:       di::m::Draw_Mail -> Void
	      };

	# Identity tests:
	#
	fun same_xsession
            ( XSESSION { xdisplay=>dy::XDISPLAY { xsocket => x1, ... }, ... },
              XSESSION { xdisplay=>dy::XDISPLAY { xsocket => x2, ... }, ... }
            )
	    =
	    xok::same_xsocket (x1, x2);

	fun same_screen ( SCREEN { xsession=>xsession1, screen=>SCREEN_INFO { xscreen => dy::XSCREEN { id=>id1, ... }, ... }},
			  SCREEN { xsession=>xsession2, screen=>SCREEN_INFO { xscreen => dy::XSCREEN { id=>id2, ... }, ... }}
			)
	    =
	    (id1 == id2)
	    and
	    same_xsession (xsession1, xsession2);

	fun same_window (   WINDOW { window_id=>id1, screen=>s1, ... },
			    WINDOW { window_id=>id2, screen=>s2, ... }   )
	    =
	   (id1 == id2) and same_screen (s1, s2);

	# See overview comments in
	#
	#     src/lib/x-kit/xclient/src/window/xsession.api
	#
	fun open_xsession
            ( display_name:     String,
              xauthentication:  Null_Or( xt::Xauthentication )				# Xauthentication info comes ultimately from ~/.Xauthority
            )
	    =
	    {   my (display as dy::XDISPLAY { default_screen, screens, xsocket, next_xid, ... } )
		    =
		    dy::open_xdisplay { display_name, xauthentication };

		keymap_imp =   ki::make_keymap_imp  display;
		atom_imp   =   ai::make_atom_imp    display;

		(wpi::make_window_property_imp (display, atom_imp))
		    ->
		    (to_window_property_imp_slot, window_property_imp);

		(si::make_selection_imp  display)
		    ->
		    (to_selection_imp_slot,  selection_imp);

		xsocket_to_topwindow_router
		    =
		    s2t::make_xsocket_to_topwindow_router
		      { display,
			keymap_imp,
			#
			to_window_property_imp_slot,
			to_selection_imp_slot
		      };

		fun make_screen_info (xscreen as dy::XSCREEN { root_window_id, root_visual, visuals, ... } )
		    =
		    {   fun make_screen_depth (depth, gcontext_imp)
			    =
			    {
				config_slot =  make_mailslot ();

				make_thread  "display make_screen_info"  .{   give (config_slot, di::c::FIRST_EXPOSE);   };

				SCREEN_DEPTH_IMPS {
				    depth,
				    gcontext_imp,
				    draw_fn
					=>
					di::make_draw_imp
					  ( take'  config_slot,
					    gcontext_imp,
					    xsocket_to_topwindow_router,
                                            xsocket
                                          )
				};
			    };

			fun make_gcontext_imps ([], l)
				=>
				l;

			    make_gcontext_imps (vd ! r, l)
				=>
				{
				    d = dy::depth_of_visual vd;

				    fun make_server ()
					=
					{   xid = next_xid ();

					    # Make a pixmap to serve as the
					    # witness drawable for the GC server:
					    #	
					    xok::request xsocket
					      ( value_to_wire::encode_create_pixmap
						  { pixmap => xid,
						    drawable => root_window_id,
						    size => ge::SIZE { wide=>1, high=>1 },
						    depth => d
				                  }
                                              );

					    make_screen_depth
						(d, gci::make_graphics_context_cache (display, xid));
				        };


				    fun get []
					    =>
					    make_server() ! l;

				        get (SCREEN_DEPTH_IMPS { depth, ... } ! r)
					    =>
					    d == depth  ??  l
                                                        ::  get r;
                                    end;


				    make_gcontext_imps (r, get l);
				};
			end;

			root_imps
			    =
			    make_screen_depth
			      (
				dy::depth_of_visual  root_visual,
				gci::make_graphics_context_cache  (display, root_window_id)
			      );

			imps = make_gcontext_imps (visuals, [root_imps]);
			imps = make_gcontext_imps([xt::NO_VISUAL_FOR_THIS_DEPTH 1], imps);

			SCREEN_INFO {
			    xscreen,
			    imps,
			    root_imps
			};
		    };

		screens
		    =
		    map  make_screen_info
			 screens;

		XSESSION
		  {
		    xdisplay => display,
		    default_screen => list::nth (screens, default_screen),
		    screens,
		    xsocket_to_topwindow_router,
		    atom_imp,
		    font_imp =>  fti::make_font_imp  display,
		    window_property_imp,
		    selection_imp,
		    keymap_imp
		  };
	  };


	# X-server I/O. 
	#
	stipulate

	    fun apply_to_xsocket f (XSESSION { xdisplay=>dy::XDISPLAY { xsocket, ... }, ... } )
                =
                f xsocket;

	herein

	    request            =  apply_to_xsocket  xok::request;
	    request_and_check  =  apply_to_xsocket  xok::request_and_check;

	    request_reply      =  apply_to_xsocket  xok::request_reply;
	    request_replies    =  apply_to_xsocket  xok::request_replies;

	    flush_out          =  apply_to_xsocket  xok::flush;

	    query_best_size    =  apply_to_xsocket  xok::query_best_size;
	    query_colors       =  apply_to_xsocket  xok::query_colors;
	    query_font         =  apply_to_xsocket  xok::query_font;
	    query_pointer      =  apply_to_xsocket  xok::query_pointer;
	    query_text_extents =  apply_to_xsocket  xok::query_text_extents;
	    query_tree         =  apply_to_xsocket  xok::query_tree;

	end;

	# Get location of mouse pointer
	# plus related information:
	#
	fun get_mouse_location
	    (XSESSION
	      { xdisplay       =>  dy::XDISPLAY { xsocket, ... },
		default_screen =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    =
	    {   # The X server query_pointer call takes a window_id
		# argument. This seems overcomplex for the typical
		# Mythryl caller, so here we just default it to the
		# the default-screen root-window:
		#
		(xok::query_pointer  xsocket  { window_id => root_window_id })
		    ->
		    { root_point, ... };

		# The X server query_pointer call returns
		# a load of stuff.  For now at least, a
		# return value of simply the mouse location
		# seems more convenient for the Mythryl app hacker:
		#
		root_point;
	    };

	fun set_mouse_location
	    (
             XSESSION
	      { xdisplay       =>  dy::XDISPLAY { xsocket, ... },
		default_screen =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    to_point
	    =
	    {   # This is an ignored dummy value:
		#	
	        from_box =  ge::BOX { col => 0, row => 0, wide => 0, high => 0 };

		command
		    =
		    v2w::encode_warp_pointer
                      {
			to_point,					# Move mouse pointer to this coordinate.
                        to   =>  THE root_window_id,			# Position mouse relative to root window.
			#						# (That is, in absolute screen coordinates.)
	                from =>  NULL,
			from_box					# Ignored because 'from' is NULL.
                      };

		xok::request  xsocket  command;
	    };

	# Map a point in the window's coordinate
	# system to the screen's coordinate system:
	#
	fun window_point_to_screen_point (WINDOW { window_id, screen, ... } ) pt
	    =
	    {   screen ->  SCREEN { xsession, screen=> SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, ... }, ... };

		my { to_point, ... }
		    =
		    w2v::decode_translate_coordinates_reply
		      (
			do_mailop
			  (request_reply
			      xsession
			      (v2w::encode_translate_coordinates { from_window=>window_id, to_window=>root_window_id, from_point=>pt } )
			  )
		      );

		to_point;
	    };

	fun send_mousebutton_press_xevent
	    (
             XSESSION
	      { xdisplay       =>  dy::XDISPLAY { xsocket, ... },
		default_screen =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      button,							# Mouse button just "clicked" down.
	      point  =>  point as ge::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the clickpoint in both
                # local and screen coords:
		#
trace .{ sprintf "xsession: send_mousebutton_press_event/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    ge::POINT { row => screen_row,
                                col => screen_col
                              };

trace .{ sprintf "xsession: send_mousebutton_press_event/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
		timestamp	=  xt::CURRENT_TIME;
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the mouse-button release event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_row;				# Mouse position on root window at time of button release.
		root_y		=  screen_col;
		event_x		=  row;					# Mouse position on recipient window at time of button release.
		event_y		=  col;
		buttons		=  xt::MOUSEBUTTON_STATE 0u0;

trace .{ "xsession: send_mousebutton_press_event/YYY calling s2w::encode_send_button_press_xevent"; };
		command
		    =
		    s2w::encode_send_button_press_xevent
		      {
			send_event_to,  propagate,  event_mask,
			timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  button, buttons
		      };		

		xok::request xsocket command;

trace .{ "xsession: send_mousebutton_press_event/BOT called  s2w::encode_send_button_press_xevent -- DONE"; };
		();
	    };

	fun send_mousebutton_release_xevent
	    (
             XSESSION
	      { xdisplay       =>  dy::XDISPLAY { xsocket, ... },
		default_screen =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      button,							# Mouse button just "clicked" down.
	      point  =>  point as ge::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the clickpoint in both
                # local and screen coords:
		#
trace .{ sprintf "xsession: send_mousebutton_release_event/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    ge::POINT { row => screen_row,
                                col => screen_col
                              };

trace .{ sprintf "xsession: send_mousebutton_release_event/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
		timestamp	=  xt::CURRENT_TIME;
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the mouse-button release event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_row;				# Mouse position on root window at time of button release.
		root_y		=  screen_col;
		event_x		=  row;					# Mouse position on recipient window at time of button release.
		event_y		=  col;

trace .{ "xsession: send_mousebutton_release_event/YYY calling s2w::encode_send_button_press_xevent"; };
		command
		    =
		    s2w::encode_send_button_release_xevent
		      {
			send_event_to,  propagate,  event_mask,
			timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  button
		      };		

		xok::request xsocket command;
trace .{ "xsession: send_mousebutton_release_event/BOT called  s2w::encode_send_button_press_xevent -- DONE"; };
		();
	    };


        # Close the xsession.
        # NOTE: there are probably other things
        # that should go on here, such as notifying
        # the xbuf_to_topwindow_xevent_router.           XXX BUGGO FIXME
        #
	fun close_xsession (XSESSION { xdisplay, ... } )
            =
            display::close_display  xdisplay;

	# Return the maximum request size
	# supported by the display:
	#
	fun max_request_length (XSESSION { xdisplay=>dy::XDISPLAY { max_request_length, ... }, ... } )
	    =
	    max_request_length;

	# Atom operations:
	#
	stipulate

	    fun wrap_atom_op f (XSESSION { atom_imp, ... } )
                =
                f atom_imp;

	herein

	    make_atom      =  wrap_atom_op  ai::make_atom;
	    find_atom      =  wrap_atom_op  ai::find_atom;
	    atom_to_string =  wrap_atom_op  ai::atom_to_string;

	end;

	# Font operations:
	#
	fun open_font (XSESSION { font_imp, ... } )
	    =
	    font_imp::open_font font_imp;


	fun default_screen_of (xsession as XSESSION { default_screen, ... } )
	    =
	    SCREEN { xsession, screen => default_screen };


	fun screens_of (xsession as XSESSION { screens, ... } )
	    =
	    map (fn s = SCREEN { xsession, screen => s })
                screens;


	fun ring_bell xsession percent
	    =
	    request  xsession
		(value_to_wire::encode_bell { percent => int::min (100, int::max(-100, percent)) } );


	# Screen functions:
	#
	color_of_screen 
	    =
            cs::get_color;

	fun xsession_of_screen (SCREEN { xsession, ... } )
	    =
            xsession;

	# Additions by ddeboer, May 2004. 
	# Dusty deBoer, KSU CIS 705, Spring 2004.

	# Return the root window of a screen.
	# This is needed in obtaining strings from xrdb,
	# as they are stored in a property of the root window:
	#
	fun root_window_of_screen (SCREEN { screen=>SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, ... }, ... } )
            =
            root_window_id;

	# End additions by ddeboer 

	fun size_of_screen (SCREEN { screen=>SCREEN_INFO { xscreen => dy::XSCREEN { size_in_pixels, ... }, ... }, ... } )
	    =
	    size_in_pixels;

	fun mm_size_of_screen (SCREEN { screen=>SCREEN_INFO { xscreen => dy::XSCREEN { size_in_mm, ... }, ... }, ... } )
	    =
	    size_in_mm;

	fun depth_of_screen (SCREEN { screen=>SCREEN_INFO { xscreen => dy::XSCREEN { root_visual, ... }, ... }, ... } )
	    =
	    dy::depth_of_visual root_visual;

	fun display_class_of_screen (SCREEN { screen=>SCREEN_INFO { xscreen => dy::XSCREEN { root_visual, ... }, ... }, ... } )
	    =
	    case (dy::display_class_of_visual root_visual)
		THE c => c;
		_     => xgripe::impossible "[xsession::display_class_of_screen: bogus root visual]";
	    esac;

	# Extract the graphics-context imp
        # for a given depth:
	#
	fun servers_of_screen_depth (SCREEN { screen=>SCREEN_INFO { imps, ... }, ... }, d)
	    =
	    f imps
	    where
		fun f []
			=>
			xgripe::xerror "invalid depth for screen";

		    f ((sd as SCREEN_DEPTH_IMPS { depth, ... } ) ! r)
			=>
			if (depth == d)  sd; else (f r);fi;
		end;
	    end;


    };									# package xsession
end;									# stipulate.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
